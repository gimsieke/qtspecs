<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2023/">2023</a>, <a href="2022/">2022</a>, <a href="2021/">2021</a>, <a href="2020/">2020</a></p><div class="toots">
<div class="toot" id="closed-891"><h2>Issue #891 closed<span class="toot-id"> #closed-891</span></h2><div class="pubdate">11 Dec at 10:01:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/891">https://github.com/qt4cg/qtspecs/pull/891</a></div><p>Cleanup the post-diff-hacking hack</p></div>
<div class="toot" id="created-891"><h2>Pull request #891 created<span class="toot-id"> #created-891</span></h2><div class="pubdate">11 Dec at 10:01:48 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/891">https://github.com/qt4cg/qtspecs/pull/891</a></div><details><summary>Cleanup the post-diff-hacking hack</summary><div class="markup"><p>Improved, I think.</p>
</div></details></div>
<div class="toot" id="closed-890"><h2>Issue #890 closed<span class="toot-id"> #closed-890</span></h2><div class="pubdate">11 Dec at 09:38:20 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/890">https://github.com/qt4cg/qtspecs/pull/890</a></div><p>Stop fussing with merge base branch</p></div>
<div class="toot" id="created-890"><h2>Pull request #890 created<span class="toot-id"> #created-890</span></h2><div class="pubdate">11 Dec at 09:38:15 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/890">https://github.com/qt4cg/qtspecs/pull/890</a></div><details><summary>Stop fussing with merge base branch</summary><div class="markup"><p>Trying to track down the spurious diffs that we see in PRs.</p>
<p>I'll have to merge this to test it, so there will be a few random merges here. Sorry.</p>
</div></details></div>
<div class="toot" id="created-889"><h2>Issue #889 created<span class="toot-id"> #created-889</span></h2><div class="pubdate">11 Dec at 00:26:25 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/889">https://github.com/qt4cg/qtspecs/issues/889</a></div><details><summary>Rename "Named Function Reference"</summary><div class="markup"><p>The term "named function reference" is used for a construct like <code>name#1</code>.</p>
<p>Although we define it as "A named function reference is an expression (written name#arity) which evaluates to a [function item]", the term "named function reference" perpetuates the incorrect assumption that it is some kind of literal or constant denoting a function item.</p>
<p>Of course, in many cases it can be treated as just that. But not when the function is context-dependent, for example name#0 or lang#1.</p>
<p>The term is also questionable because one would assume that a "named function reference" is a reference to a "named function", but there is no such concept as a "named function".</p>
<p>So what might be a better name? What the expression actually does (when evaluated) is to search the static context for a function definition whose name and arity range correspond, and then construct a function item that captures the relevant part of the dynamic context in its closure. It's hard to encapsulate all of that in a simple name for the construct, but I would suggest <strong>named function generator</strong>. This is sufficiently close to the current term to be recognisable, but tries to capture the fact that it's not just a constant or literal, it's an expression that activately does something when evaluated; and it's reasonably accurate in that the result of the evaluation is a function item that has a non-absent name.</p>
</div></details></div>
<div class="toot" id="created-888"><h2>Issue #888 created<span class="toot-id"> #created-888</span></h2><div class="pubdate">09 Dec at 23:31:39 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/888">https://github.com/qt4cg/qtspecs/issues/888</a></div><details><summary>Reclassify XPDY0002 as a type error</summary><div class="markup"><p>I propose to reclassify XPDY0002 (context item is absent) as a type error rather than a dynamic error.</p>
<p>I don't propose to change the error code.</p>
<p>The only practical distinction is that this will allow the error to be reported statically when it can be detected statically, for example if the user writes something like</p>
<pre><code>function($x as node()) {
  starts-with(name(), 'x')
}
</code></pre>
<p>At present Saxon will give you a compile-time warning for this, followed by a run-time error if the code is actually executed; this is the required behaviour for dynamic errors.</p>
<p>The change does mean that in a case like this example, it will no longer be possible to catch the error using try/catch. However, type errors can only be reported statically if the code is bound to fail at run-time, and catching errors that occur every time is not especially useful.</p>
</div></details></div>
<div class="toot" id="created-887"><h2>Issue #887 created<span class="toot-id"> #created-887</span></h2><div class="pubdate">08 Dec at 15:04:55 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/887">https://github.com/qt4cg/qtspecs/issues/887</a></div><details><summary>Trivial syntax error under "named function references"</summary><div class="markup"><p>In the XPath/XQuery book, §4.6.2.4,</p>
<p><code>let $f := &lt;foo/&gt;/fn:name#0 return &lt;bar&gt;/$f()</code></p>
<p>should be</p>
<p><code>let $f := &lt;foo/&gt;/fn:name#0 return &lt;bar/&gt;/$f()</code></p>
<p>Digging a bit deeper, this reveals that we are not properly tagging and syntax-checking code examples in the spec.</p>
</div></details></div>
<div class="toot" id="created-886"><h2>Issue #886 created<span class="toot-id"> #created-886</span></h2><div class="pubdate">07 Dec at 23:56:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/886">https://github.com/qt4cg/qtspecs/issues/886</a></div><details><summary>Binary map keys</summary><div class="markup"><p>We have made <code>xs:hexBinary</code> and <code>xs:base64Binary</code> comparable and we now allow implicit coercion between the two types.</p>
<p>I've been assuming, though I'm not sure we ever discussed it, that this automatically means that the two types can be "atomic equal" from the point of view of entries in maps: that is, a hexBinary representation of a particular binary value can no longer coexist in a map with a base64Binary representation of the same binary value.</p>
<p>If we were starting from scratch this would clearly make sense, but it has some messy implications:</p>
<ul>
<li>It's a backwards incompatibility; in 3.1 you could construct maps that you can no longer construct in 4.0</li>
<li>It potentially affects interoperability of 3.1 and 4.0 applications. For example, an XQuery 4.0 application invoking an XSLT 3.0 transformation via <code>fn:transform</code> might get back a map that's not a valid map in 4.0.</li>
</ul>
<p>In effect, this is not just a change to the behaviour of one function/operator, it is a data model change, because it changes the value space of the <code>map(*)</code> data type.</p>
<p>And more parochially, I freely admit, there's a lot of internal complexity trying to maintain a code base that supports both the 3.1 and 4.0 rules simultaneously.</p>
<p>Is this a feature that benefits users sufficiently to justify the transition complexities? Note that we can still support "eq" between the two data types without supporting <code>fn:atomic-equal</code>.</p>
</div></details></div>
<div class="toot" id="created-885"><h2>Issue #885 created<span class="toot-id"> #created-885</span></h2><div class="pubdate">07 Dec at 17:38:24 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/885">https://github.com/qt4cg/qtspecs/issues/885</a></div><details><summary>fn:uuid</summary><div class="markup"><p>…to create a random universally unique identifier (UUID), represented as 128-bit value.</p>
<p>Should ideally be nondeterministic, or we may need to do something that’s similar to <code>fn:random-number-generator</code>.</p>
</div></details></div>
<div class="toot" id="created-884"><h2>Pull request #884 created<span class="toot-id"> #created-884</span></h2><div class="pubdate">06 Dec at 22:49:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/884">https://github.com/qt4cg/qtspecs/pull/884</a></div><details><summary>862 Add explanations and examples of implausible expressions</summary><div class="markup"><p>Fix #862</p>
</div></details></div>
<div class="toot" id="created-883"><h2>Issue #883 created<span class="toot-id"> #created-883</span></h2><div class="pubdate">06 Dec at 21:57:23 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/883">https://github.com/qt4cg/qtspecs/issues/883</a></div><details><summary>Improve return type for fn:load-xquery-module()</summary><div class="markup"><p>The return type is given as <code>map(*)</code>. We could make it more precise with a record type.</p>
<p>The same goes for a number of other function signatures that currently use map(*) as an argument or result type.</p>
<p>Perhaps we should also define a more precise type for options parameters.</p>
</div></details></div>
<div class="toot" id="created-882"><h2>Issue #882 created<span class="toot-id"> #created-882</span></h2><div class="pubdate">06 Dec at 18:53:12 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/882">https://github.com/qt4cg/qtspecs/issues/882</a></div><details><summary>fn:chain or fn:compose</summary><div class="markup"><p>I thought I had a great opportunity to use <code>fn:chain</code> the other day, and then found it didn't do what I wanted.</p>
<p>I wanted to negate a predicate: in pseudo-code</p>
<p><code>items-where($seq, not contains(?, "e"))</code></p>
<p>and I thought I could do this by chaining <code>contains</code> and <code>not</code>. But it doesn't work that way: <code>fn:chain</code> <em>applies</em> a sequence of functions to an argument, it doesn't compose a sequence of functions to yield a new function.</p>
<p>I wonder if a function that composes functions would be more useful, so I could write</p>
<p><code>items-where($seq, compose((contains(?, "e"), not#1)))</code></p>
</div></details></div>
<div class="toot" id="created-881"><h2>Pull request #881 created<span class="toot-id"> #created-881</span></h2><div class="pubdate">06 Dec at 11:59:38 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/881">https://github.com/qt4cg/qtspecs/pull/881</a></div><details><summary>866 Introduce and exploit new numeric-compare() function</summary><div class="markup"><p>Fix #866</p>
<p>The proposal introduces a new fn:numeric-compare function that differs from lt/eq primarily in that decimals are compared retaining their full precision, rather than converting them to doubles which may lose precision. This makes the comparison fully transitive which makes it safe to use in all sorting algorithms.</p>
<p>The new comparison semantics are exploited in max(), min(), and sort(), and indirectly in highest() and lowest(); they are also referenced for comparing numeric values in XSLT <code>xsl:sort</code> (and therefore indirectly in <code>xsl:merge</code>) and in XQuery <code>order by</code>.</p>
<p>An effect of the change is that max() and min() applied to a sequence of integers now return an integer, not a double.</p>
</div></details></div>
<div class="toot" id="created-880"><h2>Pull request #880 created<span class="toot-id"> #created-880</span></h2><div class="pubdate">06 Dec at 11:13:12 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/880">https://github.com/qt4cg/qtspecs/pull/880</a></div><details><summary>872 Symmetry: fn:items-at → fn:get</summary><div class="markup"><p>Closes #872.</p>
</div></details></div>
<div class="toot" id="created-879"><h2>Pull request #879 created<span class="toot-id"> #created-879</span></h2><div class="pubdate">06 Dec at 11:05:48 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/879">https://github.com/qt4cg/qtspecs/pull/879</a></div><details><summary>844 New sequence functions: names</summary><div class="markup"><p>Closes #844. The <code>items</code> keyword in the function names (excluding <code>items-at</code>) has been changed to <code>subsequence</code>.</p>
<p>See #878 for the controversial discussion on what to do with <code>subsequence-(after|before|starting-where|ending-where)</code>.</p>
</div></details></div>
<div class="toot" id="closed-855"><h2>Issue #855 closed<span class="toot-id"> #closed-855</span></h2><div class="pubdate">06 Dec at 10:50:57 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/855">https://github.com/qt4cg/qtspecs/pull/855</a></div><p>844 New sequence functions: names</p></div>
<div class="toot" id="closed-869"><h2>Issue #869 closed<span class="toot-id"> #closed-869</span></h2><div class="pubdate">06 Dec at 10:29:35 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/869">https://github.com/qt4cg/qtspecs/issues/869</a></div><p>Incorrect example: for-each-pair</p></div>
<div class="toot" id="created-878"><h2>Issue #878 created<span class="toot-id"> #created-878</span></h2><div class="pubdate">06 Dec at 08:59:17 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/878">https://github.com/qt4cg/qtspecs/issues/878</a></div><details><summary>Proposed extension to subsequence</summary><div class="markup"><p>Copied from https://github.com/qt4cg/qtspecs/issues/844#issuecomment-1841415417:</p>
<hr>
<p>I'm thinking again about integrating the items-* quartet into a heavily overloaded <code>subsequence</code> function.</p>
<p>Must supply zero or one of:</p>
<ul>
<li>$start - the start position</li>
<li>$from - a predicate, such that the start is the first item to match the predicate</li>
<li>
<ul>
<li>defaulting to 1</li>
</ul>
</li>
</ul>
<p>And zero or one of:</p>
<ul>
<li>$length - the number of items to include</li>
<li>$while - a predicate, the subsequence takes items so long as the predicate is true</li>
<li>$until - a predicate, the subsequence takes items up to and including the first for which the predicate is false</li>
<li>
<ul>
<li>defaulting to the end of the sequence.</li>
</ul>
</li>
</ul>
<p>This omits the "items-after" combination, but that one is easily achieved using <code>tail(subsequence(from:="xxx"))</code>.</p>
</div></details></div>
<div class="toot" id="created-877"><h2>Issue #877 created<span class="toot-id"> #created-877</span></h2><div class="pubdate">06 Dec at 03:29:12 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/877">https://github.com/qt4cg/qtspecs/issues/877</a></div><details><summary>Inconsistency in XQFO comparator functions/operators with recursive rules</summary><div class="markup"><p>The rules for <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-hexBinary-less-than">op:hexBinary-less-than()</a> appear to define a recursive octet-by-octet operation, but I think it flounders in rule 3, where it does not ask for rule 2 to be applied seriatim to each octet pair, but asks for an en masse comparison of two octet sequences.</p>
<p>Compare to 5.3.2, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#codepoint-collation">Unicode Codepoint Collation</a>, which describes a similar recursive item-for-item comparison. Interesting formal differences (e.g., unordered list versus ordered list).</p>
<p><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-deep-equal">fn:deep-equal()</a> is similar, but it is also much more complex. Nevertheless, the way it breaks down the problem at the outset, to dispense immediately with the recursive factor, and deal simply with the rules for equality, is IMO admirable.</p>
<p>It would be nice if there were a bit more consistency in the prose and presentation of recursive rules. Do others agree, and are there other functions/operations that should be considered in this question? I'm thinking immediately only of comparator functions/operations, not functions that use recursion to filter or create. (There may be parallels, but let's start with those functions that are most similar.)</p>
</div></details></div>
<div class="toot" id="created-876"><h2>Issue #876 created<span class="toot-id"> #created-876</span></h2><div class="pubdate">06 Dec at 02:50:51 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/876">https://github.com/qt4cg/qtspecs/issues/876</a></div><details><summary>Placement of fn:in-scope-namespaces(), fn:in-scope-prefixes(), fn:namespace-uri-for-prefix()</summary><div class="markup"><p>Currently <code>fn:in-scope-namespaces()</code>, <code>fn:in-scope-prefixes()</code>, and <code>fn:namespace-uri-for-prefix</code> are filed under XQFO chapter 10, which purports to deal exclusively with QNames. But these three functions have no direct bearing on QNames in either input or output.</p>
<p>Two options occur to me:</p>
<ol>
<li>Move sections 10.2.6-8 to fall after 13.3.</li>
<li>Rename chapter 10 to "Functions related to QNames and namespaces". Create a 10.3 that pertains exclusively to namespaces. Move to this new subchapter 10.2.4, 10.2.6-8, as well as 13.3 <code>fn:namespace-uri()</code> .</li>
</ol>
<p>Or some variant of the above.</p>
<p>At any rate, I think the current placement doesn't properly expose these functions to the browsing reader.</p>
</div></details></div>
<div class="toot" id="created-875"><h2>Pull request #875 created<span class="toot-id"> #created-875</span></h2><div class="pubdate">06 Dec at 02:18:31 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/875">https://github.com/qt4cg/qtspecs/pull/875</a></div><details><summary>XQFO, chap. 9 minor edits</summary><div class="markup"><p>Hopefully nothing controversial here. Edits are motivated by consistency and clarity.</p>
</div></details></div>
<div class="toot" id="closed-624"><h2>Issue #624 closed<span class="toot-id"> #closed-624</span></h2><div class="pubdate">06 Dec at 01:14:03 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/624">https://github.com/qt4cg/qtspecs/issues/624</a></div><p>XPath function definition clarification</p></div>
<div class="toot" id="closed-616"><h2>Issue #616 closed<span class="toot-id"> #closed-616</span></h2><div class="pubdate">06 Dec at 01:13:23 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/616">https://github.com/qt4cg/qtspecs/issues/616</a></div><p>XDM: X Node vs. x node</p></div>
<div class="toot" id="closed-464"><h2>Issue #464 closed<span class="toot-id"> #closed-464</span></h2><div class="pubdate">06 Dec at 01:12:29 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/464">https://github.com/qt4cg/qtspecs/issues/464</a></div><p>Serialization sequence normalization step 3 needs clarification</p></div>
<div class="toot" id="created-874"><h2>Pull request #874 created<span class="toot-id"> #created-874</span></h2><div class="pubdate">06 Dec at 00:09:05 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/874">https://github.com/qt4cg/qtspecs/pull/874</a></div><details><summary>878 Proposed extension to subsequence</summary><div class="markup"><p>Following discussion under issue #844, I decided to explore the possibility of extending subsequence() with optional parameters, with the aim of making the quartet of items-before/after/starting-with/ending-with unnecessary.</p>
<p>This is the spec that results. I feel it's a good trade-off; by adding three optional parameters to <code>fn:subsequence</code>, we can eliminate 4 functions that we are having trouble finding names for. The examples feel to me to be intuitive and readable; and there is more capability in the new function than we had before, for example by combining a predicate for the start position with an integer for the length.</p>
<p>I haven't explored arity-2 callbacks - these certainly need some notes and examples.</p>
</div></details></div>
<div class="toot" id="closed-822"><h2>Issue #822 closed<span class="toot-id"> #closed-822</span></h2><div class="pubdate">05 Dec at 17:10:01 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/822">https://github.com/qt4cg/qtspecs/issues/822</a></div><p>XQuery, XQFO: Edits (pool)</p></div>
<div class="toot" id="closed-851"><h2>Issue #851 closed<span class="toot-id"> #closed-851</span></h2><div class="pubdate">05 Dec at 17:10:00 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/851">https://github.com/qt4cg/qtspecs/pull/851</a></div><p>822: XQuery, XQFO: Edits (pool)</p></div>
<div class="toot" id="minutes-12-05"><h2>QT4 CG meeting 057 draft minutes<span class="toot-id"> #minutes-12-05</span></h2><div class="pubdate">05 Dec at 17:10:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/12-05">https://qt4cg.org/meeting/minutes/2023/12-05</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="created-873"><h2>Pull request #873 created<span class="toot-id"> #created-873</span></h2><div class="pubdate">05 Dec at 14:56:21 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/873">https://github.com/qt4cg/qtspecs/pull/873</a></div><details><summary>865 Improve explanation of equality comparisons</summary><div class="markup"><p>Fix #865</p>
<p>This PR:</p>
<ul>
<li>Adds a non-normative appendix to XPath and XQuery comparing and contrasting the different ways of doing equality comparisons</li>
<li>Changes fn:atomic-equal so it no longer refers to fn:deep-equal (the recursion terminated, but was confusing to follow)</li>
<li>Removes text in XQuery describing the non-transitivity of <code>group by</code> clauses, which is now a solved problem</li>
<li>Corrects the description of backwards incompatibilities relating to numeric comparisons in the F+O spec.</li>
</ul>
</div></details></div>
<div class="toot" id="created-872"><h2>Issue #872 created<span class="toot-id"> #created-872</span></h2><div class="pubdate">05 Dec at 11:58:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/872">https://github.com/qt4cg/qtspecs/issues/872</a></div><details><summary>Symmetry: fn:items-at → fn:get</summary><div class="markup"><p>I think that <code>fn:items-at</code> should be changed to <code>fn:get</code>:</p>
<ul>
<li>In #843, we try to harmonize the function names across sequences, maps, and arrays. We have <code>array:get</code> and <code>map:get</code> to retrieve single entries of the input, but we have <code>fn:items-at</code> for sequences.</li>
<li><code>fn:items-at</code> allows you to supply more than a single position, but <code>items-at($seq, (1, 3, 2)</code> can easily be rewritten to <code>(1, 3, 2) ! get($seq, .)</code> – similar to <code>(1, 3, 2) ! array:get($array, .)</code> and <code>(1, 3, 2) ! map:get($map, .)</code>.</li>
<li>With #844, <code>fn:items-at</code> would be the only function left with <code>items</code> in its name.</li>
</ul>
<p>The function signature would be as simple as:</p>
<pre><code class="language-xquery">fn:get(
  $input  as item()*,
  $at     as xs:integer	
) as item()
</code></pre>
<p>Obviously, most people will still use <code>$input[$at]</code> – but the same applies to arrays and maps (and other functions like <code>fn:head</code>). One of the advantages of <code>fn:get</code> is that you can pass on the context item as position argument.</p>
</div></details></div></div><p>See 1659
            more statuses in yearly archives.</p></article></main></body></html>