<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2023/">2023</a>, <a href="2022/">2022</a>, <a href="2021/">2021</a>, <a href="2020/">2020</a></p><div class="toots">
<div class="toot" id="agenda-10-03"><h2>QT4 CG meeting 048 draft agenda<span class="toot-id"> #agenda-10-03</span></h2><div class="pubdate">29 Sep at 13:20:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/10-03">https://qt4cg.org/meeting/agenda/2023/10-03</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="closed-211"><h2>Issue #211 closed<span class="toot-id"> #closed-211</span></h2><div class="pubdate">29 Sep at 12:55:47 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/211">https://github.com/qt4cg/qtspecs/issues/211</a></div><p>XSLT streaming: capturing accumulators</p></div>
<div class="toot" id="closed-717"><h2>Issue #717 closed<span class="toot-id"> #closed-717</span></h2><div class="pubdate">29 Sep at 12:55:46 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/717">https://github.com/qt4cg/qtspecs/pull/717</a></div><p>211: add capturing accumulators to XSLT</p></div>
<div class="toot" id="created-730"><h2>Issue #730 created<span class="toot-id"> #created-730</span></h2><div class="pubdate">28 Sep at 17:43:11 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/730">https://github.com/qt4cg/qtspecs/issues/730</a></div><details><summary>Equivalence of map and function types</summary><div class="markup"><p>It is stated in XPath ยง3.6.4.2, and probably elsewhere, that</p>
<p><em>The function signature of a map matching type map(K, V), treated as a function, is function(xs:anyAtomicType) as V?</em></p>
<p>But V is a sequence type, not an item type, so you can't just tag a '?' onto the end of it. What is intended here by <code>V?</code> is a sequence type that is the union of <code>V</code> and <code>empty-sequence()</code>.</p>
</div></details></div>
<div class="toot" id="created-729"><h2>Issue #729 created<span class="toot-id"> #created-729</span></h2><div class="pubdate">28 Sep at 11:50:08 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/729">https://github.com/qt4cg/qtspecs/issues/729</a></div><details><summary>xsi:schemaLocation</summary><div class="markup"><p>The specifications (XQuery and XSLT) should say something about the effect of requesting validation on a document that contains <code>xsi:schemaLocation</code> and/or <code>xsi:noNamespaceSchemaLocation</code> attributes. At present XQuery says nothing, and XSLT says very little.</p>
<p>XQuery 3.1 says: <em>A validate expression can be used to validate a document node or an element node with respect to the [in-scope schema definitions], using the schema validation process defined in [[XML Schema 1.0]] or [[XML Schema 1.1]].</em> This doesn't really answer the question. The "with respect to" phrase could be read as implying that ONLY the in-scope schema definitions are used. Particular problems occur if xsi:schemaLocation refers to a schema document that attempts to override or redefine the schema components that have been statically imported.</p>
<p>XSLT 3.0 says nothing of interest about what schema (=set of schema components) is used when validation is requested, though it does mention in passing that <code>xsi:schemaLocation</code> attributes might be interpreted in some way by a schema processor.</p>
<p>If we look to the behaviour of Saxon as a reference implementation, then we'll quickly find fault. There's a configuration option to control whether <code>xsi:schemaLocation</code> attributes are considered or ignored; if they are considered, then the schema components referenced are added to a global pool of schema components which are used not only to validate the document in question, but to validate any subsequent documents. We're in the process of redesigning this to do something that makes more sense.</p>
</div></details></div>
<div class="toot" id="created-728"><h2>Pull request #728 created<span class="toot-id"> #created-728</span></h2><div class="pubdate">28 Sep at 11:24:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/728">https://github.com/qt4cg/qtspecs/pull/728</a></div><details><summary>52 Allow record(*)</summary><div class="markup"><p>Fix #52.
Implements decision made at meeting 046.</p>
</div></details></div>
<div class="toot" id="created-727"><h2>Pull request #727 created<span class="toot-id"> #created-727</span></h2><div class="pubdate">27 Sep at 17:38:18 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/727">https://github.com/qt4cg/qtspecs/pull/727</a></div><details><summary>725 Add clarification note for load-xquery-module</summary><div class="markup"><p>Add a note to clarify the behaviour of load-xquery-module.</p>
<p>Fix #725</p>
</div></details></div>
<div class="toot" id="closed-724"><h2>Issue #724 closed<span class="toot-id"> #closed-724</span></h2><div class="pubdate">27 Sep at 16:13:41 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/724">https://github.com/qt4cg/qtspecs/pull/724</a></div><p>PR 717 with merge conflicts resolved</p></div>
<div class="toot" id="closed-723"><h2>Issue #723 closed<span class="toot-id"> #closed-723</span></h2><div class="pubdate">27 Sep at 15:30:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/723">https://github.com/qt4cg/qtspecs/pull/723</a></div><p>Updated PR for capturing accumulators</p></div>
<div class="toot" id="closed-726"><h2>Issue #726 closed<span class="toot-id"> #closed-726</span></h2><div class="pubdate">27 Sep at 09:41:52 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/726">https://github.com/qt4cg/qtspecs/pull/726</a></div><p>PR 723 with merge conflicts resolved</p></div>
<div class="toot" id="created-726"><h2>Pull request #726 created<span class="toot-id"> #created-726</span></h2><div class="pubdate">27 Sep at 09:22:03 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/726">https://github.com/qt4cg/qtspecs/pull/726</a></div><p>PR 723 with merge conflicts resolved</p></div>
<div class="toot" id="created-725"><h2>Issue #725 created<span class="toot-id"> #created-725</span></h2><div class="pubdate">27 Sep at 09:14:59 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/725">https://github.com/qt4cg/qtspecs/issues/725</a></div><details><summary>Clarification to load-xquery-module</summary><div class="markup"><p>Add a clarification note to load-xquery-module, to correct a misunderstanding by a (very knowledgeable) user: see https://saxonica.plan.io/issues/6209</p>
<p>The function load-query-module does not modify the static or dynamic context in any way. In particular, the variables and functions that are loaded from the query module are not added to the static or dynamic context of the calling code. They are accessible only via the map that is returned from the function call.</p>
</div></details></div>
<div class="toot" id="created-724"><h2>Pull request #724 created<span class="toot-id"> #created-724</span></h2><div class="pubdate">27 Sep at 08:50:42 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/724">https://github.com/qt4cg/qtspecs/pull/724</a></div><p>PR 717 with merge conflicts resolved</p></div>
<div class="toot" id="minutes-09-26"><h2>QT4 CG meeting 047 draft minutes<span class="toot-id"> #minutes-09-26</span></h2><div class="pubdate">26 Sep at 17:30:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/09-26">https://qt4cg.org/meeting/minutes/2023/09-26</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="closed-722"><h2>Issue #722 closed<span class="toot-id"> #closed-722</span></h2><div class="pubdate">26 Sep at 17:06:57 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/722">https://github.com/qt4cg/qtspecs/pull/722</a></div><p>This is a test. This is only a test.</p></div>
<div class="toot" id="created-723"><h2>Pull request #723 created<span class="toot-id"> #created-723</span></h2><div class="pubdate">26 Sep at 16:56:11 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/723">https://github.com/qt4cg/qtspecs/pull/723</a></div><details><summary>Updated PR for capturing accumulators</summary><div class="markup"><p>Updated to take account of comments</p>
</div></details></div>
<div class="toot" id="created-722"><h2>Pull request #722 created<span class="toot-id"> #created-722</span></h2><div class="pubdate">26 Sep at 16:50:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/722">https://github.com/qt4cg/qtspecs/pull/722</a></div><details><summary>This is a test. This is only a test.</summary><div class="markup"><p>Had this been a real emergency, we would have fled in terror and you would not have been informed.</p>
<p>DO NOT MERGE THIS! :-)</p>
</div></details></div>
<div class="toot" id="closed-721"><h2>Issue #721 closed<span class="toot-id"> #closed-721</span></h2><div class="pubdate">26 Sep at 16:49:02 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/721">https://github.com/qt4cg/qtspecs/pull/721</a></div><p>Attempt to fix the problem with PRE elements in autodiffs</p></div>
<div class="toot" id="created-721"><h2>Pull request #721 created<span class="toot-id"> #created-721</span></h2><div class="pubdate">26 Sep at 16:48:55 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/721">https://github.com/qt4cg/qtspecs/pull/721</a></div><details><summary>Attempt to fix the problem with PRE elements in autodiffs</summary><div class="markup"><p>Maybe I'm more cleverer today than I was last time I looked into this.</p>
</div></details></div>
<div class="toot" id="closed-663"><h2>Issue #663 closed<span class="toot-id"> #closed-663</span></h2><div class="pubdate">26 Sep at 16:13:20 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/663">https://github.com/qt4cg/qtspecs/issues/663</a></div><p>Calling xsl:original() with keywords</p></div>
<div class="toot" id="closed-674"><h2>Issue #674 closed<span class="toot-id"> #closed-674</span></h2><div class="pubdate">26 Sep at 16:13:19 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/674">https://github.com/qt4cg/qtspecs/pull/674</a></div><p>663: Describe how calls to xsl:original with keywords work</p></div>
<div class="toot" id="closed-570"><h2>Issue #570 closed<span class="toot-id"> #closed-570</span></h2><div class="pubdate">26 Sep at 16:12:44 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/570">https://github.com/qt4cg/qtspecs/issues/570</a></div><p>XSLT: Built-in template rules for maps and arrays</p></div>
<div class="toot" id="closed-718"><h2>Issue #718 closed<span class="toot-id"> #closed-718</span></h2><div class="pubdate">26 Sep at 16:12:42 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/718">https://github.com/qt4cg/qtspecs/pull/718</a></div><p>Add on-no-match="shallow-copy-all"</p></div>
<div class="toot" id="agenda-09-26"><h2>QT4 CG meeting 047 draft agenda<span class="toot-id"> #agenda-09-26</span></h2><div class="pubdate">25 Sep at 10:55:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/09-26">https://qt4cg.org/meeting/agenda/2023/09-26</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-720"><h2>Issue #720 created<span class="toot-id"> #created-720</span></h2><div class="pubdate">25 Sep at 09:47:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/720">https://github.com/qt4cg/qtspecs/issues/720</a></div><details><summary>From Records to Objects</summary><div class="markup"><p>It has become idiomatic to use maps, and record type definitions, to declare a collection of functions; so for example the random-number-generator object offers a "method" <code>next()</code> that can be called using the syntax <code>$rng?next()</code>.</p>
<p>The problem is that it's not possible, within the XPath/XQuery language, to implement such a function with implicit access to the object on which it is invoked. The implementation of the function does not have access to any kind of <code>$this</code> variable.</p>
<p>This issue considers how we can move forwards from supporting simple records to introduce object capabilities, in an incremental and compatible way.</p>
<p>Here are three steps in that direction:</p>
<ol>
<li>Where a named record type is declared, also create a corresponding constructor function. So if you declare</li>
</ol>
<p><code>declare item type my:loc as record(longitude as xs:double, latitude as xs:double)</code></p>
<p>you also get a constructor function allowing my:loc(180, 180), allowing both positional or keyword arguments corresponding to the field names,</p>
<ol start="2">
<li>
<p>Allow default values to be defined in the record type, which act as default values for the parameters in the constructor function.</p>
</li>
<li>
<p>Allow functions that are defined as part of a record type access to a variable $this. The constructor function provides an implicit binding of this variable to the record/map/object that is being instantiated.</p>
</li>
<li>
<p>Allow self-reference to a named record type (and its constructor function) within the record definition.</p>
</li>
</ol>
<p>So you can now do:</p>
<pre><code>declare type my:counter as record (
   value as xs:integer,
   increment := fn() as my:counter {my:counter($this?value + 1)}
)
</code></pre>
<p>and then</p>
<pre><code>let $x := my:counter(0)
return $x?increment()?value
</code></pre>
<p>which returns 1.</p>
</div></details></div>
<div class="toot" id="created-719"><h2>Pull request #719 created<span class="toot-id"> #created-719</span></h2><div class="pubdate">21 Sep at 20:21:29 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/719">https://github.com/qt4cg/qtspecs/pull/719</a></div><details><summary>413: Spec for CSV-related functions</summary><div class="markup"><p>This PR contains error fixes (typos, examples that contradicted the spec text), some (hopefully) improved language and one breaking change.</p>
<p>The current draft uses the type <code>map(xs:integer, xs:string)</code> for the <code>column-names</code> option to <code>fn:csv-to-xdm</code> and <code>fn:csv-to-xml</code>. This PR flips that to <code>map(xs:string, xs:integer)</code>. It turns out that the examples were already using this, and it seems to me that having the <code>names</code> entry in the <code>csv-columns-record</code> record type be the transposed version of the <code>column-names</code> option that creates it, rather than be the same thing, is counterproductive.</p>
<p>I can think of some examples (a CSV split into several chunks, with only the first containing the headers) where being able to feed the <code>names</code> entry right back into another invocation of <code>fn:csv-to-xdm</code> would be useful. If nothing else it's confusing and not obvious, or I wouldn't have messed up the examples, and somebody would have noticed during the review process...</p>
</div></details></div>
<div class="toot" id="created-718"><h2>Pull request #718 created<span class="toot-id"> #created-718</span></h2><div class="pubdate">21 Sep at 16:39:15 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/718">https://github.com/qt4cg/qtspecs/pull/718</a></div><details><summary>Add on-no-match="shallow-copy-all"</summary><div class="markup"><p>Enable recursive descent transformation with template rules for maps and arrays.</p>
<p>Fix #570</p>
</div></details></div>
<div class="toot" id="created-717"><h2>Pull request #717 created<span class="toot-id"> #created-717</span></h2><div class="pubdate">21 Sep at 10:36:51 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/717">https://github.com/qt4cg/qtspecs/pull/717</a></div><details><summary>211: add capturing accumulators to XSLT</summary><div class="markup"><p>Adds the attribute capture="yes" to xsl:accumulator-rule. This has been available as a Saxon extension for some time and makes many accumulators much easier to implement.</p>
<p>Fix #211</p>
</div></details></div>
<div class="toot" id="created-716"><h2>Issue #716 created<span class="toot-id"> #created-716</span></h2><div class="pubdate">20 Sep at 02:34:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/716">https://github.com/qt4cg/qtspecs/issues/716</a></div><details><summary>Generators in XPath</summary><div class="markup"><h1>What is a generator?</h1>
<p>Generators are well known and provided out of the box in many programming languages. Per Wikipedia:</p>
<p>โIn&nbsp;<a href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>,  a&nbsp;<strong>generator</strong>&nbsp;is a&nbsp;<a href="https://en.wikipedia.org/wiki/Subroutine">routine</a>&nbsp;that can be used to control the&nbsp;<a href="https://en.wikipedia.org/wiki/Iteration">iteration</a>&nbsp;behaviour of a&nbsp;<a href="https://en.wikipedia.org/wiki/Control_flow#Loops">loop</a>. All generators are also&nbsp;<a href="https://en.wikipedia.org/wiki/Iterator">iterators</a>.<a href="https://en.wikipedia.org/wiki/Generator_(computer_programming)#cite_note-1">[1]</a>&nbsp;A generator is very similar to a function that returns an array, in that a generator has parameters, can be called, and generates a sequence of values.
However, instead of building an array containing all the values and returning them all at once, a generator yields the values one at a time, which requires less memory and allows the caller to get started processing the first few values immediately. In short, a generator&nbsp;<em>looks like</em>&nbsp;a function but&nbsp;<em>behaves like</em>&nbsp;an&nbsp;<a href="https://en.wikipedia.org/wiki/Iterator">iterator</a>.โ</p>
<hr>
<h1>The goal of this proposal (major use-cases)</h1>
<p>A generator in XPath should be a tool to easily implement the solutions to the following use-cases:</p>
<ol>
<li>
<p>Processing a huge collection whose members may not all be needed.<br>
A generator will produce only the next member of the collection and only on demand basis.</p>
</li>
<li>
<p>Handling a collection containing unknown or infinite number of members.
When requested the next member of the collection the generator will always produce it, if the collection still contains any members. It is the responsibility of the caller to issue only the necessary number of requests for the really needed next members.</p>
</li>
</ol>
<p>What is achieved in both cases:</p>
<ul>
<li>A (next) member is produced only on request. No time is spent on producing all members of the collection.</li>
<li>A (next) member is produced only on request. No memory is consumed to store all members of the collection.</li>
</ul>
<p>A good problem that is based on these use-cases is to generate a collection of the first N members that have some wanted properties,  and are generated from other collection(s), when it is not known what the size of the original input collections would be in order for the desired number of N members to be discovered.</p>
<p>For example: <strong><em>Produce the first 1 000 000 (1M) prime numbers</em></strong>.</p>
<p>Sometimes we may not even know if N such wanted members actually exist, for example: <strong><em>Produce the first 2 sequences of 28 prime numbers where <a href="https://en.wikipedia.org/wiki/Primes_in_arithmetic_progression#Largest_known_primes_in_AP">the primes in each of the sequences form an arithmetic progression</a>.</em></strong></p>
<hr>
<h1>The Proposal</h1>
<p>A generator is defined as (and synonym for):</p>
<pre><code class="language-xq">let $generator as record
                   (initialized as xs:boolean,
                    endReached as xs:boolean,
                    getCurrent as function(..) as item()*,
                    moveNext as function(..) as .. ,
                    *  ) 
</code></pre>
<p>A generator is an extensible <a href="https://qt4cg.org/pr/715/xquery-40/xpath-40.html#id-record-test"><strong><em>record</em></strong> </a>.</p>
<p>It has four fixed-named keys, and any other map-keys, as required to hold the internal state of that specific generator.</p>
<p>Here is the meaning of  the four fixed/named keys:</p>
<ul>
<li>
<p><strong><em>initialized</em></strong> is a boolean. When a generator <code>$gen</code>  is initially instantiated, <code>$gen?initialized</code> is <code>false()</code>. Any call to <code>$gen?getCurrent()</code> raises an error. In order to get the first value of the represented collection, the caller must call <code>$gen?moveNext()</code></p>
</li>
<li>
<p><strong><em>endReached</em></strong> is a boolean. If after a call to <code>moveNext()</code> the value of the returned generator's <code>endReached</code> key is <code>true()</code> then calling <code>moveNext()</code> and/or <code>getCurrent()</code> on this generator raises an error.</p>
</li>
<li>
<p><strong><em>getCurrent</em></strong> is a function of zero arguments. It must only be called if the values of <code>initialized</code> is <code>true()</code> and the value of <code>endReached</code> is <code>false()</code>, otherwise an error must be raised. This function produces the current member of the collection after the last call to <code>moveNext</code>, if this call didn't return a generator whose <code>endReached</code> value was <code>true()</code></p>
</li>
<li>
<p><strong><em>moveNext</em></strong>  is a function of zero arguments. When called on a generator whose <code>endReached</code> value is <code>false()</code> then it produces the next (state of the) generator. including a possibly <code>true()</code> value of <code>endReached</code> and if this value is still <code>false()</code>, then calling <code>getCurrent()</code> produces the value of the next member of the collection.</p>
</li>
</ul>
<h1>Examples of operations on generators</h1>
<p>The following examples are written in pseudo-code as at the time of writing there was no available implementation of records. And also, the code for recursion in pure XPath makes any such example longer than necessary for grasping its meaning.</p>
<h2>Take the first N members of the collection</h2>
<pre><code class="language-xq">take($gen as generator, $n as xs:integer, $result as array(*) = []) as array(*)
{
  let $gen := if(not($gen?initialized)) then $gen?moveNext()
                else $gen
      $result := if(not($gen?endReached) and $n gt 0) then array:append($result, $gen?getCurrent())
   return
    if(not($gen?endReached) and $n gt 0) then take($gen?moveNext(), $n -1, $result)
      else $result
}
</code></pre>
<h2>Skip the first N members from the collection</h2>
<pre><code class="language-xq">skip($gen as generator, $n as xs:integer) as generator
{
  if($n eq 0) then $gen
     else
     {
         let $gen := if(not($gen?initialized)) then $gen?moveNext()
                       else $gen
           return
             if(not($gen?endReached) then skip($gen?moveNext(), $n -1)
               else $gen
     }             
}
</code></pre>
<h2>Subrange of size N starting at the M-th member</h2>
<pre><code class="language-xq">subrange($gen as generator, $m as xs:integer, $n as xs:integer)
{
  take(skip($gen, $m -1), $n)
}
</code></pre>
<h2>Head of a generator</h2>
<pre><code class="language-xq">head($gen as generator)
{
  take($gen, 1)
}
</code></pre>
<h2>Tail of a generator</h2>
<pre><code class="language-xq">tail($gen as generator)
{
  skip($gen, 1)
}
</code></pre>
<h2>At index N</h2>
<pre><code class="language-xq">at($ind as xs:integer)
{
  subrange($ind, 1)
}
</code></pre>
<h2>For Each</h2>
<pre><code class="language-xq">for-each($gen as generator, $fun as function(*))
{
   map:put($gen, "getCurrent", function() { $fun($gen?getCurrent()) }  )                              
}
</code></pre>
<h2>For Each Pair</h2>
<pre><code class="language-xq">for-each-pair($gen1 as generator, $gen2 as generator, $fun as function(*))
{
   let $gen1 := if(not($gen1?initialized)) then $gen1?moveNext()
                  else $gen1,
       $gen2 := if(not($gen2?initialized)) then $gen2?moveNext()
                  else $gen2,
    return
      if($gen1?endReached or $gen2?endReached) then map:put($gen1, "endReached", true())
        else map:put(map:put($gen1, "getCurrent", function() { $fun($gen1?getCurrent(), $gen2?getCurrent()) } ) ,
                     "moveNext", function() { for-each-pair(skip($gen1, 1), skip($gen2, 1), $fun)}
                    )                             
}
</code></pre>
<h2>Filter</h2>
<pre><code class="language-xq">filter($gen as generator, $pred as function(item()*) as xs:boolean)
{
     let $getNextGoodValue := function($gen as map(*), $pred as function(item()*) as xs:boolean)
         {
            let $mapResult := iterate-while(
                                            $gen,
                                            function($gen) { not($pred($gen?getCurrent($gen))) },
                                            function($gen) { $gen?moveNext($gen) }
                                            )   
            return $mapResult?getCurrent($mapResult)                     
         },
       $gen := if($gen?initialized) then $gen 
                      else $gen?moveNext($gen)
        return
          map {
               "initialized": true(),
               "endReached":  $gen?endReached,
               "getCurrent": function($this as map(*)) { $getNextGoodValue($this?inputGen, $pred) },
               "moveNext":   function($this as map(*))
                             {    let $nextGoodValue := $getNextGoodValue($this?inputGen?moveNext($this?inputGen), $pred),
                                      $nextGen := iterate-while(
                                                                $this?inputGen?moveNext($this?inputGen),
                                                                function($gen) { not($pred($gen?getCurrent($gen))) },
                                                                function($gen) { $gen?moveNext($gen) }
                                                                )
                                    return
                                      map {
                                            "initialized": $nextGen?initialized,
                                            "endReached":  $nextGen?endReached,
                                            "getCurrent" : function($x) {$nextGoodValue},
                                            "moveNext" :   $this?moveNext,
                                            "inputGen" :   $nextGen
                                           }
                             },
               "inputGen" : $gen
              }
        }
</code></pre>
</div></details></div>
<div class="toot" id="created-715"><h2>Pull request #715 created<span class="toot-id"> #created-715</span></h2><div class="pubdate">19 Sep at 23:12:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/715">https://github.com/qt4cg/qtspecs/pull/715</a></div><details><summary>372 Rollback the default namespace changes</summary><div class="markup"><p>Implements the CG decision to roll back the changes that introduced two separate default namespaces for elements and types.</p>
<p>Fix #372</p>
</div></details></div></div><p>See 1335
            more statuses in yearly archives.</p></article></main></body></html>