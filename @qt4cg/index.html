<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2023/">2023</a>, <a href="2022/">2022</a>, <a href="2021/">2021</a>, <a href="2020/">2020</a></p><div class="toots">
<div class="toot" id="minutes-09-05"><h2>QT4 CG meeting 044 draft minutes<span class="toot-id"> #minutes-09-05</span></h2><div class="pubdate">05 Sep at 17:20:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/09-05">https://qt4cg.org/meeting/minutes/2023/09-05</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="closed-619"><h2>Issue #619 closed<span class="toot-id"> #closed-619</span></h2><div class="pubdate">05 Sep at 16:04:53 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/619">https://github.com/qt4cg/qtspecs/pull/619</a></div><p>XDM ch. 6 minor edits</p></div>
<div class="toot" id="closed-633"><h2>Issue #633 closed<span class="toot-id"> #closed-633</span></h2><div class="pubdate">05 Sep at 16:04:28 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/633">https://github.com/qt4cg/qtspecs/pull/633</a></div><p>Edits ch. 4.1 through 4.15</p></div>
<div class="toot" id="closed-601"><h2>Issue #601 closed<span class="toot-id"> #closed-601</span></h2><div class="pubdate">05 Sep at 15:15:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/601">https://github.com/qt4cg/qtspecs/issues/601</a></div><p>fn:all → fn:every?</p></div>
<div class="toot" id="closed-640"><h2>Issue #640 closed<span class="toot-id"> #closed-640</span></h2><div class="pubdate">05 Sep at 15:15:08 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/640">https://github.com/qt4cg/qtspecs/pull/640</a></div><p>601: fn:all → fn:every?</p></div>
<div class="toot" id="created-675"><h2>Issue #675 created<span class="toot-id"> #created-675</span></h2><div class="pubdate">05 Sep at 14:55:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/675">https://github.com/qt4cg/qtspecs/issues/675</a></div><details><summary>XSLT streaming rules for new constructs</summary><div class="markup"><p>The XSLT spec has rules for the streamability of all system functions and XPath language constructs. These need updating for new 4.0 constructs.</p>
</div></details></div>
<div class="toot" id="closed-664"><h2>Issue #664 closed<span class="toot-id"> #closed-664</span></h2><div class="pubdate">05 Sep at 14:08:26 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/664">https://github.com/qt4cg/qtspecs/pull/664</a></div><p>663 xsl:original keywords</p></div>
<div class="toot" id="created-674"><h2>Pull request #674 created<span class="toot-id"> #created-674</span></h2><div class="pubdate">05 Sep at 14:07:29 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/674">https://github.com/qt4cg/qtspecs/pull/674</a></div><details><summary>663: Describe how calls to xsl:original with keywords work</summary><div class="markup"><p>Rework PR 664 (fix for 663) on new baseline</p>
<p>Fix #663.</p>
</div></details></div>
<div class="toot" id="created-673"><h2>Pull request #673 created<span class="toot-id"> #created-673</span></h2><div class="pubdate">05 Sep at 13:53:36 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/673">https://github.com/qt4cg/qtspecs/pull/673</a></div><details><summary>HTML namespace changes</summary><div class="markup"><p>This PR applies my action items for updating the HTML XDM mapping around namespaces and local names.</p>
<p>Note: this currently makes <code>dm:namespace-nodes</code> return an empty sequence. I'm not currently sure what the best approach is here.</p>
</div></details></div>
<div class="toot" id="created-672"><h2>Pull request #672 created<span class="toot-id"> #created-672</span></h2><div class="pubdate">04 Sep at 20:05:30 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/672">https://github.com/qt4cg/qtspecs/pull/672</a></div><details><summary>XFO minor edits, chap. 1</summary><div class="markup"><p>Most substantive change is the trimming of prose held over from before the revision of the diagrams.</p>
</div></details></div>
<div class="toot" id="created-671"><h2>Issue #671 created<span class="toot-id"> #created-671</span></h2><div class="pubdate">02 Sep at 19:37:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/671">https://github.com/qt4cg/qtspecs/issues/671</a></div><details><summary>Switch expression without operand (analogous to XSLT choose)</summary><div class="markup"><p>By syntax analogy with <code>switch</code>,</p>
<pre><code>choose
   test ($a &lt; $b) return "lesser"
   test ($a &gt; $b) return "greater"
   test ($a eq $b) return "equal"
   default return "Getting the default is hard to explain"
</code></pre>
<p>Something like</p>
<pre><code>ChooseExpr ::= "choose" ChooseTestClause+ "default" "return"&nbsp;ExprSingle
ChooseTestClause ::= "test"&nbsp;"(" Expr ")" "return"&nbsp;ExprSingle
</code></pre>
<p>I know I can do this by stringing if-then-else together, but would greatly appreciate the cleaner and more manageable syntax for those times when many tests are inescapable.</p>
</div></details></div>
<div class="toot" id="created-670"><h2>Issue #670 created<span class="toot-id"> #created-670</span></h2><div class="pubdate">02 Sep at 05:45:09 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/670">https://github.com/qt4cg/qtspecs/issues/670</a></div><details><summary>The trouble with XPath‘s fn:fold-right. A fix and Proposal for fn:fold-lazy</summary><div class="markup"><h1><strong>The trouble with XPath‘s fn:fold-right.</strong><br><strong>Laziness in XPath.</strong></h1>
<p><em>This article discusses the standard XPath 3.1 function <strong>fn:fold-right,</strong> its definition in the official Spec, its lack of apparent use-cases and its utter failure to reproduce the (lazy) behavior of Haskell’s <strong>foldr</strong> , which is presumed to be the motivation behind <strong>fn:fold-right</strong>.</em><br>
<em>The 2nd part of the article introduces the implementation of short-circuiting and generators, which together unprecedentedly provide laziness in XPath. Based on these, a new XPath function: <strong>fn:fold-lazy</strong>    is implemented, that utilizes laziness, similar to Haskell’s <strong>foldr</strong>. This behavior is demonstrated in specific examples</em></p>
<h2><strong>Introduction</strong></h2>
<p>Higher order functions were introduced into XPath starting with <a href="https://www.w3.org/TR/xpath-functions-30/#basic-hofs">version 3.0</a> in 2014 and later in <a href="https://www.w3.org/TR/xpath-functions-31/#higher-order-functions">version 3.1</a> in 2017.<br>
The definition of the standard function <a href="https://www.w3.org/TR/xpath-functions-31/#func-fold-right">fn:fold-right</a> closely mimics that of Haskell’s <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#g:11">foldr</a>, and anyone acquainted with <strong>foldr</strong> can be left with the impression that <strong>fn:fold-right</strong> would have identical behavior (and hence use-cases) as Haskell’s <strong>foldr</strong>.</p>
<p>Unfortunately, there is a critical difference between the definitions of these two functions. Whereas the definition of <strong>foldr</strong> explicitly defines its behavior when provided with a function, lazy in its 1st argument – from <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#g:11">Haskell’s definition of
foldr</a>:</p>
<p>“… <em>Note that since the head of the resulting expression is produced by an application of the operator to the first element of the list, given an operator lazy in its right argument,&nbsp;foldr&nbsp;can produce a terminating expression from an unbounded list.”</em></p>
<p>The XPath definition of <a href="https://www.w3.org/TR/xpath-functions-31/#func-fold-right">fn:fold-right</a> does not mention any laziness.</p>
<p>There is no official concept of “laziness” in XPath, thus <strong>fn:fold-right</strong> doesn’t cover some of the most important use-cases of Haskell’s <strong>foldr</strong> , which can successfully produce a result when passed an infinite (or having unlimited length) list.</p>
<p>This in fact makes <strong>fn:fold-right</strong> almost useless, and explains why even some  of the members of the XPath 3.1 WG have stated on occasions that they do not see why the function was introduced.</p>
<h2><strong>fn:fold-right gone wrong – example</strong></h2>
<p>This Haskell code:</p>
<pre><code class="language-hs">foldr (\x y -&gt; (if x == 0 then 0 else x*y)) 1 (map (\x -&gt; x - 15) [1 ..1000000])

foldr (\x y -&gt; (if x == 0 then 0 else x*y)) 1 (map (\x -&gt; x - 15) [1 ..10000000])

foldr (\x y -&gt; (if x == 0 then 0 else x*y)) 1 (map (\x -&gt; x - 15) [1 ..])
</code></pre>
<p>produces the product of all numbers in the following list, respectively:</p>
<p>[-14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, <strong>0</strong>, 1, 2, 3, …, 999985]</p>
<p>[-14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, <strong>0</strong>, 1, 2, 3, …, 9999985]</p>
<p>[-14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, <strong>0</strong>, 1, 2, 3, …, ] -- up to infinity.</p>
<p>Because all these <code>3</code> lists contain a zero as their 15th item, the expected result is <strong><code>0</code></strong> when evaluating any of these <code>3</code> expressions – even in the last case where the provided as argument list is infinite. And this is indeed what happens:</p>
<p><img src="https://github.com/qt4cg/qtspecs/assets/10605892/4e7cbbc7-543f-433a-bdb6-e25aa59d1172" alt="image"></p>
<p>Not only Haskell produces the correct result in all cases, but <em>regardless of the list’s length, the result is produced instantaneously</em>!</p>
<p>Now, let us evaluate this equivalent XPath expression with BaseX:</p>
<pre><code class="language-xq">let $product := function($input as array(xs:integer)) as xs:integer
                         { 
                           array:fold-right($input, 1, function($x as xs:integer, $y as xs:integer) as  xs:integer 
                                                               {if($x eq 0) then 0 else $x * $y}) 
                         },
    $ar := array { (1 to 36) ! function($x as xs:integer) as xs:integer {$x -15}(.)}
  return
     $product($ar)

</code></pre>
<p>Here we are passing a list containing just 36 integers. The result is quite unexpected and spectacular:</p>
<p><img src="https://github.com/qt4cg/qtspecs/assets/10605892/83a86918-deb3-4f4a-9b2f-38bab85d863f" alt="image"></p>
<p>Here is what happens:</p>
<ol>
<li>
<p>Even though when processing the 15th integer in the array the result is 0, the XPath processor continues to evaluate the RHS (right-hand side) until the last member of the array (<code>36</code>).</p>
</li>
<li>
<p>On “its way back” the XPath processor multiplies: <code>(36*35*34*33*32* …*6*5*4)*3</code>, and the result of the right-most multiplication is bigger than the maximum integer (or decimal) that this XPath processor supports.</p>
</li>
<li>
<p><strong>C r r r a s s h</strong> … As seen in the screenshot above.</p>
</li>
</ol>
<p>The root cause for this unfortunate behavior is that the XPath processor doesn’t support short-circuiting and laziness. And thus, <strong>fn:fold-right</strong> is useless even in the normal/trivial case of a collection (array) with only 36 members. Not to speak of collections containing millions of members, or even infinite ones…</p>
<p>Let us see what happens when evaluating similar expressions with another XPath processor: Saxon.</p>
<p>Saxon seems to produce the correct result, however it takes exponentially longer times when the length of the passed array is increased, leading to this one:</p>
<p><img src="https://github.com/qt4cg/qtspecs/assets/10605892/e0b9e34e-b58e-4100-a22a-48581be84072" alt="image"></p>
<p>It took 261 seconds for the evaluation to be done, but accessing the <code>15</code>th member of the array and short-circuiting to <code>0</code> should be almost instantaneous…<br>
So what happens in this case? The difference between BaseX and Saxon is that Saxon implements a “Big Integer” and thus can multiply almost <code>1 000 000</code> integers without getting a value that cannot be handled… But doing almost <code>1</code>M multiplications of big integers obviously takes time …</p>
<p>What is common in these two examples? Obviously, neither BaseX nor Saxon detects and performs short-circuiting. Why is this? What is the reason for this?</p>
<p>I asked a developer of BaseX if I could submit a bug about this behavior. His answer was shockingly unexpected: “<em>This is not a bug, because no requirement in the Specification has been violated</em>”.</p>
<p>Thus, the main cause of the common behavior of both XPath processors to handle the evaluation of these examples, is the specification of the function, which blatantly allows such crap to happen.</p>
<p>Now that we see this, let us try to provide the wanted, useful behavior writing our own function.</p>
<h2><strong>The fix: Step 1 – fn:fold-right in pure XPath</strong></h2>
<p>Before going in depth with our pure XPath solution, we need as a base a pure-XPath implementation of <strong>fn:fold-right</strong> .</p>
<pre><code class="language-xq"> let $fold-right-inner := function ($seq as item()*,
                                    $zero as item()*,
                                    $f as function(item(), item()*) as item()* ,
                                    $self as function(*)
                                   ) as item()*
{
  if(empty($seq)) then $zero
    else
      $f(head($seq), $self(tail($seq), $zero, $f, $self))
},

    $fold-right := function ($seq as item()*,
                             $zero as item()*,
                             $f as function(item(), item()*) as item()* 
                            ) as item()*
{
  $fold-right-inner($seq, $zero, $f, $fold-right-inner)
},
               
   $fAdd := function($x, $y)  {$x + $y},
   $fMult  := function($x, $y)  {$x * $y}
   
   return
     $fold-right((1 to 6) ! function($x){$x - 3}(.), 1, $fMult)
</code></pre>
<p>When we evaluate the above with any of the two XPath processors, the correct result is produced:</p>
<p>720</p>
<p>And we certainly do have exactly the same problems as the provided built-in <strong>fn:fold-right</strong> with a similar example:</p>
<p><img src="https://github.com/qt4cg/qtspecs/assets/10605892/b65e72b1-a5a6-4f73-b485-c316a05f3cc4" alt="image"></p>
<h2><strong>The fix: Step 2 – <code>$fold-right-sc</code> detecting and performing short-circuiting</strong></h2>
<p>Now that we have <strong><code>$fold-right</code></strong> as a base, let us add code to it so that it  will detect and perform short-circuiting. We will implement a function similar to <strong><code>$fold-right</code></strong> but having this signature:</p>
<pre><code class="language-xq">    $fold-right-sc := function ($seq as item()*,
                                $zero as item()*,
                                $f as function(item(), item()*) as item()*,
                                $fGetPartial as function(*)
                               ) as item()*
</code></pre>
<p>The last of the function’s parameters <code>$fGetPartial</code> returns a new function that is the partial application of <code>$f</code>, when its 1st argument is set to the current member of the input sequence <code>$seq</code>. The idea is that whenever short-circuiting is possible, <code>$fGetPartial</code> returns not a function having one argument (arity <code>1</code>), but a constant – a function with <code>0</code> arguments (arity <code>0</code>).</p>
<p>If the arity of the so produced partial application is <code>0</code>, then our code will immediately return with the value <code>$f($currentItem)</code>.</p>
<p>Here is the complete code of <code>$fold-right-sc</code>:</p>
<pre><code class="language-xq"> let $fold-right-sc-inner := function ($seq as item()*,
                                       $zero as item()*,
                                       $f as function(item(), item()*) as item()*,
                                       $fGetPartial as function(*),
                                       $self as function(*)
                                      ) as item()*
{
  if(empty($seq)) then $zero
    else
      if(function-arity($fGetPartial(head($seq), $zero)) eq 0)
        then $fGetPartial(head($seq), $zero) ()
        else $f(head($seq), $self(tail($seq), $zero, $f, $fGetPartial, $self))
},

    $fold-right-sc := function ($seq as item()*,
                                $zero as item()*,
                                $f as function(item(), item()*) as item()*,
                                $fGetPartial as function(*)
                               ) as item()*
{
  $fold-right-sc-inner($seq, $zero, $f, $fGetPartial, $fold-right-sc-inner)
},
               
   $fAdd := function($x, $y)  {$x + $y},
   $fMult  := function($x, $y)  {if($x eq 0) then 0 else $x * $y},
   $fMultGetPartial := function($x, $y)
   {
     if($x eq 0)
       then function() {0}
       else function($z) {$x * $z}
   }
   
   return
     $fold-right-sc((1 to 1000000) ! function($x){$x - 3}(.), 1, $fMult, $fMultGetPartial)

</code></pre>
<p><strong>Do note</strong>:</p>
<ol>
<li>
<p>If the current item (the head of the sequence) is <code>0</code>, then <code>$fMultGetPartial</code> returns a function with <code>0</code> arguments (constant) that produces <code>0</code>.</p>
</li>
<li>
<p><code>$fold-right-sc</code> (inner) treats differently a partial application of arity <code>0</code> from a partial application with arity <code>1</code>. In the former case it simply produces the expected constant value without recursing further. Here is the relevant code fragment</p>
</li>
</ol>
<pre><code class="language-xq">  if(empty($seq)) then $zero
    else
      if(function-arity($fGetPartial(head($seq), $zero)) eq 0)
        then $fGetPartial(head($seq), $zero) ()
        else $f(head($seq), $self(tail($seq), $zero, $f, $fGetPartial, $self))
</code></pre>
<p>And now BaseX has no problems with the evaluation, even though the input sequence is of size 1M. The complete evaluation takes just a fraction of a millisecond (0.04 ms):</p>
<p><img src="https://github.com/qt4cg/qtspecs/assets/10605892/3eec8eba-95e9-4ef4-bc4f-a1c5b9a3f0fc" alt="image"></p>
<p>With Saxon things are not so good. Even though Saxon produces the correct result, evaluating the expression with an input sequence of size 1M takes 0.5 seconds (half a second), and evaluating the expression with an input sequence of 10M takes 5 seconds (10 times as long):</p>
<p><img src="https://github.com/qt4cg/qtspecs/assets/10605892/087c279c-86b9-4b51-a086-eb7c3f85f802" alt="image"></p>
<p><img src="media/92f636bb9993afbd2fc75157f3024f75.png" alt=""></p>
<p>What is happening?</p>
<p>Even though Saxon performs much faster than the previous 261 seconds, due to  detecting the short-circuiting possibility and performing the short-circuit, Saxon still processes all 10M items when evaluating this subexpression (which obviously the more optimized BaseX doesn’t do in advance):</p>
<p><code>(1 to 10000000) ! function($x){$x - 3}(.)</code></p>
<p>Therefore, we have one remaining problem: How to prevent long sequences (or arrays) from being fully materialized before starting the evaluation of <code>$fold-right-sc</code> ?</p>
<h2><strong>The fix: Step 3 – replacing collections with generators</strong></h2>
<p>Generators are well known and provided out of the box in many programming languages. Per Wikipedia:</p>
<p>“In&nbsp;<a href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>,  a&nbsp;<strong>generator</strong>&nbsp;is a&nbsp;<a href="https://en.wikipedia.org/wiki/Subroutine">routine</a>&nbsp;that can be used to control the&nbsp;<a href="https://en.wikipedia.org/wiki/Iteration">iteration</a>&nbsp;behaviour of a&nbsp;<a href="https://en.wikipedia.org/wiki/Control_flow#Loops">loop</a>. All generators are also&nbsp;<a href="https://en.wikipedia.org/wiki/Iterator">iterators</a>.<a href="https://en.wikipedia.org/wiki/Generator_(computer_programming)#cite_note-1">[1]</a>&nbsp;A generator is very similar to a function that returns an array, in that a generator has parameters, can be called, and generates a sequence of values.
However, instead of building an array containing all the values and returning them all at once, a generator yields the values one at a time, which requires less memory and allows the caller to get started processing the first few values immediately. In short, a generator&nbsp;<em>looks like</em>&nbsp;a function but&nbsp;<em>behaves like</em>&nbsp;an&nbsp;<a href="https://en.wikipedia.org/wiki/Iterator">iterator</a>.”</p>
<p>A full-fledged generator (such as implemented in C#) is an instance of a <a href="https://en.wikipedia.org/wiki/Finite-state_machine">Finite State Machine(FSM)</a>, and implementing it in full generality goes beyond the topic and goals of this article. Expect another article soon that will provide this.</p>
<p>Here we will implement a simple kind of generator, that when passed an integer index <code>$N</code>, produces the <code>$N</code>th item of a specific sequence. Although this is probably the simplest form of a generator, it can be useful in many cases and is a good illustrative solution to our current problem. The whole approach of replacing “something” with a function that must be called to produce this “something” is known as <a href="https://wiki.haskell.org/Lifting">“lifting”</a></p>
<p>First, we will add to our <code>$fold-right</code> just the use of generators, without the detection and performing of short-circuiting:</p>
<pre><code class="language-xq">let $fold-right-lifted-inner := function ($seqGen as function(xs:integer) as array(*),
                                    $index as xs:integer,
                                    $zero as item()*,
                                    $f as function(item(), item()*) as item()* ,
                                    $self as function(*)
                                   ) as item()*
                                {
                                  let $nextSeqResult := $seqGen($index),
                                      $isEndOfSeq :=  $nextSeqResult(1),
                                      $seqItem := $nextSeqResult(2)
                                    return
                                      if($isEndOfSeq) then $zero
                                        else
                                          $f($seqItem, $self($seqGen, $index+1, $zero, $f, $self))
                                },

    $fold-right-lifted := function ($seqGen as function(xs:integer) as array(*),
                                    $zero as item()*,
                                    $f as function(item(), item()*) as item()* 
                                  ) as item()*
                                  {
                                    $fold-right-lifted-inner($seqGen, 1, $zero, $f, $fold-right-lifted-inner)
                                  },
                                  
   $NaN := xs:double('NaN'),
   
   $fSeq1ToN := function($ind as xs:integer, $indStart as xs:integer, $indEnd as xs:integer) as array(*)
                {
                  if($ind lt  $indStart or $ind gt $indEnd)
                    then  array{true(), $NaN}
                    else array{false(), $ind}
                },
   $fSeq-1-6 := $fSeq1ToN(?, 1, 6),
               
   $fAdd := function($x, $y)  {$x + $y},
   $fMult  := function($x, $y)  {$x * $y}
   
   return
     $fold-right-lifted($fSeq-1-6, 1, $fMult) 
</code></pre>
<p>Here we see an example of a simple generator – the function <strong><code>$fSeq1ToN</code></strong>.</p>
<p>This function returns an array with two members: a Boolean, which if <code>true()</code> indicates the end of the sequence, and the 2nd member is the current head of the simulated sequence.<br>
The generator has two other parameters which are the values (inclusive) for the start-index and the end-index. Whenever the passed value of <code>$ind</code> is outside of this specified range, <strong><code>$fSeq1ToN</code></strong> returns a result array with its first member set to <code>true()</code> (the 2nd member of the result must be ignored in this case), which indicates end-of sequence.<br>
Otherwise it returns <code>array{false(), $ind}</code> . It is the responsibility of the caller to stop calling the generator:</p>
<pre><code class="language-xq">   $fSeq1ToN := function($ind as xs:integer, $indStart as xs:integer, $indEnd as xs:integer) as array(*)
                {
                  if($ind lt  $indStart or $ind gt $indEnd)
                    then  array{true(), $NaN}
                    else array{false(), $ind}
                }
</code></pre>
<p>Evaluating the complete XPath expression above produces the correct result both in BaseX and in Saxon: the product of the integers <code>1</code> to <code>6</code>:</p>
<p><img src="https://github.com/qt4cg/qtspecs/assets/10605892/adcee4dc-ddec-4f4c-9e29-1c754315e3d3" alt="image"></p>
<p>Now that we have successfully implemented the last missing piece of our complete  solution, let us put everything together:</p>
<h2><strong>The fix: Step 4 – putting it all together</strong></h2>
<p>Finally we can replace the input sequence in $fold-right-sc with a generator:</p>
<pre><code class="language-xq">let $fold-right-sc-lifted-inner := function ($seqGen as function(xs:integer) as array(*),
                                    $index as xs:integer,
                                    $zero as item()*,
                                    $f as function(item(), item()*) as item()* ,
                                    $fGetPartial as function(*),
                                    $self as function(*)
                                   ) as item()*
                                {
                                  let $nextSeqResult := $seqGen($index),
                                      $isEndOfSeq :=  $nextSeqResult(1),
                                      $seqItem := $nextSeqResult(2)
                                    return
                                      if($isEndOfSeq) then $zero
                                        else
                                          if(function-arity($fGetPartial($seqItem, $zero)) eq 0)
                                            then $fGetPartial($seqItem, $zero) ()
                                            else $f($seqItem, $self($seqGen, $index+1, $zero, $f, $fGetPartial, $self))
                                },

    $fold-right-sc-lifted := function ($seqGen as function(xs:integer) as array(*),
                                       $zero as item()*,
                                       $f as function(item(), item()*) as item()*,
                                       $fGetPartial as function(*) 
                                      ) as item()*
                                      {
                                         $fold-right-sc-lifted-inner($seqGen, 1, $zero, $f, $fGetPartial, $fold-right-sc-lifted-inner)
                                      },
                                  
   $NaN := xs:double('NaN'),
   
   $fSeq1ToN := function($ind as xs:integer, $indStart as xs:integer, $indEnd as xs:integer) as array(*)
                {
                  if($ind lt  $indStart or $ind gt $indEnd)
                    then  array{true(), $NaN}
                    else array{false(), $ind}
                },
   $fSeq-1-6 := $fSeq1ToN(?, 1, 6),
   $fSeq-1-1M := $fSeq1ToN(?, 1, 1000000),
   $fSeq-1-1M-minus-3 := function($n as xs:integer)
   {
     array{$fSeq-1-1M($n)(1), $fSeq-1-1M($n)(2) -3}
   },
               
   $fAdd := function($x, $y)  {$x + $y},
   $fMult  := function($x, $y)  {$x * $y},
   $fMultGetPartial := function($x, $y)
   {
     if($x eq 0)
       then function() {0}
       else function($z) {$x * $z}
   }
   
   return
     $fold-right-sc-lifted($fSeq-1-1M-minus-3, 1, $fMult, $fMultGetPartial) 
</code></pre>
<p>Now this expression (and even one involving a sequence of 10M items take <code>0</code> seconds to be evaluated in both BaseX and Saxon, producing the correct result <code>0</code>:</p>
<p><img src="https://github.com/qt4cg/qtspecs/assets/10605892/e00a1c4c-ee3a-473e-8386-c6fbf10b6d04" alt="image"></p>
<h2><br><strong>Summary</strong></h2>
<p>This article demonstrated the problems inherent to the standard XPath <strong>fn:fold-right</strong> and correctly determined the root causes for these problems: no short-circuiting and no collection generators.</p>
<p>Then a step-by-step solution was built that shows how to implement lazy evaluation in XPath based on short-circuiting and collection generators. This fixed the error raised by BaseX and dramatically reduced the evaluation time of
Saxon from <code>261</code> seconds to <code>0</code> seconds.</p>
<p>The new function produced can be called <strong><code>$fold-lazy</code></strong> and is a good candidate for inclusion in the XPath 4.0 standard functions.</p>
<p>A complete design and implementation of a general collection-generator will be published in a separate article.</p>
</div></details></div>
<div class="toot" id="closed-667"><h2>Issue #667 closed<span class="toot-id"> #closed-667</span></h2><div class="pubdate">29 Aug at 14:49:38 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/667">https://github.com/qt4cg/qtspecs/pull/667</a></div><p>XPath minor edits, 4.16 through end</p></div>
<div class="toot" id="closed-642"><h2>Issue #642 closed<span class="toot-id"> #closed-642</span></h2><div class="pubdate">29 Aug at 13:09:32 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/642">https://github.com/qt4cg/qtspecs/pull/642</a></div><p>561: Editorial (abbreviation fn=function, drop lambda syntax)</p></div>
<div class="toot" id="closed-646"><h2>Issue #646 closed<span class="toot-id"> #closed-646</span></h2><div class="pubdate">29 Aug at 12:39:53 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/646">https://github.com/qt4cg/qtspecs/pull/646</a></div><p>508: Editorial, examples revised (array:split, array:slice, others)</p></div>
<div class="toot" id="closed-627"><h2>Issue #627 closed<span class="toot-id"> #closed-627</span></h2><div class="pubdate">29 Aug at 12:38:11 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/627">https://github.com/qt4cg/qtspecs/pull/627</a></div><p>624: Adjusted function category descriptions</p></div>
<div class="toot" id="closed-662"><h2>Issue #662 closed<span class="toot-id"> #closed-662</span></h2><div class="pubdate">29 Aug at 12:36:42 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/662">https://github.com/qt4cg/qtspecs/pull/662</a></div><p>658b: changes to constructor functions</p></div>
<div class="toot" id="closed-656"><h2>Issue #656 closed<span class="toot-id"> #closed-656</span></h2><div class="pubdate">29 Aug at 12:36:24 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/656">https://github.com/qt4cg/qtspecs/pull/656</a></div><p>Better return type for map pair</p></div>
<div class="toot" id="closed-654"><h2>Issue #654 closed<span class="toot-id"> #closed-654</span></h2><div class="pubdate">29 Aug at 12:36:03 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/654">https://github.com/qt4cg/qtspecs/pull/654</a></div><p>Add covers-40 attribute to generated tests</p></div>
<div class="toot" id="closed-644"><h2>Issue #644 closed<span class="toot-id"> #closed-644</span></h2><div class="pubdate">29 Aug at 12:35:35 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/644">https://github.com/qt4cg/qtspecs/pull/644</a></div><p>Adjusted CSS to target classes, not element + classes</p></div>
<div class="toot" id="closed-643"><h2>Issue #643 closed<span class="toot-id"> #closed-643</span></h2><div class="pubdate">29 Aug at 12:35:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/643">https://github.com/qt4cg/qtspecs/pull/643</a></div><p>414, 546: Adjusted XDM description of xs:string, added coding</p></div>
<div class="toot" id="created-669"><h2>Issue #669 created<span class="toot-id"> #created-669</span></h2><div class="pubdate">20 Aug at 22:20:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/669">https://github.com/qt4cg/qtspecs/issues/669</a></div><details><summary>Typo in XSLT §26.4 - "appearing appearing"</summary><div class="markup"><p>The word "appearing" is doubled.</p>
</div></details></div>
<div class="toot" id="created-668"><h2>Issue #668 created<span class="toot-id"> #created-668</span></h2><div class="pubdate">18 Aug at 17:42:10 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/668">https://github.com/qt4cg/qtspecs/issues/668</a></div><details><summary>Definition of HTML case-insensitive collation</summary><div class="markup"><p>The semantics of the collation URI http://www.w3.org/2005/xpath-functions/collation/html-ascii-case-insensitive are described (in F&amp;O section 5.3.4) are described by reference to the HTML5 "living spec". The cross-reference to a changing spec is inevitably fragile and I suggest we make it non-normative. I also suggest that we define the ordering implied by this collation rather than leaving it implementation defined.</p>
<p>A sufficient definition is: the comparison of two strings A and B under this collation delivers the same result as the comparison of ascii-lower-case(A) to ascii-lower-case(B) under the Unicode codepoint collation, where ascii-lower-case($S) function is translate($S, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcedfghijklmnopqrstuvwxyz").</p>
<p>Perhaps we should also consider defining a collation URI that is unicode-case-blind, with the same definition except that ascii-lower-case(X) is replaced by fn:lower-case(X).</p>
</div></details></div>
<div class="toot" id="created-667"><h2>Pull request #667 created<span class="toot-id"> #created-667</span></h2><div class="pubdate">18 Aug at 01:54:43 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/667">https://github.com/qt4cg/qtspecs/pull/667</a></div><details><summary>XPath minor edits, 4.16 through end</summary><div class="markup"><p>Various small edits. I added two simple examples to help readers quickly understand the difference between <code>=&gt;</code> and <code>=!&gt;</code> before going to more complex examples.</p>
</div></details></div>
<div class="toot" id="created-666"><h2>Issue #666 created<span class="toot-id"> #created-666</span></h2><div class="pubdate">17 Aug at 10:02:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/666">https://github.com/qt4cg/qtspecs/issues/666</a></div><details><summary>Polyfill function implementations</summary><div class="markup"><p>For transition purposes, it may be useful to provide or enable "polyfill" implementations of functions that are specified in QT40, but not yet available in all implementations. Currently this is not possible because the relevant namespaces are reserved.</p>
<p>I propose that we relax the rule on reserved function namespaces:</p>
<p>(a) in XQuery, if the function has an annotation along the lines `%polyfill('http://www.w3.org/2005/xpath-functions'), where the parameter indicates that the function should be injected into the specified namespace instead of the namespace of the containing module.</p>
<p>(b) in XSLT, if the attribute <code>xsl:function/@override-extension-function="no"</code> is present. A function is allowed to be in a reserved namespace if this attribute is present.</p>
<p>I've chosen syntax here that's already available in 3.0/3.1, to minimise the impact on existing processors. Of course, we can't retrospectively change the 3.0/3.1 specs to authorise older processors to make this work as intended. But we can suggest that they bend the rules.</p>
<p>In both cases, (a) if the annotation is present then the rules on reserved namespaces don't apply, and (b) the function declaration is ignored if the processor provides its own internal implementation of the function.</p>
<p>I'm proposing to publish polyfill implementations of many of the new functions (not the complex ones like parse-html!). But I don't intend to make this a QT4 deliverable, I'm thinking of doing it as an open source project in GitHub/Saxonica space.</p>
</div></details></div>
<div class="toot" id="created-665"><h2>Issue #665 created<span class="toot-id"> #created-665</span></h2><div class="pubdate">17 Aug at 08:51:00 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/665">https://github.com/qt4cg/qtspecs/issues/665</a></div><details><summary>Typo in fn:items-before and fn:items-ending-where</summary><div class="markup"><p>The specifications refer to $seq in place of $input.</p>
</div></details></div>
<div class="toot" id="created-664"><h2>Pull request #664 created<span class="toot-id"> #created-664</span></h2><div class="pubdate">16 Aug at 20:19:55 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/664">https://github.com/qt4cg/qtspecs/pull/664</a></div><details><summary>663 xsl:original keywords</summary><div class="markup"><p>Fix #663.</p>
<p>A simple fix, just specify that if xsl:original is called with keywords, the keywords used are those of the overridden function.</p>
</div></details></div>
<div class="toot" id="created-663"><h2>Issue #663 created<span class="toot-id"> #created-663</span></h2><div class="pubdate">15 Aug at 22:17:21 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/663">https://github.com/qt4cg/qtspecs/issues/663</a></div><details><summary>Calling xsl:original() with keywords</summary><div class="markup"><p>We need to define what happens if xsl:original() is called with keyword arguments.</p>
<p>The answer isn't trivial, because (for 3.0 compatibility reasons) an overriding function isn't required to use the same parameter keywords as the function it overrides.</p>
<p>Perhaps we should recognize that there are functions that do not support argument keywords. This might be the case, for example, with Java or C# extension functions.</p>
</div></details></div>
<div class="toot" id="created-662"><h2>Pull request #662 created<span class="toot-id"> #created-662</span></h2><div class="pubdate">15 Aug at 16:34:24 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/662">https://github.com/qt4cg/qtspecs/pull/662</a></div><details><summary>658b: changes to constructor functions</summary><div class="markup"><p>Changes argument name to "value", makes argument default to context item.</p>
</div></details></div>
<div class="toot" id="closed-661"><h2>Issue #661 closed<span class="toot-id"> #closed-661</span></h2><div class="pubdate">15 Aug at 16:32:32 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/661">https://github.com/qt4cg/qtspecs/pull/661</a></div><p>658: constructor functions</p></div></div><p>See 1227
            more statuses in yearly archives.</p></article></main></body></html>