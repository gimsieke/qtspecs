<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2023/">2023</a>, <a href="2022/">2022</a>, <a href="2021/">2021</a>, <a href="2020/">2020</a></p><div class="toots">
<div class="toot" id="minutes-09-26"><h2>QT4 CG meeting 047 draft minutes<span class="toot-id"> #minutes-09-26</span></h2><div class="pubdate">26 Sep at 17:30:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/09-26">https://qt4cg.org/meeting/minutes/2023/09-26</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="closed-663"><h2>Issue #663 closed<span class="toot-id"> #closed-663</span></h2><div class="pubdate">26 Sep at 16:13:20 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/663">https://github.com/qt4cg/qtspecs/issues/663</a></div><p>Calling xsl:original() with keywords</p></div>
<div class="toot" id="closed-674"><h2>Issue #674 closed<span class="toot-id"> #closed-674</span></h2><div class="pubdate">26 Sep at 16:13:19 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/674">https://github.com/qt4cg/qtspecs/pull/674</a></div><p>663: Describe how calls to xsl:original with keywords work</p></div>
<div class="toot" id="closed-570"><h2>Issue #570 closed<span class="toot-id"> #closed-570</span></h2><div class="pubdate">26 Sep at 16:12:44 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/570">https://github.com/qt4cg/qtspecs/issues/570</a></div><p>XSLT: Built-in template rules for maps and arrays</p></div>
<div class="toot" id="closed-718"><h2>Issue #718 closed<span class="toot-id"> #closed-718</span></h2><div class="pubdate">26 Sep at 16:12:42 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/718">https://github.com/qt4cg/qtspecs/pull/718</a></div><p>Add on-no-match="shallow-copy-all"</p></div>
<div class="toot" id="agenda-09-26"><h2>QT4 CG meeting 047 draft agenda<span class="toot-id"> #agenda-09-26</span></h2><div class="pubdate">25 Sep at 10:55:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/09-26">https://qt4cg.org/meeting/agenda/2023/09-26</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-720"><h2>Issue #720 created<span class="toot-id"> #created-720</span></h2><div class="pubdate">25 Sep at 09:47:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/720">https://github.com/qt4cg/qtspecs/issues/720</a></div><details><summary>From Records to Objects</summary><div class="markup"><p>It has become idiomatic to use maps, and record type definitions, to declare a collection of functions; so for example the random-number-generator object offers a "method" <code>next()</code> that can be called using the syntax <code>$rng?next()</code>.</p>
<p>The problem is that it's not possible, within the XPath/XQuery language, to implement such a function with implicit access to the object on which it is invoked. The implementation of the function does not have access to any kind of <code>$this</code> variable.</p>
<p>This issue considers how we can move forwards from supporting simple records to introduce object capabilities, in an incremental and compatible way.</p>
<p>Here are three steps in that direction:</p>
<ol>
<li>Where a named record type is declared, also create a corresponding constructor function. So if you declare</li>
</ol>
<p><code>declare item type my:loc as record(longitude as xs:double, latitude as xs:double)</code></p>
<p>you also get a constructor function allowing my:loc(180, 180), allowing both positional or keyword arguments corresponding to the field names,</p>
<ol start="2">
<li>
<p>Allow default values to be defined in the record type, which act as default values for the parameters in the constructor function.</p>
</li>
<li>
<p>Allow functions that are defined as part of a record type access to a variable $this. The constructor function provides an implicit binding of this variable to the record/map/object that is being instantiated.</p>
</li>
<li>
<p>Allow self-reference to a named record type (and its constructor function) within the record definition.</p>
</li>
</ol>
<p>So you can now do:</p>
<pre><code>declare type my:counter as record (
   value as xs:integer,
   increment := fn() as my:counter {my:counter($this?value + 1)}
)
</code></pre>
<p>and then</p>
<pre><code>let $x := my:counter(0)
return $x?increment()?value
</code></pre>
<p>which returns 1.</p>
</div></details></div>
<div class="toot" id="created-719"><h2>Pull request #719 created<span class="toot-id"> #created-719</span></h2><div class="pubdate">21 Sep at 20:21:29 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/719">https://github.com/qt4cg/qtspecs/pull/719</a></div><details><summary>413: Spec for CSV-related functions</summary><div class="markup"><p>This PR contains error fixes (typos, examples that contradicted the spec text), some (hopefully) improved language and one breaking change.</p>
<p>The current draft uses the type <code>map(xs:integer, xs:string)</code> for the <code>column-names</code> option to <code>fn:csv-to-xdm</code> and <code>fn:csv-to-xml</code>. This PR flips that to <code>map(xs:string, xs:integer)</code>. It turns out that the examples were already using this, and it seems to me that having the <code>names</code> entry in the <code>csv-columns-record</code> record type be the transposed version of the <code>column-names</code> option that creates it, rather than be the same thing, is counterproductive.</p>
<p>I can think of some examples (a CSV split into several chunks, with only the first containing the headers) where being able to feed the <code>names</code> entry right back into another invocation of <code>fn:csv-to-xdm</code> would be useful. If nothing else it's confusing and not obvious, or I wouldn't have messed up the examples, and somebody would have noticed during the review process...</p>
</div></details></div>
<div class="toot" id="created-718"><h2>Pull request #718 created<span class="toot-id"> #created-718</span></h2><div class="pubdate">21 Sep at 16:39:15 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/718">https://github.com/qt4cg/qtspecs/pull/718</a></div><details><summary>Add on-no-match="shallow-copy-all"</summary><div class="markup"><p>Enable recursive descent transformation with template rules for maps and arrays.</p>
<p>Fix #570</p>
</div></details></div>
<div class="toot" id="created-717"><h2>Pull request #717 created<span class="toot-id"> #created-717</span></h2><div class="pubdate">21 Sep at 10:36:51 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/717">https://github.com/qt4cg/qtspecs/pull/717</a></div><details><summary>211: add capturing accumulators to XSLT</summary><div class="markup"><p>Adds the attribute capture="yes" to xsl:accumulator-rule. This has been available as a Saxon extension for some time and makes many accumulators much easier to implement.</p>
<p>Fix #211</p>
</div></details></div>
<div class="toot" id="created-716"><h2>Issue #716 created<span class="toot-id"> #created-716</span></h2><div class="pubdate">20 Sep at 02:34:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/716">https://github.com/qt4cg/qtspecs/issues/716</a></div><details><summary>Generators in XPath</summary><div class="markup"><h1>What is a generator?</h1>
<p>Generators are well known and provided out of the box in many programming languages. Per Wikipedia:</p>
<p>“In&nbsp;<a href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>,  a&nbsp;<strong>generator</strong>&nbsp;is a&nbsp;<a href="https://en.wikipedia.org/wiki/Subroutine">routine</a>&nbsp;that can be used to control the&nbsp;<a href="https://en.wikipedia.org/wiki/Iteration">iteration</a>&nbsp;behaviour of a&nbsp;<a href="https://en.wikipedia.org/wiki/Control_flow#Loops">loop</a>. All generators are also&nbsp;<a href="https://en.wikipedia.org/wiki/Iterator">iterators</a>.<a href="https://en.wikipedia.org/wiki/Generator_(computer_programming)#cite_note-1">[1]</a>&nbsp;A generator is very similar to a function that returns an array, in that a generator has parameters, can be called, and generates a sequence of values.
However, instead of building an array containing all the values and returning them all at once, a generator yields the values one at a time, which requires less memory and allows the caller to get started processing the first few values immediately. In short, a generator&nbsp;<em>looks like</em>&nbsp;a function but&nbsp;<em>behaves like</em>&nbsp;an&nbsp;<a href="https://en.wikipedia.org/wiki/Iterator">iterator</a>.”</p>
<hr>
<h1>The goal of this proposal (major use-cases)</h1>
<p>A generator in XPath should be a tool to easily implement the solutions to the following use-cases:</p>
<ol>
<li>
<p>Processing a huge collection whose members may not all be needed.<br>
A generator will produce only the next member of the collection and only on demand basis.</p>
</li>
<li>
<p>Handling a collection containing unknown or infinite number of members.
When requested the next member of the collection the generator will always produce it, if the collection still contains any members. It is the responsibility of the caller to issue only the necessary number of requests for the really needed next members.</p>
</li>
</ol>
<p>What is achieved in both cases:</p>
<ul>
<li>A (next) member is produced only on request. No time is spent on producing all members of the collection.</li>
<li>A (next) member is produced only on request. No memory is consumed to store all members of the collection.</li>
</ul>
<p>A good problem that is based on these use-cases is to generate a collection of the first N members that have some wanted properties,  and are generated from other collection(s), when it is not known what the size of the original input collections would be in order for the desired number of N members to be discovered.</p>
<p>For example: <strong><em>Produce the first 1 000 000 (1M) prime numbers</em></strong>.</p>
<p>Sometimes we may not even know if N such wanted members actually exist, for example: <strong><em>Produce the first 2 sequences of 28 prime numbers where <a href="https://en.wikipedia.org/wiki/Primes_in_arithmetic_progression#Largest_known_primes_in_AP">the primes in each of the sequences form an arithmetic progression</a>.</em></strong></p>
<hr>
<h1>The Proposal</h1>
<p>A generator is defined as (and synonym for):</p>
<pre><code class="language-xq">let $generator as record
                   (initialized as xs:boolean,
                    endReached as xs:boolean,
                    getCurrent as function(..) as item()*,
                    moveNext as function(..) as .. ,
                    *  ) 
</code></pre>
<p>A generator is an extensible <a href="https://qt4cg.org/pr/715/xquery-40/xpath-40.html#id-record-test"><strong><em>record</em></strong> </a>.</p>
<p>It has four fixed-named keys, and any other map-keys, as required to hold the internal state of that specific generator.</p>
<p>Here is the meaning of  the four fixed/named keys:</p>
<ul>
<li>
<p><strong><em>initialized</em></strong> is a boolean. When a generator <code>$gen</code>  is initially instantiated, <code>$gen?initialized</code> is <code>false()</code>. Any call to <code>$gen?getCurrent()</code> raises an error. In order to get the first value of the represented collection, the caller must call <code>$gen?moveNext()</code></p>
</li>
<li>
<p><strong><em>endReached</em></strong> is a boolean. If after a call to <code>moveNext()</code> the value of the returned generator's <code>endReached</code> key is <code>true()</code> then calling <code>moveNext()</code> and/or <code>getCurrent()</code> on this generator raises an error.</p>
</li>
<li>
<p><strong><em>getCurrent</em></strong> is a function of zero arguments. It must only be called if the values of <code>initialized</code> is <code>true()</code> and the value of <code>endReached</code> is <code>false()</code>, otherwise an error must be raised. This function produces the current member of the collection after the last call to <code>moveNext</code>, if this call didn't return a generator whose <code>endReached</code> value was <code>true()</code></p>
</li>
<li>
<p><strong><em>moveNext</em></strong>  is a function of zero arguments. When called on a generator whose <code>endReached</code> value is <code>false()</code> then it produces the next (state of the) generator. including a possibly <code>true()</code> value of <code>endReached</code> and if this value is still <code>false()</code>, then calling <code>getCurrent()</code> produces the value of the next member of the collection.</p>
</li>
</ul>
<h1>Examples of operations on generators</h1>
<p>The following examples are written in pseudo-code as at the time of writing there was no available implementation of records. And also, the code for recursion in pure XPath makes any such example longer than necessary for grasping its meaning.</p>
<h2>Take the first N members of the collection</h2>
<pre><code class="language-xq">take($gen as generator, $n as xs:integer, $result as array(*) = []) as array(*)
{
  let $gen := if(not($gen?initialized)) then $gen?moveNext()
                else $gen
      $result := if(not($gen?endReached) and $n gt 0) then array:append($result, $gen?getCurrent())
   return
    if(not($gen?endReached) and $n gt 0) then take($gen?moveNext(), $n -1, $result)
      else $result
}
</code></pre>
<h2>Skip the first N members from the collection</h2>
<pre><code class="language-xq">skip($gen as generator, $n as xs:integer) as generator
{
  if($n eq 0) then $gen
     else
     {
         let $gen := if(not($gen?initialized)) then $gen?moveNext()
                       else $gen
           return
             if(not($gen?endReached) then skip($gen?moveNext(), $n -1)
               else $gen
     }             
}
</code></pre>
<h2>Subrange of size N starting at the M-th member</h2>
<pre><code class="language-xq">subrange($gen as generator, $m as xs:integer, $n as xs:integer)
{
  take(skip($gen, $m -1), $n)
}
</code></pre>
<h2>Head of a generator</h2>
<pre><code class="language-xq">head($gen as generator)
{
  take($gen, 1)
}
</code></pre>
<h2>Tail of a generator</h2>
<pre><code class="language-xq">tail($gen as generator)
{
  skip($gen, 1)
}
</code></pre>
<h2>At index N</h2>
<pre><code class="language-xq">at($ind as xs:integer)
{
  subrange($ind, 1)
}
</code></pre>
<h2>For Each</h2>
<pre><code class="language-xq">for-each($gen as generator, $fun as function(*))
{
   map:put($gen, "getCurrent", function() { $fun($gen?getCurrent()) }  )                              
}
</code></pre>
<h2>For Each Pair</h2>
<pre><code class="language-xq">for-each-pair($gen1 as generator, $gen2 as generator, $fun as function(*))
{
   let $gen1 := if(not($gen1?initialized)) then $gen1?moveNext()
                  else $gen1,
       $gen2 := if(not($gen2?initialized)) then $gen2?moveNext()
                  else $gen2,
    return
      if($gen1?endReached or $gen2?endReached) then map:put($gen1, "endReached", true())
        else map:put(map:put($gen1, "getCurrent", function() { $fun($gen1?getCurrent(), $gen2?getCurrent()) } ) ,
                     "moveNext", function() { for-each-pair(skip($gen1, 1), skip($gen2, 1), $fun)}
                    )                             
}
</code></pre>
<h2>Filter</h2>
<pre><code class="language-xq">filter($gen as generator, $pred as function(item()*) as xs:boolean)
{
     let $getNextGoodValue := function($gen as map(*), $pred as function(item()*) as xs:boolean)
         {
            let $mapResult := iterate-while(
                                            $gen,
                                            function($gen) { not($pred($gen?getCurrent($gen))) },
                                            function($gen) { $gen?moveNext($gen) }
                                            )   
            return $mapResult?getCurrent($mapResult)                     
         },
       $gen := if($gen?initialized) then $gen 
                      else $gen?moveNext($gen)
        return
          map {
               "initialized": true(),
               "endReached":  $gen?endReached,
               "getCurrent": function($this as map(*)) { $getNextGoodValue($this?inputGen, $pred) },
               "moveNext":   function($this as map(*))
                             {    let $nextGoodValue := $getNextGoodValue($this?inputGen?moveNext($this?inputGen), $pred),
                                      $nextGen := iterate-while(
                                                                $this?inputGen?moveNext($this?inputGen),
                                                                function($gen) { not($pred($gen?getCurrent($gen))) },
                                                                function($gen) { $gen?moveNext($gen) }
                                                                )
                                    return
                                      map {
                                            "initialized": $nextGen?initialized,
                                            "endReached":  $nextGen?endReached,
                                            "getCurrent" : function($x) {$nextGoodValue},
                                            "moveNext" :   $this?moveNext,
                                            "inputGen" :   $nextGen
                                           }
                             },
               "inputGen" : $gen
              }
        }
</code></pre>
</div></details></div>
<div class="toot" id="created-715"><h2>Pull request #715 created<span class="toot-id"> #created-715</span></h2><div class="pubdate">19 Sep at 23:12:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/715">https://github.com/qt4cg/qtspecs/pull/715</a></div><details><summary>372 Rollback the default namespace changes</summary><div class="markup"><p>Implements the CG decision to roll back the changes that introduced two separate default namespaces for elements and types.</p>
<p>Fix #372</p>
</div></details></div>
<div class="toot" id="created-714"><h2>Issue #714 created<span class="toot-id"> #created-714</span></h2><div class="pubdate">19 Sep at 21:19:43 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/714">https://github.com/qt4cg/qtspecs/issues/714</a></div><details><summary>Function annotations in XSLT</summary><div class="markup"><p>I propose that the following attributes on an <code>xsl:function</code> should be accessible as annotations, for example in a call on function-annotations:</p>
<ul>
<li>visibility</li>
<li>streamability</li>
<li>new-each-time</li>
<li>cache</li>
</ul>
<p>plus any extension attribute in a user-defined namespace, for example <code>&lt;xsl:function saxon:debug="yes"/&gt;</code> should have the annotation <code>%saxon:debug("yes")</code>. The value is always a single string, the actual attribute value as written.</p>
</div></details></div>
<div class="toot" id="closed-129"><h2>Issue #129 closed<span class="toot-id"> #closed-129</span></h2><div class="pubdate">19 Sep at 16:26:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/129">https://github.com/qt4cg/qtspecs/issues/129</a></div><p>Context item → Context value?</p></div>
<div class="toot" id="closed-703"><h2>Issue #703 closed<span class="toot-id"> #closed-703</span></h2><div class="pubdate">19 Sep at 16:26:11 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/703">https://github.com/qt4cg/qtspecs/pull/703</a></div><p>129 (1): XPath and XQuery changes for introduction of context value</p></div>
<div class="toot" id="closed-701"><h2>Issue #701 closed<span class="toot-id"> #closed-701</span></h2><div class="pubdate">19 Sep at 16:26:00 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/701">https://github.com/qt4cg/qtspecs/issues/701</a></div><p>fn:concat: Support for 0 or more arguments</p></div>
<div class="toot" id="closed-702"><h2>Issue #702 closed<span class="toot-id"> #closed-702</span></h2><div class="pubdate">19 Sep at 16:25:59 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/702">https://github.com/qt4cg/qtspecs/pull/702</a></div><p>701: fn:concat: Support for 0 or more arguments</p></div>
<div class="toot" id="closed-696"><h2>Issue #696 closed<span class="toot-id"> #closed-696</span></h2><div class="pubdate">19 Sep at 16:25:42 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/696">https://github.com/qt4cg/qtspecs/pull/696</a></div><p>566: Rework query parameters on build-uri/parse-uri</p></div>
<div class="toot" id="closed-694"><h2>Issue #694 closed<span class="toot-id"> #closed-694</span></h2><div class="pubdate">19 Sep at 16:23:58 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/694">https://github.com/qt4cg/qtspecs/pull/694</a></div><p>XQFO minor edits, with new examples and notes, 2 through 4.6</p></div>
<div class="toot" id="closed-687"><h2>Issue #687 closed<span class="toot-id"> #closed-687</span></h2><div class="pubdate">19 Sep at 16:23:42 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/687">https://github.com/qt4cg/qtspecs/issues/687</a></div><p>Constructor functions for user-defined types</p></div>
<div class="toot" id="closed-690"><h2>Issue #690 closed<span class="toot-id"> #closed-690</span></h2><div class="pubdate">19 Sep at 16:23:41 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/690">https://github.com/qt4cg/qtspecs/pull/690</a></div><p>687 Clarify constructor functions for user-defined types</p></div>
<div class="toot" id="closed-668"><h2>Issue #668 closed<span class="toot-id"> #closed-668</span></h2><div class="pubdate">19 Sep at 16:23:30 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/668">https://github.com/qt4cg/qtspecs/issues/668</a></div><p>Definition of HTML case-insensitive collation</p></div>
<div class="toot" id="closed-680"><h2>Issue #680 closed<span class="toot-id"> #closed-680</span></h2><div class="pubdate">19 Sep at 16:23:29 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/680">https://github.com/qt4cg/qtspecs/pull/680</a></div><p>668 define case insensitive collation normatively</p></div>
<div class="toot" id="created-713"><h2>Issue #713 created<span class="toot-id"> #created-713</span></h2><div class="pubdate">19 Sep at 16:22:04 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/713">https://github.com/qt4cg/qtspecs/issues/713</a></div><details><summary>Annotations: Editorial notes</summary><div class="markup"><p>Copied from https://github.com/qt4cg/qtspecs/pull/710#pullrequestreview-1630129066:</p>
<blockquote>
<p>For avoidance of doubt, we should say in XQuery 4.6.2.4 (Named Function References) that the function created by a named function reference has its annotations taken from the function definition. There are other places where we are not explicit about the annotations of a function item, for example with partial function application. We should add a note that in XPath and XSLT, it is not possible to define function annotations, so this function will always return an empty result. (However, we should consider giving user-defined functions in XSLT annotations based on their attributes, e.g. visibility and streamability).</p>
</blockquote>
<p>…and my complementary note in the PR thread:</p>
<blockquote>
<p>I decided to merge the PR without changes, and not add the reference to XPath and XSLT, because the function may also return results for XQuery functions imported via fn:load-xquery-module.</p>
</blockquote>
<p>Additional notes from today’s meeting:</p>
<ul>
<li>For annotations without values, we could assign <code>true()</code> as a default value.</li>
<li>Examples could be added to <code>fn:function-annotations</code> to demonstrate how to check for annotations without values (or with values whose EBV is <code>false()</code>: <code>0</code>, <code>""</code>, etc.).</li>
<li>Dimitre suggested restructuring the spec for features that are not available in XPath.</li>
<li>Maybe annotations would also be helpful in XPath.</li>
</ul>
<p>Feel free everyone to add more comments.</p>
</div></details></div>
<div class="toot" id="closed-36"><h2>Issue #36 closed<span class="toot-id"> #closed-36</span></h2><div class="pubdate">19 Sep at 16:12:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/36">https://github.com/qt4cg/qtspecs/issues/36</a></div><p>fn:function-annotations (Allow support for user-defined annotations)</p></div>
<div class="toot" id="closed-710"><h2>Issue #710 closed<span class="toot-id"> #closed-710</span></h2><div class="pubdate">19 Sep at 16:12:51 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/710">https://github.com/qt4cg/qtspecs/pull/710</a></div><p>36: fn:function-annotations</p></div>
<div class="toot" id="created-712"><h2>Issue #712 created<span class="toot-id"> #created-712</span></h2><div class="pubdate">19 Sep at 13:50:37 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/712">https://github.com/qt4cg/qtspecs/issues/712</a></div><details><summary>array:sort: to be aligned with fn:sort</summary><div class="markup"><p>Related: #623. And an editorial note:</p>
<p>https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-sort</p>
<p>I think the type for the 3rd argument of <code>fn:sort</code>…</p>
<pre><code>$key  as&nbsp;(function(item()) as xs:anyAtomicType*)+  :=&nbsp;fn:data#1
</code></pre>
<p>…should be changed to zero-or-more:</p>
<pre><code>$key  as&nbsp;(function(item()) as xs:anyAtomicType*)*  :=&nbsp;fn:data#1
</code></pre>
<p>While it will be rare to encounter queries with <code>key := ()</code>, there seems to be no urgent reason to enforce at least one sort key. The change would also be in alignment with the corresponding rule (with the current signature, <code>$key</code> cannot be empty), which says:</p>
<blockquote>
<p>The number of sort key definitions is determined by the number of function items supplied in the <code>$key</code> argument. If the argument is absent or empty, the default is a single sort key definition using the function <code>data#1</code>.</p>
</blockquote>
</div></details></div>
<div class="toot" id="created-711"><h2>Issue #711 created<span class="toot-id"> #created-711</span></h2><div class="pubdate">19 Sep at 09:22:59 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/711">https://github.com/qt4cg/qtspecs/issues/711</a></div><details><summary>Using annotations for navigation of JSON trees</summary><div class="markup"><p>This issue develops ideas presented in issue #596, which itself is a continuation of ideas raised in issue #341, issue #350, and elsewhere. It's related to the requirements presented in issue #262 and issue #297.</p>
<p>Firstly, I propose a change to the data model so that annotations can be attached to any item [or perhaps any value?], not only to a function. The annotations are a map of type <code>map{xs:QName, item()*}</code>. Some general principles:</p>
<ul>
<li>Annotations on an item do not affect the result of any operation on that item unless otherwise specified.</li>
<li>Operations that are described as returning a result that contains items that are present in one of the operation's operands retain the annotations of those items, unless otherwise specified. (So for example $a[C] returns a sequence of items from $a in which the annotations are preserved).</li>
<li>Operations that construct "new" items (for example $a + $b) return an item with no annotations, unless otherwise specified.</li>
<li>The function <code>annotations($x)</code> (replacing <code>function-annotations($x)</code>) returns the annotations of an item.</li>
<li>The function annotate($x, key, value) returns a "clone" of $x with an additional annotation. (A clone of an item differs from the original only in having different annotations. All operations other than annotation-sensitive operations produce exactly the same result on the clone and the original - including tests for node identity.)</li>
<li>To avoid confusion, the term "type annotation" is replaced by "type label".</li>
</ul>
<p>Secondly, we use annotations to aid navigation of JTrees (a term I use to describe trees of arrays and maps such as might be produced by parsing JSON).</p>
<p>We introduce a component of the static context <code>tracked=true|false</code>, defaulting to false. The construct <code>tracked{expression}</code> evaluates an expression and its subexpressions in tracked mode. In tracked mode any operator or function that performs selection within an array or map (for example the lookup operator, the <code>map:get</code> and <code>array:get</code> function, using the map/array as a function item, or the <code>array:head()</code> and <code>array:foot()</code> and <code>map:find()</code> functions) annotates the items in its result with two properties: "container" whose value is the map or array from which the item was selected, and "key" which is the key or array index of the selected value within that container. The effect is that if an item was found in a JTree using a tracked expression, the annotations on the resulting item can be used in effect to navigate upwards within the tree that was searched.</p>
<p>Note that this is not a new idea: in effect, the result of a tracked selection is a <strong>zipper</strong> data structure, as described in https://en.wikipedia.org/wiki/Zipper_(data_structure).</p>
<p>A further exploitation of the idea allows us to introduce deep update of JTree structures. For example, <code>modify(root:=$a, selection:=fn{?x?y?z,} change:=fn{.+1})</code> can evaluate the <code>selection</code> argument in tracked mode, apply the <code>change</code> function to the resulting items, and then navigate back using the <code>container</code> annotation to create modified versions of all traversed containing JTrees, eventually returning a modified version of the <code>root</code> tree.</p>
</div></details></div>
<div class="toot" id="agenda-09-19"><h2>QT4 CG meeting 046 draft agenda<span class="toot-id"> #agenda-09-19</span></h2><div class="pubdate">18 Sep at 14:00:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/09-19">https://qt4cg.org/meeting/agenda/2023/09-19</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="closed-673"><h2>Issue #673 closed<span class="toot-id"> #closed-673</span></h2><div class="pubdate">18 Sep at 13:49:45 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/673">https://github.com/qt4cg/qtspecs/pull/673</a></div><p>HTML namespace changes</p></div></div><p>See 1317
            more statuses in yearly archives.</p></article></main></body></html>