<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2023/">2023</a>, <a href="2022/">2022</a>, <a href="2021/">2021</a>, <a href="2020/">2020</a></p><div class="toots">
<div class="toot" id="minutes-12-05"><h2>QT4 CG meeting 057 draft minutes<span class="toot-id"> #minutes-12-05</span></h2><div class="pubdate">05 Dec at 17:10:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/12-05">https://qt4cg.org/meeting/minutes/2023/12-05</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="created-873"><h2>Pull request #873 created<span class="toot-id"> #created-873</span></h2><div class="pubdate">05 Dec at 14:56:21 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/873">https://github.com/qt4cg/qtspecs/pull/873</a></div><details><summary>Improve explanation of equality comparisons</summary><div class="markup"><p>Fix #865</p>
<p>This PR:</p>
<ul>
<li>Adds a non-normative appendix to XPath and XQuery comparing and contrasting the different ways of doing equality comparisons</li>
<li>Changes fn:atomic-equal so it no longer refers to fn:deep-equal (the recursion terminated, but was confusing to follow)</li>
<li>Removes text in XQuery describing the non-transitivity of <code>group by</code> clauses, which is now a solved problem</li>
<li>Corrects the description of backwards incompatibilities relating to numeric comparisons in the F+O spec.</li>
</ul>
</div></details></div>
<div class="toot" id="created-872"><h2>Issue #872 created<span class="toot-id"> #created-872</span></h2><div class="pubdate">05 Dec at 11:58:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/872">https://github.com/qt4cg/qtspecs/issues/872</a></div><details><summary>Symmetry: fn:items-at → fn:get</summary><div class="markup"><p>I think that <code>fn:items-at</code> should be changed to <code>fn:get</code>:</p>
<ul>
<li>In #843, we try to harmonize the function names across sequences, maps, and arrays. We have <code>array:get</code> and <code>map:get</code> to retrieve single entries of the input, but we have <code>fn:items-at</code> for sequences.</li>
<li><code>fn:items-at</code> allows you to supply more than a single position, but <code>items-at($seq, (1, 3, 2)</code> can easily be rewritten to <code>(1, 3, 2) ! get($seq, .)</code> – similar to <code>(1, 3, 2) ! array:get($array, .)</code> and <code>(1, 3, 2) ! map:get($map, .)</code>.</li>
<li>With #844, <code>fn:items-at</code> would be the only function left with <code>items</code> in its name.</li>
</ul>
<p>The function signature would be as simple as:</p>
<pre><code class="language-xquery">fn:get(
  $input  as item()*,
  $at     as xs:integer	
) as item()
</code></pre>
<p>Obviously, most people will still use <code>$input[$at]</code> – but the same applies to arrays and maps (and other functions like <code>fn:head</code>). One of the advantages of <code>fn:get</code> is that you can pass on the context item as position argument.</p>
</div></details></div>
<div class="toot" id="created-871"><h2>Pull request #871 created<span class="toot-id"> #created-871</span></h2><div class="pubdate">04 Dec at 15:25:44 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/871">https://github.com/qt4cg/qtspecs/pull/871</a></div><p>Action qt4 cg 027 01 next match</p></div>
<div class="toot" id="created-870"><h2>Pull request #870 created<span class="toot-id"> #created-870</span></h2><div class="pubdate">04 Dec at 15:24:35 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/870">https://github.com/qt4cg/qtspecs/pull/870</a></div><details><summary>867 Explain defaults in function signatures</summary><div class="markup"><p>Fix #867</p>
</div></details></div>
<div class="toot" id="created-869"><h2>Issue #869 created<span class="toot-id"> #created-869</span></h2><div class="pubdate">04 Dec at 14:45:55 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/869">https://github.com/qt4cg/qtspecs/issues/869</a></div><details><summary>Incorrect example: for-each-pair</summary><div class="markup"><p>The fourth example of <code>fn:for-each-pair</code> is wrong:</p>
<pre><code>for-each-pair(
  (1, 8, 2),
  (3, 4, 3),
  fn($item1, $item2, $pos) {
    $pos || ': ' || max(($item1, $item2))
  }
)
</code></pre>
<p>Result:	
<code>("1: 1", "2: 4", "3: 2")</code></p>
<p>The results as given return the min of the pair, not the max.</p>
</div></details></div>
<div class="toot" id="agenda-12-05"><h2>QT4 CG meeting 057 draft agenda<span class="toot-id"> #agenda-12-05</span></h2><div class="pubdate">04 Dec at 12:15:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/12-05">https://qt4cg.org/meeting/agenda/2023/12-05</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-868"><h2>Issue #868 created<span class="toot-id"> #created-868</span></h2><div class="pubdate">04 Dec at 11:54:03 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/868">https://github.com/qt4cg/qtspecs/issues/868</a></div><details><summary>fn:intersperse → fn:join, array:join($arrays, $separator)</summary><div class="markup"><p>With <code>string-join</code>, you can create a string for multiple strings, optionally interspersed with a separator. <code>array:join</code> can be used to create an array from multiple arrays.</p>
<p><code>fn:intersperse</code>, which has been added to the XQuery 4 draft, does something very similar, and early feedback indicates that the function is useful, but easily to overlook due to its name.</p>
<p>I propose to unify the functions by…</p>
<ol>
<li>renaming <code>fn:intersperse</code> to <code>fn:join</code>;</li>
<li>adding a parameter to <code>array:join</code>: <code>$separator as array(*)* := ()</code>; and</li>
<li>allowing a separator sequence for <code>fn:string-join</code>: <code>$separator as xs:string* := ()</code>.</li>
</ol>
<h4>Examples</h4>
<p>Query | Result | Info
-- | -- | --
<code>string-join(('1','2','3'), '-')</code> | <code>'1-2-3'</code> | <em>existing syntax</em>
<code>array:join([[1],[2],[3]], ['-'])</code> | <code>[1,'-',2,'-',3]</code> | <em>new</em>
<code>join((1,2,3), '-')</code> | <code>(1,'-',2,'-',3)</code> | <em>now:</em> <code>intersperse((1,2,3),'-')</code>
<code>string-join(('1','2','3'))</code> | <code>'123'</code> | <em>existing syntax</em>
<code>array:join([[1],[2],[3]])</code> | <code>[1,2,3]</code> | <em>existing syntax</em>
<code>join((1,2,3))</code> | <code>(1,2,3)</code> | <em>now:</em> <code>intersperse((1,2,3))</code><br>(<em>or just</em> <code>(1,2,3)</code>)
<code>string-join(('1','2','3'), ('-','+')</code> | <code>'1-+2-+3'</code> | <em>new</em>
<code>array:join([[1],[2],[3]], ['-','+'])</code> | <code>[1,'-','+',2,'-','+',3]</code> | <em>new</em>
<code>join((1,2,3), ('-','+'))</code> | <code>(1,'-','+',2,'-','+',3)</code> | <em>now:</em> <code>intersperse((1,2,3),('-','+'))</code></p>
</div></details></div>
<div class="toot" id="created-867"><h2>Issue #867 created<span class="toot-id"> #created-867</span></h2><div class="pubdate">03 Dec at 16:31:20 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/867">https://github.com/qt4cg/qtspecs/issues/867</a></div><details><summary>Signature notation in F+O: default values</summary><div class="markup"><p>Section 1.5 of F+O introduces the signature proforma notation, and indicates that default values may be included for parameters.</p>
<p>It does not however say how the default value is interpreted. For example, with the signature</p>
<pre><code>fn:starts-with-sequence(
    $input as&nbsp;item()*, &nbsp;
    $subsequence as&nbsp;item()*,  &nbsp;
    $compare as&nbsp;function(item(), item()) as xs:boolean :=&nbsp;fn:deep-equal#2
)&nbsp;as&nbsp;xs:boolean

</code></pre>
<p>There is nothing to tell us that the expression fn:deep-equal#2 is evaluated with the static and dynamic context of the caller (or of the function reference).</p>
<p>Note that this is different from the similar notation used for function declarations in XQuery, where the static context for the default fn:deep-equal#2 would be taken from the function declaration in the Query prolog.</p>
</div></details></div>
<div class="toot" id="created-866"><h2>Issue #866 created<span class="toot-id"> #created-866</span></h2><div class="pubdate">03 Dec at 13:19:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/866">https://github.com/qt4cg/qtspecs/issues/866</a></div><details><summary>fn:sort, and XSLT and XQuery sorting, should use transitive comparisons</summary><div class="markup"><p>We have addressed the question of non-transitivity of equality matching in <code>distinct-values()</code>, and in XSLT and XQuery grouping, but the same issue exists for sorting. Currently <code>fn:sort</code>, as well as XSLT and XQuery sorting, rely on the "lt" operator for comparing values including mixed numerics such as doubles and decimals. Because this promotes to double, it is capable of losing precision, and is therefore non-transitive. Most sort algorithms rely on the supplied comparison function being transitive, and if it isn't, then undefined failures may occur including non-termination.</p>
<p>One particular quirk (which led me here) is that <code>fn:highest</code> and <code>fn:lowest</code> start by using <code>fn:sort</code> semantics to put the values in order, and then rely on <code>fn:deep-equal</code> semantics to find the values that are "equal highest" or "equal lowest". But <code>fn:sort</code> and <code>fn:deep-equal</code> have different ways of deciding whether two values are equal: decimal 1.2 and double 1.2 are equal for <code>fn:sort</code>, but not for <code>fn:deep-equal</code>.</p>
</div></details></div>
<div class="toot" id="created-865"><h2>Issue #865 created<span class="toot-id"> #created-865</span></h2><div class="pubdate">03 Dec at 00:49:44 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/865">https://github.com/qt4cg/qtspecs/issues/865</a></div><details><summary>Need to explain change in numeric comparison semantics</summary><div class="markup"><p>We need to explain more clearly that we now have different rules for comparing numeric values in different circumstances. My understanding of the situation is:</p>
<p>For <code>eq</code>, <code>=</code>, etc, we continue to use the XPath 2.0/3.0/3.1 rules for backwards compatibility reasons: for example comparison between decimal and double is done by converting the decimal to a double. This has known problems in terms of transitivity, but we have retained the rules because we identified that too many compatibility problems would be introduced by changing them.</p>
<p>For deep-equal, distinct-values, XSLT and XQuery grouping, etc, we have switched to the rules that were introduced for comparing map keys in 3.0, now available through the fn:atomic-equal function. Under these rules, doubles are promoted to decimals for comparison.</p>
<p>We should probably include a table showing which rules are used where.</p>
<p>A good example to use is (1e-3 = 0.001). This is true in both 3.1 and 4.0. But under the rules for maps in 3.1, and the new rules for distinct-values in 4.0, these two values are considered distinct.</p>
</div></details></div>
<div class="toot" id="created-864"><h2>Issue #864 created<span class="toot-id"> #created-864</span></h2><div class="pubdate">01 Dec at 23:34:39 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/864">https://github.com/qt4cg/qtspecs/issues/864</a></div><details><summary>$position argument in fold-right</summary><div class="markup"><p>In fn:fold-right (and thus array:fold-right) it's not clear how the position parameter works.</p>
<p>It appears to start at 1, and then to be decremented, which seems a little weird.</p>
<p>Working out what happens seems to involve reverse engineering the code, which isn't ideal. It's useful to have a formal definition of the function using code, but it shouldn't be necessary to reverse engineer 20 lines of difficult recursive code in order to get a feel for what the function does.</p>
<p>The only example given doesn't add any clarification.</p>
</div></details></div>
<div class="toot" id="closed-470"><h2>Issue #470 closed<span class="toot-id"> #closed-470</span></h2><div class="pubdate">29 Nov at 13:33:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/470">https://github.com/qt4cg/qtspecs/pull/470</a></div><p>369: add fixed-prefixes attribute in XSLT</p></div>
<div class="toot" id="closed-412"><h2>Issue #412 closed<span class="toot-id"> #closed-412</span></h2><div class="pubdate">29 Nov at 13:33:21 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/412">https://github.com/qt4cg/qtspecs/pull/412</a></div><p>409, QT4CG-027-01: xsl:next-match</p></div>
<div class="toot" id="closed-856"><h2>Issue #856 closed<span class="toot-id"> #closed-856</span></h2><div class="pubdate">29 Nov at 11:58:23 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/856">https://github.com/qt4cg/qtspecs/issues/856</a></div><p>Spec for deep-equal() still references FOTY0015</p></div>
<div class="toot" id="closed-857"><h2>Issue #857 closed<span class="toot-id"> #closed-857</span></h2><div class="pubdate">29 Nov at 11:58:22 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/857">https://github.com/qt4cg/qtspecs/pull/857</a></div><p>856 Drop reference to obsolete error condition in deep-equal()</p></div>
<div class="toot" id="created-863"><h2>Pull request #863 created<span class="toot-id"> #created-863</span></h2><div class="pubdate">29 Nov at 11:53:22 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/863">https://github.com/qt4cg/qtspecs/pull/863</a></div><details><summary>742 Drop xsl:function-library declaration</summary><div class="markup"><p>Fix #742</p>
</div></details></div>
<div class="toot" id="created-862"><h2>Issue #862 created<span class="toot-id"> #created-862</span></h2><div class="pubdate">29 Nov at 04:08:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/862">https://github.com/qt4cg/qtspecs/issues/862</a></div><details><summary>Examples needed for "Implausible Expressions"</summary><div class="markup"><p>In XPath 4.0 there is a new concept of <strong><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#id-implausible-expressions">Implausible Expressions</a></strong>.</p>
<p>There are several different sections about different types of implausible expressions:</p>
<ul>
<li>2.4.6 Implausible Expressions - only a single example, and it is not in an Examples sub-section and is difficult to locate.</li>
<li>3.8.1 Implausible Coercions -has 3 examples and seems OK.</li>
<li>4.7.4.3 Implausible Axis Steps - has no visible examples.</li>
<li>4.15.3.4 Implausible Lookup Expressions - has no examples.</li>
</ul>
<p>Another problem is that the definition of "implausible" seems not precise and subjective (what is the meaning of "<em>there is a high probability that they were written incorrectly</em>"):</p>
<p>"<strong>implausible</strong>
Certain expressions, while not erroneous, are classified as being <strong>implausible</strong>, because there is a high probability that they were written incorrectly."</p>
<p><strong>Proposed fixing actions</strong>:</p>
<ol>
<li>
<p>Provide a more precise and non-subjective definition of the concept.</p>
</li>
<li>
<p>Provide many examples of implausible expressions - both in the central section 2.4.6 and in all other sections dealing with more specific types of implausible expressions.</p>
</li>
</ol>
</div></details></div>
<div class="toot" id="closed-169"><h2>Issue #169 closed<span class="toot-id"> #closed-169</span></h2><div class="pubdate">28 Nov at 17:24:29 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/169">https://github.com/qt4cg/qtspecs/issues/169</a></div><p>Handling of duplicate keys in xsl:map</p></div>
<div class="toot" id="minutes-11-28"><h2>QT4 CG meeting 056 draft minutes<span class="toot-id"> #minutes-11-28</span></h2><div class="pubdate">28 Nov at 17:18:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/11-28">https://qt4cg.org/meeting/minutes/2023/11-28</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="agenda-11-28"><h2>QT4 CG meeting 056 draft agenda<span class="toot-id"> #agenda-11-28</span></h2><div class="pubdate">27 Nov at 12:30:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/11-28">https://qt4cg.org/meeting/agenda/2023/11-28</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="closed-858"><h2>Issue #858 closed<span class="toot-id"> #closed-858</span></h2><div class="pubdate">27 Nov at 08:38:26 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/858">https://github.com/qt4cg/qtspecs/issues/858</a></div><p>fn:identity: accept 2 arguments, ignore second</p></div>
<div class="toot" id="created-861"><h2>Issue #861 created<span class="toot-id"> #created-861</span></h2><div class="pubdate">26 Nov at 22:52:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/861">https://github.com/qt4cg/qtspecs/issues/861</a></div><details><summary>Precise meaning of $E??KS</summary><div class="markup"><p>I don't think that the semantics of the expression <code>$E??KS</code> are clearly enough defined.</p>
<blockquote>
<p>The effect of the deep lookup expression E??KS is obtained by evaluating E, establishing its recursive content C, removing any item that is not a map or array to yield a sequence D, and then evaluating the shallow lookup expression D?KS, but with one exception: if evaluation of any shallow lookup fails, then the error is not propagated, but instead its result is taken to be an empty sequence.</p>
</blockquote>
<ol>
<li>The definition of "recursive content" needs to be tightened up.</li>
<li>It needs to be more clearly stated which errors we ignore, and which we don't. For example, what if the key specifier evaluates to a non-singleton sequence?</li>
<li>In the case of <code>$E??*</code> in particular, I don't think it makes much sense to exclude items that are not maps or arrays. I think the expectation in this case is to return the full recursive content.</li>
<li>As currently defined, if <code>$M</code> is a map, the the result of <code>$M??*</code> includes the map <code>$M</code> itself. I don't think this matches expectations. Certainly, with the parallel expression <code>$node//*</code>, the result does not include <code>$node</code>.</li>
</ol>
</div></details></div>
<div class="toot" id="created-860"><h2>Issue #860 created<span class="toot-id"> #created-860</span></h2><div class="pubdate">26 Nov at 19:46:04 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/860">https://github.com/qt4cg/qtspecs/issues/860</a></div><details><summary>Unary Lookup when the context value is a sequence</summary><div class="markup"><p>We have added the text</p>
<blockquote>
<p>If the context value is anything other than a single item, the semantics of the expression ?KS are defined to be equivalent to the expression . ! ?KS. The remainder of this section therefore explains the semantics on the assumption that the [context value] is a single item, referred to as the context item.</p>
</blockquote>
<p>Consider the case where the context value is a sequence of two maps <code>(map{'x':1, 1:'p', 2:'q'}, map{'x':2, 1:'P', 2:'Q'})</code> and the expression is <code>?(?x)</code>. What is the context for evaluation of the key specifier <code>(?x)</code>? I would have expected that we evaluate the key specifier once, in the outer context, so the key specifier value is <code>(1,2)</code> and we therefore take the entries with keys 1 and 2 in both maps, giving a result of ('p', 'q', 'P', 'Q'). But the cited paragraph suggests we evaluate KS separately for each item in the context value, and this return entry 1 of map 1 and entry 2 of map 2, giving a result of ('p', 'Q').</p>
<p>I know it's an edge case and it's unlikely in practice that people will write context-dependent key specifiers, but the rules need to be clear. I thought we had previously decided that the key specifier expression should be evaluated in the outer context.</p>
</div></details></div>
<div class="toot" id="created-859"><h2>Issue #859 created<span class="toot-id"> #created-859</span></h2><div class="pubdate">26 Nov at 16:32:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/859">https://github.com/qt4cg/qtspecs/issues/859</a></div><details><summary>Syntax problem with type-qualified wildcards in lookup expressions</summary><div class="markup"><p>The new syntax for type-qualified wildcards has problems when used in a chained lookup expression, for example</p>
<p><code>[[1,2], [3,4], 5, 6]?*::array(*)?1</code></p>
<p>because the "?" that follows <code>array(*)</code> is interpreted as an occurrence indicator. This can be avoided by using parentheses, but it's too much of an elephant trap - a better solution is needed.</p>
</div></details></div>
<div class="toot" id="created-858"><h2>Issue #858 created<span class="toot-id"> #created-858</span></h2><div class="pubdate">25 Nov at 19:27:17 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/858">https://github.com/qt4cg/qtspecs/issues/858</a></div><details><summary>fn:identity: accept 2 arguments, ignore second</summary><div class="markup"><p>Apart from <code>id</code>, Haskell has <a href="http://zvon.org/other/haskell/Outputprelude/const_f.html"><code>const</code></a>, which accepts 2 arguments, but only returns the first. Thanks to the introduction of default arguments, it’s straightforward to extend <code>fn:identity</code> to be able to accept 2 arguments:</p>
<pre><code class="language-xquery">fn:identity(
  $input    as item()*,
  $ignored  as item()*  := ()
) as item()*
</code></pre>
</div></details></div>
<div class="toot" id="created-857"><h2>Pull request #857 created<span class="toot-id"> #created-857</span></h2><div class="pubdate">24 Nov at 16:00:09 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/857">https://github.com/qt4cg/qtspecs/pull/857</a></div><details><summary>856 Drop reference to obsolete error condition in deep-equal()</summary><div class="markup"><p>Fix #856</p>
</div></details></div>
<div class="toot" id="created-856"><h2>Issue #856 created<span class="toot-id"> #created-856</span></h2><div class="pubdate">24 Nov at 13:05:14 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/856">https://github.com/qt4cg/qtspecs/issues/856</a></div><details><summary>Spec for deep-equal() still references FOTY0015</summary><div class="markup"><p>The errors section of fn:deep-equal still says</p>
<p>A type error is raised [[err:FOTY0015] if either input sequence contains a function item that is not a map or array.</p>
<p>This is no longer the case (and error FOTY0015 is now obsolete and should be removed from the appendix)</p>
</div></details></div>
<div class="toot" id="created-855"><h2>Pull request #855 created<span class="toot-id"> #created-855</span></h2><div class="pubdate">24 Nov at 10:46:18 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/855">https://github.com/qt4cg/qtspecs/pull/855</a></div><details><summary>844 New sequence functions: names</summary><div class="markup"><p>Closes #844</p>
</div></details></div>
<div class="toot" id="closed-852"><h2>Issue #852 closed<span class="toot-id"> #closed-852</span></h2><div class="pubdate">23 Nov at 12:04:43 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/852">https://github.com/qt4cg/qtspecs/issues/852</a></div><p>Typo in XQuery equivalent for fn:transitive-closure</p></div></div><p>See 1632
            more statuses in yearly archives.</p></article></main></body></html>