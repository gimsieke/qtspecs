<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><!--Generated by the DeltaXML.com xhtml-outfilter.xsl--><!--Using XSL Processor: Saxonica--><title>XQuery 4.0: An XML Query Language </title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link rel="stylesheet" href="css/qtspecs.css"><link rel="stylesheet" href="css/xquery-40.css"><link rel="stylesheet" type="text/css" href="https://www.w3.org/StyleSheets/TR/2016/W3C-REC.css"><style type="text/css">
          body { margin-top: 50px }
          a.button { background: #DDD; border: 2px outset black; padding: 2px; margin: 2px; font-family: sans-serif; font-size: small;}
          a.button:hover { cursor:pointer; }
          a.button:active { border-style: inset; }
        </style><link rel="stylesheet" href="/css/autodiff.css"></head><body><div style="position:fixed; clear:both; top:0px" id="_autodiff_buttons"><p><a class="button" onclick="view('old')">
              View Old
            </a><a class="button" onclick="view('new')">
              View New
            </a><a class="button" onclick="view('both')">
              View Both
            </a><a class="button" onclick="view('only')">
              View Only
            </a><a class="button" onclick="scroll_to('prev')">
              Previous
            </a><a class="button" onclick="scroll_to('next')">
              Next
            </a><span id="__autodiff__"></span></p></div><div class="head"><p><a href="https://www.w3.org/"><img src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" alt="W3C" height="48" width="72"></a></p><h1><a id="title"></a>XQuery 4.0: An XML Query Language </h1><h2><a id="w3c-doctype"></a>W3C Editor's Draft 15&nbsp;March&nbsp;2024</h2><dl><dt>This version:</dt><dd><a href="https://qt4cg.org/pr/433/xquery-40//">https://qt4cg.org/<span class="deltaxml-old">specifications/</span><span class="deltaxml-new">pr/433/</span>xquery-40/</a></dd><dt>Most recent version of XQuery:</dt><dd><a href="https://qt4cg.org/specifications/xquery-40/">https://qt4cg.org/specifications/xquery-40/</a></dd><dt>Most recent Recommendation of XQuery:</dt><dd><a href="https://www.w3.org/TR/2017/REC-xquery-31-20170321/">https://www.w3.org/TR/2017/REC-xquery-31-20170321/</a></dd><dt>Editor:</dt><dd>Michael Kay, Saxonica <a href="mailto:mike@saxonica.com">&lt;mike@saxonica.com&gt;</a></dd></dl><p>Please check the <a href="https://www.w3.org/XML/2017/qt-errata/xquery-31-errata.html"><strong>errata</strong></a> for any errors or issues reported since publication.</p><p>See also <a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xquery-31"><strong>translations</strong></a>.</p><p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2000&nbsp;<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><hr></div><div><h2><a id="abstract"></a>Abstract</h2><p class="xquery">XML is a versatile markup language, capable of labeling the information content of diverse data sources<span class="deltaxml-old">,</span> including structured and semi-structured documents, relational databases, and object repositories. A query language that uses the structure of XML intelligently can express queries across all these kinds of data, whether physically stored in XML or viewed as XML via middleware. This specification describes a query language called XQuery, which is designed to be broadly applicable across many types of XML data sources.</p><p class="xquery"><span class="deltaxml-old">A list of changes made since XQuery 3.1 can be found in </span><a href="#id-revision-log"><b><span class="deltaxml-old">L Change Log</span></b></a><span class="deltaxml-old">. </span></p><p class="xquery"><span class="deltaxml-new">JSON is a lightweight data-interchange format that is widely used to exchange data on the web and to store data in databases. Many applications use JSON together with XML and HTML. XQuery 4.0 extends XQuery to support JSON as well as XML, adding maps and arrays to the data model and supporting them with new expressions in the language and new functions in </span><a href="#xpath-functions-40"><span class="deltaxml-new">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new">. A list of changes made since XQuery 3.1 can be found in </span><a href="#id-revision-log"><b><span class="deltaxml-new">K Change Log</span></b></a><span class="deltaxml-new">. These are the most important new features in XQuery 4.0: </span></p><ol class="enumar"><li><p><a href="#id-maps"><b><span class="deltaxml-new">4.13.1 Maps</span></b></a><span class="deltaxml-new">.</span></p></li><li><p><a href="#id-arrays"><b><span class="deltaxml-new">4.13.2 Arrays</span></b></a><span class="deltaxml-new">.</span></p></li></ol></div><div><h2><a id="status"></a>Status of this Document</h2><p><span class="deltaxml-old">This is a draft prepared by the QT4CG (officially registered in W3C as the XSLT Extensions Community Group). Comments are invited.</span></p><p><span class="deltaxml-new">This is a first proposal by the editor, with no official standing whatsoever. Comments are invited.</span></p></div><nav id="toc"><h2><a id="contents"></a>Table of Contents</h2><ol class="toc"><li><a href="#id-introduction"><span class="secno">1 </span><span class="content">Introduction</span></a><ol class="toc"></ol></li><li><a href="#id-basics"><span class="secno">2 </span><span class="content">Basics</span></a><ol class="toc"><li><a href="#id-terminology"><span class="secno">2.1 </span><span class="content">Terminology</span></a><ol class="toc"><li><a href="#id-values"><span class="secno">2.1.1 </span><span class="content">Values</span></a></li><li><a href="#id-namespaces-and-qnames"><span class="secno">2.1.2 </span><span class="content">Namespaces and QNames</span></a></li></ol></li><li><a href="#context"><span class="secno">2.2 </span><span class="content"> Module Context and Expression Context</span></a><ol class="toc"><li><a href="#static_context"><span class="secno">2.2.1 </span><span class="content">Static Context</span></a></li><li><a href="#eval_context"><span class="secno">2.2.2 </span><span class="content">Dynamic Context</span></a></li></ol></li><li><a href="#id-processing-model"><span class="secno">2.3 </span><span class="content">Processing Model</span></a><ol class="toc"><li><a href="#id-data-model-generation"><span class="secno">2.3.1 </span><span class="content">Data Model Generation</span></a></li><li><a href="#id-schema-import-processing"><span class="secno">2.3.2 </span><span class="content">Schema Import Processing</span></a></li><li><a href="#id-expression-processing"><span class="secno">2.3.3 </span><span class="content">Expression Processing</span></a><a href="#id-static-analysis"><span class="secno">2.3.3.1 </span><span class="content">Static Analysis Phase</span></a><a href="#id-dynamic-evaluation"><span class="secno">2.3.3.2 </span><span class="content">Dynamic Evaluation Phase</span></a></li><li><a href="#id-serialization"><span style="display: none;" class="delete_version"><span class="secno">2.3.4 </span><span class="content xquery">Serialization</span></span><span style="display: none;" class="add_version"><span class="secno">2.3.4 </span><span class="content">Serialization</span></span><span class="modify_version"><span class="secno">2.3.4 </span><span class="content">Serialization</span></span></a></li><li><a href="#id-consistency-constraints"><span class="secno">2.3.5 </span><span class="content">Consistency Constraints</span></a></li></ol></li><li><a href="#errors"><span class="secno">2.4 </span><span class="content">Error Handling</span></a><ol class="toc"><li><a href="#id-kinds-of-errors"><span class="secno">2.4.1 </span><span class="content">Kinds of Errors</span></a></li><li><a href="#id-identifying-errors"><span class="secno">2.4.2 </span><span class="content">Identifying and Reporting Errors</span></a></li><li><a href="#id-handling-dynamic"><span class="secno">2.4.3 </span><span class="content">Handling Dynamic Errors</span></a></li><li><a href="#id-errors-and-opt"><span class="secno">2.4.4 </span><span class="content">Errors and Optimization</span></a></li><li><a href="#id-guarded-expressions"><span class="secno">2.4.5 </span><span class="content">Guarded Expressions</span></a></li><li class="delete_version" style="display: none;"><a href="#id-implausible-expressions"><span class="secno">2.4.6 </span><span class="content">Implausible Expressions</span></a></li><li class="modify_version"><a href="#id-implausible-expressions"><span class="secno"><span class="deltaxml-old">2.4.6 </span></span><span class="content"><span class="deltaxml-old">Implausible Expressions</span></span></a></li></ol></li><li><a href="#id-important-concepts"><span class="secno">2.5 </span><span class="content">Concepts</span></a><ol class="toc"><li><a href="#id-document-order"><span class="secno">2.5.1 </span><span class="content">Document Order</span></a></li><li><a href="#id-atomization"><span class="secno">2.5.2 </span><span class="content">Atomization</span></a></li><li><a href="#id-ebv"><span class="secno">2.5.3 </span><span class="content">Effective Boolean Value</span></a></li><li><a href="#id-input-sources"><span class="secno">2.5.4 </span><span class="content">Input Sources</span></a></li><li><a href="#id-uri-literals"><span class="secno">2.5.5 </span><span class="content">URI Literals</span></a></li><li><a href="#id-resolve-relative-uri"><span class="secno">2.5.6 </span><span class="content">Resolving a Relative URI Reference</span></a></li></ol></li></ol></li><li><a href="#id-types"><span class="secno">3 </span><span class="content">Types</span></a><ol class="toc"><li><a href="#id-predefined-types"><span class="secno">3.1 </span><span class="content">Predefined Schema Types</span></a></li><li><a href="#id-namespace-sensitive"><span class="secno">3.2 </span><span class="content">Namespace-sensitive Types</span></a></li><li><a href="#id-typed-value"><span class="secno">3.3 </span><span class="content">Typed Value and String Value</span></a></li><li><a href="#id-sequencetype-syntax"><span class="secno">3.4 </span><span class="content">Sequence Types</span></a></li><li><a href="#id-sequencetype-matching"><span class="secno">3.5 </span><span class="content">Sequence Type Matching</span></a></li><li><a href="#id-matching-item"><span class="secno">3.6 </span><span class="content">Item Types</span></a><ol class="toc"><li><a href="#general-item-types"><span class="secno">3.6.1 </span><span class="content">General item types</span></a></li><li><a href="#id-atomic-and-union-types"><span class="secno">3.6.2 </span><span class="content">Atomic and Union Types</span></a><a href="#id-local-union-types"><span class="secno">3.6.2.1 </span><span class="content">Local Union Types</span></a><a href="#id-enumeration-types"><span class="secno">3.6.2.2 </span><span class="content">Enumeration Types</span></a></li><li><a href="#node-types"><span class="secno">3.6.3 </span><span class="content">Node Types</span></a><a href="#id-simple-node-tests"><span class="secno">3.6.3.1 </span><span class="content">Simple Node Tests</span></a><a href="#id-element-test"><span class="secno">3.6.3.2 </span><span class="content">Element Test</span></a><a href="#id-schema-element-test"><span class="secno">3.6.3.3 </span><span class="content">Schema Element Test</span></a><a href="#id-attribute-test"><span class="secno">3.6.3.4 </span><span class="content">Attribute Test</span></a><a href="#id-schema-attribute-test"><span class="secno">3.6.3.5 </span><span class="content">Schema Attribute Test</span></a></li><li><a href="#id-function-map-array-tests"><span class="secno">3.6.4 </span><span class="content">Function, Map, and Array Tests</span></a><a href="#id-function-test"><span class="secno">3.6.4.1 </span><span class="content">Function Test</span></a><a href="#id-map-test"><span class="secno">3.6.4.2 </span><span class="content">Map Test</span></a><a href="#id-record-test"><span class="secno">3.6.4.3 </span><span class="content">Record Test</span></a><a href="#id-recursive-record-tests"><span class="secno"><span class="deltaxml-old">3.6.4.4 </span></span><span class="content"><span class="deltaxml-old">Recursive Record Tests</span></span></a><a href="#id-array-test"><span style="display: none;" class="delete_version"><span class="secno">3.6.4.5 </span><span class="content">Array Test</span></span><span style="display: none;" class="add_version"><span class="secno">3.6.4.4 </span><span class="content">Array Test</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">3.6.4.5</span><span class="deltaxml-new">3.6.4.4</span> </span><span class="content">Array Test</span></span></a></li><li><a href="#id-xs-error"><span class="secno">3.6.5 </span><span class="content">xs:error</span></a></li></ol></li><li><a href="#id-sequencetype-subtype"><span class="secno">3.7 </span><span class="content">Subtype Relationships</span></a><ol class="toc"><li><a href="#id-seqtype-subtype"><span class="secno">3.7.1 </span><span class="content">Subtypes of Sequence Types</span></a></li><li><a href="#id-itemtype-subtype"><span class="secno">3.7.2 </span><span class="content">Subtypes of Item Types</span></a><a href="#id-item-subtype-general"><span class="secno">3.7.2.1 </span><span class="content">General Rules</span></a><a href="#id-item-subtype-atomic"><span class="secno">3.7.2.2 </span><span class="content">Atomic and Union Types</span></a><a href="#id-item-subtype-nodes"><span class="secno">3.7.2.3 </span><span class="content">Node Types: General Rules</span></a><a href="#id-item-subtype-elements"><span class="secno">3.7.2.4 </span><span class="content">Node Types: Element Tests</span></a><a href="#id-item-subtype-attributes"><span class="secno">3.7.2.5 </span><span class="content">Node Types: Attribute Tests</span></a><a href="#id-item-subtype-functions"><span class="secno">3.7.2.6 </span><span class="content">Functions</span></a><a href="#id-item-subtype-maps"><span class="secno">3.7.2.7 </span><span class="content">Maps</span></a><a href="#id-item-subtype-arrays"><span class="secno">3.7.2.8 </span><span class="content">Arrays</span></a><a href="#id-item-subtype-records"><span class="secno">3.7.2.9 </span><span class="content">Record Tests</span></a><a href="#id-itemtype-subtype-aliases"><span class="secno"><span class="deltaxml-old">3.7.2.10 </span></span><span class="content"><span class="deltaxml-old">Named Item Types</span></span></a></li><li><a href="#id-assertions-subtype"><span style="display: none;" class="delete_version"><span class="secno">3.7.3 </span><span class="content xquery">The judgement subtype-assertions(AnnotationsA, AnnotationsB) </span></span><span style="display: none;" class="add_version"><span class="secno">3.7.3 </span><span class="content">The judgement subtype-assertions(AnnotationsA, AnnotationsB) </span></span><span class="modify_version"><span class="secno">3.7.3 </span><span class="content">The judgement subtype-assertions(AnnotationsA, AnnotationsB) </span></span></a></li></ol></li><li class="delete_version" style="display: none;"><a href="#id-coercion-rules"><span class="secno">3.8 </span><span class="content">Coercion Rules</span></a><ol class="toc"><li><a href="#id-implausible-coercions"><span class="secno">3.8.1 </span><span class="content">Implausible Coercions</span></a></li><li><a href="#id-function-coercion"><span class="secno">3.8.2 </span><span class="content">Function Coercion</span></a></li></ol></li><li class="modify_version"><a href="#id-coercion-rules"><span class="secno"><span class="deltaxml-old">3.8 </span></span><span class="content"><span class="deltaxml-old">Coercion Rules</span></span></a><ol class="toc"><li><a href="#id-implausible-coercions"><span class="secno"><span class="deltaxml-old">3.8.1 </span></span><span class="content"><span class="deltaxml-old">Implausible Coercions</span></span></a></li><li><a href="#id-function-coercion"><span class="secno"><span class="deltaxml-old">3.8.2 </span></span><span class="content"><span class="deltaxml-old">Function Coercion</span></span></a></li></ol></li></ol></li><li><a href="#id-expressions"><span class="secno">4 </span><span class="content">Expressions</span></a><ol class="toc"><li><a href="#with-expressions"><span class="secno">4.1 </span><span class="content">Setting Namespace Context</span></a></li><li><a href="#comments"><span class="secno">4.2 </span><span class="content">Comments</span></a></li><li><a href="#id-primary-expressions"><span class="secno">4.3 </span><span class="content">Primary Expressions</span></a><ol class="toc"><li><a href="#id-literals"><span class="secno">4.3.1 </span><span class="content">Literals</span></a><a href="#id-numeric-literals"><span class="secno"><span class="deltaxml-old">4.3.1.1 </span></span><span class="content"><span class="deltaxml-old">Numeric Literals</span></span></a><a href="#id-string-literal"><span class="secno"><span class="deltaxml-old">4.3.1.2 </span></span><span class="content"><span class="deltaxml-old">String Literals</span></span></a><a href="#id-constants-other-types"><span class="secno"><span class="deltaxml-old">4.3.1.3 </span></span><span class="content"><span class="deltaxml-old">Constants of Other Types</span></span></a></li><li><a href="#id-variables"><span class="secno">4.3.2 </span><span class="content">Variable References</span></a></li><li><a href="#id-context-value-references"><span class="secno"><span class="deltaxml-old">4.3.3 </span></span><span class="content"><span class="deltaxml-old">Context Value References</span></span></a><a href="#id-paren-expressions"><span class="secno"><span class="deltaxml-new">4.3.3 </span></span><span class="content"><span class="deltaxml-new">Parenthesized Expressions</span></span></a></li><li><a href="#id-paren-expressions"><span class="secno"><span class="deltaxml-old">4.3.4 </span></span><span class="content"><span class="deltaxml-old">Parenthesized Expressions</span></span></a><a href="#id-context-item-expression"><span class="secno"><span class="deltaxml-new">4.3.4 </span></span><span class="content"><span class="deltaxml-new">Context Item Expression</span></span></a></li><li><a href="#id-enclosed-expr"><span class="secno">4.3.5 </span><span class="content">Enclosed Expressions</span></a></li></ol></li><li class="delete_version" style="display: none;"><a href="#id-postfix-expression"><span class="secno">4.4 </span><span class="content">Postfix Expressions</span></a></li><li class="modify_version"><a href="#id-postfix-expression"><span class="secno"><span class="deltaxml-old">4.4 </span></span><span class="content"><span class="deltaxml-old">Postfix Expressions</span></span></a></li><li class="delete_version" style="display: none;"><a href="#id-filter-expression"><span class="secno">4.5 </span><span class="content">Filter Expressions</span></a></li><li class="modify_version"><a href="#id-filter-expression"><span class="secno"><span class="deltaxml-old">4.5 </span></span><span class="content"><span class="deltaxml-old">Filter Expressions</span></span></a></li><li><a href="#id-functions"><span style="display: none;" class="delete_version"><span class="secno">4.6 </span><span class="content">Functions</span></span><span style="display: none;" class="add_version"><span class="secno">4.4 </span><span class="content">Functions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.6</span><span class="deltaxml-new">4.4</span> </span><span class="content">Functions</span></span></a><ol class="toc"><li><a href="#id-static-functions"><span class="secno"><span class="deltaxml-old">4.6.1 </span></span><span class="content"><span class="deltaxml-old">Static Function Calls</span></span></a><a href="#id-static-functions"><span class="secno"><span class="deltaxml-new">4.4.1 </span></span><span class="content"><span class="deltaxml-new">Function Definitions</span></span></a><a href="#id-function-calls"><span style="display: none;" class="delete_version"><span class="secno">4.6.1.1 </span><span class="content">Static Function Call Syntax</span></span><span style="display: none;" class="add_version"><span class="secno">4.4.1.1 </span><span class="content">Static Function Call Syntax</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.6.1.1</span><span class="deltaxml-new">4.4.1.1</span> </span><span class="content">Static Function Call Syntax</span></span></a><a href="#id-eval-static-function-call"><span style="display: none;" class="delete_version"><span class="secno">4.6.1.2 </span><span class="content">Evaluating Static Function Calls</span></span><span style="display: none;" class="add_version"><span class="secno">4.4.1.2 </span><span class="content">Evaluating Static Function Calls</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.6.1.2</span><span class="deltaxml-new">4.4.1.2</span> </span><span class="content">Evaluating Static Function Calls</span></span></a></li><li><a href="#id-dynamic-functions"><span style="display: none;" class="delete_version"><span class="secno">4.6.2 </span><span class="content">Function Items</span></span><span style="display: none;" class="add_version"><span class="secno">4.4.2 </span><span class="content">Function Items</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.6.2</span><span class="deltaxml-new">4.4.2</span> </span><span class="content">Function Items</span></span></a><a href="#id-dynamic-function-invocation"><span class="secno"><span class="deltaxml-old">4.6.2.1 </span></span><span class="content"><span class="deltaxml-old">Dynamic Function Calls</span></span></a><a href="#id-eval-dynamic-function-call"><span style="display: none;" class="delete_version"><span class="secno">4.6.2.2 </span><span class="content">Evaluating Dynamic Function Calls</span></span><span style="display: none;" class="add_version"><span class="secno">4.4.2.1 </span><span class="content">Evaluating Dynamic Function Calls</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.6.2.2</span><span class="deltaxml-new">4.4.2.1</span> </span><span class="content">Evaluating Dynamic Function Calls</span></span></a><a href="#id-partial-function-application"><span style="display: none;" class="delete_version"><span class="secno">4.6.2.3 </span><span class="content">Partial Function Application</span></span><span style="display: none;" class="add_version"><span class="secno">4.4.2.2 </span><span class="content">Partial Function Application</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.6.2.3</span><span class="deltaxml-new">4.4.2.2</span> </span><span class="content">Partial Function Application</span></span></a><a href="#id-named-function-ref"><span style="display: none;" class="delete_version"><span class="secno">4.6.2.4 </span><span class="content">Named Function References</span></span><span style="display: none;" class="add_version"><span class="secno">4.4.2.3 </span><span class="content">Named Function References</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.6.2.4</span><span class="deltaxml-new">4.4.2.3</span> </span><span class="content">Named Function References</span></span></a><a href="#id-inline-func"><span style="display: none;" class="delete_version"><span class="secno">4.6.2.5 </span><span class="content">Inline Function Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.4.2.4 </span><span class="content">Inline Function Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.6.2.5</span><span class="deltaxml-new">4.4.2.4</span> </span><span class="content">Inline Function Expressions</span></span></a><a href="#id-focus-functions"><span class="secno"><span class="deltaxml-old">4.6.2.6 </span></span><span class="content"><span class="deltaxml-old">Focus Functions</span></span></a><a href="#id-function-identity"><span class="secno"><span class="deltaxml-old">4.6.2.7 </span></span><span class="content"><span class="deltaxml-old">Function Identity</span></span></a></li><li class="add_version" style="display: none;"><a href="#id-coercion-rules"><span class="secno">4.4.3 </span><span class="content">Coercion Rules</span></a></li><li class="modify_version"><a href="#id-coercion-rules"><span class="secno"><span class="deltaxml-new">4.4.3 </span></span><span class="content"><span class="deltaxml-new">Coercion Rules</span></span></a></li><li class="add_version" style="display: none;"><a href="#id-function-coercion"><span class="secno">4.4.4 </span><span class="content">Function Coercion</span></a></li><li class="modify_version"><a href="#id-function-coercion"><span class="secno"><span class="deltaxml-new">4.4.4 </span></span><span class="content"><span class="deltaxml-new">Function Coercion</span></span></a></li></ol></li><li class="add_version" style="display: none;"><a href="#id-postfix-expression"><span class="secno">4.5 </span><span class="content">Postfix Expressions</span></a><ol class="toc"><li><a href="#id-filter-expression"><span class="secno">4.5.1 </span><span class="content">Filter Expressions</span></a></li><li><a href="#id-dynamic-function-invocation"><span class="secno">4.5.2 </span><span class="content">Dynamic Function Calls</span></a></li></ol></li><li class="modify_version"><a href="#id-postfix-expression"><span class="secno"><span class="deltaxml-new">4.5 </span></span><span class="content"><span class="deltaxml-new">Postfix Expressions</span></span></a><ol class="toc"><li><a href="#id-filter-expression"><span class="secno"><span class="deltaxml-new">4.5.1 </span></span><span class="content"><span class="deltaxml-new">Filter Expressions</span></span></a></li><li><a href="#id-dynamic-function-invocation"><span class="secno"><span class="deltaxml-new">4.5.2 </span></span><span class="content"><span class="deltaxml-new">Dynamic Function Calls</span></span></a></li></ol></li><li><a href="#id-path-expressions"><span style="display: none;" class="delete_version"><span class="secno">4.7 </span><span class="content">Path Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.6 </span><span class="content">Path Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.7</span><span class="deltaxml-new">4.6</span> </span><span class="content">Path Expressions</span></span></a><ol class="toc"><li class="delete_version" style="display: none;"><a href="#id-absolute-path-expressions"><span class="secno">4.7.1 </span><span class="content">Absolute Path Expressions</span></a></li><li class="modify_version"><a href="#id-absolute-path-expressions"><span class="secno"><span class="deltaxml-old">4.7.1 </span></span><span class="content"><span class="deltaxml-old">Absolute Path Expressions</span></span></a></li><li class="delete_version" style="display: none;"><a href="#id-relative-path-expressions"><span class="secno">4.7.2 </span><span class="content">Relative Path Expressions</span></a></li><li class="modify_version"><a href="#id-relative-path-expressions"><span class="secno"><span class="deltaxml-old">4.7.2 </span></span><span class="content"><span class="deltaxml-old">Relative Path Expressions</span></span></a></li><li><a href="#id-relative-path-expressions"><span class="secno"><span class="deltaxml-new">4.6.1 </span></span><span class="content"><span class="deltaxml-new">Relative Path Expressions</span></span></a><a href="#id-path-operator"><span style="display: none;" class="delete_version"><span class="secno">4.7.3 </span><span class="content">Path operator (/)</span></span><span style="display: none;" class="add_version"><span class="secno">4.6.1.1 </span><span class="content">Path operator (/)</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.7.3</span><span class="deltaxml-new">4.6.1.1</span> </span><span class="content">Path operator (/)</span></span></a></li><li><a href="#id-steps"><span style="display: none;" class="delete_version"><span class="secno">4.7.4 </span><span class="content">Steps</span></span><span style="display: none;" class="add_version"><span class="secno">4.6.2 </span><span class="content">Steps</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.7.4</span><span class="deltaxml-new">4.6.2</span> </span><span class="content">Steps</span></span></a><a href="#axes"><span style="display: none;" class="delete_version"><span class="secno">4.7.4.1 </span><span class="content">Axes</span></span><span style="display: none;" class="add_version"><span class="secno">4.6.2.1 </span><span class="content">Axes</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.7.4.1</span><span class="deltaxml-new">4.6.2.1</span> </span><span class="content">Axes</span></span></a><a href="#node-tests"><span style="display: none;" class="delete_version"><span class="secno">4.7.4.2 </span><span class="content">Node Tests</span></span><span style="display: none;" class="add_version"><span class="secno">4.6.2.2 </span><span class="content">Node Tests</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.7.4.2</span><span class="deltaxml-new">4.6.2.2</span> </span><span class="content">Node Tests</span></span></a><a href="#implausible-axis-steps"><span class="secno"><span class="deltaxml-old">4.7.4.3 </span></span><span class="content"><span class="deltaxml-old">Implausible Axis Steps</span></span></a></li><li><a href="#id-predicate"><span style="display: none;" class="delete_version"><span class="secno">4.7.5 </span><span class="content">Predicates within Steps</span></span><span style="display: none;" class="add_version"><span class="secno">4.6.3 </span><span class="content">Predicates within Steps</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.7.5</span><span class="deltaxml-new">4.6.3</span> </span><span class="content">Predicates within Steps</span></span></a></li><li><a href="#unabbrev"><span style="display: none;" class="delete_version"><span class="secno">4.7.6 </span><span class="content">Unabbreviated Syntax</span></span><span style="display: none;" class="add_version"><span class="secno">4.6.4 </span><span class="content">Unabbreviated Syntax</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.7.6</span><span class="deltaxml-new">4.6.4</span> </span><span class="content">Unabbreviated Syntax</span></span></a></li><li><a href="#abbrev"><span style="display: none;" class="delete_version"><span class="secno">4.7.7 </span><span class="content">Abbreviated Syntax</span></span><span style="display: none;" class="add_version"><span class="secno">4.6.5 </span><span class="content">Abbreviated Syntax</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.7.7</span><span class="deltaxml-new">4.6.5</span> </span><span class="content">Abbreviated Syntax</span></span></a></li></ol></li><li><a href="#id-sequence-expressions"><span style="display: none;" class="delete_version"><span class="secno">4.8 </span><span class="content">Sequence Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.7 </span><span class="content">Sequence Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.8</span><span class="deltaxml-new">4.7</span> </span><span class="content">Sequence Expressions</span></span></a><ol class="toc"><li><a href="#construct_seq"><span style="display: none;" class="delete_version"><span class="secno">4.8.1 </span><span class="content">Sequence Concatenation</span></span><span style="display: none;" class="add_version"><span class="secno">4.7.1 </span><span class="content">Sequence Concatenation</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.8.1</span><span class="deltaxml-new">4.7.1</span> </span><span class="content">Sequence Concatenation</span></span></a></li><li><a href="#id-range-expressions"><span style="display: none;" class="delete_version"><span class="secno">4.8.2 </span><span class="content">Range Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.7.2 </span><span class="content">Range Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.8.2</span><span class="deltaxml-new">4.7.2</span> </span><span class="content">Range Expressions</span></span></a></li><li><a href="#combining_seq"><span style="display: none;" class="delete_version"><span class="secno">4.8.3 </span><span class="content">Combining Node Sequences</span></span><span style="display: none;" class="add_version"><span class="secno">4.7.3 </span><span class="content">Combining Node Sequences</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.8.3</span><span class="deltaxml-new">4.7.3</span> </span><span class="content">Combining Node Sequences</span></span></a></li></ol></li><li><a href="#id-arithmetic"><span style="display: none;" class="delete_version"><span class="secno">4.9 </span><span class="content">Arithmetic Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.8 </span><span class="content">Arithmetic Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.9</span><span class="deltaxml-new">4.8</span> </span><span class="content">Arithmetic Expressions</span></span></a></li><li><a href="#id-string-expr"><span style="display: none;" class="delete_version"><span class="secno">4.10 </span><span class="content">String Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.9 </span><span class="content">String Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.10</span><span class="deltaxml-new">4.9</span> </span><span class="content">String Expressions</span></span></a><ol class="toc"><li><a href="#id-string-concat-expr"><span style="display: none;" class="delete_version"><span class="secno">4.10.1 </span><span class="content">String Concatenation Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.9.1 </span><span class="content">String Concatenation Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.10.1</span><span class="deltaxml-new">4.9.1</span> </span><span class="content">String Concatenation Expressions</span></span></a></li><li><a href="#id-string-templates"><span style="display: none;" class="delete_version"><span class="secno">4.10.2 </span><span class="content">String Templates</span></span><span style="display: none;" class="add_version"><span class="secno">4.9.2 </span><span class="content">String Templates</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.10.2</span><span class="deltaxml-new">4.9.2</span> </span><span class="content">String Templates</span></span></a></li><li><a href="#id-string-constructors"><span style="display: none;" class="delete_version"><span class="secno">4.10.3 </span><span class="content xquery">String Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.9.3 </span><span class="content">String Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.10.3</span><span class="deltaxml-new">4.9.3</span> </span><span class="content">String Constructors</span></span></a></li></ol></li><li><a href="#id-comparisons"><span style="display: none;" class="delete_version"><span class="secno">4.11 </span><span class="content">Comparison Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.10 </span><span class="content">Comparison Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.11</span><span class="deltaxml-new">4.10</span> </span><span class="content">Comparison Expressions</span></span></a><ol class="toc"><li><a href="#id-value-comparisons"><span style="display: none;" class="delete_version"><span class="secno">4.11.1 </span><span class="content">Value Comparisons</span></span><span style="display: none;" class="add_version"><span class="secno">4.10.1 </span><span class="content">Value Comparisons</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.11.1</span><span class="deltaxml-new">4.10.1</span> </span><span class="content">Value Comparisons</span></span></a></li><li><a href="#id-general-comparisons"><span style="display: none;" class="delete_version"><span class="secno">4.11.2 </span><span class="content">General Comparisons</span></span><span style="display: none;" class="add_version"><span class="secno">4.10.2 </span><span class="content">General Comparisons</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.11.2</span><span class="deltaxml-new">4.10.2</span> </span><span class="content">General Comparisons</span></span></a></li><li><a href="#id-node-comparisons"><span style="display: none;" class="delete_version"><span class="secno">4.11.3 </span><span class="content">Node Comparisons</span></span><span style="display: none;" class="add_version"><span class="secno">4.10.3 </span><span class="content">Node Comparisons</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.11.3</span><span class="deltaxml-new">4.10.3</span> </span><span class="content">Node Comparisons</span></span></a></li></ol></li><li><a href="#id-logical-expressions"><span style="display: none;" class="delete_version"><span class="secno">4.12 </span><span class="content">Logical Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.11 </span><span class="content">Logical Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.12</span><span class="deltaxml-new">4.11</span> </span><span class="content">Logical Expressions</span></span></a></li><li><a href="#id-constructors"><span style="display: none;" class="delete_version"><span class="secno">4.13 </span><span class="content xquery">Node Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.12 </span><span class="content">Node Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13</span><span class="deltaxml-new">4.12</span> </span><span class="content">Node Constructors</span></span></a><ol class="toc"><li><a href="#id-element-constructor"><span style="display: none;" class="delete_version"><span class="secno">4.13.1 </span><span class="content">Direct Element Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.1 </span><span class="content">Direct Element Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.1</span><span class="deltaxml-new">4.12.1</span> </span><span class="content">Direct Element Constructors</span></span></a><a href="#id-attributes"><span style="display: none;" class="delete_version"><span class="secno">4.13.1.1 </span><span class="content">Attributes</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.1.1 </span><span class="content">Attributes</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.1.1</span><span class="deltaxml-new">4.12.1.1</span> </span><span class="content">Attributes</span></span></a><a href="#id-namespaces"><span style="display: none;" class="delete_version"><span class="secno">4.13.1.2 </span><span class="content">Namespace Declaration Attributes</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.1.2 </span><span class="content">Namespace Declaration Attributes</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.1.2</span><span class="deltaxml-new">4.12.1.2</span> </span><span class="content">Namespace Declaration Attributes</span></span></a><a href="#id-content"><span style="display: none;" class="delete_version"><span class="secno">4.13.1.3 </span><span class="content">Content</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.1.3 </span><span class="content">Content</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.1.3</span><span class="deltaxml-new">4.12.1.3</span> </span><span class="content">Content</span></span></a><a href="#id-whitespace"><span style="display: none;" class="delete_version"><span class="secno">4.13.1.4 </span><span class="content">Boundary Whitespace</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.1.4 </span><span class="content">Boundary Whitespace</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.1.4</span><span class="deltaxml-new">4.12.1.4</span> </span><span class="content">Boundary Whitespace</span></span></a></li><li><a href="#id-otherConstructors"><span style="display: none;" class="delete_version"><span class="secno">4.13.2 </span><span class="content">Other Direct Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.2 </span><span class="content">Other Direct Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.2</span><span class="deltaxml-new">4.12.2</span> </span><span class="content">Other Direct Constructors</span></span></a></li><li><a href="#id-computedConstructors"><span style="display: none;" class="delete_version"><span class="secno">4.13.3 </span><span class="content">Computed Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.3 </span><span class="content">Computed Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.3</span><span class="deltaxml-new">4.12.3</span> </span><span class="content">Computed Constructors</span></span></a><a href="#id-computedElements"><span style="display: none;" class="delete_version"><span class="secno">4.13.3.1 </span><span class="content">Computed Element Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.3.1 </span><span class="content">Computed Element Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.3.1</span><span class="deltaxml-new">4.12.3.1</span> </span><span class="content">Computed Element Constructors</span></span></a><a href="#id-computedAttributes"><span style="display: none;" class="delete_version"><span class="secno">4.13.3.2 </span><span class="content">Computed Attribute Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.3.2 </span><span class="content">Computed Attribute Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.3.2</span><span class="deltaxml-new">4.12.3.2</span> </span><span class="content">Computed Attribute Constructors</span></span></a><a href="#id-documentConstructors"><span style="display: none;" class="delete_version"><span class="secno">4.13.3.3 </span><span class="content">Document Node Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.3.3 </span><span class="content">Document Node Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.3.3</span><span class="deltaxml-new">4.12.3.3</span> </span><span class="content">Document Node Constructors</span></span></a><a href="#id-textConstructors"><span style="display: none;" class="delete_version"><span class="secno">4.13.3.4 </span><span class="content">Text Node Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.3.4 </span><span class="content">Text Node Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.3.4</span><span class="deltaxml-new">4.12.3.4</span> </span><span class="content">Text Node Constructors</span></span></a><a href="#id-computed-pis"><span style="display: none;" class="delete_version"><span class="secno">4.13.3.5 </span><span class="content">Computed Processing Instruction Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.3.5 </span><span class="content">Computed Processing Instruction Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.3.5</span><span class="deltaxml-new">4.12.3.5</span> </span><span class="content">Computed Processing Instruction Constructors</span></span></a><a href="#id-computed-comments"><span style="display: none;" class="delete_version"><span class="secno">4.13.3.6 </span><span class="content">Computed Comment Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.3.6 </span><span class="content">Computed Comment Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.3.6</span><span class="deltaxml-new">4.12.3.6</span> </span><span class="content">Computed Comment Constructors</span></span></a><a href="#id-computed-namespaces"><span style="display: none;" class="delete_version"><span class="secno">4.13.3.7 </span><span class="content">Computed Namespace Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.3.7 </span><span class="content">Computed Namespace Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.3.7</span><span class="deltaxml-new">4.12.3.7</span> </span><span class="content">Computed Namespace Constructors</span></span></a></li><li><a href="#id-ns-nodes-on-elements"><span style="display: none;" class="delete_version"><span class="secno">4.13.4 </span><span class="content">In-scope Namespaces of a Constructed Element</span></span><span style="display: none;" class="add_version"><span class="secno">4.12.4 </span><span class="content">In-scope Namespaces of a Constructed Element</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.13.4</span><span class="deltaxml-new">4.12.4</span> </span><span class="content">In-scope Namespaces of a Constructed Element</span></span></a></li></ol></li><li><a href="#id-maps-and-arrays"><span style="display: none;" class="delete_version"><span class="secno">4.14 </span><span class="content">Maps and Arrays</span></span><span style="display: none;" class="add_version"><span class="secno">4.13 </span><span class="content">Maps and Arrays</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.14</span><span class="deltaxml-new">4.13</span> </span><span class="content">Maps and Arrays</span></span></a><ol class="toc"><li><a href="#id-maps"><span style="display: none;" class="delete_version"><span class="secno">4.14.1 </span><span class="content">Maps</span></span><span style="display: none;" class="add_version"><span class="secno">4.13.1 </span><span class="content">Maps</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.14.1</span><span class="deltaxml-new">4.13.1</span> </span><span class="content">Maps</span></span></a><a href="#id-map-constructors"><span style="display: none;" class="delete_version"><span class="secno">4.14.1.1 </span><span class="content">Map Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.13.1.1 </span><span class="content">Map Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.14.1.1</span><span class="deltaxml-new">4.13.1.1</span> </span><span class="content">Map Constructors</span></span></a><a href="#id-map-lookup"><span style="display: none;" class="delete_version"><span class="secno">4.14.1.2 </span><span class="content">Map Lookup using Function Call Syntax</span></span><span style="display: none;" class="add_version"><span class="secno">4.13.1.2 </span><span class="content">Map Lookup using Function Call Syntax</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.14.1.2</span><span class="deltaxml-new">4.13.1.2</span> </span><span class="content">Map Lookup using Function Call Syntax</span></span></a></li><li><a href="#id-arrays"><span style="display: none;" class="delete_version"><span class="secno">4.14.2 </span><span class="content">Arrays</span></span><span style="display: none;" class="add_version"><span class="secno">4.13.2 </span><span class="content">Arrays</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.14.2</span><span class="deltaxml-new">4.13.2</span> </span><span class="content">Arrays</span></span></a><a href="#id-array-constructors"><span style="display: none;" class="delete_version"><span class="secno">4.14.2.1 </span><span class="content">Array Constructors</span></span><span style="display: none;" class="add_version"><span class="secno">4.13.2.1 </span><span class="content">Array Constructors</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.14.2.1</span><span class="deltaxml-new">4.13.2.1</span> </span><span class="content">Array Constructors</span></span></a><a href="#id-array-lookup"><span style="display: none;" class="delete_version"><span class="secno">4.14.2.2 </span><span class="content">Array Lookup using Function Call Syntax</span></span><span style="display: none;" class="add_version"><span class="secno">4.13.2.2 </span><span class="content">Array Lookup using Function Call Syntax</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.14.2.2</span><span class="deltaxml-new">4.13.2.2</span> </span><span class="content">Array Lookup using Function Call Syntax</span></span></a></li><li><a href="#id-lookup"><span style="display: none;" class="delete_version"><span class="secno">4.14.3 </span><span class="content">The Lookup Operators ("?" and "??") for Maps and Arrays</span></span><span style="display: none;" class="add_version"><span class="secno">4.13.3 </span><span class="content">The Lookup Operator ("?") for Maps and Arrays</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.14.3</span><span class="deltaxml-new">4.13.3</span> </span><span class="content">The Lookup <span class="deltaxml-old">Operators</span><span class="deltaxml-new">Operator</span> ("?"<span class="deltaxml-old"> and "??"</span>) for Maps and Arrays</span></span></a><a href="#id-postfix-lookup"><span class="secno"><span class="deltaxml-old">4.14.3.1 </span></span><span class="content"><span class="deltaxml-old">Postfix Lookup Expressions</span></span></a><a href="#id-unary-lookup"><span style="display: none;" class="delete_version"><span class="secno">4.14.3.2 </span><span class="content">Unary Lookup</span></span><span style="display: none;" class="add_version"><span class="secno">4.13.3.1 </span><span class="content">Unary Lookup</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.14.3.2</span><span class="deltaxml-new">4.13.3.1</span> </span><span class="content">Unary Lookup</span></span></a><a href="#id-deep-lookup"><span class="secno"><span class="deltaxml-old">4.14.3.3 </span></span><span class="content"><span class="deltaxml-old">Deep Lookup</span></span></a><a href="#id-implausible-lookup-expressions"><span class="secno"><span class="deltaxml-old">4.14.3.4 </span></span><span class="content"><span class="deltaxml-old">Implausible Lookup Expressions</span></span></a><a href="#id-postfix-lookup"><span class="secno"><span class="deltaxml-new">4.13.3.2 </span></span><span class="content"><span class="deltaxml-new">Postfix Lookup</span></span></a></li><li class="delete_version" style="display: none;"><a href="#id-pinned-maps-and-arrays"><span class="secno">4.14.4 </span><span class="content">Pinned Maps and Arrays</span></a></li><li class="modify_version"><a href="#id-pinned-maps-and-arrays"><span class="secno"><span class="deltaxml-old">4.14.4 </span></span><span class="content"><span class="deltaxml-old">Pinned Maps and Arrays</span></span></a></li></ol></li><li><a href="#id-flwor-expressions"><span style="display: none;" class="delete_version"><span class="secno">4.15 </span><span class="content xquery">FLWOR Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.14 </span><span class="content">FLWOR Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.15</span><span class="deltaxml-new">4.14</span> </span><span class="content">FLWOR Expressions</span></span></a><ol class="toc"><li><a href="#id-binding-rules"><span style="display: none;" class="delete_version"><span class="secno">4.15.1 </span><span class="content">Variable Bindings</span></span><span style="display: none;" class="add_version"><span class="secno">4.14.1 </span><span class="content">Variable Bindings</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.15.1</span><span class="deltaxml-new">4.14.1</span> </span><span class="content">Variable Bindings</span></span></a></li><li><a href="#id-xquery-for-clause"><span style="display: none;" class="delete_version"><span class="secno">4.15.2 </span><span class="content">For Clause</span></span><span style="display: none;" class="add_version"><span class="secno">4.14.2 </span><span class="content">For Clause</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.15.2</span><span class="deltaxml-new">4.14.2</span> </span><span class="content">For Clause</span></span></a></li><li><a href="#id-xquery-let-clause"><span style="display: none;" class="delete_version"><span class="secno">4.15.3 </span><span class="content">Let Clause</span></span><span style="display: none;" class="add_version"><span class="secno">4.14.3 </span><span class="content">Let Clause</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.15.3</span><span class="deltaxml-new">4.14.3</span> </span><span class="content">Let Clause</span></span></a></li><li><a href="#id-windows"><span style="display: none;" class="delete_version"><span class="secno">4.15.4 </span><span class="content">Window Clause</span></span><span style="display: none;" class="add_version"><span class="secno">4.14.4 </span><span class="content">Window Clause</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.15.4</span><span class="deltaxml-new">4.14.4</span> </span><span class="content">Window Clause</span></span></a><a href="#id-tumbling-windows"><span style="display: none;" class="delete_version"><span class="secno">4.15.4.1 </span><span class="content">Tumbling Windows</span></span><span style="display: none;" class="add_version"><span class="secno">4.14.4.1 </span><span class="content">Tumbling Windows</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.15.4.1</span><span class="deltaxml-new">4.14.4.1</span> </span><span class="content">Tumbling Windows</span></span></a><a href="#id-sliding-windows"><span style="display: none;" class="delete_version"><span class="secno">4.15.4.2 </span><span class="content">Sliding Windows</span></span><span style="display: none;" class="add_version"><span class="secno">4.14.4.2 </span><span class="content">Sliding Windows</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.15.4.2</span><span class="deltaxml-new">4.14.4.2</span> </span><span class="content">Sliding Windows</span></span></a><a href="#id-effects-of-window-clauses"><span style="display: none;" class="delete_version"><span class="secno">4.15.4.3 </span><span class="content">Effects of Window Clauses on the Tuple Stream</span></span><span style="display: none;" class="add_version"><span class="secno">4.14.4.3 </span><span class="content">Effects of Window Clauses on the Tuple Stream</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.15.4.3</span><span class="deltaxml-new">4.14.4.3</span> </span><span class="content">Effects of Window Clauses on the Tuple Stream</span></span></a></li><li><a href="#id-where"><span style="display: none;" class="delete_version"><span class="secno">4.15.5 </span><span class="content">Where Clause</span></span><span style="display: none;" class="add_version"><span class="secno">4.14.5 </span><span class="content">Where Clause</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.15.5</span><span class="deltaxml-new">4.14.5</span> </span><span class="content">Where Clause</span></span></a></li><li class="delete_version" style="display: none;"><a href="#id-while"><span class="secno">4.15.6 </span><span class="content">While Clause</span></a></li><li class="modify_version"><a href="#id-while"><span class="secno"><span class="deltaxml-old">4.15.6 </span></span><span class="content"><span class="deltaxml-old">While Clause</span></span></a></li><li><a href="#id-count"><span style="display: none;" class="delete_version"><span class="secno">4.15.7 </span><span class="content">Count Clause</span></span><span style="display: none;" class="add_version"><span class="secno">4.14.6 </span><span class="content">Count Clause</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.15.7</span><span class="deltaxml-new">4.14.6</span> </span><span class="content">Count Clause</span></span></a></li><li><a href="#id-group-by"><span style="display: none;" class="delete_version"><span class="secno">4.15.8 </span><span class="content">Group By Clause</span></span><span style="display: none;" class="add_version"><span class="secno">4.14.7 </span><span class="content">Group By Clause</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.15.8</span><span class="deltaxml-new">4.14.7</span> </span><span class="content">Group By Clause</span></span></a></li><li><a href="#id-order-by-clause"><span style="display: none;" class="delete_version"><span class="secno">4.15.9 </span><span class="content">Order By Clause</span></span><span style="display: none;" class="add_version"><span class="secno">4.14.8 </span><span class="content">Order By Clause</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.15.9</span><span class="deltaxml-new">4.14.8</span> </span><span class="content">Order By Clause</span></span></a></li><li><a href="#id-return-clause"><span style="display: none;" class="delete_version"><span class="secno">4.15.10 </span><span class="content">Return Clause</span></span><span style="display: none;" class="add_version"><span class="secno">4.14.9 </span><span class="content">Return Clause</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.15.10</span><span class="deltaxml-new">4.14.9</span> </span><span class="content">Return Clause</span></span></a></li></ol></li><li><a href="#id-unordered-expressions"><span style="display: none;" class="delete_version"><span class="secno">4.16 </span><span class="content xquery">Ordered and Unordered Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.15 </span><span class="content">Ordered and Unordered Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.16</span><span class="deltaxml-new">4.15</span> </span><span class="content">Ordered and Unordered Expressions</span></span></a></li><li><a href="#id-conditionals"><span style="display: none;" class="delete_version"><span class="secno">4.17 </span><span class="content">Conditional Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.16 </span><span class="content">Conditional Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.17</span><span class="deltaxml-new">4.16</span> </span><span class="content">Conditional Expressions</span></span></a></li><li><a href="#id-otherwise"><span style="display: none;" class="delete_version"><span class="secno">4.18 </span><span class="content">Otherwise Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.17 </span><span class="content">Otherwise Expression</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.18</span><span class="deltaxml-new">4.17</span> </span><span class="content">Otherwise <span class="deltaxml-old">Expressions</span><span class="deltaxml-new">Expression</span></span></span></a></li><li><a href="#id-switch"><span class="secno"><span class="deltaxml-old">4.19 </span></span><span class="content xquery"><span class="deltaxml-old">Switch Expressions</span></span></a><a href="#id-switch"><span class="secno"><span class="deltaxml-new">4.18 </span></span><span class="content"><span class="deltaxml-new">Switch Expression</span></span></a></li><li><a href="#id-quantified-expressions"><span style="display: none;" class="delete_version"><span class="secno">4.20 </span><span class="content">Quantified Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.19 </span><span class="content">Quantified Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.20</span><span class="deltaxml-new">4.19</span> </span><span class="content">Quantified Expressions</span></span></a></li><li><a href="#id-try-catch"><span style="display: none;" class="delete_version"><span class="secno">4.21 </span><span class="content xquery">Try/Catch Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.20 </span><span class="content">Try/Catch Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.21</span><span class="deltaxml-new">4.20</span> </span><span class="content">Try/Catch Expressions</span></span></a></li><li><a href="#id-expressions-on-datatypes"><span style="display: none;" class="delete_version"><span class="secno">4.22 </span><span class="content">Expressions on SequenceTypes</span></span><span style="display: none;" class="add_version"><span class="secno">4.21 </span><span class="content">Expressions on SequenceTypes</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.22</span><span class="deltaxml-new">4.21</span> </span><span class="content">Expressions on SequenceTypes</span></span></a><ol class="toc"><li><a href="#id-instance-of"><span style="display: none;" class="delete_version"><span class="secno">4.22.1 </span><span class="content">Instance Of</span></span><span style="display: none;" class="add_version"><span class="secno">4.21.1 </span><span class="content">Instance Of</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.22.1</span><span class="deltaxml-new">4.21.1</span> </span><span class="content">Instance Of</span></span></a></li><li><a href="#id-typeswitch"><span style="display: none;" class="delete_version"><span class="secno">4.22.2 </span><span class="content xquery">Typeswitch</span></span><span style="display: none;" class="add_version"><span class="secno">4.21.2 </span><span class="content">Typeswitch</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.22.2</span><span class="deltaxml-new">4.21.2</span> </span><span class="content">Typeswitch</span></span></a></li><li><a href="#id-cast"><span style="display: none;" class="delete_version"><span class="secno">4.22.3 </span><span class="content">Cast</span></span><span style="display: none;" class="add_version"><span class="secno">4.21.3 </span><span class="content">Cast</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.22.3</span><span class="deltaxml-new">4.21.3</span> </span><span class="content">Cast</span></span></a></li><li><a href="#id-castable"><span style="display: none;" class="delete_version"><span class="secno">4.22.4 </span><span class="content">Castable</span></span><span style="display: none;" class="add_version"><span class="secno">4.21.4 </span><span class="content">Castable</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.22.4</span><span class="deltaxml-new">4.21.4</span> </span><span class="content">Castable</span></span></a></li><li><a href="#id-constructor-functions"><span style="display: none;" class="delete_version"><span class="secno">4.22.5 </span><span class="content">Constructor Functions</span></span><span style="display: none;" class="add_version"><span class="secno">4.21.5 </span><span class="content">Constructor Functions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.22.5</span><span class="deltaxml-new">4.21.5</span> </span><span class="content">Constructor Functions</span></span></a></li><li><a href="#id-treat"><span style="display: none;" class="delete_version"><span class="secno">4.22.6 </span><span class="content">Treat</span></span><span style="display: none;" class="add_version"><span class="secno">4.21.6 </span><span class="content">Treat</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.22.6</span><span class="deltaxml-new">4.21.6</span> </span><span class="content">Treat</span></span></a></li></ol></li><li><a href="#id-map-operator"><span style="display: none;" class="delete_version"><span class="secno">4.23 </span><span class="content">Simple map operator (!)</span></span><span style="display: none;" class="add_version"><span class="secno">4.22 </span><span class="content">Simple map operator (!)</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.23</span><span class="deltaxml-new">4.22</span> </span><span class="content">Simple map operator (!)</span></span></a></li><li><a href="#id-arrow-operator"><span style="display: none;" class="delete_version"><span class="secno">4.24 </span><span class="content">Arrow Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.23 </span><span class="content">Arrow Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.24</span><span class="deltaxml-new">4.23</span> </span><span class="content">Arrow Expressions</span></span></a><ol class="toc"><li><a href="#id-sequence-arrow-expression"><span class="secno"><span class="deltaxml-old">4.24.1 </span></span><span class="content"><span class="deltaxml-old">Sequence Arrow Expressions</span></span></a></li><li><a href="#id-mapping-arrow-expression"><span class="secno"><span class="deltaxml-old">4.24.2 </span></span><span class="content"><span class="deltaxml-old">Mapping Arrow Expressions</span></span></a></li><li><a href="#lookup-arrow-expression"><span class="secno"><span class="deltaxml-old">4.24.3 </span></span><span class="content"><span class="deltaxml-old">Lookup Arrow Expressions</span></span></a></li></ol></li><li><a href="#id-validate"><span style="display: none;" class="delete_version"><span class="secno">4.25 </span><span class="content xquery">Validate Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.24 </span><span class="content">Validate Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.25</span><span class="deltaxml-new">4.24</span> </span><span class="content">Validate Expressions</span></span></a></li><li><a href="#id-extension-expressions"><span style="display: none;" class="delete_version"><span class="secno">4.26 </span><span class="content xquery">Extension Expressions</span></span><span style="display: none;" class="add_version"><span class="secno">4.25 </span><span class="content">Extension Expressions</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">4.26</span><span class="deltaxml-new">4.25</span> </span><span class="content">Extension Expressions</span></span></a></li></ol></li><li><a href="#id-query-prolog"><span style="display: none;" class="delete_version"><span class="secno">5 </span><span class="content xquery">Modules and Prologs</span></span><span style="display: none;" class="add_version"><span class="secno">5 </span><span class="content">Modules and Prologs</span></span><span class="modify_version"><span class="secno">5 </span><span class="content">Modules and Prologs</span></span></a><ol class="toc"><li><a href="#id-version-declaration"><span class="secno">5.1 </span><span class="content">Version Declaration</span></a></li><li><a href="#id-module-declaration"><span class="secno">5.2 </span><span class="content">Module Declaration</span></a></li><li><a href="#id-boundary-space-decls"><span class="secno">5.3 </span><span class="content">Boundary-space Declaration</span></a></li><li><a href="#id-default-collation-declaration"><span class="secno">5.4 </span><span class="content">Default Collation Declaration</span></a></li><li><a href="#id-base-uri-decl"><span class="secno">5.5 </span><span class="content">Base URI Declaration</span></a></li><li><a href="#id-construction-declaration"><span class="secno">5.6 </span><span class="content">Construction Declaration</span></a></li><li><a href="#id-default-ordering-decl"><span class="secno">5.7 </span><span class="content">Ordering Mode Declaration</span></a></li><li><a href="#id-empty-order-decl"><span class="secno">5.8 </span><span class="content">Empty Order Declaration</span></a></li><li><a href="#id-copy-namespaces-decl"><span class="secno">5.9 </span><span class="content">Copy-Namespaces Declaration</span></a></li><li><a href="#id-decimal-format-decl"><span class="secno">5.10 </span><span class="content">Decimal Format Declaration</span></a></li><li><a href="#id-schema-import"><span class="secno">5.11 </span><span class="content">Schema Import</span></a></li><li><a href="#id-module-import"><span class="secno">5.12 </span><span class="content">Module Import</span></a><ol class="toc"><li><a href="#id-module-handling-module-uris"><span class="secno">5.12.1 </span><span class="content">The Target Namespace of a Module</span></a></li><li><a href="#id-module-handling-multiple-same"><span class="secno">5.12.2 </span><span class="content">Multiple Modules with the same Namespace</span></a></li><li><a href="#id-module-handling-location-uris"><span class="secno">5.12.3 </span><span class="content">Location URIs</span></a></li><li><a href="#id-module-handling-cycles"><span class="secno">5.12.4 </span><span class="content">Cycles</span></a></li></ol></li><li><a href="#id-namespace-declaration"><span class="secno">5.13 </span><span class="content">Namespace Declaration</span></a></li><li><a href="#id-default-namespace"><span class="secno">5.14 </span><span class="content">Default Namespace Declaration</span></a></li><li><a href="#id-annotations"><span class="secno">5.15 </span><span class="content">Annotations</span></a></li><li><a href="#id-variable-declarations"><span class="secno">5.16 </span><span class="content">Variable Declaration</span></a></li><li><a><span style="display: none;" class="delete_version" href="#id-context-value-declarations"><span class="secno">5.17 </span><span class="content">Context Value Declaration</span></span><span style="display: none;" class="add_version" href="#id-context-item-declarations"><span class="secno">5.17 </span><span class="content">Context Item Declaration</span></span><span class="modify_version" href="#id-context-item-declarations"><span class="secno">5.17 </span><span class="content">Context <span class="deltaxml-old">Value</span><span class="deltaxml-new">Item</span> Declaration</span></span></a></li><li><a href="#FunctionDeclns"><span style="display: none;" class="delete_version"><span class="secno">5.18 </span><span class="content">Function Declarations</span></span><span style="display: none;" class="add_version"><span class="secno">5.18 </span><span class="content">Function Declaration</span></span><span class="modify_version"><span class="secno">5.18 </span><span class="content">Function <span class="deltaxml-old">Declarations</span><span class="deltaxml-new">Declaration</span></span></span></a><ol class="toc"><li><a href="#id-user-defined-functions"><span class="secno"><span class="deltaxml-old">5.18.1 </span></span><span class="content"><span class="deltaxml-old">User-Defined Functions</span></span></a></li><li><a href="#id-function-names"><span class="secno"><span class="deltaxml-old">5.18.2 </span></span><span class="content"><span class="deltaxml-old">Function Names</span></span></a></li><li><a href="#id-function-parameters"><span class="secno"><span class="deltaxml-old">5.18.3 </span></span><span class="content"><span class="deltaxml-old">Function Parameters</span></span></a></li><li><a href="#id-function-annotations"><span class="secno"><span class="deltaxml-old">5.18.4 </span></span><span class="content"><span class="deltaxml-old">Function Annotations</span></span></a></li><li><a href="#id-external-functions"><span class="secno"><span class="deltaxml-old">5.18.5 </span></span><span class="content"><span class="deltaxml-old">External Functions</span></span></a></li><li><a href="#id-recursion"><span class="secno"><span class="deltaxml-old">5.18.6 </span></span><span class="content"><span class="deltaxml-old">Recursion</span></span></a></li></ol></li><li><a href="#id-item-type-declaration"><span class="secno">5.19 </span><span class="content">Item Type Declarations</span></a></li><li><a href="#id-option-declaration"><span class="secno">5.20 </span><span class="content">Option Declaration</span></a></li></ol></li><li><a href="#id-conformance"><span class="secno">6 </span><span class="content">Conformance</span></a><ol class="toc"><li><a href="#id-minimal-conformance"><span style="display: none;" class="delete_version"><span class="secno">6.1 </span><span class="content xquery">Minimal Conformance</span></span><span style="display: none;" class="add_version"><span class="secno">6.1 </span><span class="content">Minimal Conformance</span></span><span class="modify_version"><span class="secno">6.1 </span><span class="content">Minimal Conformance</span></span></a></li><li><a href="#id-conform-optional-features"><span style="display: none;" class="delete_version"><span class="secno">6.2 </span><span class="content xquery">Optional Features</span></span><span style="display: none;" class="add_version"><span class="secno">6.2 </span><span class="content">Optional Features</span></span><span class="modify_version"><span class="secno">6.2 </span><span class="content">Optional Features</span></span></a><ol class="toc"><li><a href="#id-schema-aware-feature"><span class="secno">6.2.1 </span><span class="content">Schema Aware Feature</span></a></li><li><a href="#id-typed-data-feature"><span class="secno">6.2.2 </span><span class="content">Typed Data Feature</span></a></li><li class="add_version" style="display: none;"><a href="#id-static-typing-feature"><span class="secno">6.2.3 </span><span class="content">Static Typing Feature</span></a></li><li class="modify_version"><a href="#id-static-typing-feature"><span class="secno"><span class="deltaxml-new">6.2.3 </span></span><span class="content"><span class="deltaxml-new">Static Typing Feature</span></span></a></li><li><a href="#id-module-feature"><span class="secno">6.2.4 </span><span class="content">Module Feature</span></a></li><li><a href="#id-serialization-feature"><span class="secno">6.2.5 </span><span class="content">Serialization Feature</span></a></li></ol></li><li><a href="#id-data-model-conformance"><span style="display: none;" class="delete_version"><span class="secno">6.3 </span><span class="content xquery">Data Model Conformance</span></span><span style="display: none;" class="add_version"><span class="secno">6.3 </span><span class="content">Data Model Conformance</span></span><span class="modify_version"><span class="secno">6.3 </span><span class="content">Data Model Conformance</span></span></a></li><li><a href="#id-syntax-extensions"><span style="display: none;" class="delete_version"><span class="secno">6.4 </span><span class="content xquery">Syntax Extensions</span></span><span style="display: none;" class="add_version"><span class="secno">6.4 </span><span class="content">Syntax Extensions</span></span><span class="modify_version"><span class="secno">6.4 </span><span class="content">Syntax Extensions</span></span></a></li></ol></li><li><a href="#nt-bnf"><span class="secno">A </span><span class="content">XQuery 4.0 Grammar</span></a><ol class="toc"><li><a href="#id-grammar"><span class="secno">A.1 </span><span class="content">EBNF</span></a><ol class="toc"><li><a href="#EBNFNotation"><span class="secno">A.1.1 </span><span class="content">Notation</span></a></li><li><a href="#extra-grammatical-constraints"><span class="secno">A.1.2 </span><span class="content">Extra-grammatical Constraints</span></a></li><li><a href="#notes-on-parsing"><span class="secno">A.1.3 </span><span class="content">Grammar Notes</span></a></li></ol></li><li class="delete_version" style="display: none;"><a href="#productions-derived-from-XML"><span class="secno">A.2 </span><span class="content">Productions Derived from XML</span></a></li><li class="modify_version"><a href="#productions-derived-from-XML"><span class="secno"><span class="deltaxml-old">A.2 </span></span><span class="content"><span class="deltaxml-old">Productions Derived from XML</span></span></a></li><li><a href="#lexical-structure"><span style="display: none;" class="delete_version"><span class="secno">A.3 </span><span class="content">Lexical structure</span></span><span style="display: none;" class="add_version"><span class="secno">A.2 </span><span class="content">Lexical structure</span></span><span class="modify_version"><span class="secno">A.<span class="deltaxml-old">3</span><span class="deltaxml-new">2</span> </span><span class="content">Lexical structure</span></span></a><ol class="toc"><li><a href="#terminal-symbols"><span style="display: none;" class="delete_version"><span class="secno">A.3.1 </span><span class="content">Terminal Symbols</span></span><span style="display: none;" class="add_version"><span class="secno">A.2.1 </span><span class="content">Terminal Symbols</span></span><span class="modify_version"><span class="secno">A.<span class="deltaxml-old">3.1</span><span class="deltaxml-new">2.1</span> </span><span class="content">Terminal Symbols</span></span></a></li><li><a href="#id-terminal-delimitation"><span style="display: none;" class="delete_version"><span class="secno">A.3.2 </span><span class="content">Terminal Delimitation</span></span><span style="display: none;" class="add_version"><span class="secno">A.2.2 </span><span class="content">Terminal Delimitation</span></span><span class="modify_version"><span class="secno">A.<span class="deltaxml-old">3.2</span><span class="deltaxml-new">2.2</span> </span><span class="content">Terminal Delimitation</span></span></a></li><li class="delete_version" style="display: none;"><a href="#id-lt-and-gt-characters"><span class="secno">A.3.3 </span><span class="content">Less-Than and Greater-Than Characters</span></a></li><li class="modify_version"><a href="#id-lt-and-gt-characters"><span class="secno"><span class="deltaxml-old">A.3.3 </span></span><span class="content"><span class="deltaxml-old">Less-Than and Greater-Than Characters</span></span></a></li><li><a href="#id-eol-handling"><span style="display: none;" class="delete_version"><span class="secno">A.3.4 </span><span class="content">End-of-Line Handling</span></span><span style="display: none;" class="add_version"><span class="secno">A.2.3 </span><span class="content">End-of-Line Handling</span></span><span class="modify_version"><span class="secno">A.<span class="deltaxml-old">3.4</span><span class="deltaxml-new">2.3</span> </span><span class="content">End-of-Line Handling</span></span></a><a href="#id-xml10-eol-handling"><span style="display: none;" class="delete_version"><span class="secno">A.3.4.1 </span><span class="content">XML 1.0 End-of-Line Handling</span></span><span style="display: none;" class="add_version"><span class="secno">A.2.3.1 </span><span class="content">XML 1.0 End-of-Line Handling</span></span><span class="modify_version"><span class="secno">A.<span class="deltaxml-old">3.4.1</span><span class="deltaxml-new">2.3.1</span> </span><span class="content">XML 1.0 End-of-Line Handling</span></span></a><a href="#id-xml11-eol-handling"><span style="display: none;" class="delete_version"><span class="secno">A.3.4.2 </span><span class="content">XML 1.1 End-of-Line Handling</span></span><span style="display: none;" class="add_version"><span class="secno">A.2.3.2 </span><span class="content">XML 1.1 End-of-Line Handling</span></span><span class="modify_version"><span class="secno">A.<span class="deltaxml-old">3.4.2</span><span class="deltaxml-new">2.3.2</span> </span><span class="content">XML 1.1 End-of-Line Handling</span></span></a></li><li><a href="#whitespace-rules"><span style="display: none;" class="delete_version"><span class="secno">A.3.5 </span><span class="content">Whitespace Rules</span></span><span style="display: none;" class="add_version"><span class="secno">A.2.4 </span><span class="content">Whitespace Rules</span></span><span class="modify_version"><span class="secno">A.<span class="deltaxml-old">3.5</span><span class="deltaxml-new">2.4</span> </span><span class="content">Whitespace Rules</span></span></a><a href="#DefaultWhitespaceHandling"><span style="display: none;" class="delete_version"><span class="secno">A.3.5.1 </span><span class="content">Default Whitespace Handling</span></span><span style="display: none;" class="add_version"><span class="secno">A.2.4.1 </span><span class="content">Default Whitespace Handling</span></span><span class="modify_version"><span class="secno">A.<span class="deltaxml-old">3.5.1</span><span class="deltaxml-new">2.4.1</span> </span><span class="content">Default Whitespace Handling</span></span></a><a href="#ExplicitWhitespaceHandling"><span style="display: none;" class="delete_version"><span class="secno">A.3.5.2 </span><span class="content">Explicit Whitespace Handling</span></span><span style="display: none;" class="add_version"><span class="secno">A.2.4.2 </span><span class="content">Explicit Whitespace Handling</span></span><span class="modify_version"><span class="secno">A.<span class="deltaxml-old">3.5.2</span><span class="deltaxml-new">2.4.2</span> </span><span class="content">Explicit Whitespace Handling</span></span></a></li></ol></li><li><a href="#id-reserved-fn-names"><span style="display: none;" class="delete_version"><span class="secno">A.4 </span><span class="content">Reserved Function Names</span></span><span style="display: none;" class="add_version"><span class="secno">A.3 </span><span class="content">Reserved Function Names</span></span><span class="modify_version"><span class="secno">A.<span class="deltaxml-old">4</span><span class="deltaxml-new">3</span> </span><span class="content">Reserved Function Names</span></span></a></li><li><a href="#id-precedence-order"><span style="display: none;" class="delete_version"><span class="secno">A.5 </span><span class="content">Precedence Order (Non-Normative)</span></span><span style="display: none;" class="add_version"><span class="secno">A.4 </span><span class="content">Precedence Order (Non-Normative)</span></span><span class="modify_version"><span class="secno">A.<span class="deltaxml-old">5</span><span class="deltaxml-new">4</span> </span><span class="content">Precedence Order (Non-Normative)</span></span></a></li></ol></li><li><a href="#id-type-promotion-and-operator-mapping"><span class="secno">B </span><span class="content">Type Promotion and Operator Mapping</span></a><ol class="toc"><li><a href="#promotion"><span class="secno">B.1 </span><span class="content">Type Promotion</span></a></li><li><a href="#mapping"><span class="secno">B.2 </span><span class="content">Operator Mapping</span></a></li><li class="add_version" style="display: none;"><a href="#id-math-symbols"><span class="secno">B.3 </span><span class="content">Mathematical Operator Symbols</span></a></li><li class="modify_version"><a href="#id-math-symbols"><span class="secno"><span class="deltaxml-new">B.3 </span></span><span class="content"><span class="deltaxml-new">Mathematical Operator Symbols</span></span></a></li></ol></li><li><a href="#id-xq-context-components"><span style="display: none;" class="delete_version"><span class="secno">C </span><span class="content xquery">Context Components</span></span><span style="display: none;" class="add_version"><span class="secno">C </span><span class="content">Context Components</span></span><span class="modify_version"><span class="secno">C </span><span class="content">Context Components</span></span></a><ol class="toc"><li><a href="#id-xq-static-context-components"><span class="secno">C.1 </span><span class="content">Static Context Components</span></a></li><li><a href="#id-xq-evaluation-context-components"><span class="secno">C.2 </span><span class="content">Dynamic Context Components</span></a></li></ol></li><li><a href="#id-impl-defined-items"><span class="secno">D </span><span class="content">Implementation-Defined Items</span></a><ol class="toc"></ol></li><li><a href="#id-references"><span class="secno">E </span><span class="content">References</span></a><ol class="toc"><li><a href="#id-normative-references"><span class="secno">E.1 </span><span class="content">Normative References</span></a></li><li><a href="#id-non-normative-references"><span class="secno">E.2 </span><span class="content">Non-normative References</span></a></li><li><a href="#id-background-material"><span class="secno">E.3 </span><span class="content">Background Material</span></a></li></ol></li><li><a href="#id-errors"><span class="secno">F </span><span class="content">Error Conditions</span></a><ol class="toc"></ol></li><li><a href="#id-mime-type"><span style="display: none;" class="delete_version"><span class="secno">G </span><span class="content xquery">The application/xquery Media Type</span></span><span style="display: none;" class="add_version"><span class="secno">G </span><span class="content">The application/xquery Media Type</span></span><span class="modify_version"><span class="secno">G </span><span class="content">The application/xquery Media Type</span></span></a><ol class="toc"><li><a href="#id-mime-type-intro"><span class="secno">G.1 </span><span class="content">Introduction</span></a></li><li><a href="#id-registration-of-mime-type"><span class="secno">G.2 </span><span class="content">Registration of MIME Media Type application/xquery </span></a><ol class="toc"><li><a href="#id-interoperability-considerations"><span class="secno">G.2.1 </span><span class="content">Interoperability Considerations</span></a></li><li><a href="#id-applications-of-media-type"><span class="secno">G.2.2 </span><span class="content">Applications Using this Media Type</span></a></li><li><a href="#id-file-extensions"><span class="secno">G.2.3 </span><span class="content">File Extensions</span></a></li><li><a href="#id-intended-usage"><span class="secno">G.2.4 </span><span class="content">Intended Usage</span></a></li><li><a href="#id-author-change-controller"><span class="secno">G.2.5 </span><span class="content">Author/Change Controller</span></a></li></ol></li><li><a href="#xquery-mime-encoding"><span class="secno">G.3 </span><span class="content">Encoding Considerations</span></a></li><li><a href="#xquery-mime-recognizing"><span class="secno">G.4 </span><span class="content">Recognizing XQuery Files</span></a></li><li><a href="#id-charset-default-rules"><span class="secno">G.5 </span><span class="content">Charset Default Rules</span></a></li><li><a href="#id-security-considerations"><span class="secno">G.6 </span><span class="content">Security Considerations</span></a></li></ol></li><li><a href="#id-glossary"><span class="secno">H </span><span class="content">Glossary</span></a> (Non-Normative) <ol class="toc"></ol></li><li><a href="#id-atomic-comparisons"><span class="secno"><span class="deltaxml-old">I </span></span><span class="content"><span class="deltaxml-old">Atomic Comparisons: An Overview</span></span></a><a href="#id-example-applications"><span class="secno"><span class="deltaxml-new">I </span></span><span class="content"><span class="deltaxml-new">Example Applications</span></span></a> (Non-Normative) <ol class="toc"><li><a href="#id-equality-comparison"><span class="secno"><span class="deltaxml-old">I.1 </span></span><span class="content"><span class="deltaxml-old">Equality Comparisons</span></span></a><a href="#id-joins"><span class="secno"><span class="deltaxml-new">I.1 </span></span><span class="content"><span class="deltaxml-new">Joins</span></span></a></li><li><a href="#id-ordering-comparison"><span class="secno"><span class="deltaxml-old">I.2 </span></span><span class="content"><span class="deltaxml-old">Ordering Comparisons</span></span></a><a href="#id-queries-on-sequence"><span class="secno"><span class="deltaxml-new">I.2 </span></span><span class="content"><span class="deltaxml-new">Queries on Sequence</span></span></a></li><li class="add_version" style="display: none;"><a href="#id-recursive-transformations"><span class="secno">I.3 </span><span class="content">Recursive Transformations</span></a></li><li class="modify_version"><a href="#id-recursive-transformations"><span class="secno"><span class="deltaxml-new">I.3 </span></span><span class="content"><span class="deltaxml-new">Recursive Transformations</span></span></a></li><li class="add_version" style="display: none;"><a href="#id-select-distinct"><span class="secno">I.4 </span><span class="content">Selecting Distinct Combinations</span></a></li><li class="modify_version"><a href="#id-select-distinct"><span class="secno"><span class="deltaxml-new">I.4 </span></span><span class="content"><span class="deltaxml-new">Selecting Distinct Combinations</span></span></a></li></ol></li><li class="delete_version" style="display: none;"><a href="#id-example-applications"><span class="secno">J </span><span class="content xquery">Example Applications</span></a> (Non-Normative) <ol class="toc"><li><a href="#id-joins"><span class="secno">J.1 </span><span class="content">Joins</span></a></li><li><a href="#id-queries-on-sequence"><span class="secno">J.2 </span><span class="content">Queries on Sequence</span></a></li><li><a href="#id-recursive-transformations"><span class="secno">J.3 </span><span class="content">Recursive Transformations</span></a></li><li><a href="#id-select-distinct"><span class="secno">J.4 </span><span class="content">Selecting Distinct Combinations</span></a></li></ol></li><li class="modify_version"><a href="#id-example-applications"><span class="secno"><span class="deltaxml-old">J </span></span><span class="content xquery"><span class="deltaxml-old">Example Applications</span></span></a><span class="deltaxml-old"> (Non-Normative) </span><ol class="toc"><li><a href="#id-joins"><span class="secno"><span class="deltaxml-old">J.1 </span></span><span class="content"><span class="deltaxml-old">Joins</span></span></a></li><li><a href="#id-queries-on-sequence"><span class="secno"><span class="deltaxml-old">J.2 </span></span><span class="content"><span class="deltaxml-old">Queries on Sequence</span></span></a></li><li><a href="#id-recursive-transformations"><span class="secno"><span class="deltaxml-old">J.3 </span></span><span class="content"><span class="deltaxml-old">Recursive Transformations</span></span></a></li><li><a href="#id-select-distinct"><span class="secno"><span class="deltaxml-old">J.4 </span></span><span class="content"><span class="deltaxml-old">Selecting Distinct Combinations</span></span></a></li></ol></li><li><a href="#id-incompatibilities"><span style="display: none;" class="delete_version"><span class="secno">K </span><span class="content">Backwards Compatibility</span></span><span style="display: none;" class="add_version"><span class="secno">J </span><span class="content">Backwards Compatibility</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">K</span><span class="deltaxml-new">J</span> </span><span class="content">Backwards Compatibility</span></span></a> (Non-Normative) <ol class="toc"><li><a href="#id-incompatibilities-31"><span style="display: none;" class="delete_version"><span class="secno">K.1 </span><span class="content">Incompatibilities relative to XQuery 3.1</span></span><span style="display: none;" class="add_version"><span class="secno">J.1 </span><span class="content">Incompatibilities relative to XQuery 3.1</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">K</span><span class="deltaxml-new">J</span>.1 </span><span class="content">Incompatibilities relative to XQuery 3.1</span></span></a></li><li><a href="#id-incompatibilities-30"><span style="display: none;" class="delete_version"><span class="secno">K.2 </span><span class="content">Incompatibilities relative to XQuery 3.0</span></span><span style="display: none;" class="add_version"><span class="secno">J.2 </span><span class="content">Incompatibilities relative to XQuery 3.0</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">K</span><span class="deltaxml-new">J</span>.2 </span><span class="content">Incompatibilities relative to XQuery 3.0</span></span></a></li><li><a href="#id-incompatibilities-10"><span style="display: none;" class="delete_version"><span class="secno">K.3 </span><span class="content">Incompatibilities relative to XQuery 1.0 </span></span><span style="display: none;" class="add_version"><span class="secno">J.3 </span><span class="content">Incompatibilities relative to XQuery 1.0 </span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">K</span><span class="deltaxml-new">J</span>.3 </span><span class="content">Incompatibilities relative to XQuery 1.0 </span></span></a></li></ol></li><li><a href="#id-revision-log"><span style="display: none;" class="delete_version"><span class="secno">L </span><span class="content">Change Log</span></span><span style="display: none;" class="add_version"><span class="secno">K </span><span class="content">Change Log</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">L</span><span class="deltaxml-new">K</span> </span><span class="content">Change Log</span></span></a> (Non-Normative) <ol class="toc"><li><a href="#id-changes-since-3.1"><span style="display: none;" class="delete_version"><span class="secno">L.1 </span><span class="content">Changes since version 3.1</span></span><span style="display: none;" class="add_version"><span class="secno">K.1 </span><span class="content">Changes since version 3.1</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">L</span><span class="deltaxml-new">K</span>.1 </span><span class="content">Changes since version 3.1</span></span></a><ol class="toc"><li><a href="#id-substantive-changes-since-3.1"><span style="display: none;" class="delete_version"><span class="secno">L.1.1 </span><span class="content">Substantive Changes</span></span><span style="display: none;" class="add_version"><span class="secno">K.1.1 </span><span class="content">Substantive Changes</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">L</span><span class="deltaxml-new">K</span>.1.1 </span><span class="content">Substantive Changes</span></span></a></li><li><a href="#id-editorial-changes-since-3.1"><span style="display: none;" class="delete_version"><span class="secno">L.1.2 </span><span class="content">Editorial Changes</span></span><span style="display: none;" class="add_version"><span class="secno">K.1.2 </span><span class="content">Editorial Changes</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old">L</span><span class="deltaxml-new">K</span>.1.2 </span><span class="content">Editorial Changes</span></span></a></li></ol></li></ol></li></ol></nav><hr><div class="body"><div class="div1"><h2><a id="id-introduction"></a>1 Introduction</h2><p class="xquery">As increasing amounts of information are stored, exchanged, and presented using XML, the ability to intelligently query XML data sources becomes increasingly important. One of the great strengths of XML is its flexibility in representing many different kinds of information from diverse sources. To exploit this flexibility, an XML query language must provide features for retrieving and interpreting information from these diverse sources.</p><p class="xquery">As increasing amounts of JSON are used for lightweight data-exchange, an XML query language for Web data needs to handle JSON as well as XML and HTML.</p><p class="xquery">XQuery is designed to <span class="deltaxml-new">meet the requirements identified by the W3C XML Query Working Group </span><a href="#xquery-31-requirements"><span class="deltaxml-new">[XQuery 3.1 Requirements]</span></a><span class="deltaxml-new">. It is designed to </span>be a language in which queries are concise and easily understood. It is also flexible enough to query a broad spectrum of <span class="deltaxml-new">XML </span>information sources, <span class="deltaxml-old">both XML and non-XML, </span>including both databases and documents. <span class="deltaxml-old">XQuery was originally</span><span class="deltaxml-new">The Query Working Group has identified a requirement for both a non-XML query syntax and an XML-based query syntax. XQuery is designed to meet the first of these requirements. XQuery is</span> derived from an XML query language called Quilt <a href="#Quilt">[Quilt]</a>, which in turn borrowed features from several other languages, including XPath 1.0 <a href="#xpath">[XML Path Language (XPath) Version 1.0]</a>, XQL <a href="#XQL">[XQL]</a>, XML-QL <a href="#XML-QL">[XML-QL]</a>, SQL <a href="#SQL">[SQL]</a>, and OQL <a href="#ODMG">[ODMG]</a>. </p><p><span style="display: none;" class="delete_version"> [<a id="dt-datamodel" title="data model">Definition</a>: XQuery 4.0 operates on the abstract, logical structure of an XML document or JSON object rather than its surface syntax. This logical structure, known as the <b>data model</b>, is defined in <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>.] </span><span style="display: none;" class="add_version"> [<a id="dt-datamodel" title="data model">Definition</a>: XQuery 4.0 operates on the abstract, logical structure of an XML document or JSON object, rather than its surface syntax. This logical structure, known as the <b>data model</b>, is defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>.] </span><span class="modify_version"> [<a id="dt-datamodel" title="data model">Definition</a>: XQuery 4.0 operates on the abstract, logical structure of an XML document or JSON object<span class="deltaxml-new">,</span> rather than its surface syntax. This logical structure, known as the <b>data model</b>, is defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a>.] </span></p><p><span class="xquery">XQuery 4.0 is an extension of XPath 4.0.</span> In general, any expression that is syntactically valid and executes successfully in both XPath 4.0 and XQuery 4.0 will return the same result in both languages. There are a few exceptions to this rule: </p><ul><li><p><span style="display: none;" class="delete_version">Because XQuery expands <span class="xquery"><a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference">predefined entity references</a> and <a title="character reference" class="termref" href="#dt-character-reference">character references</a></span> and XPath does not, expressions containing these produce different results in the two languages. For instance, the value of the string literal <code>"&amp;amp;"</code> is <code>&amp;</code> in XQuery, and <code>&amp;amp;</code> in XPath. (A host language may expand predefined entity references or character references before the XPath expression is evaluated.)</span><span style="display: none;" class="add_version">Because XQuery expands <span class="xquery"><a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference">predefined entity references</a> and <a title="character reference" class="termref" href="#dt-character-reference">character references</a></span> and XPath does not, expressions containing these produce different results in the two languages. For instance, the value of the string literal <code>"&amp;amp;"</code> is <code>&amp;</code> in XQuery, and <code>&amp;amp;</code> in XPath. (XPath is often embedded in other languages, which may expand predefined entity references or character references before the XPath expression is evaluated.)</span><span class="modify_version">Because XQuery expands <span class="xquery"><a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference">predefined entity references</a> and <a title="character reference" class="termref" href="#dt-character-reference">character references</a></span> and XPath does not, expressions containing these produce different results in the two languages. For instance, the value of the string literal <code>"&amp;amp;"</code> is <code>&amp;</code> in XQuery, and <code>&amp;amp;</code> in XPath. (<span class="deltaxml-old">A host language</span><span class="deltaxml-new">XPath is often embedded in other languages, which</span> may expand predefined entity references or character references before the XPath expression is evaluated.)</span></p></li><li><p><span style="display: none;" class="delete_version">If XPath 1.0 compatibility mode is enabled, XPath behaves differently from XQuery in a number of ways, <span class="xquery">which are discussed in <a href="#xpath-40">[XPath 4.0]</a>.</span></span><span style="display: none;" class="add_version">If XPath 1.0 compatibility mode is enabled, XPath behaves differently from XQuery in a number of ways, <span class="xquery">which are discussed in <a href="#xpath-31">[XML Path Language (XPath) Version 3.1]</a>.</span></span><span class="modify_version">If XPath 1.0 compatibility mode is enabled, XPath behaves differently from XQuery in a number of ways, <span class="xquery">which are discussed in <a href="#xpath-40"><span class="deltaxml-old">[XPath 4.0]</span></a><a href="#xpath-31"><span class="deltaxml-new">[XML Path Language (XPath) Version 3.1]</span></a>.</span></span></p></li></ul><p>Because these languages are so closely related, their grammars and language descriptions are generated from a common source to ensure consistency<span class="deltaxml-new">, and the editors of these specifications work together closely</span>.</p><p>XQuery 4.0 also depends on and is closely related to the following specifications:</p><ul><li><p><a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a> defines the data model that underlies all XQuery 4.0 expressions.</p></li><li><p>The type system of XQuery 4.0 is based on XML Schema. It is implementation-defined whether the type system is based on <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.</p></li><li><p>The <span class="deltaxml-old">system</span><span class="deltaxml-new">built-in</span> function library and the operators supported by XQuery 4.0 are defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>.</p></li><li class="add_version" style="display: none;"><p>XQuery also has an XML-based syntax, which is described in <a href="#xqueryx-31">[XQueryX 3.1]</a>. </p></li><li class="xquery"><p><span class="deltaxml-new">XQuery also has an XML-based syntax, which is described in </span><a href="#xqueryx-31"><span class="deltaxml-new">[XQueryX 3.1]</span></a><span class="deltaxml-new">. </span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The XML-based syntax for XQuery known as XQueryX is no longer maintained.</span></p></div><p class="xquery"><span style="display: none;" class="delete_version"> [<a id="dt-xquery-40-processor" title="XQuery 4.0 Processor">Definition</a>: An <b>XQuery 4.0 Processor</b> processes a query according to the XQuery 4.0 specification. ] [<a id="dt-xquery-31-processor" title="XQuery 3.1 Processor">Definition</a>: An <b>XQuery 3.1 Processor</b> processes a query according to the XQuery 3.1 specification. ] [<a id="dt-xquery-30-processor" title="XQuery 3.0 Processor">Definition</a>: An <b>XQuery 3.0 Processor</b> processes a query according to the XQuery 3.0 specification. ] [<a id="dt-xquery-10-processor" title="XQuery 1.0 Processor">Definition</a>: An <b>XQuery 1.0 Processor</b> processes a query according to the XQuery 1.0 specification. ] </span><span style="display: none;" class="add_version"> [<a id="dt-xquery-31-processor" title="XQuery 3.1 Processor">Definition</a>: An <b>XQuery 3.1 Processor</b> processes a query according to the XQuery 3.1 specification. ] [<a id="dt-xquery-30-processor" title="XQuery 3.0 Processor">Definition</a>: An <b>XQuery 3.0 Processor</b> processes a query according to the XQuery 3.0 specification. ] [<a id="dt-xquery-10-processor" title="XQuery 1.0 Processor">Definition</a>: An <b>XQuery 1.0 Processor</b> processes a query according to the XQuery 1.0 specification. ] </span><span class="modify_version"> [<a id="dt-xquery-40-processor" title="XQuery 4.0 Processor"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: An </span><span class="deltaxml-old">XQuery 4.0 Processor</span><span class="deltaxml-old"> processes a query according to the XQuery 4.0 specification. ] [</span><a id="dt-xquery-31-processor" title="XQuery 3.1 Processor">Definition</a>: An <b>XQuery 3.1 Processor</b> processes a query according to the XQuery 3.1 specification. ] [<a id="dt-xquery-30-processor" title="XQuery 3.0 Processor">Definition</a>: An <b>XQuery 3.0 Processor</b> processes a query according to the XQuery 3.0 specification. ] [<a id="dt-xquery-10-processor" title="XQuery 1.0 Processor">Definition</a>: An <b>XQuery 1.0 Processor</b> processes a query according to the XQuery 1.0 specification. ] </span></p><p><span style="display: none;" class="delete_version">This document specifies a grammar for XQuery 4.0, using the same basic EBNF notation used in <a href="#XML">[XML 1.0]</a>. Unless otherwise noted (see <a href="#lexical-structure"><span class="delete_version"><b>A.3 Lexical structure</b></span><span class="modify_version"><b>A.3 Lexical structure</b></span></a>), whitespace is not significant in <span class="xquery">queries</span>. Grammar productions are introduced together with the features that they describe, and a complete grammar is also presented in the appendix [<a href="#nt-bnf"><b>A XQuery 4.0 Grammar</b></a>]. The appendix is the normative version.</span><span style="display: none;" class="add_version">This document specifies a grammar for XQuery 4.0, using the same basic EBNF notation used in <a href="#XML">[XML 1.0]</a>. Unless otherwise noted (see <a href="#lexical-structure"><span class="add_version"><b>A.2 Lexical structure</b></span><span class="modify_version"><b>A.2 Lexical structure</b></span></a>), whitespace is not significant in <span class="xquery">queries</span>. Grammar productions are introduced together with the features that they describe, and a complete grammar is also presented in the appendix [<a href="#nt-bnf"><b>A XQuery 4.0 Grammar</b></a>]. The appendix is the normative version.</span><span class="modify_version">This document specifies a grammar for XQuery 4.0, using the same basic EBNF notation used in <a href="#XML">[XML 1.0]</a>. Unless otherwise noted (see <a href="#lexical-structure"><span style="display: none;" class="delete_version"><b>A.3 Lexical structure</b></span><span style="display: none;" class="add_version"><b>A.2 Lexical structure</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">3</span><span class="deltaxml-new">2</span> Lexical structure</b></span></a>), whitespace is not significant in <span class="xquery">queries</span>. Grammar productions are introduced together with the features that they describe, and a complete grammar is also presented in the appendix [<a href="#nt-bnf"><b>A XQuery 4.0 Grammar</b></a>]. The appendix is the normative version.</span></p><p>In the grammar productions in this document, named symbols are underlined and literal text is enclosed in double quotes. For example, the following productions describe the syntax of a static function call:</p><a id="d3e188"></a><a id="d3e199"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e189.doc-xquery40-FunctionCall"></a><a id="noid_d4e200.doc-xquery40-FunctionCall"></a>[<span class="deltaxml-old">175</span><span class="deltaxml-new">162</span>]&nbsp;&nbsp;&nbsp;</td><td><code>FunctionCall</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a><a href="#doc-xquery40-ArgumentList">ArgumentList</a></code></td><td><i>/* <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a> */</i></td></tr><tr style="vertical-align:baseline;"><td></td><td></td><td></td><td></td><td><i>/* <a href="#parse-note-parens">gn: parens</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e190.doc-xquery40-ArgumentList"></a><a id="noid_d4e201.doc-xquery40-ArgumentList"></a>[<span class="deltaxml-old">153</span><span class="deltaxml-new">142</span>]&nbsp;&nbsp;&nbsp;</td><td><code>ArgumentList</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"(" ((<a href="#doc-xquery40-PositionalArguments">PositionalArguments</a> ("," <a href="#prod-xquery40-KeywordArguments">KeywordArguments</a>)?) | <a href="#prod-xquery40-KeywordArguments">KeywordArguments</a>)? ")"</code></span><span style="display: none;" class="add_version"><code>"(" ((<a href="#doc-xquery40-PositionalArguments">PositionalArguments</a> ("," <a href="#doc-xquery40-KeywordArguments">KeywordArguments</a>)?) | <a href="#doc-xquery40-KeywordArguments">KeywordArguments</a>)? ")"</code></span><span class="modify_version"><code>"(" ((<a href="#doc-xquery40-PositionalArguments">PositionalArguments</a> ("," <a href="#doc-xquery40-KeywordArguments">KeywordArguments</a>)?) | <a href="#doc-xquery40-KeywordArguments">KeywordArguments</a>)? ")"</code></span></td><td></td></tr></tbody></table><p>The productions should be read as follows: A function call consists of an <a href="#doc-xquery40-EQName">EQName</a> followed by an <a href="#doc-xquery40-ArgumentList">ArgumentList</a>. The argument list consists of an opening parenthesis, an optional list of one or more arguments (separated by commas), and a closing parenthesis.</p><p>This document normatively defines the static and dynamic semantics of XQuery 4.0. In this document, examples and material labeled as <span class="deltaxml-old">“Note”</span><span class="deltaxml-new">"Note"</span> are provided for explanatory purposes and are not normative.</p><p>Certain aspects of language processing are described in this specification as <b>implementation-defined</b> or <b>implementation-dependent</b>.</p><ul><li><p> [<a id="dt-implementation-defined" title="implementation defined">Definition</a>: <b>Implementation-defined</b> indicates an aspect that may differ between implementations, but must be specified by the implementor for each particular implementation.] </p></li><li><p> [<a id="dt-implementation-dependent" title="implementation   dependent">Definition</a>: <b>Implementation-dependent</b> indicates an aspect that may differ between implementations, is not specified by this or any W3C specification, and is not required to be specified by the implementor for any particular implementation.] </p></li></ul></div><div class="div1"><h2><a id="id-basics"></a>2 Basics</h2><div class="div2"><h3><a id="id-terminology"></a>2.1 Terminology</h3><p>The basic building block of XQuery 4.0 is the <b>expression</b>, which is a string of <a href="#Unicode">[Unicode]</a> characters; the version of Unicode to be used is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The language provides several kinds of expressions which may be constructed from keywords, symbols, and operands. In general, the operands of an expression are other expressions. XQuery 4.0 allows expressions to be nested with full generality. <span class="xquery">(However, unlike a pure functional language, it does not allow variable substitution if the variable declaration contains construction of new nodes.)</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>This specification contains no assumptions or requirements regarding the character set encoding of strings of <a href="#Unicode">[Unicode]</a> characters.</p></div><p>Like XML, XQuery 4.0 is a case-sensitive language. Keywords in XQuery 4.0 use lower-case characters and are not reserved—that is, names in XQuery 4.0 expressions are allowed to be the same as language keywords, except for certain unprefixed function-names listed in <a href="#id-reserved-fn-names"><span style="display: none;" class="delete_version"><b>A.4 Reserved Function Names</b></span><span style="display: none;" class="add_version"><b>A.3 Reserved Function Names</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">4</span><span class="deltaxml-new">3</span> Reserved Function Names</b></span></a>.</p><div class="div3"><h4><a id="id-values"></a>2.1.1 Values</h4><p> [<a id="dt-value" title="value">Definition</a>: In the <a title="data model" class="termref" href="#dt-datamodel">data model</a>, a <b>value</b> is always a <a title="sequence" class="termref" href="#dt-sequence">sequence</a>.] </p><p> [<a id="dt-sequence" title="sequence">Definition</a>: A <b>sequence</b> is an ordered collection of zero or more <a title="item" class="termref" href="#dt-item">items</a>.] </p><p> [<a id="dt-item" title="item">Definition</a>: An <b>item</b> is either an <a title="atomic value" class="termref" href="#dt-atomic-value">atomic value</a>, a <a title="node" class="termref" href="#dt-node">node</a>, or a <a title="function item" class="termref" href="#dt-function-item">function item</a>.] </p><p> [<a id="dt-atomic-value" title="atomic value">Definition</a>: An <b>atomic value</b> is a value in the value space of an <b>atomic type</b>, as defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.] </p><p><span style="display: none;" class="delete_version"> [<a id="dt-node" title="node">Definition</a>: A <b>node</b> is an instance of one of the <b>node kinds</b> defined in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#Node">Section 5 Nodes</a><sup><small>DM40</small></sup>.] Each node has a unique <b>node identity</b>, a <b>typed value</b>, and a <b>string value</b>. In addition, some nodes have a <b>name</b>. The <b>typed value</b> of a node is a sequence of zero or more atomic values. The <b>string value</b> of a node is a value of type <code>xs:string</code>. The <b>name</b> of a node is a value of type <code>xs:QName</code>.</span><span style="display: none;" class="add_version"> [<a id="dt-node" title="node">Definition</a>: A <b>node</b> is an instance of one of the <b>node kinds</b> defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#Node">Section 6 Nodes </a><sup><small>DM31</small></sup>.] Each node has a unique <b>node identity</b>, a <b>typed value</b>, and a <b>string value</b>. In addition, some nodes have a <b>name</b>. The <b>typed value</b> of a node is a sequence of zero or more atomic values. The <b>string value</b> of a node is a value of type <code>xs:string</code>. The <b>name</b> of a node is a value of type <code>xs:QName</code>.</span><span class="modify_version"> [<a id="dt-node" title="node">Definition</a>: A <b>node</b> is an instance of one of the <b>node kinds</b> defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#Node">Section <span class="deltaxml-old">5</span><span class="deltaxml-new">6</span> Nodes<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>.] Each node has a unique <b>node identity</b>, a <b>typed value</b>, and a <b>string value</b>. In addition, some nodes have a <b>name</b>. The <b>typed value</b> of a node is a sequence of zero or more atomic values. The <b>string value</b> of a node is a value of type <code>xs:string</code>. The <b>name</b> of a node is a value of type <code>xs:QName</code>.</span></p><p> [<a id="dt-function-item" title="function item">Definition</a>: A <b>function item</b> is an item that can be called using a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a>.] </p><p>Maps (see <a href="#id-maps"><span style="display: none;" class="delete_version"><b>4.14.1 Maps</b></span><span style="display: none;" class="add_version"><b>4.13.1 Maps</b></span><span class="modify_version"><b><span class="deltaxml-old">4.14.1</span><span class="deltaxml-new">4.13.1</span> Maps</b></span></a>) and arrays (see <a href="#id-arrays"><span style="display: none;" class="delete_version"><b>4.14.2 Arrays</b></span><span style="display: none;" class="add_version"><b>4.13.2 Arrays</b></span><span class="modify_version"><b><span class="deltaxml-old">4.14.2</span><span class="deltaxml-new">4.13.2</span> Arrays</b></span></a>) are specific kinds of <a title="function item" class="termref" href="#dt-function-item">function item</a><span class="deltaxml-old">s</span>.</p><p> [<a id="dt-singleton" title="singleton">Definition</a>: A sequence containing exactly one item is called a <b>singleton</b>.] An item is identical to a singleton sequence containing that item. Sequences are never nested—for example, combining the values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2, 3). [<a id="dt-empty-sequence" title="empty sequence">Definition</a>: A sequence containing zero items is called an <b>empty sequence</b>.] </p><p> [<a id="dt-data-model-instance" title="XDM instance">Definition</a>: The term <b>XDM instance</b> is used, synonymously with the term <a title="value" class="termref" href="#dt-value">value</a>, to denote an unconstrained <a title="sequence" class="termref" href="#dt-sequence">sequence</a> of <a title="item" class="termref" href="#dt-item">items</a>.] </p><p>Element nodes have a property called <b>in-scope namespaces</b>. [<a id="dt-in-scope-namespaces" title="in-scope namespaces">Definition</a>: The <b>in-scope namespaces</b> property of an element node is a set of namespace bindings, each of which associates a namespace prefix with a URI.] For a given element, one namespace binding may have an empty prefix; the URI of this namespace binding is the default namespace within the scope of the element.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">In <a href="#xpath">[XML Path Language (XPath) Version 1.0]</a>, the in-scope namespaces of an element node are represented by a collection of <b>namespace nodes</b> arranged on a <b>namespace axis</b>, which is optional and deprecated in <a href="#xpath-40">[XPath 4.0]</a>. XQuery does not support the namespace axis and does not represent namespace bindings in the form of nodes.</span><span style="display: none;" class="add_version">In <a href="#xpath">[XML Path Language (XPath) Version 1.0]</a>, the in-scope namespaces of an element node are represented by a collection of <b>namespace nodes</b> arranged on a <b>namespace axis</b>, which is optional and deprecated in <a href="#xpath-31">[XML Path Language (XPath) Version 3.1]</a>. XQuery does not support the namespace axis and does not represent namespace bindings in the form of nodes.</span><span class="modify_version">In <a href="#xpath">[XML Path Language (XPath) Version 1.0]</a>, the in-scope namespaces of an element node are represented by a collection of <b>namespace nodes</b> arranged on a <b>namespace axis</b>, which is optional and deprecated in <a href="#xpath-40"><span class="deltaxml-old">[XPath 4.0]</span></a><a href="#xpath-31"><span class="deltaxml-new">[XML Path Language (XPath) Version 3.1]</span></a>. XQuery does not support the namespace axis and does not represent namespace bindings in the form of nodes.</span></p><p><span style="display: none;" class="delete_version">However, where other specifications such as <a href="#xslt-xquery-serialization-40">[XSLT and XQuery Serialization 4.0]</a> refer to namespace nodes, these nodes may be synthesized from the in-scope namespaces of an element node by interpreting each namespace binding as a namespace node. An application that needs to create a set of namespace nodes to represent these bindings for an element bound to <code>$e</code> can do so using the following code. </span><span style="display: none;" class="add_version">However, where other specifications such as <a href="#xslt-xquery-serialization-31">[XSLT and XQuery Serialization 3.1]</a> refer to namespace nodes, these nodes may be synthesized from the in-scope namespaces of an element node by interpreting each namespace binding as a namespace node. An application that needs to create a set of namespace nodes to represent these bindings for an element bound to <code>$e</code> can do so using the following code. </span><span class="modify_version">However, where other specifications such as <a href="#xslt-xquery-serialization-31">[XSLT and XQuery Serialization <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a> refer to namespace nodes, these nodes may be synthesized from the in-scope namespaces of an element node by interpreting each namespace binding as a namespace node. An application that needs to create a set of namespace nodes to represent these bindings for an element bound to <code>$e</code> can do so using the following code. </span></p><div class="exampleInner"><pre><span class="deltaxml-old">in-scope-prefixes($e) ! namespace {.}{ namespace-uri-for-prefix(., $e)}</span></pre><pre><span class="deltaxml-new">in-scope-prefixes($e) ! namespace {.}{ namespace-uri-for-prefix(., $e)} </span></pre></div></div></div><div class="div3"><h4><a id="id-namespaces-and-qnames"></a>2.1.2 Namespaces and QNames</h4><p><span style="display: none;" class="delete_version"> [<a id="dt-expanded-qname" title="expanded QName">Definition</a>: An <b>expanded QName</b> is a triple: its components are a prefix, a local name, and a namespace URI. In the case of a name in no namespace, the namespace URI and prefix are both absent. In the case of a name in the default namespace, the prefix is absent.] When comparing two expanded QNames, the prefixes are ignored: the local name parts must be equal under the Unicode codepoint collation (<a href="https://qt4cg.org/specifications/xpath-functions-40/#collations">Section 5.3.1 Collations</a><sup><small>FO40</small></sup>), and the namespace URI parts must either both be absent, or must be equal under the Unicode codepoint collation.</span><span style="display: none;" class="add_version"> [<a id="dt-expanded-qname" title="expanded QName">Definition</a>: An <b>expanded QName</b> is a triple: its components are a prefix, a local name, and a namespace URI. In the case of a name in no namespace, the namespace URI and prefix are both absent. In the case of a name in the default namespace, the prefix is absent.] When comparing two expanded QNames, the prefixes are ignored: the local name parts must be equal under the Unicode Codepoint Collation, and the namespace URI parts must either both be absent, or must be equal under the Unicode Codepoint Collation.</span><span class="modify_version"> [<a id="dt-expanded-qname" title="expanded QName">Definition</a>: An <b>expanded QName</b> is a triple: its components are a prefix, a local name, and a namespace URI. In the case of a name in no namespace, the namespace URI and prefix are both absent. In the case of a name in the default namespace, the prefix is absent.] When comparing two expanded QNames, the prefixes are ignored: the local name parts must be equal under the Unicode <span class="deltaxml-old">codepoint collation (</span><span class="deltaxml-new">Codepoint Collation</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#collations"><span class="deltaxml-old">Section 5.3.1 Collations</span></a><span class="deltaxml-old">FO40</span><span class="deltaxml-old">)</span>, and the namespace URI parts must either both be absent, or must be equal under the Unicode <span class="deltaxml-old">codepoint collation</span><span class="deltaxml-new">Codepoint Collation</span>.</span></p><p>In the XQuery 4.0 grammar, QNames representing the names of elements, attributes, functions, variables, types, or other such constructs are written as instances of the grammatical production <a href="#doc-xquery40-EQName">EQName</a>.</p><a id="d3e456"></a><a id="d3e465"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-EQName"></a>[<span class="deltaxml-old">266</span><span class="deltaxml-new">252</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-QName">QName</a> | <a href="#doc-xquery40-URIQualifiedName">URIQualifiedName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QName"></a>[<span class="deltaxml-old">286</span><span class="deltaxml-new">270</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-QName">QName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td><td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e437.doc-xquery40-NCName"></a><span class="deltaxml-new">[271]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">NCName</span></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName"><span class="deltaxml-new">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</span></a><sup><small><span class="deltaxml-new">Names</span></small></sup></code></td><td><i><span class="deltaxml-new">/* </span><a href="#parse-note-xml-version"><span class="deltaxml-new">xgc: xml-version</span></a><span class="deltaxml-new"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-URILiteral"></a>[<span class="deltaxml-old">265</span><span class="deltaxml-new">251</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-URILiteral">URILiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-StringLiteral">StringLiteral</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-URIQualifiedName"></a>[<span class="deltaxml-old">275</span><span class="deltaxml-new">259</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-BracedURILiteral">BracedURILiteral</a><a href="#prod-xquery40-NCName">NCName</a></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-BracedURILiteral"></a>[<span class="deltaxml-old">276</span><span class="deltaxml-new">260</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-BracedURILiteral">BracedURILiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"Q" "{" (<a href="#doc-xquery40-PredefinedEntityRef">PredefinedEntityRef</a> | <a href="#doc-xquery40-CharRef">CharRef</a> | [^&amp;{}])* "}"</code></span><span style="display: none;" class="add_version"><code>"Q" "{" (<a href="#doc-xquery40-PredefinedEntityRef">PredefinedEntityRef</a> | <a href="#prod-xquery40-CharRef">CharRef</a> | [^&amp;{}])* "}"</code></span><span class="modify_version"><code>"Q" "{" (<a href="#doc-xquery40-PredefinedEntityRef">PredefinedEntityRef</a> | <a href="#prod-xquery40-CharRef">CharRef</a> | [^&amp;{}])* "}"</code></span></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e431.doc-xquery40-NCName"></a><span class="deltaxml-old">[287]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">NCName</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName"><span class="deltaxml-old">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</span></a><sup><small><span class="deltaxml-old">Names</span></small></sup></code></td><td><i><span class="deltaxml-old">/* </span><a href="#parse-note-xml-version"><span class="deltaxml-old">xgc: xml-version</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody></table><p>The <a href="#doc-xquery40-EQName">EQName</a> production allows a QName to be written in one of three ways: </p><ul><li><p>local-name only (for example, <code>invoice</code>).</p><p>A name written in this form has no prefix, and the rules for determining the namespace depend on the context in which the name appears. This form is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>.</p></li><li><p>prefix plus local-name (for example, <code>my:invoice</code>).</p><p>In this case the prefix and local name of the QName are as written, and the namespace URI is inferred from the prefix by examining the in-scope namespaces in the static context where the QName appears; the context must include a binding for the prefix. This form is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>.</p></li><li><p><span style="display: none;" class="delete_version">URI plus local-name (for example, <code>Q{http://example.com/ns}invoice</code>).</span><span style="display: none;" class="add_version">URI plus local-name (for example, <code>Q{http://example.com/ns}invoice)</code>.</span><span class="modify_version">URI plus local-name (for example, <code>Q{http://example.com/ns}invoice)</code>.</span></p><p>In this case the local name and namespace URI are as written, and the prefix is absent. This way of writing a QName is context-free, which makes it particularly suitable for use in <span class="xquery">queries</span> that are generated by software. This form is a <a href="#doc-xquery40-URIQualifiedName">URIQualifiedName</a>. If the <a href="#doc-xquery40-BracedURILiteral"> BracedURILiteral</a> has no content (for example, <code>Q{}invoice</code>) then the namespace URI of the QName is absent.</p></li></ul><p> [<a id="dt-qname" title="lexical QName">Definition</a>: A <b>lexical QName</b> is a name that conforms to the syntax of the <a href="#doc-xquery40-QName">QName</a> production]. </p><p> The namespace URI value in a <a href="#doc-xquery40-URIQualifiedName">URIQualifiedName</a> is whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <a href="https://www.w3.org/TR/xmlschema-2/#anyURI">Section 3.2.17 anyURI </a><sup><small>XS1-2</small></sup> or <a href="https://www.w3.org/TR/xmlschema11-2/#anyURI">Section 3.3.17 anyURI </a><sup><small>XS11-2</small></sup>. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>] if the namespace URI for an EQName is <code>http://www.w3.org/2000/xmlns/</code>. </p><p>Here are some examples of <a href="#doc-xquery40-EQName">EQName</a>s:</p><ul><li><p><code>pi</code> is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> without a namespace prefix.</p></li><li><p><code>math:pi</code> is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> with a namespace prefix.</p></li><li><p><code>Q{http://www.w3.org/2005/xpath-functions/math}pi</code> specifies the namespace URI using a <a href="#doc-xquery40-BracedURILiteral">BracedURILiteral</a>; it is not a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>.</p></li></ul><p>This document uses the following namespace prefixes to represent the namespace URIs with which they are listed. Although these prefixes are used within this specification to refer to the corresponding namespaces, not all of these bindings will necessarily be present in the static context of every expression, and authors are free to use different prefixes for these namespaces, or to bind these prefixes to different namespaces.</p><ul><li class="xquery"><p><span style="display: none;" class="delete_version"><code>xml</code>: <code>http://www.w3.org/XML/1998/namespace</code></span><span style="display: none;" class="add_version"><code>xml = http://www.w3.org/XML/1998/namespace</code></span><span class="modify_version"><code>xml<span class="deltaxml-old">:</span> <span class="deltaxml-new">= </span>http://www.w3.org/XML/1998/namespace</code></span></p></li><li><p><span style="display: none;" class="delete_version"><code>xs</code>: <code>http://www.w3.org/2001/XMLSchema</code></span><span style="display: none;" class="add_version"><code>xs = http://www.w3.org/2001/XMLSchema</code></span><span class="modify_version"><code>xs<span class="deltaxml-old">:</span> <span class="deltaxml-new">= </span>http://www.w3.org/2001/XMLSchema</code></span></p></li><li class="xquery"><p><span style="display: none;" class="delete_version"><code>xsi</code>: <code>http://www.w3.org/2001/XMLSchema-instance</code></span><span style="display: none;" class="add_version"><code>xsi = http://www.w3.org/2001/XMLSchema-instance</code></span><span class="modify_version"><code>xsi<span class="deltaxml-old">:</span> <span class="deltaxml-new">= </span>http://www.w3.org/2001/XMLSchema-instance</code></span></p></li><li><p><span style="display: none;" class="delete_version"><code>fn</code>: <code>http://www.w3.org/2005/xpath-functions</code></span><span style="display: none;" class="add_version"><code>fn = http://www.w3.org/2005/xpath-functions</code></span><span class="modify_version"><code>fn<span class="deltaxml-old">:</span> <span class="deltaxml-new">= </span>http://www.w3.org/2005/xpath-functions</code></span></p></li><li class="delete_version" style="display: none;"><p><code>array</code>: <code>http://www.w3.org/2005/xpath-functions/array</code></p></li><li class="modify_version"><p><code><span class="deltaxml-old">array</span></code><span class="deltaxml-old">: </span><code><span class="deltaxml-old">http://www.w3.org/2005/xpath-functions/array</span></code></p></li><li><p><span style="display: none;" class="delete_version"><code>map</code>: <code>http://www.w3.org/2005/xpath-functions/map</code></span><span style="display: none;" class="add_version"><code>map = http://www.w3.org/2005/xpath-functions/map</code></span><span class="modify_version"><code>map<span class="deltaxml-old">:</span> <span class="deltaxml-new">= </span>http://www.w3.org/2005/xpath-functions/map</code></span></p></li><li><p><span style="display: none;" class="delete_version"><code>math</code>: <code>http://www.w3.org/2005/xpath-functions/math</code></span><span style="display: none;" class="add_version"><code>array = http://www.w3.org/2005/xpath-functions/array</code></span><span class="modify_version"><code><span class="deltaxml-old">math</span><span class="deltaxml-new">array</span><span class="deltaxml-old">:</span> <span class="deltaxml-new">= </span>http://www.w3.org/2005/xpath-functions/<span class="deltaxml-old">math</span><span class="deltaxml-new">array</span></code></span></p></li><li><p><code><span class="deltaxml-old">err</span></code><span class="deltaxml-old">: </span><code><span class="deltaxml-old">http://www.w3.org/2005/xqt-errors</span></code><span class="deltaxml-old"> (see </span><a href="#id-identifying-errors"><b><span class="deltaxml-old">2.4.2 Identifying and Reporting Errors</span></b></a><span class="deltaxml-old">).</span></p><p><code><span class="deltaxml-new">math = http://www.w3.org/2005/xpath-functions/math</span></code></p></li><li class="xquery"><p><span style="display: none;" class="delete_version"><code>local</code>: <code>http://www.w3.org/2005/xquery-local-functions</code> (see <a href="#FunctionDeclns"><span class="delete_version"><b>5.18 Function Declarations</b></span><span class="modify_version"><b>5.18 Function Declarations</b></span></a>.) </span><span style="display: none;" class="add_version"><code>local = http://www.w3.org/2005/xquery-local-functions</code> (see <a href="#FunctionDeclns"><span class="add_version"><b>5.18 Function Declaration</b></span><span class="modify_version"><b>5.18 Function Declaration</b></span></a>.)</span><span class="modify_version"><code>local<span class="deltaxml-old">:</span> <span class="deltaxml-new">= </span>http://www.w3.org/2005/xquery-local-functions</code> (see <a href="#FunctionDeclns"><span style="display: none;" class="delete_version"><b>5.18 Function Declarations</b></span><span style="display: none;" class="add_version"><b>5.18 Function Declaration</b></span><span class="modify_version"><b>5.18 Function <span class="deltaxml-old">Declarations</span><span class="deltaxml-new">Declaration</span></b></span></a>.)<span class="deltaxml-old"> </span></span></p></li><li class="delete_version" style="display: none;"><p><code>output</code>: <code>http://www.w3.org/2010/xslt-xquery-serialization</code></p></li><li class="modify_version"><p><code><span class="deltaxml-old">output</span></code><span class="deltaxml-old">: </span><code><span class="deltaxml-old">http://www.w3.org/2010/xslt-xquery-serialization</span></code></p></li><li class="delete_version" style="display: none;"><p><code>xq</code>: <code>http://www.w3.org/2012/xquery</code></p></li><li class="xquery"><p><code><span class="deltaxml-old">xq</span></code><span class="deltaxml-old">: </span><code><span class="deltaxml-old">http://www.w3.org/2012/xquery</span></code></p></li></ul><p class="xquery"><span class="deltaxml-new">In addition to the prefixes in the above list, this document uses the prefix </span><code><span class="deltaxml-new">err</span></code><span class="deltaxml-new"> to represent the namespace URI </span><code><span class="deltaxml-new">http://www.w3.org/2005/xqt-errors</span></code><span class="deltaxml-new"> (see </span><a href="#id-identifying-errors"><b><span class="deltaxml-new">2.4.2 Identifying and Reporting Errors</span></b></a><span class="deltaxml-new">). This namespace prefix is not predeclared and its use in this document is not normative. It also uses the namespace URI </span><code><span class="deltaxml-new">http://www.w3.org/2012/xquery</span></code><span class="deltaxml-new"> for which no prefix is used in this document, which is reserved for use in this specification. It is currently used for annotations and option declarations that are defined by the XML Query Working Group.</span></p><p><span style="display: none;" class="delete_version"> [<a id="dt-URI" title="URI">Definition</a>: Within this specification, the term <b>URI</b> refers to a Universal Resource Identifier as defined in <a href="#RFC3986">[RFC3986]</a> and extended in <a href="#RFC3987">[RFC3987]</a> with the new name <b>IRI</b>.] The term URI has been retained in preference to IRI to avoid introducing new names for concepts such as “Base URI” that are defined or referenced across the whole family of XML specifications.</span><span style="display: none;" class="add_version"> [<a id="dt-URI" title="URI">Definition</a>: Within this specification, the term <b>URI</b> refers to a Universal Resource Identifier as defined in <a href="#RFC3986">[RFC3986]</a> and extended in <a href="#RFC3987">[RFC3987]</a> with the new name <b>IRI</b>.] The term URI has been retained in preference to IRI to avoid introducing new names for concepts such as "Base URI" that are defined or referenced across the whole family of XML specifications.</span><span class="modify_version"> [<a id="dt-URI" title="URI">Definition</a>: Within this specification, the term <b>URI</b> refers to a Universal Resource Identifier as defined in <a href="#RFC3986">[RFC3986]</a> and extended in <a href="#RFC3987">[RFC3987]</a> with the new name <b>IRI</b>.] The term URI has been retained in preference to IRI to avoid introducing new names for concepts such as <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>Base URI<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> that are defined or referenced across the whole family of XML specifications.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">In most contexts, processors are not required to raise errors if a URI is not lexically valid according to <a href="#RFC3986">[RFC3986]</a> and <a href="#RFC3987">[RFC3987]</a>. See <a href="#id-uri-literals"><b>2.5.5 URI Literals</b></a><span class="xquery">and <a href="#id-namespaces"><span class="delete_version"><b>4.13.1.2 Namespace Declaration Attributes</b></span><span class="modify_version"><b>4.13.1.2 Namespace Declaration Attributes</b></span></a></span> for details.</span><span style="display: none;" class="add_version">In most contexts, processors are not required to raise errors if a URI is not lexically valid according to <a href="#RFC3986">[RFC3986]</a> and <a href="#RFC3987">[RFC3987]</a>. See <a href="#id-uri-literals"><b>2.5.5 URI Literals</b></a><span class="xquery">and <a href="#id-namespaces"><span class="add_version"><b>4.12.1.2 Namespace Declaration Attributes</b></span><span class="modify_version"><b>4.12.1.2 Namespace Declaration Attributes</b></span></a></span> for details.</span><span class="modify_version">In most contexts, processors are not required to raise errors if a URI is not lexically valid according to <a href="#RFC3986">[RFC3986]</a> and <a href="#RFC3987">[RFC3987]</a>. See <a href="#id-uri-literals"><b>2.5.5 URI Literals</b></a><span class="xquery">and <a href="#id-namespaces"><span style="display: none;" class="delete_version"><b>4.13.1.2 Namespace Declaration Attributes</b></span><span style="display: none;" class="add_version"><b>4.12.1.2 Namespace Declaration Attributes</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1.2</span><span class="deltaxml-new">4.12.1.2</span> Namespace Declaration Attributes</b></span></a></span> for details.</span></p></div></div></div><div class="div2"><h3><a id="context"></a>2.2 <span class="xquery">Module Context and </span>Expression Context</h3><p> [<a id="dt-expression-context" title="expression context">Definition</a>: The <b>expression context</b> for a given expression consists of all the information that can affect the result of the expression.] </p><p class="xquery"><span style="display: none;" class="delete_version"> [<a id="dt-module-context" title="module context">Definition</a>: The <b>module context</b> for a given module consists of all the information that is accessible to top-level expressions in the module.] The context of a top-level expression is defined based on the context of the module in which it is defined: the context of the <a href="#doc-xquery40-QueryBody">QueryBody</a> is the context of the main module, and the context for evaluating a function body or for a variable’s initializing expression is defined based on the context of the module in which the function or variable is defined.</span><span style="display: none;" class="add_version"> [<a id="dt-module-context" title="module context">Definition</a>: The <b>module context</b> for a given module consists of all the information that is accessible to top-level expressions in the module.] The context of a top-level expression is defined based on the context of the module in which it is defined: the context of the <a href="#doc-xquery40-QueryBody">QueryBody</a> is the context of the main module, and the context for evaluating a function body or for a variable's initializing expression is defined based on the context of the module in which the function or variable is defined.</span><span class="modify_version"> [<a id="dt-module-context" title="module context">Definition</a>: The <b>module context</b> for a given module consists of all the information that is accessible to top-level expressions in the module.] The context of a top-level expression is defined based on the context of the module in which it is defined: the context of the <a href="#doc-xquery40-QueryBody">QueryBody</a> is the context of the main module, and the context for evaluating a function body or for a <span class="deltaxml-old">variable’s</span><span class="deltaxml-new">variable's</span> initializing expression is defined based on the context of the module in which the function or variable is defined.</span></p><p>This information is organized into two categories called the <a title="static context" class="termref" href="#dt-static-context">static context</a> and the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a>.</p><div class="div3"><h4><a id="static_context"></a>2.2.1 Static Context</h4><p> [<a id="dt-static-context" title="static context">Definition</a>: The <b>static context</b> of an expression is the information that is available during static analysis of the expression, prior to its evaluation.] This information can be used to decide whether the expression contains a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p><p>The individual components of the <a title="static context" class="termref" href="#dt-static-context">static context</a> are described below. <span class="xquery">Rules governing the initialization and alteration of these components can be found in <a href="#id-xq-static-context-components"><b>C.1 Static Context Components</b></a>.</span></p><ul><li><p> [<a id="dt-xpath-compat-mode" title="XPath 1.0 compatibility     mode">Definition</a>: <b>XPath 1.0 compatibility mode.</b><span class="xquery">This component must be set by all host languages that include XPath 3.1 as a subset, indicating whether rules for compatibility with XPath 1.0 are in effect. XQuery sets the value of this component to <code>false</code>. </span> ] </p></li><li><p> [<a id="dt-static-namespaces" title="statically known namespaces">Definition</a>: <b>Statically known namespaces.</b> This is a mapping from prefix to namespace URI that defines all the namespaces that are known during static processing of a given expression.] </p><p>The URI value is whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <a href="https://www.w3.org/TR/xmlschema-2/#anyURI">Section 3.2.17 anyURI </a><sup><small>XS1-2</small></sup> or <a href="https://www.w3.org/TR/xmlschema11-2/#anyURI">Section 3.3.17 anyURI </a><sup><small>XS11-2</small></sup>.</p><p>The statically known namespaces may include a binding for the zero-length prefix; however, this is <span class="deltaxml-old">used </span>only <span class="deltaxml-new">used </span>in limited circumstances because the rules for resolving unprefixed QNames depend on <span class="deltaxml-new">the </span>how such a name is used.</p><p>Note the difference between <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a>, which is a dynamic property of an element node, and <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>, which is a static property of an expression.</p><p class="xquery">Some namespaces are predefined; additional namespaces can be added to the statically known namespaces by <a title="namespace declaration" class="termref" href="#dt-namespace-declaration">namespace declarations</a>, <a title="schema import" class="termref" href="#dt-schema-import">schema imports</a>, or <a title="module import" class="termref" href="#dt-module-import">module imports</a> in a <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a>, by a <a title="module declaration" class="termref" href="#dt-module-declaration">module declaration</a>, and by <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> in <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructors</a>.</p></li><li><p><span class="deltaxml-old"> [</span><a id="dt-default-namespace-elements-and-types" title="default namespace for elements and types"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: </span><b><span class="deltaxml-old">Default namespace for elements and types.</span></b><span class="deltaxml-old"> This is a namespace URI, or </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-old">absent</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">. This indicates how unprefixed QNames are interpreted when they appear in a position where an element name or type name is expected.] </span></p><ul><li><p><span class="deltaxml-old">If the value is set to a namespace URI, this namespace is used for any such unprefixed QName. The URI value is whitespace-normalized according to the rules for the </span><code><span class="deltaxml-old">xs:anyURI</span></code><span class="deltaxml-old"> type in </span><a href="https://www.w3.org/TR/xmlschema-2/#anyURI"><span class="deltaxml-old">Section 3.2.17 anyURI </span></a><sup><small><span class="deltaxml-old">XS1-2</span></small></sup><span class="deltaxml-old"> or </span><a href="https://www.w3.org/TR/xmlschema11-2/#anyURI"><span class="deltaxml-old">Section 3.3.17 anyURI </span></a><sup><small><span class="deltaxml-old">XS11-2</span></small></sup><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">If the value is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-old">absent</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">, an unprefixed QName representing an element or type name is interpreted as being in no namespace.</span></p></li></ul><p><span class="deltaxml-new"> [</span><a id="dt-def-element-ns" title="default element namespace"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: </span><b><span class="deltaxml-new">Default element namespace.</span></b><span class="deltaxml-new"> This is a namespace URI or </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent"><span class="deltaxml-new">absent</span></a><sup><small><span class="deltaxml-new">DM31</span></small></sup><span class="deltaxml-new">. The namespace URI, if present, is used for any unprefixed QName appearing in a position where an element name is expected.] The URI value is whitespace normalized according to the rules for the </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new"> type in </span><a href="https://www.w3.org/TR/xmlschema-2/#anyURI"><span class="deltaxml-new">Section 3.2.17 anyURI </span></a><sup><small><span class="deltaxml-new">XS1-2</span></small></sup><span class="deltaxml-new"> or </span><a href="https://www.w3.org/TR/xmlschema11-2/#anyURI"><span class="deltaxml-new">Section 3.3.17 anyURI </span></a><sup><small><span class="deltaxml-new">XS11-2</span></small></sup><span class="deltaxml-new">.</span></p></li><li class="add_version" style="display: none;"><p> [<a id="dt-def-type-ns" title="default type namespace">Definition</a>: <b>Default type namespace.</b> This is a namespace URI or <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. The namespace URI, if present, is used for any unprefixed QName appearing in a position where a type name is expected.] The URI value is whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <a href="https://www.w3.org/TR/xmlschema-2/#anyURI">Section 3.2.17 anyURI </a><sup><small>XS1-2</small></sup> or <a href="https://www.w3.org/TR/xmlschema11-2/#anyURI">Section 3.3.17 anyURI </a><sup><small>XS11-2</small></sup>.</p></li><li class="modify_version"><p><span class="deltaxml-new"> [</span><a id="dt-def-type-ns" title="default type namespace"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: </span><b><span class="deltaxml-new">Default type namespace.</span></b><span class="deltaxml-new"> This is a namespace URI or </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent"><span class="deltaxml-new">absent</span></a><sup><small><span class="deltaxml-new">DM31</span></small></sup><span class="deltaxml-new">. The namespace URI, if present, is used for any unprefixed QName appearing in a position where a type name is expected.] The URI value is whitespace normalized according to the rules for the </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new"> type in </span><a href="https://www.w3.org/TR/xmlschema-2/#anyURI"><span class="deltaxml-new">Section 3.2.17 anyURI </span></a><sup><small><span class="deltaxml-new">XS1-2</span></small></sup><span class="deltaxml-new"> or </span><a href="https://www.w3.org/TR/xmlschema11-2/#anyURI"><span class="deltaxml-new">Section 3.3.17 anyURI </span></a><sup><small><span class="deltaxml-new">XS11-2</span></small></sup><span class="deltaxml-new">.</span></p></li><li><p><span style="display: none;" class="delete_version"> [<a id="dt-default-function-namespace" title="default function namespace">Definition</a>: <b>Default function namespace.</b> This is either a namespace URI, or <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>. The namespace URI, if present, is used for any unprefixed QName appearing in a position where a function name is expected.] The URI value is whitespace-normalized according to the rules for the <code>xs:anyURI</code> type in <a href="https://www.w3.org/TR/xmlschema-2/#anyURI">Section 3.2.17 anyURI </a><sup><small>XS1-2</small></sup> or <a href="https://www.w3.org/TR/xmlschema11-2/#anyURI">Section 3.3.17 anyURI </a><sup><small>XS11-2</small></sup></span><span style="display: none;" class="add_version"> [<a id="dt-default-function-namespace" title="default function namespace">Definition</a>: <b>Default function namespace.</b> This is either a namespace URI, or <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. The namespace URI, if present, is used for any unprefixed QName appearing in a position where a function name is expected.] The URI value is whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <a href="https://www.w3.org/TR/xmlschema-2/#anyURI">Section 3.2.17 anyURI </a><sup><small>XS1-2</small></sup> or <a href="https://www.w3.org/TR/xmlschema11-2/#anyURI">Section 3.3.17 anyURI </a><sup><small>XS11-2</small></sup></span><span class="modify_version"> [<a id="dt-default-function-namespace" title="default function namespace">Definition</a>: <b>Default function namespace.</b> This is either a namespace URI, or <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>. The namespace URI, if present, is used for any unprefixed QName appearing in a position where a function name is expected.] The URI value is whitespace<span class="deltaxml-old">-</span><span class="deltaxml-new"> </span>normalized according to the rules for the <code>xs:anyURI</code> type in <a href="https://www.w3.org/TR/xmlschema-2/#anyURI">Section 3.2.17 anyURI </a><sup><small>XS1-2</small></sup> or <a href="https://www.w3.org/TR/xmlschema11-2/#anyURI">Section 3.3.17 anyURI </a><sup><small>XS11-2</small></sup></span></p><p> In its simplest form its value is simply a whitespace-normalized <code>xs:anyURI</code> value (most commonly, the URI <code>http://www.w3.org/2005/xpath-functions</code>) to be used as the default namespace for unprefixed function names. However, the use of a more complex algorithm is not precluded, for example an algorithm which searches multiple namespaces for a matching name. </p><p class="xquery"> In XQuery, a default function namespace can be declared in the prolog in a <b>default function namespace declaration</b> (see <a href="#id-default-namespace"><b>5.14 Default Namespace Declaration</b></a>); in the absence of such a declaration, the namespace <code>http://www.w3.org/2005/xpath-functions</code> is used.</p></li><li><p><span style="display: none;" class="delete_version"> [<a id="dt-issd" title="in-scope schema definitions">Definition</a>: <b>In-scope schema definitions</b> is a generic term for all the element declarations, attribute declarations, and schema type definitions that are in scope during static analysis of an expression.] It includes the following three parts:</span><span style="display: none;" class="add_version"> [<a id="dt-issd" title="in-scope schema definitions">Definition</a>: <b>In-scope schema definitions.</b> This is a generic term for all the element declarations, attribute declarations, and schema type definitions that are in scope during static analysis of an expression.] It includes the following three parts:</span><span class="modify_version"> [<a id="dt-issd" title="in-scope schema definitions">Definition</a>: <b>In-scope schema definitions<span class="deltaxml-new">.</span></b> <span class="deltaxml-new">This </span>is a generic term for all the element declarations, attribute declarations, and schema type definitions that are in scope during static analysis of an expression.] It includes the following three parts:</span></p><ul><li><p> [<a id="dt-is-types" title="in-scope schema type">Definition</a>: <b>In-scope schema types.</b> Each schema type definition is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a <b>named type</b>) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> type identifier (for an <b>anonymous type</b>). The in-scope schema types include the predefined schema types described in <a href="#id-predefined-types"><b>3.1 Predefined Schema Types</b></a>. <span class="xquery">If the <a title="schema aware feature" class="termref" href="#dt-schema-aware-feature">Schema Aware Feature</a> is supported, in-scope schema types also include all type definitions found in imported schemas.</span> ] </p></li><li><p><span style="display: none;" class="delete_version"> [<a id="dt-is-elems" title="in-scope element declarations">Definition</a>: <b>In-scope element declarations.</b> Each element declaration is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a top-level element declaration) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> element identifier (for a local element declaration). <span class="xquery"> If the <a title="schema aware feature" class="termref" href="#dt-schema-aware-feature">Schema Aware Feature</a> is supported, in-scope element declarations include all element declarations found in imported schemas. </span> ] An element declaration includes information about the element’s <a title="substitution group" class="termref" href="#dt-substitution-group">substitution group</a> affiliation.</span><span style="display: none;" class="add_version"> [<a id="dt-is-elems" title="in-scope element declarations">Definition</a>: <b>In-scope element declarations.</b> Each element declaration is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a top-level element declaration) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> element identifier (for a local element declaration). <span class="xquery"> If the <a title="schema aware feature" class="termref" href="#dt-schema-aware-feature">Schema Aware Feature</a> is supported, in-scope element declarations include all element declarations found in imported schemas. </span> ] An element declaration includes information about the element's <a title="substitution group" class="termref" href="#dt-substitution-group">substitution group</a> affiliation.</span><span class="modify_version"> [<a id="dt-is-elems" title="in-scope element declarations">Definition</a>: <b>In-scope element declarations.</b> Each element declaration is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a top-level element declaration) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> element identifier (for a local element declaration). <span class="xquery"> If the <a title="schema aware feature" class="termref" href="#dt-schema-aware-feature">Schema Aware Feature</a> is supported, in-scope element declarations include all element declarations found in imported schemas. </span> ] An element declaration includes information about the <span class="deltaxml-old">element’s</span><span class="deltaxml-new">element's</span> <a title="substitution group" class="termref" href="#dt-substitution-group">substitution group</a> affiliation.</span></p><p> [<a id="dt-substitution-group" title="substitution group">Definition</a>: <b>Substitution groups</b> are defined in <a href="https://www.w3.org/TR/xmlschema-1/#Element_Equivalence_Class">Section 2.2.2.2 Element Substitution Group </a><sup><small>XS1-1</small></sup> and <a href="https://www.w3.org/TR/xmlschema11-1/#Element_Equivalence_Class">Section 2.2.2.2 Element Substitution Group </a><sup><small>XS11-1</small></sup>. Informally, the substitution group headed by a given element (called the <b>head element</b>) consists of the set of elements that can be substituted for the head element without affecting the outcome of schema validation.] </p></li><li><p> [<a id="dt-is-attrs" title="in-scope attribute declarations">Definition</a>: <b>In-scope attribute declarations.</b> Each attribute declaration is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a top-level attribute declaration) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> attribute identifier (for a local attribute declaration). <span class="xquery">If the <a title="schema aware feature" class="termref" href="#dt-schema-aware-feature">Schema Aware Feature</a> is supported, in-scope attribute declarations include all attribute declarations found in imported schemas.</span> ] </p></li></ul></li><li><p> [<a id="dt-in-scope-variables" title="in-scope variables">Definition</a>: <b>In-scope variables.</b> This is a mapping from <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> to type. It defines the set of variables that are available for reference within an expression. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is the name of the variable, and the type is the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the variable.] </p><p><span class="xquery">Variable declarations in a <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> are added to <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a>.</span> An expression that binds a variable extends the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a>, within the scope of the variable, with the variable and its type. Within the body of an <a title="inline function expression" class="termref" href="#dt-inline-func">inline function expression</a><span class="xquery"> or <a title="user-defined function" class="termref" href="#dt-udf">user-defined function</a></span>, the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> are extended by the names and types of the <b>function parameters</b>.</p><p class="xquery">The static type of a variable may either be declared in a query or inferred by static type inference as discussed in <a href="#id-static-analysis"><b>2.3.3.1 Static Analysis Phase</b></a>.</p></li><li><p><span style="display: none;" class="delete_version"> [<a id="dt-context-value-static-type" title="context value static type">Definition</a>: <b>Context value static type.</b> This is a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>; it defines the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the <a title="context value" class="termref" href="#dt-context-value">context value</a> within the scope of a given expression.] </span><span style="display: none;" class="add_version"> [<a id="dt-context-item-static-type" title="context item static type">Definition</a>: <b>Context item static type.</b> This component defines the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the context item within the scope of a given expression.] </span><span class="modify_version"> [<a id="dt-context-value-static-type" title="context value static type"><span class="deltaxml-old">Definition</span></a><a id="dt-context-item-static-type" title="context item static type"><span class="deltaxml-new">Definition</span></a>: <b>Context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> static type.</b> This <span class="deltaxml-old">is a</span><span class="deltaxml-new">component</span> <a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-old">sequence type</span></a><span class="deltaxml-old">; it </span>defines the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the <a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-old">context value</span></a><span class="deltaxml-new">context item</span> within the scope of a given expression.] </span></p></li><li><p><span style="display: none;" class="delete_version"> [<a id="dt-in-scope-named-item-types" title="in-scope named item types">Definition</a>: <b>In-scope named item types.</b> This is a mapping from <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> to <a title="named item type" class="termref" href="#dt-named-item-type">named item types</a>.] </span><span style="display: none;" class="add_version"> [<a id="dt-item-type-aliases" title="item type aliases">Definition</a>: <b>Item type aliases.</b> This is a mapping from <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> to <code>ItemTypes</code>.] </span><span class="modify_version"> [<a id="dt-in-scope-named-item-types" title="in-scope named item types"><span class="deltaxml-old">Definition</span></a><a id="dt-item-type-aliases" title="item type aliases"><span class="deltaxml-new">Definition</span></a>: <b><span class="deltaxml-old">In-scope named item types</span><span class="deltaxml-new">Item type aliases</span>.</b> This is a mapping from <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> to <a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-old">named item types</span></a><code><span class="deltaxml-new">ItemTypes</span></code>.] </span></p><p><span class="deltaxml-old"> [</span><a id="dt-named-item-type" title="named item type"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">named item type</span></b><span class="deltaxml-old"> is an </span><code><span class="deltaxml-old">ItemType</span></code><span class="deltaxml-old"> identified by an </span><a class="termref" title="expanded QName" href="#dt-expanded-qname"><span class="deltaxml-old">expanded QName</span></a><span class="deltaxml-old">.] </span></p><p><span class="deltaxml-old">Named item types serve two purposes:</span></p><ul><li><p><span class="deltaxml-old">They allow frequently used item types, especially complex item types such as record types, to be given simple names, to avoid repeating the definition every time it is used.</span></p></li><li><p><span class="deltaxml-old">They allow the definition of recursive types, which are useful for describing recursive data structures such as lists and trees. For details see </span><a href="#id-recursive-record-tests"><b><span class="deltaxml-old">3.6.4.4 Recursive Record Tests</span></b></a><span class="deltaxml-old">. </span></p></li></ul><p><span class="deltaxml-new"> [</span><a id="dt-type-alias" title="type alias"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: A </span><b><span class="deltaxml-new">type alias</span></b><span class="deltaxml-new"> is an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new">expanded QName</span></a><span class="deltaxml-new"> that is mapped to an </span><code><span class="deltaxml-new">ItemType</span></code><span class="deltaxml-new"> in the </span><a title="item type aliases" class="termref" href="#dt-item-type-aliases"><span class="deltaxml-new">item type aliases</span></a><span class="deltaxml-new"> of the </span><a class="termref" title="static context" href="#dt-static-context"><span class="deltaxml-new">static context</span></a><span class="deltaxml-new">.] </span></p><p><span class="deltaxml-new">Item type aliases allow frequently used item types, especially complex item types such as record types, to be given simple names, so that the definition of the type is not repeated every time it is used.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p class="xquery">In XQuery, named item types can be declared in the Query Prolog.</p></div></li><li><p> [<a id="dt-statically-known-function-definitions" title="statically known function definitions">Definition</a>: <b>Statically known function definitions.</b> This is a set of <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a>.] </p><p> [<a id="dt-function-definition" title="function definition">Definition</a>: A <b>function definition</b> contains information used to evaluate a static function call, including the name, parameters, and return type of the function.] </p><p>The properties of a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> include:</p><ul><li><p>The function category, which is one of application, system, or external:</p><ul><li><p><span style="display: none;" class="delete_version"> [<a id="dt-application-function" title="application function">Definition</a>: <b>Application functions</b> are function definitions written in a host language such as XQuery or XSLT whose syntax and semantics are defined in this family of specifications. Their behavior (including the rules determining the static and dynamic context) follows the rules for such functions in the relevant host language specification.] The most common application functions are functions written by users in XQuery or XSLT. </span><span style="display: none;" class="add_version"> [<a id="dt-application-function" title="application function">Definition</a>: <b>Application functions</b> are function definitions written in a host language such as XQuery or XSLT whose semantics are defined in this family of specifications. Their behavior (including the rules determining the static and dynamic context) follows the rules for such functions in the relevant host language specification.] </span><span class="modify_version"> [<a id="dt-application-function" title="application function">Definition</a>: <b>Application functions</b> are function definitions written in a host language such as XQuery or XSLT whose <span class="deltaxml-old">syntax and </span>semantics are defined in this family of specifications. Their behavior (including the rules determining the static and dynamic context) follows the rules for such functions in the relevant host language specification.] <span class="deltaxml-old">The most common application functions are functions written by users in XQuery or XSLT. </span></span></p></li><li><p><span style="display: none;" class="delete_version"> [<a id="dt-system-function" title="system function">Definition</a>: <b>System functions</b> include the functions defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>, functions defined by the specifications of a host language, <a title="constructor function" class="termref" href="#dt-constructor-function">constructor functions</a> for atomic types, and any additional functions provided by the implementation. System functions are sometimes called built-in functions.] </span><span style="display: none;" class="add_version"> [<a id="dt-system-function" title="system function">Definition</a>: <b>System functions</b> include the functions defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a> and may also include additional functions provided by the implementation.] </span><span class="modify_version"> [<a id="dt-system-function" title="system function">Definition</a>: <b>System functions</b> include the functions defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a><span class="deltaxml-old">, functions defined by the specifications of a host language,</span> <a title="constructor function" class="termref" href="#dt-constructor-function"><span class="deltaxml-old">constructor functions</span></a><span class="deltaxml-old"> for atomic types, and any</span><span class="deltaxml-new">and may also include</span> additional functions provided by the implementation.<span class="deltaxml-old"> System functions are sometimes called built-in functions.</span>] </span></p><p><span style="display: none;" class="delete_version">The behavior of system functions follows the rules given for the individual function in this family of specifications, or in the specification of the particular processor implementation. A system function may have behavior that depends on the static or dynamic context of the caller (for example, comparing strings using the default collation from the <span>dynamic</span> context of the caller). Such functions are said to be <a title="context dependent" class="termref" href="#dt-context-dependent">context dependent</a>.</span><span style="display: none;" class="add_version">The behavior of system functions follows the rules given for the individual function in this family of specifications, or in the specification of the particular processor implementation. System functions in some cases have behavior that depends on the static or dynamic context of the caller (for example, they may compare strings using the default collation from the static context of the caller): such functions are said to be <a title="context dependent" class="termref" href="#dt-context-dependent">context dependent</a>.</span><span class="modify_version">The behavior of system functions follows the rules given for the individual function in this family of specifications, or in the specification of the particular processor implementation. <span class="deltaxml-old">A system function may</span><span class="deltaxml-new">System functions in some cases</span> have behavior that depends on the static or dynamic context of the caller (for example, <span class="deltaxml-old">comparing</span><span class="deltaxml-new">they may compare</span> strings using the default collation from the <span class="deltaxml-old">dynamic</span><span class="deltaxml-new">static</span> context of the caller)<span class="deltaxml-old">. Such</span><span class="deltaxml-new">: such</span> functions are said to be <a title="context dependent" class="termref" href="#dt-context-dependent">context dependent</a>.</span></p></li><li><p><span style="display: none;" class="delete_version"> [<a id="dt-external-function" title="external function">Definition</a>: <b>External functions</b> can be characterized as functions that are neither part of the processor implementation, nor written in a language whose semantics are under the control of this family of specifications. The semantics of external functions, including any context dependencies, are entirely implementation-defined. In XSLT, external functions are called <a href="https://www.w3.org/TR/xslt-30/#extension-functions">Section 24.1 Extension Functions </a><sup><small>XT30</small></sup>. ] For example, an implementation might provide a set of <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> external functions in addition to the core function library described in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a> or a host language. </span><span style="display: none;" class="add_version"><b>External functions</b> can be characterized as functions that are neither part of the processor implementation, nor written in a language whose semantics are under the control of this family of specifications. The semantics of external functions, including any context dependencies, are entirely implementation-defined. </span><span class="modify_version"><span class="deltaxml-old"> [</span><a id="dt-external-function" title="external function"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: </span><b>External functions</b> can be characterized as functions that are neither part of the processor implementation, nor written in a language whose semantics are under the control of this family of specifications. The semantics of external functions, including any context dependencies, are entirely implementation-defined. <span class="deltaxml-old">In XSLT, external functions are called </span><a href="https://www.w3.org/TR/xslt-30/#extension-functions"><span class="deltaxml-old">Section 24.1 Extension Functions </span></a><span class="deltaxml-old">XT30</span><span class="deltaxml-old">. ] For example, an implementation might provide a set of </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-old">implementation-defined</span></a><span class="deltaxml-old"> external functions in addition to the core function library described in </span><a href="#xpath-functions-40"><span class="deltaxml-old">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-old"> or a host language. </span></span></p></li></ul><p><span style="display: none;" class="delete_version"> [<a id="dt-context-dependent" title="context dependent">Definition</a>: A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> is said to be <b>context dependent</b> if its result depends on the static or dynamic context of its caller. A function definition may be context-dependent for some arities in its arity range, and context-independent for others: for example <code>fn:name#0</code> is context-dependent while <code>fn:name#1</code> is context-independent.] </span><span style="display: none;" class="add_version"> [<a id="dt-context-dependent" title="context dependent">Definition</a>: A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> is said to be <b>context dependent</b> if its result depends on the static or dynamic context of its caller.] </span><span class="modify_version"> [<a id="dt-context-dependent" title="context dependent">Definition</a>: A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> is said to be <b>context dependent</b> if its result depends on the static or dynamic context of its caller.<span class="deltaxml-old"> A function definition may be context-dependent for some arities in its arity range, and context-independent for others: for example </span><span class="deltaxml-old">fn:name#0</span><span class="deltaxml-old"> is context-dependent while </span><span class="deltaxml-old">fn:name#1</span><span class="deltaxml-old"> is context-independent.</span>] </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Some system functions, such as <code>fn:position</code>, <code>fn:last</code>, and <code>fn:static-base-uri</code>, exist for the sole purpose of providing information about the static or dynamic context of their caller.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p><a title="application function" class="termref" href="#dt-application-function">Application functions</a> are <span class="deltaxml-new">only ever </span>context dependent <span class="deltaxml-old">only </span>to the extent that they define optional parameters with default values that are context dependent.</p></div></li><li><p>The function name, which is an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p></li><li><p>A (possibly empty) list of required parameters, each having:</p><ul><li><p>a parameter name (an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>)</p></li><li><p>a required type (a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>)</p></li></ul></li><li><p>A (possibly empty) list of optional parameters, each having:</p><ul><li><p>a parameter name (an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>)</p></li><li><p>a required type (a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>)</p></li><li><p>a default value expression (an <b>expression</b>: see <a href="#id-expressions"><b>4 Expressions</b></a>)</p></li></ul></li><li><p>A return type (a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>)</p></li><li><p>A (possibly empty) set of <b>function annotations</b></p><p class="xquery">In XQuery, function annotations are described in <a href="#id-annotations"><b>5.15 Annotations</b></a>.</p></li><li><p>A body. The function body contains the logic that enables the function result to be computed from the supplied arguments and information in the static and dynamic context.</p></li></ul><p>The names of the parameters must be distinct.</p><p> [<a id="dt-arity-range" title="arity range">Definition</a>: A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> has an <b>arity range</b>, which is a range of consecutive non-negative integers. If the function definition has <var>M</var> required parameters and <var>N</var> optional parameters, then its arity range is from <var>M</var> to <var>M</var>+<var>N</var> inclusive.] </p><p>The static context may contain several <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> with the same name, but the <a title="arity range" class="termref" href="#dt-arity-range">arity ranges</a> of two such function definitions must not overlap. For example, if two function definitions <var>A</var> and <var>B</var> have the same function name, then:</p><ul><li><p>It is acceptable for <var>A</var> to have two required parameters and no optional parameters, while <var>B</var> has three required parameters and one optional parameter.</p></li><li><p>It is not acceptable for <var>A</var> to have one required parameter while <var>B</var> has three optional parameters.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations must ensure that no two <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> have the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and overlapping arity ranges (even if the signatures are consistent).</p><p>XQuery and XSLT enforce this rule by defining a static error if the rule is violated; but further constraints may be needed if an API allows external functions to be added to the static context.</p></div><p><span style="display: none;" class="delete_version"><a title="system function" class="termref" href="#dt-system-function">System functions</a> (also commonly called built-in functions) are <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> that are always present in the static context by virtue of rules in the host language; they will typically include the functions specified in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>.</span><span style="display: none;" class="add_version"> [<a id="dt-built-in-function" title="built-in function">Definition</a>: <b>Built-in functions</b> are <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> that are always present in the static context by virtue of rules in the host language; they will typically include the functions specified in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>.] </span><span class="modify_version"><a title="system function" class="termref" href="#dt-system-function"><span class="deltaxml-old">System functions</span></a> <span class="deltaxml-old">(also</span><span class="deltaxml-new">[</span><a id="dt-built-in-function" title="built-in function"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">:</span> <b><span class="deltaxml-old">commonly called built</span><span class="deltaxml-new">Built</span>-in functions<span class="deltaxml-old">)</span></b> are <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> that are always present in the static context by virtue of rules in the host language; they will typically include the functions specified in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>.<span class="deltaxml-new">] </span></span></p><p>The <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> are available for reference from a <a title="static function call" class="termref" href="#dt-static-function-call">static function call</a>, or from a <a title="named function reference" class="termref" href="#dt-named-function-ref">named function reference</a>. </p></li><li><p><span style="display: none;" class="delete_version"> [<a id="dt-static-collations" title="statically known collations">Definition</a>: <b>Statically known collations.</b> This is an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> mapping from URI to collation. It defines the names of the collations that are available for use in processing <span class="xquery">queries and</span> expressions.] [<a id="dt-collation" title="collation">Definition</a>: A <b>collation</b> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <a href="https://qt4cg.org/specifications/xpath-functions-40/#string-compare">Section 5.3 Comparison of strings</a><sup><small>FO40</small></sup>.] </span><span style="display: none;" class="add_version"> [<a id="dt-static-collations" title="statically known collations">Definition</a>: <b>Statically known collations.</b> This is an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> mapping from URI to collation. It defines the names of the collations that are available for use in processing <span class="xquery">queries and</span> expressions.] [<a id="dt-collation" title="collation">Definition</a>: A <b>collation</b> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <a href="https://www.w3.org/TR/xpath-functions-31/#string-compare">Section 5.3 Comparison of strings </a><sup><small>FO31</small></sup>.] </span><span class="modify_version"> [<a id="dt-static-collations" title="statically known collations">Definition</a>: <b>Statically known collations.</b> This is an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> mapping from URI to collation. It defines the names of the collations that are available for use in processing <span class="xquery">queries and</span> expressions.] [<a id="dt-collation" title="collation">Definition</a>: A <b>collation</b> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <a href="https://www.w3.org/TR/xpath-functions-31/#string-compare">Section 5.3 Comparison of strings<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>.] </span></p></li><li class="add_version" style="display: none;"><p> [<a id="dt-def-collation" title="default collation">Definition</a>: <b>Default collation.</b> This identifies one of the collations in <a title="statically known collations" class="termref" href="#dt-static-collations">statically known collations</a> as the collation to be used by functions and operators for comparing and ordering values of type <code>xs:string</code> and <code>xs:anyURI</code> (and types derived from them) when no explicit collation is specified.] </p></li><li class="modify_version"><p><span class="deltaxml-new"> [</span><a id="dt-def-collation" title="default collation"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: </span><b><span class="deltaxml-new">Default collation.</span></b><span class="deltaxml-new"> This identifies one of the collations in </span><a title="statically known collations" class="termref" href="#dt-static-collations"><span class="deltaxml-new">statically known collations</span></a><span class="deltaxml-new"> as the collation to be used by functions and operators for comparing and ordering values of type </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> and </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new"> (and types derived from them) when no explicit collation is specified.] </span></p></li><li class="xquery"><p> [<a id="dt-construction-mode" title="construction mode">Definition</a>: <b>Construction mode.</b> The construction mode governs the behavior of element and document node constructors. If construction mode is <code>preserve</code>, the type of a constructed element node is <code>xs:anyType</code>, and all attribute and element nodes copied during node construction retain their original types. If construction mode is <code>strip</code>, the type of a constructed element node is <code>xs:untyped</code>; all element nodes copied during node construction receive the type <code>xs:untyped</code>, and all attribute nodes copied during node construction receive the type <code>xs:untypedAtomic</code>.] </p></li><li class="xquery"><p><span style="display: none;" class="delete_version"> [<a id="dt-ordering-mode" title="ordering mode">Definition</a>: <b>Ordering mode.</b> Ordering mode, which has the value <code>ordered</code> or <code>unordered</code>, affects the ordering of the result sequence returned by certain expressions, as discussed in <a href="#id-unordered-expressions"><span class="delete_version"><b>4.16 Ordered and Unordered Expressions</b></span><span class="modify_version"><b>4.16 Ordered and Unordered Expressions</b></span></a>.] </span><span style="display: none;" class="add_version"> [<a id="dt-ordering-mode" title="ordering mode">Definition</a>: <b>Ordering mode.</b> Ordering mode, which has the value <code>ordered</code> or <code>unordered</code>, affects the ordering of the result sequence returned by certain expressions, as discussed in <a href="#id-unordered-expressions"><span class="add_version"><b>4.15 Ordered and Unordered Expressions</b></span><span class="modify_version"><b>4.15 Ordered and Unordered Expressions</b></span></a>.] </span><span class="modify_version"> [<a id="dt-ordering-mode" title="ordering mode">Definition</a>: <b>Ordering mode.</b> Ordering mode, which has the value <code>ordered</code> or <code>unordered</code>, affects the ordering of the result sequence returned by certain expressions, as discussed in <a href="#id-unordered-expressions"><span style="display: none;" class="delete_version"><b>4.16 Ordered and Unordered Expressions</b></span><span style="display: none;" class="add_version"><b>4.15 Ordered and Unordered Expressions</b></span><span class="modify_version"><b><span class="deltaxml-old">4.16</span><span class="deltaxml-new">4.15</span> Ordered and Unordered Expressions</b></span></a>.] </span></p></li><li class="xquery"><p><span style="display: none;" class="delete_version"> [<a id="dt-default-empty-order" title="default order for empty sequences">Definition</a>: <b>Default order for empty sequences.</b> This component controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression, as described in <a href="#id-order-by-clause"><span class="delete_version"><b>4.15.9 Order By Clause</b></span><span class="modify_version"><b>4.15.9 Order By Clause</b></span></a>.] Its value may be <code>greatest</code> or <code>least</code>.</span><span style="display: none;" class="add_version"> [<a id="dt-default-empty-order" title="default order for empty sequences">Definition</a>: <b>Default order for empty sequences.</b> This component controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression, as described in <a href="#id-order-by-clause"><span class="add_version"><b>4.14.8 Order By Clause</b></span><span class="modify_version"><b>4.14.8 Order By Clause</b></span></a>.] Its value may be <code>greatest</code> or <code>least</code>.</span><span class="modify_version"> [<a id="dt-default-empty-order" title="default order for empty sequences">Definition</a>: <b>Default order for empty sequences.</b> This component controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression, as described in <a href="#id-order-by-clause"><span style="display: none;" class="delete_version"><b>4.15.9 Order By Clause</b></span><span style="display: none;" class="add_version"><b>4.14.8 Order By Clause</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.9</span><span class="deltaxml-new">4.14.8</span> Order By Clause</b></span></a>.] Its value may be <code>greatest</code> or <code>least</code>.</span></p></li><li class="xquery"><p><span style="display: none;" class="delete_version"> [<a id="dt-boundary-space-policy" title="boundary-space policy">Definition</a>: <b>Boundary-space policy.</b> This component controls the processing of <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> by <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructors</a>, as described in <a href="#id-whitespace"><span class="delete_version"><b>4.13.1.4 Boundary Whitespace</b></span><span class="modify_version"><b>4.13.1.4 Boundary Whitespace</b></span></a>.] Its value may be <code>preserve</code> or <code>strip</code>.</span><span style="display: none;" class="add_version"> [<a id="dt-boundary-space-policy" title="boundary-space policy">Definition</a>: <b>Boundary-space policy.</b> This component controls the processing of <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> by <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructors</a>, as described in <a href="#id-whitespace"><span class="add_version"><b>4.12.1.4 Boundary Whitespace</b></span><span class="modify_version"><b>4.12.1.4 Boundary Whitespace</b></span></a>.] Its value may be <code>preserve</code> or <code>strip</code>.</span><span class="modify_version"> [<a id="dt-boundary-space-policy" title="boundary-space policy">Definition</a>: <b>Boundary-space policy.</b> This component controls the processing of <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> by <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructors</a>, as described in <a href="#id-whitespace"><span style="display: none;" class="delete_version"><b>4.13.1.4 Boundary Whitespace</b></span><span style="display: none;" class="add_version"><b>4.12.1.4 Boundary Whitespace</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1.4</span><span class="deltaxml-new">4.12.1.4</span> Boundary Whitespace</b></span></a>.] Its value may be <code>preserve</code> or <code>strip</code>.</span></p></li><li class="xquery"><p><span style="display: none;" class="delete_version"> [<a id="dt-copy-namespaces-mode" title="copy-namespaces mode">Definition</a>: <b>Copy-namespaces mode.</b> This component controls the namespace bindings that are assigned when an existing element node is copied by an element constructor, as described in <a href="#id-element-constructor"><span class="delete_version"><b>4.13.1 Direct Element Constructors</b></span><span class="modify_version"><b>4.13.1 Direct Element Constructors</b></span></a>. Its value consists of two parts: <code>preserve</code> or <code>no-preserve</code>, and <code>inherit</code> or <code>no-inherit</code>.] </span><span style="display: none;" class="add_version"> [<a id="dt-copy-namespaces-mode" title="copy-namespaces mode">Definition</a>: <b>Copy-namespaces mode.</b> This component controls the namespace bindings that are assigned when an existing element node is copied by an element constructor, as described in <a href="#id-element-constructor"><span class="add_version"><b>4.12.1 Direct Element Constructors</b></span><span class="modify_version"><b>4.12.1 Direct Element Constructors</b></span></a>. Its value consists of two parts: <code>preserve</code> or <code>no-preserve</code>, and <code>inherit</code> or <code>no-inherit</code>.] </span><span class="modify_version"> [<a id="dt-copy-namespaces-mode" title="copy-namespaces mode">Definition</a>: <b>Copy-namespaces mode.</b> This component controls the namespace bindings that are assigned when an existing element node is copied by an element constructor, as described in <a href="#id-element-constructor"><span style="display: none;" class="delete_version"><b>4.13.1 Direct Element Constructors</b></span><span style="display: none;" class="add_version"><b>4.12.1 Direct Element Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1</span><span class="deltaxml-new">4.12.1</span> Direct Element Constructors</b></span></a>. Its value consists of two parts: <code>preserve</code> or <code>no-preserve</code>, and <code>inherit</code> or <code>no-inherit</code>.] </span></p></li><li><p><span style="display: none;" class="delete_version"> [<a id="dt-static-base-uri" title="Static Base URI">Definition</a>: <b>Static Base URI.</b> This is an absolute URI, used to resolve relative URIs during static analysis. ] For example, it is used to resolve module location URIs in XQuery, and the URIs in <code>xsl:import</code> and <code>xsl:include</code> in XSLT. <span class="xquery"> All expressions within a module have the same static base URI. The Static Base URI can be set using a <a title="base URI declaration" class="termref" href="#dt-base-uri-decl">base URI declaration</a>. </span></span><span style="display: none;" class="add_version"> [<a id="dt-static-base-uri" title="Static Base URI">Definition</a>: <b>Static Base URI.</b> This is an absolute URI, used to resolve <span class="xquery">relative URIs both during static analysis and during dynamic evaluation.</span> ] <span class="xquery"> All expressions within a module have the same static base URI. The Static Base URI can be set using a <a title="base URI declaration" class="termref" href="#dt-base-uri-decl">base URI declaration</a>. </span> The Static Base URI is available during dynamic evaluation by use of the <code>fn:static-base-uri</code> function, and is used implicitly during dynamic evaluation by functions such as <code>fn:doc</code>. Relative URI references are resolved as described in <a href="#id-resolve-relative-uri"><b>2.5.6 Resolving a Relative URI Reference</b></a>.</span><span class="modify_version"> [<a id="dt-static-base-uri" title="Static Base URI">Definition</a>: <b>Static Base URI.</b> This is an absolute URI, used to resolve <span class="xquery">relative URIs <span class="deltaxml-new">both </span>during static analysis<span class="deltaxml-old">. ] For example, it is used to resolve module location URIs in XQuery, and the URIs in</span><span class="deltaxml-new"> and during dynamic evaluation.</span></span> <span class="deltaxml-old">xsl:import</span><span class="deltaxml-new">]</span> <span class="deltaxml-old">and</span><span class="xquery"> <span class="deltaxml-old">xsl:include</span><span class="deltaxml-old"> in XSLT. </span><span class="deltaxml-old"> </span>All expressions within a module have the same static base URI. The Static Base URI can be set using a <a title="base URI declaration" class="termref" href="#dt-base-uri-decl">base URI declaration</a>. </span><span class="deltaxml-new"> The Static Base URI is available during dynamic evaluation by use of the </span><code><span class="deltaxml-new">fn:static-base-uri</span></code><span class="deltaxml-new"> function, and is used implicitly during dynamic evaluation by functions such as </span><code><span class="deltaxml-new">fn:doc</span></code><span class="deltaxml-new">. Relative URI references are resolved as described in </span><a href="#id-resolve-relative-uri"><b><span class="deltaxml-new">2.5.6 Resolving a Relative URI Reference</span></b></a><span class="deltaxml-new">.</span></span></p><p><span class="deltaxml-old"> Relative URI references are resolved as described in </span><a href="#id-resolve-relative-uri"><b><span class="deltaxml-old">2.5.6 Resolving a Relative URI Reference</span></b></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">At execution time, relative URIs supplied to functions such as </span><code><span class="deltaxml-old">fn:doc</span></code><span class="deltaxml-old"> are resolved against the </span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri"><span class="deltaxml-old">Executable Base URI</span></a><span class="deltaxml-old">, which may or may not be the same as the Static Base URI.</span></p><p class="xquery"><span class="deltaxml-new"> If the value of the Static Base URI is based on the location of the query module (in the terminology of </span><a href="#RFC3986"><span class="deltaxml-new">[RFC3986]</span></a><span class="deltaxml-new">, the URI used to retrieve the encapsulating entity), then the implementation </span><strong><span class="deltaxml-new">may</span></strong><span class="deltaxml-new"> use different values for the Static Base URI during static analysis and during dynamic evaluation. This might be necessary, for example, if a query consisting of several modules is compiled, and the resulting object code is distributed to a different location for execution. It would then be inappropriate to use the same location when resolving </span><code><span class="deltaxml-new">import module</span></code><span class="deltaxml-new"> declarations as when retrieving source documents using the </span><code><span class="deltaxml-new">fn:doc</span></code><span class="deltaxml-new"> function. If an implementation uses different values for the Static Base URI during static analysis and during dynamic evaluation, then it is implementation-defined which of the two values is used for particular operations that rely on the Static Base URI; for example, it is implementation-defined which value is used for resolving collation URIs.</span></p></li><li><p> [<a id="dt-known-docs" title="statically known  documents">Definition</a>: <b>Statically known documents.</b> This is a mapping from strings to types. The string represents the absolute URI of a resource that is potentially available using the <code>fn:doc</code> function. The type is the <a title="static type" class="termref" href="#dt-static-type">static type</a> of a call to <code>fn:doc</code> with the given URI as its literal argument. ] If the argument to <code>fn:doc</code> is a string literal that is not present in <b>statically known documents</b>, then the <a title="static type" class="termref" href="#dt-static-type">static type</a> of <code>fn:doc</code> is <code>document-node()?</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The purpose of the <b>statically known documents</b> is to provide static type information, not to determine which documents are available. A URI need not be found in the <b>statically known documents</b> to be accessed using <code>fn:doc</code>. </p></div></li><li><p> [<a id="dt-known-collections" title="statically known  collections">Definition</a>: <b>Statically known collections.</b> This is a mapping from strings to types. The string represents the absolute URI of a resource that is potentially available using the <code>fn:collection</code> function. The type is the type of the sequence of items that would result from calling the <code>fn:collection</code> function with this URI as its argument.] If the argument to <code>fn:collection</code> is a string literal that is not present in <b>statically known collections</b>, then the <a title="static type" class="termref" href="#dt-static-type">static type</a> of <code>fn:collection</code> is <code>item()*</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The purpose of the <b>statically known collections</b> is to provide static type information, not to determine which collections are available. A URI need not be found in the <b>statically known collections</b> to be accessed using <code>fn:collection</code>. </p></div></li><li><p> [<a id="dt-known-default-collection" title="statically known default collection type">Definition</a>: <b>Statically known default collection type.</b> This is the type of the sequence of items that would result from calling the <code>fn:collection</code> function with no arguments.] Unless initialized to some other value by an implementation, the value of <b>statically known default collection type</b> is <code>item()*</code>.</p></li><li><p> [<a id="dt-static-decimal-formats" title="statically known decimal formats">Definition</a>: <b>Statically known decimal formats.</b> This is a mapping from QNames to decimal formats, with one default format that has no visible name, referred to as the unnamed decimal format. Each format is available for use when formatting numbers using the <code>fn:format-number</code> function.] </p><p>Each decimal format defines a set of properties, which control the interpretation of characters in the picture string supplied to the <code>fn:format-number</code> function, and also specify characters to be used in the result of formatting the number.</p><p>The following properties specify characters used both in the picture string, and in the formatted number. In each case the value is a single character:</p><ul><li><p> [<a id="id-static-decimal-format-decimal-separator" title="decimal-separator">Definition</a>: <b>decimal-separator</b> is the character used to separate the integer part of the number from the fractional part, both in the picture string and in the formatted number; the default value is the period character (.)] </p></li><li><p><span style="display: none;" class="delete_version"> [<a id="id-static-decimal-format-exponent-separator" title="exponent-separator">Definition</a>: <b>exponent-separator</b> is the character used to separate the mantissa from the exponent in scientific notation both in the picture string and in the formatted number; the default value is the Unicode Latin small letter e character (#x65).] </span><span style="display: none;" class="add_version"> [<a id="id-static-decimal-format-exponent-separator" title="exponent-separator">Definition</a>: <b>exponent-separator</b> is the character used to separate the mantissa from the exponent in scientific notation both in the picture string and in the formatted number; the default value is the character (e).] </span><span class="modify_version"> [<a id="id-static-decimal-format-exponent-separator" title="exponent-separator">Definition</a>: <b>exponent-separator</b> is the character used to separate the mantissa from the exponent in scientific notation both in the picture string and in the formatted number; the default value is the <span class="deltaxml-old">Unicode Latin small letter e character (#x65</span><span class="deltaxml-new">character (e</span>).] </span></p></li><li><p> [<a id="id-static-decimal-format-grouping-separator" title="grouping-separator">Definition</a>: <b>grouping-separator</b> is the character typically used as a thousands separator, both in the picture string and in the formatted number; the default value is the comma character (,)] </p></li><li><p> [<a id="id-static-decimal-format-percent" title="percent">Definition</a>: <b>percent</b> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-hundred fraction; the default value is the percent character (%)] </p></li><li><p><span style="display: none;" class="delete_version"> [<a id="id-static-decimal-format-per-mille" title="per-mille">Definition</a>: <b>per-mille</b> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-thousand fraction; the default value is the Unicode per mille sign character (#x2030)] </span><span style="display: none;" class="add_version"> [<a id="id-static-decimal-format-per-mille" title="per-mille">Definition</a>: <b>per-mille</b> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-thousand fraction; the default value is the Unicode per-mille character (#x2030)] </span><span class="modify_version"> [<a id="id-static-decimal-format-per-mille" title="per-mille">Definition</a>: <b>per-mille</b> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-thousand fraction; the default value is the Unicode per<span class="deltaxml-old"> </span><span class="deltaxml-new">-</span>mille <span class="deltaxml-old">sign </span>character (#x2030)] </span></p></li><li><p><span style="display: none;" class="delete_version"> [<a id="id-static-decimal-format-zero-digit" title="zero-digit">Definition</a>: <b>zero-digit</b> is the character used to represent the digit zero; the default value is the Unicode digit zero (#x30). This character must be a digit (category Nd in the Unicode property database), and it must have the numeric value zero. This property implicitly defines the ten Unicode characters that are used to represent the values 0 to 9: Unicode is organized so that each set of decimal digits forms a contiguous block of characters in numerical sequence. Within the picture string any of these ten character can be used (interchangeably) as a place-holder for a mandatory digit. Within the final result string, these ten characters are used to represent the digits zero to nine.] </span><span style="display: none;" class="add_version"> [<a id="id-static-decimal-format-zero-digit" title="zero-digit">Definition</a>: <b>zero-digit</b> is the character used to represent the digit zero; the default value is the Western digit zero (#x30). This character must be a digit (category Nd in the Unicode property database), and it must have the numeric value zero. This property implicitly defines the ten Unicode characters that are used to represent the values 0 to 9: Unicode is organized so that each set of decimal digits forms a contiguous block of characters in numerical sequence. Within the picture string any of these ten character can be used (interchangeably) as a place-holder for a mandatory digit. Within the final result string, these ten characters are used to represent the digits zero to nine.] </span><span class="modify_version"> [<a id="id-static-decimal-format-zero-digit" title="zero-digit">Definition</a>: <b>zero-digit</b> is the character used to represent the digit zero; the default value is the <span class="deltaxml-old">Unicode</span><span class="deltaxml-new">Western</span> digit zero (#x30). This character must be a digit (category Nd in the Unicode property database), and it must have the numeric value zero. This property implicitly defines the ten Unicode characters that are used to represent the values 0 to 9: Unicode is organized so that each set of decimal digits forms a contiguous block of characters in numerical sequence. Within the picture string any of these ten character can be used (interchangeably) as a place-holder for a mandatory digit. Within the final result string, these ten characters are used to represent the digits zero to nine.] </span></p></li></ul><p>The following properties specify characters to be used in the picture string supplied to the <code>fn:format-number</code> function, but not in the formatted number. In each case the value must be a single character. </p><ul><li><p> [<a id="id-static-decimal-format-digit" title="digit">Definition</a>: <b>digit</b> is a character used in the picture string to represent an optional digit; the default value is the number sign character (#)] </p></li><li><p><span style="display: none;" class="delete_version"> [<a id="id-static-decimal-format-pattern-separator" title="pattern-separator">Definition</a>: <b>pattern-separator</b> is a character used to separate positive and negative sub-pictures in a picture string; the default value is the semicolon character (;)] </span><span style="display: none;" class="add_version"> [<a id="id-static-decimal-format-pattern-separator" title="pattern-separator">Definition</a>: <b>pattern-separator</b> is a character used to separate positive and negative sub-pictures in a picture string; the default value is the semi-colon character (;)] </span><span class="modify_version"> [<a id="id-static-decimal-format-pattern-separator" title="pattern-separator">Definition</a>: <b>pattern-separator</b> is a character used to separate positive and negative sub-pictures in a picture string; the default value is the <span class="deltaxml-old">semicolon</span><span class="deltaxml-new">semi-colon</span> character (;)] </span></p></li></ul><p>The following properties specify characters or strings that may appear in the result of formatting the number, but not in the picture string:</p><ul><li><p><span style="display: none;" class="delete_version"> [<a id="id-static-decimal-format-infinity" title="infinity">Definition</a>: <b>infinity</b> is the string used to represent the double value infinity (<code>INF</code>); the default value is the string <code>"Infinity"</code> ] </span><span style="display: none;" class="add_version"> [<a id="id-static-decimal-format-infinity" title="infinity">Definition</a>: <b>infinity</b> is the string used to represent the double value infinity (<code>INF</code>); the default value is the string "Infinity"] </span><span class="modify_version"> [<a id="id-static-decimal-format-infinity" title="infinity">Definition</a>: <b>infinity</b> is the string used to represent the double value infinity (<code>INF</code>); the default value is the string "Infinity"<span class="deltaxml-old"> </span>] </span></p></li><li><p><span style="display: none;" class="delete_version"> [<a id="id-static-decimal-format-NaN" title="NaN">Definition</a>: <b>NaN</b> is the string used to represent the double value <code>NaN</code> (not a number); the default value is the string <code>"NaN"</code> ] </span><span style="display: none;" class="add_version"> [<a id="id-static-decimal-format-NaN" title="NaN">Definition</a>: <b>NaN</b> is the string used to represent the double value NaN (not-a-number); the default value is the string "NaN"] </span><span class="modify_version"> [<a id="id-static-decimal-format-NaN" title="NaN">Definition</a>: <b>NaN</b> is the string used to represent the double value NaN (not<span class="deltaxml-old"> </span><span class="deltaxml-new">-</span>a<span class="deltaxml-old"> </span><span class="deltaxml-new">-</span>number); the default value is the string "NaN"<span class="deltaxml-old"> </span>] </span></p></li><li><p> [<a id="id-static-decimal-format-minus-sign" title="minus-sign">Definition</a>: <b>minus-sign</b> is the single character used to mark negative numbers; the default value is the hyphen-minus character (#x2D). ] </p></li></ul></li></ul></div><div class="div3"><h4><a id="eval_context"></a>2.2.2 Dynamic Context</h4><p><span style="display: none;" class="delete_version"> [<a id="dt-dynamic-context" title="dynamic context">Definition</a>: The <b>dynamic context</b> of an expression is defined as information that is needed for the dynamic evaluation of an expression.] If evaluation of an expression relies on some part of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> that is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>, a <a class="termref" title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>].</span><span style="display: none;" class="add_version"> [<a id="dt-dynamic-context" title="dynamic context">Definition</a>: The <b>dynamic context</b> of an expression is defined as information that is needed for the dynamic evaluation of an expression.] If evaluation of an expression relies on some part of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> that is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>, a <a class="termref" title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>].</span><span class="modify_version"> [<a id="dt-dynamic-context" title="dynamic context">Definition</a>: The <b>dynamic context</b> of an expression is defined as information that is needed for the dynamic evaluation of an expression.] If evaluation of an expression relies on some part of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> that is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>, a <a class="termref" title="dynamic error" href="#dt-dynamic-error"><span class="deltaxml-old">type</span><span class="deltaxml-new">dynamic</span> error</a> is raised [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">In previous versions of the specification, this was classified as a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-old">dynamic error</span></a><span class="deltaxml-old">. The change allows the error to be raised during static analysis when possible; for example a function written as </span><code><span class="deltaxml-old">fn($x){@code}</span></code><span class="deltaxml-old"> can now be reported as an error whether or not the function is actually evaluated. The actual error code remains unchanged for backwards compatibility reasons.</span></p><p><span class="deltaxml-old">There are other cases where static detection of the error is not possible.</span></p></div><p>The individual components of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> are described below. <span class="xquery">Rules governing the initialization and alteration of these components can be found in <a href="#id-xq-evaluation-context-components"><b>C.2 Dynamic Context Components</b></a>.</span></p><p>The <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> consists of all the components of the <a title="static context" class="termref" href="#dt-static-context">static context</a>, and the additional components listed below.</p><p><span style="display: none;" class="delete_version"> [<a id="dt-focus" title="focus">Definition</a>: The first three components of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> (context value, context position, and context size) are called the <b>focus</b> of the expression. ] The focus enables the processor to keep track of which items are being processed by the expression. <span class="xquery">If any component in the focus is defined, all components of the focus are defined.</span></span><span style="display: none;" class="add_version"> [<a id="dt-focus" title="focus">Definition</a>: The first three components of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> (context item, context position, and context size) are called the <b>focus</b> of the expression. ] The focus enables the processor to keep track of which items are being processed by the expression. <span class="xquery">If any component in the focus is defined, all components of the focus are defined.</span> [<a id="dt-singleton-focus" title="singleton focus">Definition</a>: A <b>singleton focus</b> is a focus that refers to a single item; in a singleton focus, context item is set to the item, context position = 1 and context size = 1.] </span><span class="modify_version"> [<a id="dt-focus" title="focus">Definition</a>: The first three components of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> (context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>, context position, and context size) are called the <b>focus</b> of the expression. ] The focus enables the processor to keep track of which items are being processed by the expression. <span class="xquery">If any component in the focus is defined, all components of the focus are defined.</span><span class="deltaxml-new"> [</span><a id="dt-singleton-focus" title="singleton focus"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: A </span><b><span class="deltaxml-new">singleton focus</span></b><span class="deltaxml-new"> is a focus that refers to a single item; in a singleton focus, context item is set to the item, context position = 1 and context size = 1.] </span></span></p><p><span class="deltaxml-old"> [</span><a id="dt-fixed-focus" title="fixed focus"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">fixed focus</span></b><span class="deltaxml-old"> is a focus for an expression that is evaluated once, rather than being applied to a series of values; in a fixed focus, the context value is set to one specific value, the context position is 1, and the context size is 1.] </span></p><p><span class="deltaxml-old"> [</span><a id="dt-singleton-focus" title="singleton focus"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">singleton focus</span></b><span class="deltaxml-old"> is a </span><a title="fixed focus" class="termref" href="#dt-fixed-focus"><span class="deltaxml-old">fixed focus</span></a><span class="deltaxml-old"> in which the </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-old">context value</span></a><span class="deltaxml-old"> is a </span><a title="singleton" class="termref" href="#dt-singleton"><span class="deltaxml-old">singleton</span></a><span class="deltaxml-old"> item.]. With a singleton focus, the context value is a single item, the context position is 1, and the context size is 1. </span></p><p>Certain language constructs, notably the <a title="path expression" class="termref" href="#dt-path-expression">path operator</a><code>E1/E2</code>, the <a href="#doc-xquery40-SimpleMapExpr">simple map operator</a><code>E1!E2</code>, and the <a title="" class="termref" href="#dt-predicate">predicate</a><code>E1[E2]</code>, create a new focus for the evaluation of a sub-expression. In these constructs, <code>E2</code> is evaluated once for each item in the sequence that results from evaluating <code>E1</code>. Each time <code>E2</code> is evaluated, it is evaluated with a different focus. The focus for evaluating <code>E2</code> is referred to below as the <b>inner focus</b>, while the focus for evaluating <code>E1</code> is referred to as the <b>outer focus</b>. The inner focus is used only for the evaluation of <code>E2</code>. Evaluation of E1 continues with its original focus unchanged.</p><ul><li><p><span style="display: none;" class="delete_version"> [<a id="dt-context-value" title="context value">Definition</a>: The <b>context value</b> is the <a class="termref" title="value" href="#dt-value">value</a> currently being processed.] In many cases (but not always), the context value will be a single item. [<a id="dt-context-node" title="context node">Definition</a>: When the context value is a single item, it can also be referred to as the <b>context item</b>; when it is a single node, it can also be referred to as the <b>context node</b>.] The context value is returned by an expression consisting of a single dot (<code>.</code>). When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, each item in the sequence obtained by evaluating <code>E1</code> becomes the context value in the inner focus for an evaluation of <code>E2</code>. </span><span style="display: none;" class="add_version"> [<a id="dt-context-item" title="context item">Definition</a>: The <b>context item</b> is the <a class="termref" title="item" href="#dt-item">item</a> currently being processed.] [<a id="dt-context-node" title="context node">Definition</a>: When the context item is a node, it can also be referred to as the <b>context node</b>.] The context item is returned by an expression consisting of a single dot (<code>.</code>). When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, each item in the sequence obtained by evaluating <code>E1</code> becomes the context item in the inner focus for an evaluation of <code>E2</code>. </span><span class="modify_version"> [<a id="dt-context-value" title="context value"><span class="deltaxml-old">Definition</span></a><a id="dt-context-item" title="context item"><span class="deltaxml-new">Definition</span></a>: The <b>context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span></b> is the <a class="termref" title="value" href="#dt-value"><span class="deltaxml-old">value</span></a><a class="termref" title="item" href="#dt-item"><span class="deltaxml-new">item</span></a> currently being processed.] <span class="deltaxml-old">In many cases (but not always), the context value will be a single item. </span>[<a id="dt-context-node" title="context node">Definition</a>: When the context <span class="deltaxml-old">value is a single item, it can also be referred to as the</span><span class="deltaxml-new">item</span> <span class="deltaxml-old">context item</span><span class="deltaxml-old">; when it </span>is a <span class="deltaxml-old">single </span>node, it can also be referred to as the <b>context node</b>.] The context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> is returned by an expression consisting of a single dot (<code>.</code>). When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, each item in the sequence obtained by evaluating <code>E1</code> becomes the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> in the inner focus for an evaluation of <code>E2</code>. </span></p><p class="xquery"><span style="display: none;" class="delete_version"> [<a id="dt-initial-context-value" title="initial context value">Definition</a>: In the dynamic context of every module in a query, the context value component must have the same setting. If this shared setting is not <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>, it is referred to as the <b>initial context value</b>. ] </span><span style="display: none;" class="add_version"> [<a id="dt-initial-context-item" title="initial context item">Definition</a>: In the dynamic context of every module in a query, the context item component must have the same setting. If this shared setting is not <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>, it is referred to as the <b>initial context item</b>. ] </span><span class="modify_version"> [<a id="dt-initial-context-value" title="initial context value"><span class="deltaxml-old">Definition</span></a><a id="dt-initial-context-item" title="initial context item"><span class="deltaxml-new">Definition</span></a>: In the dynamic context of every module in a query, the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> component must have the same setting. If this shared setting is not <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>, it is referred to as the <b>initial context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span></b>. ] </span></p></li><li><p><span style="display: none;" class="delete_version"> [<a id="dt-context-position" title="context position">Definition</a>: The <b>context position</b> is the position of the context value within the series of values currently being processed.] It changes whenever the context value changes. When the focus is defined, the value of the context position is an integer greater than zero. The context position is returned by the expression <code>fn:position()</code>. When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the context position in the inner focus for an evaluation of <code>E2</code> is the position of the context value in the sequence obtained by evaluating <code>E1</code>. The position of the first item in a sequence is always 1 (one). The context position is always less than or equal to the context size.</span><span style="display: none;" class="add_version"> [<a id="dt-context-position" title="context position">Definition</a>: The <b>context position</b> is the position of the context item within the sequence of items currently being processed.] It changes whenever the context item changes. When the focus is defined, the value of the context position is an integer greater than zero. The context position is returned by the expression <code>fn:position()</code>. When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the context position in the inner focus for an evaluation of <code>E2</code> is the position of the context item in the sequence obtained by evaluating <code>E1</code>. The position of the first item in a sequence is always 1 (one). The context position is always less than or equal to the context size.</span><span class="modify_version"> [<a id="dt-context-position" title="context position">Definition</a>: The <b>context position</b> is the position of the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> within the <span class="deltaxml-old">series of values</span><span class="deltaxml-new">sequence of items</span> currently being processed.] It changes whenever the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> changes. When the focus is defined, the value of the context position is an integer greater than zero. The context position is returned by the expression <code>fn:position()</code>. When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the context position in the inner focus for an evaluation of <code>E2</code> is the position of the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> in the sequence obtained by evaluating <code>E1</code>. The position of the first item in a sequence is always 1 (one). The context position is always less than or equal to the context size.</span></p></li><li><p><span style="display: none;" class="delete_version"> [<a id="dt-context-size" title="context size">Definition</a>: The <b>context size</b> is the number of values in the series of values currently being processed.] Its value is always an integer greater than zero. The context size is returned by the expression <code>fn:last()</code>. When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the context size in the inner focus for an evaluation of <code>E2</code> is the number of items in the sequence obtained by evaluating <code>E1</code>. </span><span style="display: none;" class="add_version"> [<a id="dt-context-size" title="context size">Definition</a>: The <b>context size</b> is the number of items in the sequence of items currently being processed.] Its value is always an integer greater than zero. The context size is returned by the expression <code>fn:last()</code>. When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the context size in the inner focus for an evaluation of <code>E2</code> is the number of items in the sequence obtained by evaluating <code>E1</code>. </span><span class="modify_version"> [<a id="dt-context-size" title="context size">Definition</a>: The <b>context size</b> is the number of <span class="deltaxml-old">values</span><span class="deltaxml-new">items</span> in the <span class="deltaxml-old">series of values</span><span class="deltaxml-new">sequence of items</span> currently being processed.] Its value is always an integer greater than zero. The context size is returned by the expression <code>fn:last()</code>. When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the context size in the inner focus for an evaluation of <code>E2</code> is the number of items in the sequence obtained by evaluating <code>E1</code>. </span></p></li><li><p> [<a id="dt-variable-values" title="variable values">Definition</a>: <b>Variable values</b>. This is a mapping from <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> to value. It contains the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> as the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> for the expression. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is the name of the variable and the value is the dynamic value of the variable, which includes its <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a>.] </p></li><li><p> [<a id="dt-dynamically-known-function-definitions" title="dynamically known function definitions">Definition</a>: <b>Dynamically known function definitions</b>. This is a set of <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a>. It includes the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a> as a subset, but may include other function definitions that are not known statically. ] </p><p>The function definitions in the dynamic context are used primarily by the <code>fn:function-lookup</code> function.</p><p>If two function definitions in the <a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions">dynamically known function definitions</a> have the same name, then their <a title="arity range" class="termref" href="#dt-arity-range">arity ranges</a> must not overlap.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The reason for allowing named functions to be available dynamically beyond those that are available statically is primarily to allow for cases where the run-time execution environment is significantly different from the compile-time environment. This could happen, for example, if a stylesheet or query is compiled within a web server and then executed in the web browser. The <code>fn:function-lookup</code> function allows dynamic discovery of resources that were not available statically.</p></div><p><span class="deltaxml-new">The dynamically known function definitions may include </span><b><span class="deltaxml-new">external functions</span></b><span class="deltaxml-new">.</span></p><p><span class="deltaxml-new"> [</span><a id="dt-external-function" title="external function"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: </span><b><span class="deltaxml-new">External functions</span></b><span class="deltaxml-new"> are functions that are implemented outside the query environment.] For example, an implementation might provide a set of </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new">implementation-defined</span></a><span class="deltaxml-new"> external functions in addition to the core function library described in </span><a href="#xpath-functions-40"><span class="deltaxml-new">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new">. </span></p></li><li><p> [<a id="dt-date-time" title="current dateTime">Definition</a>: <b>Current dateTime.</b> This information represents an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> point in time during the processing of <span class="xquery">a query</span> , and includes an explicit timezone. It can be retrieved by the <code>fn:current-dateTime</code> function. If called multiple times during the execution of <span class="xquery">a query</span> , this function always returns the same result.] </p></li><li><p> [<a id="dt-timezone" title="implicit timezone">Definition</a>: <b>Implicit timezone.</b> This is the timezone to be used when a date, time, or dateTime value that does not have a timezone is used in a comparison or arithmetic operation. The implicit timezone is an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> value of type <code>xs:dayTimeDuration</code>. See <a href="https://www.w3.org/TR/xmlschema-2/#dateTime-timezones">Section 3.2.7.3 Timezones </a><sup><small>XS1-2</small></sup> or <a href="https://www.w3.org/TR/xmlschema11-2/#dateTime">Section 3.3.7 dateTime </a><sup><small>XS11-2</small></sup> for the range of valid values of a timezone.] </p></li><li class="delete_version" style="display: none;"><p> [<a id="dt-executable-base-uri" title="Executable Base URI">Definition</a>: <b>Executable Base URI.</b> This is an absolute URI used to resolve relative URIs during the evaluation of expressions; it is used, for example, to resolve a relative URI supplied to the <code>fn:doc</code> or <code>fn:unparsed-text</code> functions. ] </p><p>URIs are resolved as described in <a href="#id-resolve-relative-uri"><b>2.5.6 Resolving a Relative URI Reference</b></a>.</p><p>The function <code>fn:static-base-uri</code>, despite its name, returns the value of the <a title="Executable Base URI" class="termref" href="#dt-executable-base-uri">Executable Base URI</a>.</p><p>In many straightforward processing scenarios, the <a title="Executable Base URI" class="termref" href="#dt-executable-base-uri">Executable Base URI</a> in the dynamic context will be the same as the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> for the corresponding expression in the static context. There are situations, however, where they may differ:</p><ul><li><p>Some processors may allow the static analysis of a query or stylesheet to take place on a development machine, while execution of the query or stylesheet happens on a test or production server. In this situation, resources needed during static analysis (such as other modules of the query or stylesheet) will be located on the development machine, by reference to the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a>, while resources needed during execution (such as reference data files) will be located on the production machine, accessed via the <a title="Executable Base URI" class="termref" href="#dt-executable-base-uri">Executable Base URI</a>.</p></li><li><p>When the <code>fn:static-base-uri</code> function is called within the initializing expression of an optional parameter in a function declaration, it returns the executable base URI of the relevant function call. This allows a user-written function to accept two parameters: a required parameter containing a relative URI, and an optional parameter containing a base URI. The optional parameter can be given a default value of <code>fn:static-base-uri()</code>, allowing the code in the function body to resolve the relative URI against the executable base URI of the caller.</p></li></ul></li><li class="modify_version"><p><span class="deltaxml-old"> [</span><a id="dt-executable-base-uri" title="Executable Base URI"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: </span><b><span class="deltaxml-old">Executable Base URI.</span></b><span class="deltaxml-old"> This is an absolute URI used to resolve relative URIs during the evaluation of expressions; it is used, for example, to resolve a relative URI supplied to the </span><code><span class="deltaxml-old">fn:doc</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">fn:unparsed-text</span></code><span class="deltaxml-old"> functions. ] </span></p><p><span class="deltaxml-old">URIs are resolved as described in </span><a href="#id-resolve-relative-uri"><b><span class="deltaxml-old">2.5.6 Resolving a Relative URI Reference</span></b></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">The function </span><code><span class="deltaxml-old">fn:static-base-uri</span></code><span class="deltaxml-old">, despite its name, returns the value of the </span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri"><span class="deltaxml-old">Executable Base URI</span></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">In many straightforward processing scenarios, the </span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri"><span class="deltaxml-old">Executable Base URI</span></a><span class="deltaxml-old"> in the dynamic context will be the same as the </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-old">Static Base URI</span></a><span class="deltaxml-old"> for the corresponding expression in the static context. There are situations, however, where they may differ:</span></p><ul><li><p><span class="deltaxml-old">Some processors may allow the static analysis of a query or stylesheet to take place on a development machine, while execution of the query or stylesheet happens on a test or production server. In this situation, resources needed during static analysis (such as other modules of the query or stylesheet) will be located on the development machine, by reference to the </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-old">Static Base URI</span></a><span class="deltaxml-old">, while resources needed during execution (such as reference data files) will be located on the production machine, accessed via the </span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri"><span class="deltaxml-old">Executable Base URI</span></a><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">When the </span><code><span class="deltaxml-old">fn:static-base-uri</span></code><span class="deltaxml-old"> function is called within the initializing expression of an optional parameter in a function declaration, it returns the executable base URI of the relevant function call. This allows a user-written function to accept two parameters: a required parameter containing a relative URI, and an optional parameter containing a base URI. The optional parameter can be given a default value of </span><code><span class="deltaxml-old">fn:static-base-uri()</span></code><span class="deltaxml-old">, allowing the code in the function body to resolve the relative URI against the executable base URI of the caller.</span></p></li></ul></li><li class="delete_version" style="display: none;"><p> [<a id="dt-def-collation" title="default collation">Definition</a>: <b>Default collation.</b> This identifies one of the collations in <a title="statically known collations" class="termref" href="#dt-static-collations">statically known collations</a> as the collation to be used by functions and operators for comparing and ordering values of type <code>xs:string</code> and <code>xs:anyURI</code> (and types derived from them) when no explicit collation is specified.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Although the default collation is defined (in 4.0) as a property of the dynamic context, its value will in nearly all cases be known statically. The reason it is defined in the dynamic context is to allow a call on the <code>fn:default-collation</code> function to be used when defining the default value of an optional parameter to a user-defined function. In this situation, the actual value supplied for the parameter is taken from the dynamic context of the relevant function call.</p></div></li><li class="modify_version"><p><span class="deltaxml-old"> [</span><a id="dt-def-collation" title="default collation"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: </span><b><span class="deltaxml-old">Default collation.</span></b><span class="deltaxml-old"> This identifies one of the collations in </span><a title="statically known collations" class="termref" href="#dt-static-collations"><span class="deltaxml-old">statically known collations</span></a><span class="deltaxml-old"> as the collation to be used by functions and operators for comparing and ordering values of type </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:anyURI</span></code><span class="deltaxml-old"> (and types derived from them) when no explicit collation is specified.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Although the default collation is defined (in 4.0) as a property of the dynamic context, its value will in nearly all cases be known statically. The reason it is defined in the dynamic context is to allow a call on the </span><code><span class="deltaxml-old">fn:default-collation</span></code><span class="deltaxml-old"> function to be used when defining the default value of an optional parameter to a user-defined function. In this situation, the actual value supplied for the parameter is taken from the dynamic context of the relevant function call.</span></p></div></li><li><p> [<a id="dt-default-language" title="default language">Definition</a>: <b>Default language.</b> This is the natural language used when creating human-readable output (for example, by the functions <code>fn:format-date</code> and <code>fn:format-integer</code>) if no other language is requested. The value is a language code as defined by the type <code>xs:language</code>.] </p></li><li><p> [<a id="dt-default-calendar" title="default calendar">Definition</a>: <b>Default calendar.</b> This is the calendar used when formatting dates in human-readable output (for example, by the functions <code>fn:format-date</code> and <code>fn:format-dateTime</code>) if no other calendar is requested. The value is a string.] </p></li><li><p> [<a id="dt-default-place" title="default place">Definition</a>: <b>Default place.</b> This is a geographical location used to identify the place where events happened (or will happen) when formatting dates and times using functions such as <code>fn:format-date</code> and <code>fn:format-dateTime</code>, if no other place is specified. It is used when translating timezone offsets to civil timezone names, and when using calendars where the translation from ISO dates/times to a local representation is dependent on geographical location. Possible representations of this information are an ISO country code or an Olson timezone name, but implementations are free to use other representations from which the above information can be derived.] </p></li><li><p> [<a id="dt-available-docs" title="available documents">Definition</a>: <b>Available documents.</b> This is a mapping of strings to document nodes. Each string represents the absolute URI of a resource. The document node is the root of a tree that represents that resource using the <a title="data model" class="termref" href="#dt-datamodel">data model</a>. The document node is returned by the <code>fn:doc</code> function when applied to that URI.] The set of available documents is not limited to the set of <a title="statically known  documents" class="termref" href="#dt-known-docs">statically known documents</a>, and it may be empty.</p><p>If there are one or more URIs in <a title="available documents" class="termref" href="#dt-available-docs">available documents</a> that map to a document node <code>D</code>, then the document-uri property of <code>D</code> must either be absent, or must be one of these URIs.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that given a document node <code>$N</code>, the result of <code>fn:doc(fn:document-uri($N)) is $N</code> will always be <code>true</code>, unless <code>fn:document-uri($N)</code> is an empty sequence.</p></div></li><li><p> [<a id="dt-available-text-resources" title="available text resources">Definition</a>: <b>Available text resources</b>. This is a mapping of strings to text resources. Each string represents the absolute URI of a resource. The resource is returned by the <code>fn:unparsed-text</code> function when applied to that URI.] The set of available text resources is not limited to the set of <a title="statically known  documents" class="termref" href="#dt-known-docs">statically known documents</a>, and it may be empty.</p></li><li><p> [<a id="dt-available-collections" title="available item collections">Definition</a>: <b>Available collections.</b> This is a mapping of strings to sequences of items. Each string represents the absolute URI of a resource. The sequence of items represents the result of the <code>fn:collection</code> function when that URI is supplied as the argument. ] The set of available collections is not limited to the set of <a title="statically known  collections" class="termref" href="#dt-known-collections">statically known collections</a>, and it may be empty.</p><p>For every document node <code>D</code> that is in the target of a mapping in <a title="available item collections" class="termref" href="#dt-available-collections">available collections</a>, or that is the root of a tree containing such a node, the document-uri property of <code>D</code> must either be absent, or must be a URI <code>U</code> such that <a title="available documents" class="termref" href="#dt-available-docs">available documents</a> contains a mapping from <code>U</code> to <code>D</code>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that for any document node <code>$N</code> retrieved using the <code>fn:collection</code> function, either directly or by navigating to the root of a node that was returned, the result of <code>fn:doc(fn:document-uri($N)) is $N</code> will always be <code>true</code>, unless <code>fn:document-uri($N)</code> is an empty sequence. This implies a requirement for the <code>fn:doc</code> and <code>fn:collection</code> functions to be consistent in their effect. If the implementation uses catalogs or user-supplied URI resolvers to dereference URIs supplied to the <code>fn:doc</code> function, the implementation of the <code>fn:collection</code> function must take these mechanisms into account. For example, an implementation might achieve this by mapping the collection URI to a set of document URIs, which are then resolved using the same catalog or URI resolver that is used by the <code>fn:doc</code> function.</p></div></li><li><p> [<a id="dt-default-collection" title="default collection">Definition</a>: <b>Default collection.</b> This is the sequence of items that would result from calling the <code>fn:collection</code> function with no arguments.] The value of <b>default collection</b> may be initialized by the implementation.</p></li><li><p> [<a id="dt-available-uri-collections" title="available uri collections">Definition</a>: <b>Available URI collections.</b> This is a mapping of strings to sequences of URIs. The string represents the absolute URI of a resource which can be interpreted as an aggregation of a number of individual resources each of which has its own URI. The sequence of URIs represents the result of the <code>fn:uri-collection</code> function when that URI is supplied as the argument. ] There is no implication that the URIs in this sequence can be successfully dereferenced, or that the resources they refer to have any particular media type.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An implementation <strong>may</strong> maintain some consistent relationship between the available collections and the available URI collections, for example by ensuring that the result of <code>fn:uri-collection(X)!fn:doc(.)</code> is the same as the result of <code>fn:collection(X)</code>. However, this is not required. The <code>fn:uri-collection</code> function is more general than <code>fn:collection</code> in that <code>fn:collection</code> allows access to nodes that might lack individual URIs, for example nodes corresponding to XML fragments stored in the rows of a relational database.</p></div></li><li><p> [<a id="dt-default-uri-collection" title="default URI collection">Definition</a>: <b>Default URI collection.</b> This is the sequence of URIs that would result from calling the <code>fn:uri-collection</code> function with no arguments.] The value of <b>default URI collection</b> may be initialized by the implementation.</p></li><li><p> [<a id="dt-environment-variables" title="environment variables">Definition</a>: <b>Environment variables.</b> This is a mapping from names to values. Both the names and the values are strings. The names are compared using an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> collation, and are unique under this collation. The set of environment variables is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> and <strong>may</strong> be empty.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>A possible implementation is to provide the set of POSIX environment variables (or their equivalent on other operating systems) appropriate to the process in which the <span class="xquery">query is initiated</span> .</p></div></li></ul></div></div><div class="div2"><h3><a id="id-processing-model"></a>2.3 Processing Model</h3><p>XQuery 4.0 is defined in terms of the <a title="data model" class="termref" href="#dt-datamodel">data model</a> and the <a title="expression context" class="termref" href="#dt-expression-context">expression context</a>.</p><img src="ProcMod-XQuery.gif" alt="Processing                          Model Overview"><p>Figure 1: Processing Model Overview</p><p>Figure 1 provides a schematic overview of the processing steps that are discussed in detail below. Some of these steps are completely outside the domain of XQuery 4.0; in Figure 1, these are depicted outside the line that represents the boundaries of the language, an area labeled <b>external processing</b>. The external processing domain includes generation of <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instances</a> that represent the data to be queried (see <a href="#id-data-model-generation"><b>2.3.1 Data Model Generation</b></a>), schema import processing (see <a href="#id-schema-import-processing"><b>2.3.2 Schema Import Processing</b></a>) and serialization<span class="xquery"> (see <a href="#id-serialization"><b>2.3.4 Serialization</b></a>)</span>. The area inside the boundaries of the language is known as the <span class="xquery"><b>query processing domain</b></span> , which includes the static analysis and dynamic evaluation phases (see <a href="#id-expression-processing"><b>2.3.3 Expression Processing</b></a>). Consistency constraints on the <span class="xquery">query</span> processing domain are defined in <a href="#id-consistency-constraints"><b>2.3.5 Consistency Constraints</b></a>.</p><div class="div3"><h4><a id="id-data-model-generation"></a>2.3.1 Data Model Generation</h4><p>The input data for <span class="xquery">a query</span> must be represented as one or more <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instances</a>. This process occurs outside the domain of XQuery 4.0, which is why Figure 1 represents it in the external processing domain. Here are some steps by which an XML document might be converted to an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a>:</p><ol class="enumar"><li><p>A document may be parsed using an XML parser that generates an <b>XML Information Set</b> (see <a href="#XINFO">[XML Infoset]</a>). The parsed document may then be validated against one or more schemas. This process, which is described in <a href="http://www.w3.org/TR/xmlschema-1/">[XML Schema 1.0 Part 1]</a> or <a href="http://www.w3.org/TR/xmlschema11-1/">[XML Schema 1.1 Part 1]</a>, results in an abstract information structure called the <b>Post-Schema Validation Infoset</b> (PSVI). If a document has no associated schema, its Information Set is preserved. (See DM1 in Fig. 1.)</p></li><li><p>The Information Set or PSVI may be transformed into an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> by a process described in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a>. (See DM2 in Fig. 1.)</p></li></ol><p>The above steps provide an example of how an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> might be constructed. An XDM instance might also be synthesized directly from a relational database, or constructed in some other way (see DM3 in Fig. 1.) XQuery 4.0 is defined in terms of the <a title="data model" class="termref" href="#dt-datamodel">data model</a>, but it does not place any constraints on how XDM instances are constructed.</p><p><span style="display: none;" class="delete_version"> [<a id="dt-type-annotation" title="type annotation">Definition</a>: Each element node and attribute node in an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> has a <b>type annotation</b> (described in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#types">Section 2.8 Schema Information</a><sup><small>DM40</small></sup>). The type annotation of a node is a reference to an XML Schema type. ] The <code>type-name</code> of a node is the name of the type referenced by its <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>. If the <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> was derived from a validated XML document as described in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#const-psvi">Section 3.3 Construction from a PSVI</a><sup><small>DM40</small></sup>, the type annotations of the element and attribute nodes are derived from schema validation. XQuery 4.0 does not provide a way to directly access the type annotation of an element or attribute node.</span><span style="display: none;" class="add_version"> [<a id="dt-type-annotation" title="type annotation">Definition</a>: Each element node and attribute node in an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> has a <b>type annotation</b> (described in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types">Section 2.7 Schema Information </a><sup><small>DM31</small></sup>). The type annotation of a node is a reference to an XML Schema type. ] The <code>type-name</code> of a node is the name of the type referenced by its <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>. If the <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> was derived from a validated XML document as described in <a href="https://www.w3.org/TR/xpath-datamodel-31/#const-psvi">Section 3.3 Construction from a PSVI </a><sup><small>DM31</small></sup>, the type annotations of the element and attribute nodes are derived from schema validation. XQuery 4.0 does not provide a way to directly access the type annotation of an element or attribute node.</span><span class="modify_version"> [<a id="dt-type-annotation" title="type annotation">Definition</a>: Each element node and attribute node in an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> has a <b>type annotation</b> (described in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types">Section <span class="deltaxml-old">2.8</span><span class="deltaxml-new">2.7</span> Schema Information<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>). The type annotation of a node is a reference to an XML Schema type. ] The <code>type-name</code> of a node is the name of the type referenced by its <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>. If the <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> was derived from a validated XML document as described in <a href="https://www.w3.org/TR/xpath-datamodel-31/#const-psvi">Section 3.3 Construction from a PSVI<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>, the type annotations of the element and attribute nodes are derived from schema validation. XQuery 4.0 does not provide a way to directly access the type annotation of an element or attribute node.</span></p><p>The value of an attribute is represented directly within the attribute node. An attribute node whose type is unknown (such as might occur in a schemaless document) is given the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><code>xs:untypedAtomic</code>.</p><p>The value of an element is represented by the children of the element node, which may include text nodes and other element nodes. The <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of an element node indicates how the values in its child text nodes are to be interpreted. An element that has not been validated (such as might occur in a schemaless document) is annotated with the schema type <code>xs:untyped</code>. An element that has been validated and found to be partially valid is annotated with the schema type <code>xs:anyType</code>. If an element node is annotated as <code>xs:untyped</code>, all its descendant element nodes are also annotated as <code>xs:untyped</code>. However, if an element node is annotated as <code>xs:anyType</code>, some of its descendant element nodes may have a more specific <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>.</p></div><div class="div3"><h4><a id="id-schema-import-processing"></a>2.3.2 Schema Import Processing</h4><p class="xquery">The <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> may be extracted from actual XML schemas (see step SI1 in Figure 1) or may be generated by some other mechanism (see step SI2 in Figure 1). In either case, the result must satisfy the consistency constraints defined in <a href="#id-consistency-constraints"><b>2.3.5 Consistency Constraints</b></a>.</p></div><div class="div3"><h4><a id="id-expression-processing"></a>2.3.3 Expression Processing</h4><p>XQuery 4.0 defines two phases of processing called the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a> and the <a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation">dynamic evaluation phase</a> (see Fig. 1). During the static analysis phase, <a title="static error" class="termref" href="#dt-static-error">static errors</a>, <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a>, or <a title="type error" class="termref" href="#dt-type-error">type errors</a> may be raised. During the dynamic evaluation phase, only <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a> or <a title="type error" class="termref" href="#dt-type-error">type errors</a> may be raised. These kinds of errors are defined in <a href="#id-kinds-of-errors"><b>2.4.1 Kinds of Errors</b></a>. </p><p>Within each phase, an implementation is free to use any strategy or algorithm whose result conforms to the specifications in this document.</p><div class="div4"><h5><a id="id-static-analysis"></a>2.3.3.1 Static Analysis Phase</h5><p> [<a id="dt-static-analysis" title="static analysis phase">Definition</a>: The <b>static analysis phase</b> depends on the expression itself and on the <a title="static context" class="termref" href="#dt-static-context">static context</a>. The <b>static analysis phase</b> does not depend on input data (other than schemas).] </p><p>During the static analysis phase, the <span class="xquery">query</span> is parsed into an internal representation called the <b>operation tree</b> (step SQ1 in Figure 1). A parse error is raised as a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXPST0003" title="err:XPST0003">err:XPST0003</a>]. The <a title="static context" class="termref" href="#dt-static-context">static context</a> is initialized by the implementation (step SQ2). <span class="xquery">The <a title="static context" class="termref" href="#dt-static-context">static context</a> is then changed and augmented based on information in the <b>prolog</b> (step SQ3). If the <a title="schema aware feature" class="termref" href="#dt-schema-aware-feature">Schema Aware Feature</a> is supported, the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> are populated with information from imported schemas. If the <a title="module feature" class="termref" href="#dt-module-feature">Module Feature</a> is supported, the static context is extended with function declarations and variable declarations from imported modules.</span> The <a title="static context" class="termref" href="#dt-static-context">static context</a> is used to resolve schema type names, function names, namespace prefixes, and variable names (step SQ4). If a name of one of these kinds in the <b>operation tree</b> is not found in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, a <a title="static error" class="termref" href="#dt-static-error">static error</a> ([<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>] or [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>]) is raised (however, see exceptions to this rule in <a href="#id-element-test"><b>3.6.3.2 Element Test</b></a> and <a href="#id-attribute-test"><b>3.6.3.4 Attribute Test</b></a>.)</p><p>The <b>operation tree</b> is then <b>normalized</b> by making explicit the implicit operations such as <a title="atomization" class="termref" href="#dt-atomization">atomization</a> and extraction of <a title="effective boolean value" class="termref" href="#dt-ebv">Effective Boolean Values</a> (step SQ5).</p><p>During the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a>, a processor may perform type analysis. The effect of type analysis is to assign a <a title="static type" class="termref" href="#dt-static-type">static type</a> to each expression in the operation tree. [<a id="dt-static-type" title="static type">Definition</a>: The <b>static type</b> of an expression is the best inference that the processor is able to make statically about the type of the result of the expression.] This specification does not define the rules for type analysis nor the static types that are assigned to particular expressions: the only constraint is that the inferred type must match all possible values that the expression is capable of returning.</p><p>Examples of inferred static types might be:</p><ul><li><p>For the expression <code>concat(a,b)</code> the inferred static type is <code>xs:string</code></p></li><li><p>For the expression <code>$a = $v</code> the inferred static type is <code>xs:boolean</code></p></li><li><p>For the expression <code>$s[exp]</code> the inferred static type has the same item type as the static type of <code>$s</code>, but a cardinality that allows the empty sequence even if the static type of <code>$s</code> does not allow an empty sequence.</p></li><li><p>The inferred static type of the expression <code>data($x)</code> (whether written explicitly or inserted into the operation tree in places where atomization is implicit) depends on the inferred static type of <code>$x</code>: for example, if <code>$x</code> has type <code>element(*, xs:integer)</code> then <code>data($x)</code> has static type <code>xs:integer</code>.</p></li></ul><p>In XQuery 1.0 and XPath 2.0, rules for static type inferencing were published normatively in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>, but implementations were allowed to refine these rules to infer a more precise type where possible. In XQuery 3.1 and XPath 3.1, the rules for static type inferencing are entirely implementation-dependent.</p><p>Every kind of expression also imposes requirements on the type of its operands. For example, with the expression <code>substring($a, $b, $c)</code>, <code>$a</code> must be of type <code>xs:string</code> (or something that can be converted to <code>xs:string</code> by the function calling rules), while <code>$b</code> and <code>$c</code> must be of type <code>xs:double</code>.</p><p>If the <a title="static     typing feature" class="termref" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect, a processor must raise a type error during static analysis if the inferred static type of an expression is not subsumed by the required type of the context where the expression is used. For example, the call of substring above would cause a type error if the inferred static type of <code>$a</code> is <code>xs:integer</code>; equally, a type error would be reported during static analysis if the inferred static type is <code>xs:anyAtomicType</code>.</p><p>If the <a title="static     typing feature" class="termref" href="#dt-static-typing-feature">Static Typing Feature</a> is not in effect, a processor may raise a type error during static analysis only when one of the following conditions is met:</p><ol class="enumar"><li><p>When the inferred static type of an expression has no overlap (intersection) with the required type, and cannot be converted to the required type using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. For example, given the call <code>fn:upper-case($s)</code>, the processor may raise an error if the declared or inferred type of <code>$s</code> is <code>xs:integer</code>, but not if it is <code>xs:anyAtomicType</code>. </p></li><li><p>When the only possible value of an expression that is consistent with the required type is the empty sequence. Consider for example the expression <code>fn:codepoints-to-string(fn:tokenize($in))</code>. Since <code>fn:codepoints-to-string</code> requires <code>xs:integer*</code> while <code>fn:tokenize($in)</code> delivers <code>xs:string*</code>, this expression can succeed only in the special case where the value is empty, so processors <strong>may</strong> report this as an error. An error <strong>must not</strong> be raised under this rule unless both the inferred static type and the required type permit values other than the empty sequence.</p></li><li><p>When an <a href="#doc-xquery40-ForwardStep">ForwardStep</a> or <a href="#doc-xquery40-ReverseStep">ReverseStep</a> is used, and it is known during static analysis that the step will select no nodes.</p><p>One example of this is an expression such as <code>@price/text()</code>: attribute nodes never have children, so this expression will never select anything.</p><p>Another example arises when schema information is available: if it is known that the variable <code>$emp</code> holds a value of type <code>schema-element(employee)</code>, and that no element of this type can have an attribute named <code>@sallary</code> (sic), then a type error may be reported if the expression <code>$emp/@sallary</code> is encountered.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">A static error <strong>must not</strong> be reported simply because a predicate will always return <code>false</code>: the expression <code>a[name()='b']</code> will always return an empty sequence, but it is not an error.</span><span style="display: none;" class="add_version">A static error <strong>must not</strong> be reported simply because a predicate will always return false: the expression <code>a[name()='b']</code> will always return an empty sequence, but it is not an error.</span><span class="modify_version">A static error <strong>must not</strong> be reported simply because a predicate will always return false: the expression <code>a[name()='b']</code> will always return an empty sequence, but it is not an error.</span></p></div></li><li><p><span style="display: none;" class="delete_version">When the <a href="#doc-xquery40-KeySpecifier">KeySpecifier</a> in a <a href="#doc-xquery40-Lookup">Lookup</a> expression is such that the result of the lookup will inevitably be empty. For example if the context value is known to be of type <code>record(longitude, latitude)</code> then a static type error <strong>may</strong> be raised against the expression <code>?altitude</code>.</span><span style="display: none;" class="add_version">When the <a href="#doc-xquery40-KeySpecifier">KeySpecifier</a> in a <a href="#doc-xquery40-Lookup">Lookup</a> expression is such that the result of the lookup will inevitably be empty. For example if the context item is known to be of type <code>record(longitude, latitude)</code> then a static type error <strong>may</strong> be raised against the expression <code>?altitude</code>.</span><span class="modify_version">When the <a href="#doc-xquery40-KeySpecifier">KeySpecifier</a> in a <a href="#doc-xquery40-Lookup">Lookup</a> expression is such that the result of the lookup will inevitably be empty. For example if the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> is known to be of type <code>record(longitude, latitude)</code> then a static type error <strong>may</strong> be raised against the expression <code>?altitude</code>.</span></p></li></ol><p>For backwards compatibility, processors <strong>should</strong> provide an option to avoid reporting type errors in respect of constructs such as <code>@a/@b</code> that were executed without error in previous versions. Note in particular that the construct <code>/..</code> was sometimes recommended in XPath 1.0 as the preferred way to denote an empty node-set.</p><p>Alternatively, if the <a title="static     typing feature" class="termref" href="#dt-static-typing-feature">Static Typing Feature</a> is not in effect, the processor <strong>may</strong> defer all type checking until the dynamic evaluation phase.</p></div><div class="div4"><h5><a id="id-dynamic-evaluation"></a>2.3.3.2 Dynamic Evaluation Phase</h5><p> [<a id="dt-dynamic-evaluation" title="dynamic evaluation phase">Definition</a>: The <b>dynamic evaluation phase</b> is the phase during which the value of an expression is computed.] It is dependent on successful completion of the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a>.</p><p>The dynamic evaluation phase can occur only if no errors were detected during the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a>. If the <a title="static     typing feature" class="termref" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect, all <a title="type error" class="termref" href="#dt-type-error">type errors</a> are detected during static analysis and serve to inhibit the dynamic evaluation phase.</p><p>The dynamic evaluation phase depends on the <b>operation tree</b> of the expression being evaluated (step DQ1), on the input data (step DQ4), and on the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> (step DQ5), which in turn draws information from the external environment (step DQ3) and the <a title="static context" class="termref" href="#dt-static-context">static context</a> (step DQ2). The dynamic evaluation phase may create new data-model values (step DQ4) and it may extend the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> (step DQ5)—for example, by binding values to variables.</p><p> [<a id="dt-dynamic-type" title="dynamic type">Definition</a>: Every value matches one or more <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a>. A value is said to have a <b>dynamic type</b><var>T</var> if it matches (or <b>is an instance of</b>) the sequence type <var>T</var>.] </p><p>In many cases (but not all), one of the dynamic types that a value matches will be a subtype of all the others, in which case it makes sense to speak of <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>the dynamic type<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> of the value as meaning this single most specific type. In other cases (examples are empty maps and empty arrays) none of the dynamic types is more specific than all the others.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An atomic value has a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> which will always be a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of all the other types that it matches; we can therefore refer to this as the <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> of the atomic value without ambiguity.</p></div><p>A value may match a dynamic type that is more specific than the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the expression that computed it (for example, the static type of an expression might be <code>xs:integer*</code>, denoting a sequence of zero or more integers, but at evaluation time its value may be an instance of <code>xs:integer</code>, denoting exactly one integer). </p><p>If an operand of an expression does not have a <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> that is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the <a title="static type" class="termref" href="#dt-static-type">static type</a> required for that operand, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><p>Even though static typing can catch many <a title="type error" class="termref" href="#dt-type-error">type errors</a> before an expression is executed, it is possible for an expression to raise an error during evaluation that was not detected by static analysis. For example, an expression may contain a cast of a string into an integer, which is statically valid. However, if the actual value of the string at run time cannot be cast into an integer, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> will result. Similarly, an expression may apply an arithmetic operator to a value whose <a title="static type" class="termref" href="#dt-static-type">static type</a> is <code>xs:untypedAtomic</code>. This is not a <a title="static error" class="termref" href="#dt-static-error">static error</a>, but at run time, if the value cannot be successfully cast to a <a title="numeric" class="termref" href="#dt-numeric">numeric</a> type, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> will be raised.</p><p>When the <a title="static     typing feature" class="termref" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect, it is also possible for static analysis of an expression to raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>, even though execution of the expression on certain inputs would be successful. For example, an expression might contain a function that requires an element as its parameter, and the static analysis phase might infer the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the function parameter to be an optional element. This case is treated as a <a title="type error" class="termref" href="#dt-type-error">type error</a> and inhibits evaluation, even though the function call would have been successful for input data in which the optional element is present.</p></div></div><div class="div3"><h4><a id="id-serialization"></a>2.3.4 Serialization</h4><p><span style="display: none;" class="delete_version"> [<a id="dt-serialization" title="serialization">Definition</a>: <b>Serialization</b> is the process of converting an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> to a sequence of octets (step DM4 in Figure 1.), as described in <a href="#xslt-xquery-serialization-40">[XSLT and XQuery Serialization 4.0]</a>.] </span><span style="display: none;" class="add_version"> [<a id="dt-serialization" title="serialization">Definition</a>: <b>Serialization</b> is the process of converting an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> to a sequence of octets (step DM4 in Figure 1.), as described in <a href="#xslt-xquery-serialization-31">[XSLT and XQuery Serialization 3.1]</a>.] </span><span class="modify_version"> [<a id="dt-serialization" title="serialization">Definition</a>: <b>Serialization</b> is the process of converting an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> to a sequence of octets (step DM4 in Figure 1.), as described in <a href="#xslt-xquery-serialization-31">[XSLT and XQuery Serialization <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a>.] </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>This definition of serialization is the definition used in this specification. Any form of serialization that is not based on <a href="#xslt-xquery-serialization-31">[XSLT and XQuery Serialization <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a> is outside the scope of the XQuery 4.0 specification.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="http://expath.org">EXPath Community Group</a> has developed a <a href="http://expath.org/spec/file">File Module</a>, which some implementations use to perform file system related operations such as listing, reading, or writing files or directories. Multiple files can be written from a single query.</p></div><p class="xquery">An XQuery implementation is not required to provide a serialization interface. For example, an implementation may provide only a DOM interface (see <a href="#DOM">[Document Object Model]</a>) or an interface based on an event stream. </p><p class="xquery"><span style="display: none;" class="delete_version"><a href="#xslt-xquery-serialization-40">[XSLT and XQuery Serialization 4.0]</a> defines a set of <b>serialization parameters</b> that govern the serialization process. If an XQuery implementation provides a serialization interface, it may support (and may expose to users) any of the serialization parameters listed (with default values) in <a href="#id-xq-static-context-components"><b>C.1 Static Context Components</b></a>. If an implementation does not support one of these parameters, it must ignore it without raising an error.</span><span style="display: none;" class="add_version"><a href="#xslt-xquery-serialization-31">[XSLT and XQuery Serialization 3.1]</a> defines a set of <b>serialization parameters</b> that govern the serialization process. If an XQuery implementation provides a serialization interface, it may support (and may expose to users) any of the serialization parameters listed (with default values) in <a href="#id-xq-static-context-components"><b>C.1 Static Context Components</b></a>. If an implementation does not support one of these parameters, it must ignore it without raising an error.</span><span class="modify_version"><a href="#xslt-xquery-serialization-31">[XSLT and XQuery Serialization <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a> defines a set of <b>serialization parameters</b> that govern the serialization process. If an XQuery implementation provides a serialization interface, it may support (and may expose to users) any of the serialization parameters listed (with default values) in <a href="#id-xq-static-context-components"><b>C.1 Static Context Components</b></a>. If an implementation does not support one of these parameters, it must ignore it without raising an error.</span></p><p class="xquery"><span style="display: none;" class="delete_version"> [<a id="dt-output-declaration" title="output declaration">Definition</a>: An <b>output declaration</b> is an option declaration in the namespace <code>http://www.w3.org/2010/xslt-xquery-serialization</code>; it is used to declare serialization parameters.] Except for <code>parameter-document</code>, each option corresponds to a serialization parameter element defined in <a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#serparams-schema">Section B Schema for Serialization Parameters</a><sup><small>SE40</small></sup>. The name of each option is the same as the name of the corresponding serialization parameter element, and the values permitted for each option are the same as the values allowed in the serialization parameter element. For QName values, prefixes are expanded to namespace URIs by means of the statically known namespaces, or if unprefixed, the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>.</span><span style="display: none;" class="add_version"> [<a id="dt-output-declaration" title="output declaration">Definition</a>: An <b>output declaration</b> is an option declaration in the namespace "http://www.w3.org/2010/xslt-xquery-serialization"; it is used to declare serialization parameters.] Except for <code>parameter-document</code>, each option corresponds to a serialization parameter element defined in <a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparams-schema">Section B Schema for Serialization Parameters </a><sup><small>SER31</small></sup>. The name of each option is the same as the name of the corresponding serialization parameter element, and the values permitted for each option are the same as the values allowed in the serialization parameter element. For QName values, prefixes are expanded to namespace URIs by means of the statically known namespaces, or if unprefixed, <span>the default element namespace</span>.</span><span class="modify_version"> [<a id="dt-output-declaration" title="output declaration">Definition</a>: An <b>output declaration</b> is an option declaration in the namespace <span class="deltaxml-new">"</span>http://www.w3.org/2010/xslt-xquery-serialization<span class="deltaxml-new">"</span>; it is used to declare serialization parameters.] Except for <code>parameter-document</code>, each option corresponds to a serialization parameter element defined in <a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparams-schema">Section B Schema for Serialization Parameters<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">SE40</span><span class="deltaxml-new">SER31</span></small></sup>. The name of each option is the same as the name of the corresponding serialization parameter element, and the values permitted for each option are the same as the values allowed in the serialization parameter element. For QName values, prefixes are expanded to namespace URIs by means of the statically known namespaces, or if unprefixed, <span>the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-new">default element namespace</span></span>.</span></p><p class="xquery">There is no output declaration for <code>use-character-maps</code>, it can be set only by means of a parameter document. When the application requests serialization of the output, the processor may use these parameters to control the way in which the serialization takes place. Processors may also allow external mechanisms for specifying serialization parameters, which may or may not override serialization parameters specified in the query prolog.</p><p>The following example illustrates the use of declaration options. </p><div class="example"><div class="exampleInner"><pre><span class="deltaxml-old">declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization"; declare option output:method "xml"; declare option output:encoding "iso-8859-1"; declare option output:indent "yes"; declare option output:parameter-document "file:///home/me/serialization-parameters.xml";</span></pre><pre><span class="deltaxml-new">declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization"; declare option output:method "xml"; declare option output:encoding "iso-8859-1"; declare option output:indent "yes"; declare option output:parameter-document "file:///home/me/serialization-parameters.xml"; </span></pre></div></div><p class="xquery">An <b>output declaration</b> may appear only in a main module; it is a static error [<a href="#ERRXQST0108" title="err:XQST0108">err:XQST0108</a>] if an output declaration appears in a <a title="library module" class="termref" href="#dt-library-module">library module</a>. It is a static error [<a href="#ERRXQST0110" title="err:XQST0110">err:XQST0110</a>] if the same serialization parameter is declared more than once. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0109" title="err:XQST0109">err:XQST0109</a>] if the local name of an output declaration in the <code>http://www.w3.org/2010/xslt-xquery-serialization</code> namespace is not one of the serialization parameter names listed in <a href="#id-xq-static-context-components"><b>C.1 Static Context Components</b></a> or <code>parameter-document</code>, or if the name of an output declaration is <code>use-character-maps</code>. The default value for the <code>method</code> parameter is <code>"xml"</code>. An implementation may define additional <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> serialization parameters in its own namespaces. </p><p class="xquery">If the local name of an output declaration in the <code>http://www.w3.org/2010/xslt-xquery-serialization</code> namespace is <code>parameter-document</code>, the value of the output declaration is treated as a URI literal. The value is a location hint, and identifies an XDM instance in an implementation-defined way. If a processor is performing serialization, it is a static error [<a href="#ERRXQST0119" title="err:XQST0119">err:XQST0119</a>] if the implementation is not able to process the value of the <code>output:parameter-document</code> declaration to produce an XDM instance.</p><p class="xquery"><span style="display: none;" class="delete_version">If a processor is performing serialization, the XDM instance identified by an <code>output:parameter-document</code> output declaration specifies the values of serialization parameters in the manner defined by <a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#serparams-in-xdm-instance">Section 3.1 Setting Serialization Parameters by Means of a Parameter Document</a><sup><small>SE40</small></sup>. It is a static error [<a href="#ERRXQST0115" title="err:XQST0115">err:XQST0115</a>] if this yields a serialization error. The value of any other output declaration overrides any value that might have been specified for the same serialization parameter using an output declaration in the <code>http://www.w3.org/2010/xslt-xquery-serialization</code> namespace with the local name parameter-document declaration.</span><span style="display: none;" class="add_version">If a processor is performing serialization, the XDM instance identified by an <code>output:parameter-document</code> output declaration specifies the values of serialization parameters in the manner defined by <a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparams-in-xdm-instance">Section 3.1 Setting Serialization Parameters by Means of a Data Model Instance </a><sup><small>SER31</small></sup>. It is a static error [<a href="#ERRXQST0115" title="err:XQST0115">err:XQST0115</a>] if this yields a serialization error. The value of any other output declaration overrides any value that might have been specified for the same serialization parameter using an output declaration in the <code>http://www.w3.org/2010/xslt-xquery-serialization</code> namespace with the local name parameter-document declaration.</span><span class="modify_version">If a processor is performing serialization, the XDM instance identified by an <code>output:parameter-document</code> output declaration specifies the values of serialization parameters in the manner defined by <a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparams-in-xdm-instance">Section 3.1 Setting Serialization Parameters by Means of a <span class="deltaxml-old">Parameter Document</span><span class="deltaxml-new">Data Model Instance </span></a><sup><small><span class="deltaxml-old">SE40</span><span class="deltaxml-new">SER31</span></small></sup>. It is a static error [<a href="#ERRXQST0115" title="err:XQST0115">err:XQST0115</a>] if this yields a serialization error. The value of any other output declaration overrides any value that might have been specified for the same serialization parameter using an output declaration in the <code>http://www.w3.org/2010/xslt-xquery-serialization</code> namespace with the local name parameter-document declaration.</span></p><p class="xquery">A serialization parameter that is not applicable to the chosen output method must be ignored, except that if its value is not a valid value for that parameter, an error may be raised.</p><p class="xquery">A processor that is performing serialization must raise a serialization error if the values of any serialization parameters that it supports (other than any that are ignored under the previous paragraph) are incorrect.</p><p class="xquery">A processor that is not performing serialization may report errors if any serialization parameters are incorrect, or may ignore such parameters.</p><p class="xquery">Specifying serialization parameters in a query does not by itself demand that the output be serialized. It merely defines the desired form of the serialized output for use in situations where the processor has been asked to perform serialization. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a title="data model" class="termref" href="#dt-datamodel">data model</a> permits an element node to have fewer <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> than its parent. Correct serialization of such an element node would require <span class="deltaxml-old">“undeclaration”</span><span class="deltaxml-new">"undeclaration"</span> of namespaces, which is a feature of <a href="#XMLNAMES11">[XML Names 1.1]</a>. An implementation that does not support <a href="#XMLNAMES11">[XML Names 1.1]</a> is permitted to serialize such an element without <span class="deltaxml-old">“undeclaration”</span><span class="deltaxml-new">"undeclaration"</span> of namespaces, which effectively causes the element to inherit the in-scope namespaces of its parent. </p></div></div><div class="div3"><h4><a id="id-consistency-constraints"></a>2.3.5 Consistency Constraints</h4><p>In order for XQuery 4.0 to be well defined, the input <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instances</a>, the <a title="static context" class="termref" href="#dt-static-context">static context</a>, and the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> must be mutually consistent. The consistency constraints listed below are prerequisites for correct functioning of an XQuery 4.0 implementation. Enforcement of these consistency constraints is beyond the scope of this specification. This specification does not define the result of <span class="xquery">a query</span> under any condition in which one or more of these constraints is not satisfied.</p><ul><li><p><span style="display: none;" class="delete_version">For every node that has a type annotation, if that type annotation is found in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> (ISSD), then its definition in the ISSD must be <span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible">compatible</a><sup><small>DM40</small></sup></span> with its definition in the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema">schema</a><sup><small>DM40</small></sup> that was used to validate the node. </span><span style="display: none;" class="add_version">For every node that has a type annotation, if that type annotation is found in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> (ISSD), then its definition in the ISSD must be equivalent to its definition in the type annotation. </span><span class="modify_version">For every node that has a type annotation, if that type annotation is found in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> (ISSD), then its definition in the ISSD must be <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible"><span class="deltaxml-old">compatible</span></a><span class="deltaxml-old">DM40</span><span class="deltaxml-new">equivalent</span> <span class="deltaxml-old">with</span><span class="deltaxml-new">to</span> its definition in the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema"><span class="deltaxml-old">schema</span></a><span class="deltaxml-old">DM40</span><span class="deltaxml-new">type</span> <span class="deltaxml-old">that was used to validate the node</span><span class="deltaxml-new">annotation</span>. </span></p></li><li><p>Every element name, attribute name, or schema type name referenced in <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> or <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a> must be in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>, unless it is an element name referenced as part of an <a href="#doc-xquery40-ElementTest">ElementTest</a> or an attribute name referenced as part of an <a href="#doc-xquery40-AttributeTest">AttributeTest</a>.</p></li><li><p>Any reference to a global element, attribute, or type name in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> must have a corresponding element, attribute or type definition in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>.</p></li><li><p> For each mapping of a string to a document node in <a title="available documents" class="termref" href="#dt-available-docs">available documents</a>, if there exists a mapping of the same string to a document type in <a title="statically known  documents" class="termref" href="#dt-known-docs">statically known documents</a>, the document node must match the document type, using the matching rules in <a href="#id-sequencetype-matching"><b>3.5 Sequence Type Matching</b></a>.</p></li><li><p>For each mapping of a string to a sequence of items in <a title="available item collections" class="termref" href="#dt-available-collections">available collections</a>, if there exists a mapping of the same string to a type in <a title="statically known  collections" class="termref" href="#dt-known-collections">statically known collections</a>, the sequence of items must match the type, using the matching rules in <a href="#id-sequencetype-matching"><b>3.5 Sequence Type Matching</b></a>.</p></li><li><p>The sequence of items in the <a title="default collection" class="termref" href="#dt-default-collection">default collection</a> must match the <a title="statically known default collection type" class="termref" href="#dt-known-default-collection">statically known default collection type</a>, using the matching rules in <a href="#id-sequencetype-matching"><b>3.5 Sequence Type Matching</b></a>.</p></li><li><p>The <span class="deltaxml-new">value of the </span><a class="termref" title="context item" href="#dt-context-item">context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span></a> must match the <a class="termref" title="context item static type" href="#dt-context-item-static-type">context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> static type</a>, using the matching rules in <a href="#id-sequencetype-matching"><b>3.5 Sequence Type Matching</b></a>.</p></li><li><p>For each (variable, type) pair in <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> and the corresponding (variable, value) pair in <a title="variable values" class="termref" href="#dt-variable-values">variable values</a> such that the variable names are equal, the value must match the type, using the matching rules in <a href="#id-sequencetype-matching"><b>3.5 Sequence Type Matching</b></a>.</p></li><li class="xquery"><p>For each variable declared as external, if the variable declaration does not include a <a href="#doc-xquery40-VarDefaultValue">VarDefaultValue</a>, the external environment must provide a value for the variable.</p><p>For each variable declared as external for which the external environment provides a value: If the variable declaration includes a declared type, the value provided by the external environment must match the declared type, using the matching rules in <a href="#id-sequencetype-matching"><b>3.5 Sequence Type Matching</b></a>. If the variable declaration does not include a declared type, the external environment must provide a type to accompany the value provided, using the same matching rules.</p></li><li class="xquery"><p>For each function declared as external: the <span class="deltaxml-old">function’s</span><span class="deltaxml-new">function's</span> <a title="function item" class="termref" href="#dt-function-item">implementation</a> must either return a value that matches the declared result type, using the matching rules in <a href="#id-sequencetype-matching"><b>3.5 Sequence Type Matching</b></a>, or raise an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> error.</p></li><li class="xquery"><p><span class="deltaxml-old">For a given query, define a </span><b><span class="deltaxml-old">participating ISSD</span></b><span class="deltaxml-old"> as the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-old">in-scope schema definitions</span></a><span class="deltaxml-old"> of a module that is used in evaluating the query. All participating ISSDs must be </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible"><span class="deltaxml-old">compatible</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">This rule ensures that when one module </span><var><span class="deltaxml-old">M</span></var><span class="deltaxml-old"> imports schema </span><var><span class="deltaxml-old">X</span></var><span class="deltaxml-old">, and another module </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> imports schema </span><var><span class="deltaxml-old">Y</span></var><span class="deltaxml-old">, then an element node validated against type </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> in </span><var><span class="deltaxml-old">M</span></var><span class="deltaxml-old"> can be safely passed to a function in </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> that expects an argument of type </span><code><span class="deltaxml-old">element(*, T)</span></code><span class="deltaxml-old">. The requirement for compatibility does not guarantee that in all cases, validation of an element against the two different schemas will produce exactly the same outcome (there may be differences, for example, in the definition of substitution groups or wildcards), and the processor must allow for such differences.</span></p></div><p><span class="deltaxml-new">For a given query, define a </span><b><span class="deltaxml-new">participating ISSD</span></b><span class="deltaxml-new"> as the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new">in-scope schema definitions</span></a><span class="deltaxml-new"> of a module that is used in evaluating the query. If two participating ISSDs contain a definition for the same schema type, element name, or attribute name, the definitions must be equivalent in both ISSDs. In this context, equivalence means that validating an instance against type </span><em><span class="deltaxml-new">T</span></em><span class="deltaxml-new"> in one ISSD will always have the same effect as validating the same instance against type </span><em><span class="deltaxml-new">T</span></em><span class="deltaxml-new"> in the other ISSD (that is, it will produce the same PSVI, insofar as the PSVI is used during subsequent processing). This means, for example, that the membership of the substitution group of an element declaration in one ISSD must be the same as that of the corresponding element declaration in the other ISSD; that the set of types derived by extension from a given type must be the same; and that in the presence of a strict or lax wildcard, the set of global element (or attribute) declarations capable of matching the wildcard must be the same. </span></p></li><li><p>In the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>, the prefix <code>xml</code> must not be bound to any namespace URI other than <code>http://www.w3.org/XML/1998/namespace</code>, and no prefix other than <code>xml</code> may be bound to this namespace URI. The prefix <code>xmlns</code> must not be bound to any namespace URI, and no prefix may be bound to the namespace URI <code>http://www.w3.org/2000/xmlns/</code>.</p></li></ul></div></div><div class="div2"><h3><a id="errors"></a>2.4 Error Handling</h3><div class="div3"><h4><a id="id-kinds-of-errors"></a>2.4.1 Kinds of Errors</h4><p> As described in <a href="#id-expression-processing"><b>2.3.3 Expression Processing</b></a>, XQuery 4.0 defines a <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a>, which does not depend on input data, and a <a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation">dynamic evaluation phase</a>, which does depend on input data. Errors may be raised during each phase.</p><p> [<a id="dt-static-error" title="static error">Definition</a>: An error that can be detected during the static analysis phase, and is not a type error, is a <b>static error</b>.] A syntax error is an example of a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p><p><span style="display: none;" class="delete_version"> [<a id="dt-dynamic-error" title="dynamic error">Definition</a>: A <b>dynamic error</b> is an error that must be detected during the dynamic evaluation phase and may be detected during the static analysis phase.] Numeric overflow is an example of a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>. </span><span style="display: none;" class="add_version"> [<a id="dt-dynamic-error" title="dynamic error">Definition</a>: A <b>dynamic error</b> is an error that must be detected during the dynamic evaluation phase and may be detected during the static analysis phase. Numeric overflow is an example of a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>.] </span><span class="modify_version"> [<a id="dt-dynamic-error" title="dynamic error">Definition</a>: A <b>dynamic error</b> is an error that must be detected during the dynamic evaluation phase and may be detected during the static analysis phase.<span class="deltaxml-old">]</span> Numeric overflow is an example of a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>.<span class="deltaxml-new">]</span> </span></p><p> [<a id="dt-type-error" title="type error">Definition</a>: A <b>type error</b> may be raised during the static analysis phase or the dynamic evaluation phase. During the static analysis phase, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs when the <a title="static type" class="termref" href="#dt-static-type">static type</a> of an expression does not match the expected type of the context in which the expression occurs. During the dynamic evaluation phase, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs when the <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> of a value does not match the expected type of the context in which the value occurs.] </p><p>The outcome of the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a> is either success or one or more <a title="type error" class="termref" href="#dt-type-error">type errors</a>, <a title="static error" class="termref" href="#dt-static-error">static errors</a>, or statically detected <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a>. The result of the <a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation">dynamic evaluation phase</a> is either a result value, a <a title="type error" class="termref" href="#dt-type-error">type error</a>, or a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>.</p><p>If more than one error is present, or if an error condition comes within the scope of more than one error defined in this specification, then any non-empty subset of these errors may be reported.</p><p> During the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a>, if the <a title="static     typing feature" class="termref" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect and the <a title="static type" class="termref" href="#dt-static-type">static type</a> assigned to an expression other than <code>()</code> or <code>data(())</code> is <code>empty-sequence()</code>, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0005" title="err:XPST0005">err:XPST0005</a>]. This catches cases in which a query refers to an element or attribute that is not present in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>, possibly because of a spelling error.</p><p>Independently of whether the <a title="static     typing feature" class="termref" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect, if an implementation can determine during the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a> that <span class="xquery">a <a href="#doc-xquery40-QueryBody">QueryBody</a></span> , if evaluated, would necessarily raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> or that an expression, if evaluated, would necessarily raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>, the implementation may (but is not required to) report that error during the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a>.</p><p>An implementation can raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> for <span class="xquery">a <a href="#doc-xquery40-QueryBody">QueryBody</a></span> statically only if the <span class="xquery">query</span> can never execute without raising that error, as in the following example:</p><div class="exampleInner"><pre><span class="deltaxml-old">error()</span></pre><pre><span class="deltaxml-new">error() </span></pre></div><p>The following example contains a type error, which can be reported statically even if the implementation can not prove that the expression will actually be evaluated.</p><div class="exampleInner"><pre><span class="deltaxml-old">if (empty($arg)) then "cat" * 2 else 0</span></pre><pre><span class="deltaxml-new">if (empty($arg)) then "cat" * 2 else 0 </span></pre></div><p> [<a id="dt-warning" title="warning">Definition</a>: In addition to <a title="static error" class="termref" href="#dt-static-error">static errors</a>, <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a>, and <a title="type error" class="termref" href="#dt-type-error">type errors</a>, an XQuery 4.0 implementation may raise <b>warnings</b>, either during the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a> or the <a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation">dynamic evaluation phase</a>. The circumstances in which warnings are raised, and the ways in which warnings are handled, are <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.] </p><p>In addition to the errors defined in this specification, an implementation may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> for a reason beyond the scope of this specification. For example, limitations may exist on the maximum numbers or sizes of various objects. <span>An error must be raised if such a limitation is exceeded [<a href="#ERRXPDY0130" title="err:XPDY0130">err:XPDY0130</a>].</span></p></div><div class="div3"><h4><a id="id-identifying-errors"></a>2.4.2 Identifying and Reporting Errors</h4><p>The errors defined in this specification are identified by QNames that have the form <code>err:XXYYnnnn</code>, where:</p><ul><li><p><code>err</code> denotes the namespace for XPath and XQuery errors, <code>http://www.w3.org/2005/xqt-errors</code>. This binding of the namespace prefix <code>err</code> is used for convenience in this document, and is not normative.</p></li><li class="xquery"><p><code>XX</code> denotes the language in which the error is defined, using the following encoding:</p><ul class="xquery"><li><p><code>XP</code> denotes an error defined by XPath. Such an error may also occur XQuery since XQuery includes XPath as a subset.</p></li><li><p><code>XQ</code> denotes an error defined by XQuery (or an error originally defined by XQuery and later added to XPath).</p></li></ul></li><li><p><code>YY</code> denotes the error category, using the following encoding:</p><ul><li><p><code>ST</code> denotes a static error.</p></li><li><p><code>DY</code> denotes a dynamic error.</p></li><li><p><code>TY</code> denotes a type error.</p></li></ul></li><li><p><code>nnnn</code> is a unique numeric code.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The namespace URI for XPath and XQuery errors is not expected to change from one version of <span class="xquery">XQuery</span> to another. However, the contents of this namespace may be extended to include additional error definitions.</p></div><p>The method by which an XQuery 4.0 processor reports error information to the external environment is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>An error can be represented by a URI reference that is derived from the error QName as follows: an error with namespace URI <em><code>NS</code></em> and local part <em><code>LP</code></em> can be represented as the URI reference <em><code>NS</code></em><code>#</code><em><code>LP</code></em>. For example, an error whose QName is <code>err:XPST0017</code> could be represented as <code>http://www.w3.org/2005/xqt-errors#XPST0017</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Along with a code identifying an error, implementations may wish to return additional information, such as the location of the error or the processing phase in which it was detected. If an implementation chooses to do so, then the mechanism that it uses to return this information is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p></div></div><div class="div3"><h4><a id="id-handling-dynamic"></a>2.4.3 Handling Dynamic Errors</h4><p>Except as noted in this document, if any operand of an expression raises a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>, the expression also raises a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>. If an expression can validly return a value or raise a dynamic error, the implementation may choose to return the value or raise the dynamic error (see <a href="#id-errors-and-opt"><b>2.4.4 Errors and Optimization</b></a>). For example, the logical expression <code>expr1 and expr2</code> may return the value <code>false</code> if either operand returns <code>false</code>, or may raise a dynamic error if either operand raises a dynamic error.</p><p> If more than one operand of an expression raises an error, the implementation may choose which error is raised by the expression. For example, in this expression: </p><div class="exampleInner"><pre>($x div $y) + xs:decimal($z)</pre></div><p><span style="display: none;" class="delete_version"> both the sub-expressions <code>($x div $y)</code> and <code>xs:decimal($z)</code> may raise an error. The implementation may choose which error is raised by the <code>+</code> expression. Once one operand raises an error, the implementation is not required, but is permitted, to evaluate any other operands.</span><span style="display: none;" class="add_version"> both the sub-expressions <code>($x div $y)</code> and <code>xs:decimal($z)</code> may raise an error. The implementation may choose which error is raised by the "<code>+</code>" expression. Once one operand raises an error, the implementation is not required, but is permitted, to evaluate any other operands.</span><span class="modify_version"> both the sub-expressions <code>($x div $y)</code> and <code>xs:decimal($z)</code> may raise an error. The implementation may choose which error is raised by the <span class="deltaxml-new">"</span><code>+</code><span class="deltaxml-new">"</span> expression. Once one operand raises an error, the implementation is not required, but is permitted, to evaluate any other operands.</span></p><p><span style="display: none;" class="delete_version"> [<a id="dt-error-value" title="error value">Definition</a>: In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called <b>error values</b>.] An implementation may provide a mechanism whereby an application-defined error handler can process error values and produce diagnostic messages. <span class="xquery">XQuery 3.1 provides standard error handling via <a href="https://qt4cg.org/specifications/xquery-40/xquery-40.html#id-try-catch">Section 4.21 Try/Catch Expressions</a><sup><small>XQ40</small></sup>.</span></span><span style="display: none;" class="add_version"> [<a id="dt-error-value" title="error value">Definition</a>: In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called <b>error values</b>.] An implementation may provide a mechanism whereby an application-defined error handler can process error values and produce diagnostic messages. <span class="xquery">XQuery 3.1 provides standard error handling via <a href="https://www.w3.org/TR/xquery-31/#id-try-catch">Section 3.17 Try/Catch Expressions </a><sup><small>XQ31</small></sup>.</span></span><span class="modify_version"> [<a id="dt-error-value" title="error value">Definition</a>: In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called <b>error values</b>.] An implementation may provide a mechanism whereby an application-defined error handler can process error values and produce diagnostic messages. <span class="xquery">XQuery 3.1 provides standard error handling via <a href="https://www.w3.org/TR/xquery-31/#id-try-catch">Section <span class="deltaxml-old">4.21</span><span class="deltaxml-new">3.17</span> Try/Catch Expressions<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">XQ40</span><span class="deltaxml-new">XQ31</span></small></sup>.</span></span></p><p><span style="display: none;" class="delete_version">A dynamic error may be raised by a <a class="termref" title="system function" href="#dt-system-function">system function</a> or operator. For example, the <code>div</code> operator raises an error if its operands are <code>xs:decimal</code> values and its second operand is equal to zero. Errors raised by system functions and operators are defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a> or the host language.</span><span style="display: none;" class="add_version">A dynamic error may be raised by a <a class="termref" title="built-in function" href="#dt-built-in-function">built-in function</a> or operator. For example, the <code>div</code> operator raises an error if its operands are <code>xs:decimal</code> values and its second operand is equal to zero. Errors raised by built-in functions and operators are defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>.</span><span class="modify_version">A dynamic error may be raised by a <a class="termref" title="built-in function" href="#dt-built-in-function"><span class="deltaxml-old">system</span><span class="deltaxml-new">built-in</span> function</a> or operator. For example, the <code>div</code> operator raises an error if its operands are <code>xs:decimal</code> values and its second operand is equal to zero. Errors raised by <span class="deltaxml-old">system</span><span class="deltaxml-new">built-in</span> functions and operators are defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a><span class="deltaxml-old"> or the host language</span>.</span></p><p><span style="display: none;" class="delete_version">A dynamic error can also be raised explicitly by calling the <code>fn:error</code> function, which always raises a dynamic error and never returns a value. This function is defined in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-error">Section 3.1.1 fn:error</a><sup><small>FO40</small></sup>. For example, the following function call raises a dynamic error, providing a QName that identifies the error, a descriptive string, and a diagnostic value (assuming that the prefix <code>app</code> is bound to a namespace containing application-defined error codes):</span><span style="display: none;" class="add_version">A dynamic error can also be raised explicitly by calling the <code>fn:error</code> function, which always raises a dynamic error and never returns a value. This function is defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-error">Section 3.1.1 fn:error </a><sup><small>FO31</small></sup>. For example, the following function call raises a dynamic error, providing a QName that identifies the error, a descriptive string, and a diagnostic value (assuming that the prefix <code>app</code> is bound to a namespace containing application-defined error codes):</span><span class="modify_version">A dynamic error can also be raised explicitly by calling the <code>fn:error</code> function, which always raises a dynamic error and never returns a value. This function is defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-error">Section 3.1.1 fn:error<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>. For example, the following function call raises a dynamic error, providing a QName that identifies the error, a descriptive string, and a diagnostic value (assuming that the prefix <code>app</code> is bound to a namespace containing application-defined error codes):</span></p><div class="exampleInner"><pre><span class="deltaxml-old">error(xs:QName("app:err057"), "Unexpected value", string($v))</span></pre><pre><span class="deltaxml-new">fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))</span></pre></div></div><div class="div3"><h4><a id="id-errors-and-opt"></a>2.4.4 Errors and Optimization</h4><p>Because different implementations may choose to evaluate or optimize an expression in different ways, certain aspects of raising <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a> are <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, as described in this section.</p><p>An implementation is always free to evaluate the operands of an operator in any order.</p><p>In some cases, a processor can determine the result of an expression without accessing all the data that would be implied by the formal expression semantics. For example, the formal description of <a title="filter expression" class="termref" href="#dt-filter-expression">filter expressions</a> suggests that <code>$s[1]</code> should be evaluated by examining all the items in sequence <code>$s</code>, and selecting all those that satisfy the predicate <code>position()=1</code>. In practice, many implementations will recognize that they can evaluate this expression by taking the first item in the sequence and then exiting. If <code>$s</code> is defined by an expression such as <code>//book[author eq 'Berners-Lee']</code>, then this strategy may avoid a complete scan of a large document and may therefore greatly improve performance. However, a consequence of this strategy is that a dynamic error or type error that would be detected if the expression semantics were followed literally might not be detected at all if the evaluation exits early. In this example, such an error might occur if there is a <code>book</code> element in the input data with more than one <code>author</code> subelement.</p><p>The extent to which a processor may optimize its access to data, at the cost of not raising errors, is defined by the following rules.</p><p>Consider an expression <em>Q</em> that has an operand (sub-expression) <em>E</em>. In general the value of <em>E</em> is a sequence. At an intermediate stage during evaluation of the sequence, some of its items will be known and others will be unknown. If, at such an intermediate stage of evaluation, a processor is able to establish that there are only two possible outcomes of evaluating <em>Q</em>, namely the value <em>V</em> or an error, then the processor may deliver the result <em>V</em> without evaluating further items in the operand <em>E</em>. For this purpose, two values are considered to represent the same outcome if their items are pairwise the same, where nodes are the same if they have the same identity, and values are the same if they are equal and have exactly the same type.</p><p>There is an exception to this rule: If a processor evaluates an operand <em>E</em> (wholly or in part), then it is required to establish that the actual value of the operand <em>E</em> does not violate any constraints on its cardinality. For example, the expression <code>$e eq 0</code> results in a type error if the value of <code>$e</code> contains two or more items. A processor is not allowed to decide, after evaluating the first item in the value of <code>$e</code> and finding it equal to zero, that the only possible outcomes are the value <code>true</code> or a type error caused by the cardinality violation. It must establish that the value of <code>$e</code> contains no more than one item.</p><p>These rules apply to all the operands of an expression considered in combination: thus if an expression has two operands <em>E1</em> and <em>E2</em>, it may be evaluated using any samples of the respective sequences that satisfy the above rules.</p><p>The rules cascade: if <em>A</em> is an operand of <em>B</em> and <em>B</em> is an operand of <em>C</em>, then the processor needs to evaluate only a sufficient sample of <em>B</em> to determine the value of <em>C</em>, and needs to evaluate only a sufficient sample of <em>A</em> to determine this sample of <em>B</em>.</p><p>The effect of these rules is that the processor is free to stop examining further items in a sequence as soon as it can establish that further items would not affect the result except possibly by causing an error. For example, the processor may return <code>true</code> as the result of the expression <code>S1 = S2</code> as soon as it finds a pair of equal values from the two sequences.</p><p>Another consequence of these rules is that where none of the items in a sequence contributes to the result of an expression, the processor is not obliged to evaluate any part of the sequence. Again, however, the processor cannot dispense with a required cardinality check: if an empty sequence is not permitted in the relevant context, then the processor must ensure that the operand is not an empty sequence.</p><p>Examples:</p><ul><li><p>If an implementation can find (for example, by using an index) that at least one item returned by <code>$expr1</code> in the following example has the value <code>47</code>, it is allowed to return <code>true</code> as the result of the <code>some</code> expression, without searching for another item returned by <code>$expr1</code> that would raise an error if it were evaluated. </p><div class="exampleInner"><pre>some $x in $expr1 satisfies $x = 47</pre></div></li><li><p>In the following example, if an implementation can find (for example, by using an index) the <code>product</code> element-nodes that have an <code>id</code> child with the value <code>47</code>, it is allowed to return these nodes as the result of the <a title="path expression" class="termref" href="#dt-path-expression">path expression</a>, without searching for another <code>product</code> node that would raise an error because it has an <code>id</code> child whose value is not an integer.</p><div class="exampleInner"><pre>//product[id = 47]</pre></div></li></ul><p>For a variety of reasons, including optimization, implementations may rewrite expressions into a different form. There are a number of rules that limit the extent of this freedom: </p><ul><li><p> Other than the raising or not raising of errors, the result of evaluating a rewritten expression must conform to the semantics defined in this specification for the original expression. </p><div class="note"><p class="prefix"><b>Note:</b></p><p> This allows an implementation to return a result in cases where the original expression would have raised an error, or to raise an error in cases where the original expression would have returned a result. The main cases where this is likely to arise in practice are (a) where a rewrite changes the order of evaluation, such that a subexpression causing an error is evaluated when the expression is written one way and is not evaluated when the expression is written a different way, and (b) where intermediate results of the evaluation cause overflow or other out-of-range conditions. </p></div><div class="note"><p class="prefix"><b>Note:</b></p><p> This rule does not mean that the result of the expression will always be the same in non-error cases as if it had not been rewritten, because there are many cases where the result of an expression is to some degree <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> or <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. </p></div></li><li><p> The rules described in <a href="#id-guarded-expressions"><b>2.4.5 Guarded Expressions</b></a> ensure that for certain kinds of expression (for example conditional expressions), changing the order of evaluation of subexpressions does not result in dynamic errors that would not otherwise occur.</p></li><li><p> Expressions must not be rewritten in such a way as to create or remove static errors. The static errors in this specification are defined for the original expression, and must be preserved if the expression is rewritten.</p></li><li><p> As stated earlier, an expression must not be rewritten to dispense with a required cardinality check: for example, <code>string-length(//title)</code> must raise an error if the document contains more than one title element. </p></li></ul></div><div class="div3"><h4><a id="id-guarded-expressions"></a>2.4.5 Guarded Expressions</h4><p> [<a id="dt-guarded" title="guarded">Definition</a>: An expression <var>E</var> is said to be <b>guarded</b> by some governing condition <var>C</var> if evaluation of <var>E</var> is not allowed to fail with a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> except when <var>C</var> applies.] </p><p>For example, in a conditional expression <code>if (P) then T else F</code>, the subexpression <var>T</var> is guarded by <var>P</var>, and the subexpression <var>F</var> is guarded by <code>not(P)</code>. One way an implementation can satisfy this rule is by not evaluating <var>T</var> unless <var>P</var> is true, and likewise not evaluating <var>F</var> unless <var>P</var> is false. Another way of satisfying the rule is for the implementation to evaluate all the subexpressions, but to catch any errors that occur in a guarded subexpression so they are not propagated. </p><p>The existence of this rule enables errors to be prevented by writing expressions such as <code>if ($y eq 0) then "N/A" else ($x div $y)</code>. This example will never fail with a divide-by-zero error because the <code>else</code> branch of the conditional is <a title="guarded" class="termref" href="#dt-guarded">guarded</a>.</p><p><span style="display: none;" class="delete_version">Similarly, in the mapping expression <code>E1!E2</code>, the subexpression <code>E2</code> is guarded by the existence of an item from <code>E1</code>. This means, for example, that the expression <code>(1 to $n)!doc('bad.xml')</code> must not raise a dynamic error if <code>$n</code> is zero. The rule governing evaluation of guarded expressions is phrased so as not to disallow “loop-lifting” or “constant-folding” optimizations whose aim is to avoid repeated evaluation of a common subexpression; but such optimizations must not result in errors that would not otherwise occur.</span><span style="display: none;" class="add_version">Similarly, in the mapping expression <code>E1!E2</code>, the subexpression <code>E2</code> is guarded by the existence of an item from <var>E<sub>1</sub></var>. This means, for example, that the expression <code>(1 to $n)!doc('bad.xml')</code> must not raise a dynamic error if <code>$n</code> is zero. The rule governing evaluation of guarded expressions is phrased so as not to disallow “loop-lifting” or “constant-folding” optimizations whose aim is to avoid repeated evaluation of a common subexpression; but such optimizations must not result in errors that would not otherwise occur.</span><span class="modify_version">Similarly, in the mapping expression <code>E1!E2</code>, the subexpression <code>E2</code> is guarded by the existence of an item from <var><span class="deltaxml-old">E1</span><span class="deltaxml-new">E</span><sub><span class="deltaxml-new">1</span></sub></var>. This means, for example, that the expression <code>(1 to $n)!doc('bad.xml')</code> must not raise a dynamic error if <code>$n</code> is zero. The rule governing evaluation of guarded expressions is phrased so as not to disallow “loop-lifting” or “constant-folding” optimizations whose aim is to avoid repeated evaluation of a common subexpression; but such optimizations must not result in errors that would not otherwise occur.</span></p><p>The complete list of expressions that have guarded subexpressions is as follows:</p><ul><li><p>In a conditional expression (<a href="#doc-xquery40-IfExpr">IfExpr</a>) the <code>then</code> branch is guarded by the condition being true, and the <code>else</code> branch is guarded by the condition being false.</p></li><li class="xquery"><p>In a <code>switch</code> expression (<a href="#doc-xquery40-SwitchExpr">SwitchExpr</a>), the <code>return</code> expression of a particular <code>case</code> is guarded by the condition for that case matching, and no earlier case matching.</p></li><li class="xquery"><p>In a <code>typeswitch</code> expression (<a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a>), the <code>return</code> expression of a particular <code>case</code> is guarded by the condition for that case matching, and no earlier case matching.</p></li><li><p>In an <code>and</code> expression (<a href="#doc-xquery40-AndExpr">AndExpr</a>), the second operand is guarded by the value of the first operand being true.</p></li><li><p>In an <code>or</code> expression (<a href="#doc-xquery40-OrExpr">OrExpr</a>), the second operand is guarded by the value of the first operand being false.</p></li><li><p>In an <code>otherwise</code> expression (<a href="#doc-xquery40-OtherwiseExpr">OtherwiseExpr</a>), the second operand is guarded by the value of the first operand being an empty sequence.</p></li><li><p><span style="display: none;" class="delete_version">In a path expression of the form <code>E1/E2</code> or <code>E1//E2</code>, and in a mapping expression of the form <code>E1!E2</code>, the right-hand operand <code>E2</code> is guarded by the existence of at least one item in the result of evaluating <code>E1</code>.</span><span style="display: none;" class="add_version">In a path expression of the form <code>E1/E2</code> or <code>E1//E2</code>, and in a mapping expression of the form <code>E1!E2</code>, the right-hand operand <code>E2</code> is guarded by the existence of the relevant context item in the result of evaluating <code>E1</code>.</span><span class="modify_version">In a path expression of the form <code>E1/E2</code> or <code>E1//E2</code>, and in a mapping expression of the form <code>E1!E2</code>, the right-hand operand <code>E2</code> is guarded by the existence of <span class="deltaxml-old">at least one</span><span class="deltaxml-new">the relevant context</span> item in the result of evaluating <code>E1</code>.</span></p><p><span style="display: none;" class="delete_version">This rule applies even if <code>E2</code> does not reference the context value. For example, no dynamic error can be thrown by the expression <code>(1 to $n)!doc('bad.xml')</code> in the case where <code>$n</code> is zero.</span><span style="display: none;" class="add_version">This rule applies even if <code>E2</code> does not reference the context item. For example, no dynamic error can be thrown by the expression <code>(1 to $n)!doc('bad.xml')</code> in the case where <code>$n</code> is zero.</span><span class="modify_version">This rule applies even if <code>E2</code> does not reference the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>. For example, no dynamic error can be thrown by the expression <code>(1 to $n)!doc('bad.xml')</code> in the case where <code>$n</code> is zero.</span></p></li><li><p><span style="display: none;" class="delete_version">In a filter expression of the form <code>E[P]</code>, the predicate <code>P</code> is guarded by the existence of at least one item in the result of evaluating <code>E</code>.</span><span style="display: none;" class="add_version">In a filter expression of the form <code>E[P]</code>, the predicate <code>P</code> is guarded by the existence of the relevant context item in the result of evaluating <code>E</code>.</span><span class="modify_version">In a filter expression of the form <code>E[P]</code>, the predicate <code>P</code> is guarded by the existence of <span class="deltaxml-old">at least one</span><span class="deltaxml-new">the relevant context</span> item in the result of evaluating <code>E</code>.</span></p><p><span style="display: none;" class="delete_version">This rule has the consequence that in a filter expression with multiple predicates, such as <code>E[P1][P2]</code>, evaluation of <code>P2</code> must not raise a dynamic error unless <code>P1</code> returns <code>true</code>. This rule does not prevent reordering of predicates (for example, to take advantage of indexes), but it does require that any such reordering must not result in errors that would not otherwise occur.</span><span style="display: none;" class="add_version">This rule has the consequence that in a filter expression with multiple predicates, such as <code>E[P1][P2]</code>, evaluation of <code>P2</code> must not raise a dynamic error unless <code>P1</code> returns true. This rule does not prevent reordering of predicates (for example, to take advantage of indexes), but it does require that any such reordering must not result in errors that would not otherwise occur.</span><span class="modify_version">This rule has the consequence that in a filter expression with multiple predicates, such as <code>E[P1][P2]</code>, evaluation of <code>P2</code> must not raise a dynamic error unless <code>P1</code> returns true. This rule does not prevent reordering of predicates (for example, to take advantage of indexes), but it does require that any such reordering must not result in errors that would not otherwise occur.</span></p></li><li><p class="xquery">In a <code>FLWOR</code> expression (<a href="#doc-xquery40-FLWORExpr">FLWORExpr</a>), an expression that is logically dependent on the tuples in the tuple stream is guarded by the existence of a relevant tuple. This applies even where the expression does not actually reference any of the variable bindings in the tuple stream. For example, in the expression <code>for $x in S return E</code>, the expression <code>E</code> is guarded by the existence of an item bound to <code>$x</code>.</p><p>This means that the expression <code>for $x in 1 to $n return doc('bad.xml')</code> must not raise a dynamic error in the case where <code>$n</code> is zero.</p></li><li><p>In a <code>quantified</code> expression (<a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a>) such as <code>some $x in S satisfies P</code>, the expression <code>P</code> is guarded by the existence of an item bound to <code>$x</code>.</p></li></ul><p>The fact that an expression is <a title="guarded" class="termref" href="#dt-guarded">guarded</a> does not remove the obligation to report <a title="static error" class="termref" href="#dt-static-error">static errors</a> in the expression; nor does it remove the option to report statically detectable <a title="type error" class="termref" href="#dt-type-error">type errors</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>These rules do not constrain the order of evaluation of subexpressions. For example, given an expression such as <code>//person[@first="Winston"][@last="Churchill"]</code>, or equivalently <code>//person[@first="Winston" and @last="Churchill"]</code>, an implementation might use an index on the value of <code>@last</code> to select items that satisfy the second condition, and then filter these items on the value of the first condition. Alternatively, it might evaluate both predicates in parallel. Or it might interpose an additional redundant condition: <code>//person[string-length(@first)+string-length(@last)=16][@first="Winston"][@last="Churchill"]</code>. But implementations must ensure that such rewrites do not result in dynamic errors being reported that would not occur if the predicates were evaluated in order as written.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Although the rules for guarded expressions prevent optimizations resulting in spurious errors, they do not prevent optimizations whose effect is to mask errors. For example, the rules guarantee that <code>("A", 3)[. instance of xs:integer][. eq 3]</code> will not raise an error caused by the comparison <code>("A" eq 3)</code>, but they do not guarantee the converse: the expression <code>("A", 3)[. eq 3][. instance of xs:integer]</code> may or may not raise a dynamic error.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The rules in this section do not disallow all expression rewrites that might result in dynamic errors. For example, rewriting <code>($x - $y + $z)</code> as <code>($x + $z - $y)</code> is permitted even though it might result in an arithmetic overflow.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Some implementations allow calls on external functions that have side-effects. The semantics of such function calls are entirely <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation defined</a>. Processors <strong>may</strong> choose to reference the rules for <a title="guarded" class="termref" href="#dt-guarded">guarded</a> expressions when defining the behavior of such function calls, but this is outside the scope of the language specification.</p></div></div><div class="div3"><h4><a id="id-implausible-expressions"></a><span class="deltaxml-old">2.4.6 Implausible Expressions</span></h4><p><span class="deltaxml-old"> [</span><a id="dt-implausible" title="implausible"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: Certain expressions, while not erroneous, are classified as being </span><b><span class="deltaxml-old">implausible</span></b><span class="deltaxml-old">, because they achieve no useful effect.] </span></p><p><span class="deltaxml-old">An example of an implausible expression is </span><code><span class="deltaxml-old">@code/text()</span></code><span class="deltaxml-old">. This expression will always evaluate to an empty sequence, because attribute nodes cannot have text node children. The semantics of the expression are well defined, but it is likely that the user writing this expression intended something different; if they wanted to an expression that evaluated to an empty sequence, there would be easier ways to write it.</span></p><p><span class="deltaxml-old">Where an expression is classified (by rules in this specification) as being </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-old">implausible</span></a><span class="deltaxml-old">, a processor </span><strong><span class="deltaxml-old">may</span></strong><span class="deltaxml-old"> (but is not </span><strong><span class="deltaxml-old">required</span></strong><span class="deltaxml-old"> to) raise a static error.</span></p><p><span class="deltaxml-old">For reasons of backwards compatibility and interoperability, and to facilitate automatic generation of XQuery 4.0 code, a processor </span><strong><span class="deltaxml-old">must</span></strong><span class="deltaxml-old"> provide a mode of operation in which </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-old">implausible</span></a><span class="deltaxml-old"> expressions are not treated as static errors, but are evaluated with the defined semantics for the expression.</span></p><p><span class="deltaxml-old">Some other examples of implausible expressions include:</span></p><ul><li><p><code><span class="deltaxml-old">round(tokenize($input))</span></code><span class="deltaxml-old">. The result of </span><code><span class="deltaxml-old">fn:tokenize</span></code><span class="deltaxml-old"> is a sequence of strings (</span><code><span class="deltaxml-old">xs:string*</span></code><span class="deltaxml-old">), while the required type for the first argument of </span><code><span class="deltaxml-old">fn:round</span></code><span class="deltaxml-old"> is optional numeric (</span><code><span class="deltaxml-old">xs:numeric?</span></code><span class="deltaxml-old">). The expression can succeed only in the exceptional case where the result of </span><code><span class="deltaxml-old">fn:tokenize</span></code><span class="deltaxml-old"> is an empty sequence, in which case the result of </span><code><span class="deltaxml-old">fn:round</span></code><span class="deltaxml-old"> will also be an empty sequence; it is therefore highly likely that the expression was written in error.</span></p></li><li><p><code><span class="deltaxml-old">parse-csv($input)?column-names</span></code><span class="deltaxml-old">. The signature of the </span><code><span class="deltaxml-old">parse-csv</span></code><span class="deltaxml-old"> function declares its return type as </span><code><span class="deltaxml-old">record(columns, rows)</span></code><span class="deltaxml-old">. There is no field in this record named </span><code><span class="deltaxml-old">column-names</span></code><span class="deltaxml-old">, and therefore the lookup expression will always return an empty sequence. Again, there is no good reason that a user would write this, so it is likely that it was written in error.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The specification is deliberately conservative in the choice of constructs that have been classified as implausible. Constructs have not been classified as implausible merely because there are better ways of writing the same thing, but only in cases where it is considered that no user in full understanding of the specification would intentionally write such a construct. All these cases correspond to situations that would be classed as errors in a language with stricter static typing rules.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">In many cases the classification of constructs as implausible is designed to protect users from usability problems that have been found with earlier versions of the language. without introducing backwards incompatibilities.</span></p></div></div></div><div class="div2"><h3><a id="id-important-concepts"></a>2.5 Concepts</h3><p>This section explains some concepts that are important to the processing of XQuery 4.0 expressions.</p><div class="div3"><h4><a id="id-document-order"></a>2.5.1 Document Order</h4><p><span style="display: none;" class="delete_version">An ordering called <b>document order</b> is defined among all the nodes accessible during processing of a given <span class="xquery">query</span> , which may consist of one or more <b>trees</b> (documents or fragments). Document order is defined in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#document-order">Section 2.5 Document Order</a><sup><small>DM40</small></sup>, and its definition is repeated here for convenience. Document order is a total ordering, although the relative order of some nodes is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. [<a id="dt-document-order" title="document order">Definition</a>: Informally, <b>document order</b> is the order in which nodes appear in the XML serialization of a document.] [<a id="stable" title="stable">Definition</a>: Document order is <b>stable</b>, which means that the relative order of two nodes will not change during the processing of a given <span class="xquery">query</span> , even if this order is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.] [<a id="dt-reverse-document-order" title="reverse document order">Definition</a>: The node ordering that is the reverse of document order is called <b>reverse document order</b>.] </span><span style="display: none;" class="add_version">An ordering called <b>document order</b> is defined among all the nodes accessible during processing of a given <span class="xquery">query</span> , which may consist of one or more <b>trees</b> (documents or fragments). Document order is defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#document-order">Section 2.4 Document Order </a><sup><small>DM31</small></sup>, and its definition is repeated here for convenience. Document order is a total ordering, although the relative order of some nodes is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. [<a id="dt-document-order" title="document order">Definition</a>: Informally, <b>document order</b> is the order in which nodes appear in the XML serialization of a document.] [<a id="stable" title="stable">Definition</a>: Document order is <b>stable</b>, which means that the relative order of two nodes will not change during the processing of a given <span class="xquery">query</span> , even if this order is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.] [<a id="dt-reverse-document-order" title="reverse document order">Definition</a>: The node ordering that is the reverse of document order is called <b>reverse document order</b>.] </span><span class="modify_version">An ordering called <b>document order</b> is defined among all the nodes accessible during processing of a given <span class="xquery">query</span> , which may consist of one or more <b>trees</b> (documents or fragments). Document order is defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#document-order">Section <span class="deltaxml-old">2.5</span><span class="deltaxml-new">2.4</span> Document Order<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>, and its definition is repeated here for convenience. Document order is a total ordering, although the relative order of some nodes is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. [<a id="dt-document-order" title="document order">Definition</a>: Informally, <b>document order</b> is the order in which nodes appear in the XML serialization of a document.] [<a id="stable" title="stable">Definition</a>: Document order is <b>stable</b>, which means that the relative order of two nodes will not change during the processing of a given <span class="xquery">query</span> , even if this order is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.] [<a id="dt-reverse-document-order" title="reverse document order">Definition</a>: The node ordering that is the reverse of document order is called <b>reverse document order</b>.] </span></p><p>Within a tree, document order satisfies the following constraints:</p><ol class="enumar"><li><p>The root node is the first node.</p></li><li><p>Every node occurs before all of its children and descendants.</p></li><li><p>Attribute nodes immediately follow the element node with which they are associated. The relative order of attribute nodes is stable but <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p></li><li><p>The relative order of siblings is the order in which they occur in the <code>children</code> property of their parent node.</p></li><li><p>Children and descendants occur before following siblings.</p></li></ol><p>The relative order of nodes in distinct trees is stable but <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, subject to the following constraint: If any node in a given tree T1 is before any node in a different tree T2, then all nodes in tree T1 are before all nodes in tree T2.</p></div><div class="div3"><h4><a id="id-atomization"></a>2.5.2 Atomization</h4><p><span style="display: none;" class="delete_version">The semantics of some XQuery 4.0 operators depend on a process called <a title="atomization" class="termref" href="#dt-atomization">atomization</a>. Atomization is applied to a value when the value is used in a context in which a sequence of atomic values is required. The result of atomization is either a sequence of atomic values or a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FOTY0012" href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOTY0012">err:FOTY0012</a>]<sup><small>FO40</small></sup>. [<a id="dt-atomization" title="atomization">Definition</a>: <b>Atomization</b> of a sequence is defined as the result of invoking the <code>fn:data</code> function, as defined in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-data">Section 2.4 fn:data</a><sup><small>FO40</small></sup>.] </span><span style="display: none;" class="add_version">The semantics of some XQuery 4.0 operators depend on a process called <a title="atomization" class="termref" href="#dt-atomization">atomization</a>. Atomization is applied to a value when the value is used in a context in which a sequence of atomic values is required. The result of atomization is either a sequence of atomic values or a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FOTY0012" href="https://www.w3.org/TR/xpath-functions-31/#ERRFOTY0012">err:FOTY0012</a>]<sup><small>FO31</small></sup>. [<a id="dt-atomization" title="atomization">Definition</a>: <b>Atomization</b> of a sequence is defined as the result of invoking the <code>fn:data</code> function, as defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-data">Section 2.4 fn:data </a><sup><small>FO31</small></sup>.] </span><span class="modify_version">The semantics of some XQuery 4.0 operators depend on a process called <a title="atomization" class="termref" href="#dt-atomization">atomization</a>. Atomization is applied to a value when the value is used in a context in which a sequence of atomic values is required. The result of atomization is either a sequence of atomic values or a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FOTY0012" href="https://www.w3.org/TR/xpath-functions-31/#ERRFOTY0012">err:FOTY0012</a>]<sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>. [<a id="dt-atomization" title="atomization">Definition</a>: <b>Atomization</b> of a sequence is defined as the result of invoking the <code>fn:data</code> function, as defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-data">Section 2.4 fn:data<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>.] </span></p><p> The semantics of <code>fn:data</code> are repeated here for convenience. The result of <code>fn:data</code> is the sequence of atomic values produced by applying the following rules to each item in the input sequence:</p><ul><li><p>If the item is an atomic value, it is returned.</p></li><li><p><span style="display: none;" class="delete_version">If the item is a node, its <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> is returned (a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FOTY0012" href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOTY0012">err:FOTY0012</a>]<sup><small>FO40</small></sup> is raised if the node has no typed value.)</span><span style="display: none;" class="add_version">If the item is a node, its <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> is returned (a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FOTY0012" href="https://www.w3.org/TR/xpath-functions-31/#ERRFOTY0012">err:FOTY0012</a>]<sup><small>FO31</small></sup> is raised if the node has no typed value.)</span><span class="modify_version">If the item is a node, its <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> is returned (a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FOTY0012" href="https://www.w3.org/TR/xpath-functions-31/#ERRFOTY0012">err:FOTY0012</a>]<sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup> is raised if the node has no typed value.)</span></p></li><li><p><span style="display: none;" class="delete_version">If the item is a <a title="function item" class="termref" href="#dt-function-item">function item</a> (other than an array) or map a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FOTY0013" href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOTY0013">err:FOTY0013</a>]<sup><small>FO40</small></sup> is raised.</span><span style="display: none;" class="add_version">If the item is a <a title="function item" class="termref" href="#dt-function-item">function item</a> (other than an array) or map a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FOTY0013" href="https://www.w3.org/TR/xpath-functions-31/#ERRFOTY0013">err:FOTY0013</a>]<sup><small>FO31</small></sup> is raised.</span><span class="modify_version">If the item is a <a title="function item" class="termref" href="#dt-function-item">function item</a> (other than an array) or map a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FOTY0013" href="https://www.w3.org/TR/xpath-functions-31/#ERRFOTY0013">err:FOTY0013</a>]<sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup> is raised.</span></p></li><li><p>If the item is an array <code>$a</code>, atomization is defined as <code>$a?* ! fn:data(.)</code>, which is equivalent to atomizing the members of the array.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This definition recursively atomizes members that are arrays. Hence, the result of atomizing the array <code>[ [1, 2, 3], [4, 5, 6] ]</code> is the sequence <code>(1, 2, 3, 4, 5, 6)</code>.</p></div></li></ul><p>Atomization is used in processing the following types of expressions: </p><ul><li><p>Arithmetic expressions</p></li><li><p>Comparison expressions</p></li><li><p>Function calls and returns</p></li><li><p>Cast expressions</p></li><li class="xquery"><p>Constructor expressions for various kinds of nodes</p></li><li class="xquery"><p><code>order by</code> clauses in FLWOR expressions</p></li><li class="xquery"><p><code>group by</code> clauses in FLWOR expressions</p></li><li class="xquery"><p>Switch expressions</p></li></ul></div><div class="div3"><h4><a id="id-ebv"></a>2.5.3 Effective Boolean Value</h4><p><span style="display: none;" class="delete_version">Under certain circumstances (listed below), it is necessary to find the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of a value. [<a id="dt-ebv" title="effective boolean value">Definition</a>: The <b>effective boolean value</b> of a value is defined as the result of applying the <code>fn:boolean</code> function to the value, as defined in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-boolean">Section 7.3.1 fn:boolean</a><sup><small>FO40</small></sup>.] </span><span style="display: none;" class="add_version">Under certain circumstances (listed below), it is necessary to find the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of a value. [<a id="dt-ebv" title="effective boolean value">Definition</a>: The <b>effective boolean value</b> of a value is defined as the result of applying the <code>fn:boolean</code> function to the value, as defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-boolean">Section 7.3.1 fn:boolean </a><sup><small>FO31</small></sup>.] </span><span class="modify_version">Under certain circumstances (listed below), it is necessary to find the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of a value. [<a id="dt-ebv" title="effective boolean value">Definition</a>: The <b>effective boolean value</b> of a value is defined as the result of applying the <code>fn:boolean</code> function to the value, as defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-boolean">Section 7.3.1 fn:boolean<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>.] </span></p><p>The dynamic semantics of <code>fn:boolean</code> are repeated here for convenience:</p><ol class="enumar"><li><p>If its operand is an empty sequence, <code>fn:boolean</code> returns <code>false</code>.</p></li><li><p>If its operand is a sequence whose first item is a node, <code>fn:boolean</code> returns <code>true</code>.</p></li><li><p>If its operand is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> value of type <code>xs:boolean</code> or derived from <code>xs:boolean</code>, <code>fn:boolean</code> returns the value of its operand unchanged.</p></li><li><p>If its operand is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> value of type <code>xs:string</code>, <code>xs:anyURI</code>, <code>xs:untypedAtomic</code>, or a type derived from one of these, <code>fn:boolean</code> returns <code>false</code> if the operand value has zero length; otherwise it returns <code>true</code>.</p></li><li><p>If its operand is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> value of any <a title="numeric" class="termref" href="#dt-numeric">numeric</a> type or derived from a numeric type, <code>fn:boolean</code> returns <code>false</code> if the operand value is <code>NaN</code> or is numerically equal to zero; otherwise it returns <code>true</code>.</p></li><li><p><span style="display: none;" class="delete_version">In all other cases, <code>fn:boolean</code> raises a type error [<a title="err:FORG0006" href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0006">err:FORG0006</a>]<sup><small>FO40</small></sup>.</span><span style="display: none;" class="add_version">In all other cases, <code>fn:boolean</code> raises a type error [<a title="err:FORG0006" href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0006">err:FORG0006</a>]<sup><small>FO31</small></sup>.</span><span class="modify_version">In all other cases, <code>fn:boolean</code> raises a type error [<a title="err:FORG0006" href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0006">err:FORG0006</a>]<sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>For instance, <code>fn:boolean</code> raises a type error if the operand is a function, a map, or an array.</p></div></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of a sequence that contains at least one node and at least one atomic value is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> in regions of a query where <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>unordered</code>.</p></div><p>The <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of a sequence is computed implicitly during processing of the following types of expressions: </p><ul><li><p>Logical expressions (<code>and</code>, <code>or</code>)</p></li><li><p>The <code>fn:not</code> function</p></li><li class="xquery"><p>The <code>where</code> clause of a FLWOR expression</p></li><li><p>Certain types of <a title="" class="termref" href="#dt-predicate">predicates</a>, such as <code>a[b]</code></p></li><li><p>Conditional expressions (<code>if</code>)</p></li><li><p>Quantified expressions (<code>some</code>, <code>every</code>)</p></li><li class="xquery"><p><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a> and <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a> in <code>window</code> clauses.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The definition of <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> is <em>not</em> used when casting a value to the type <code>xs:boolean</code>, for example in a <code>cast</code> expression or when passing a value to a function whose expected parameter is of type <code>xs:boolean</code>.</p></div></div><div class="div3"><h4><a id="id-input-sources"></a>2.5.4 Input Sources</h4><p><span style="display: none;" class="delete_version">XQuery 4.0 has a set of functions that provide access to XML documents (<code>fn:doc</code>, <code>fn:doc-available</code>), collections (<code>fn:collection</code>, <code>fn:uri-collection</code>), text files (<code>fn:unparsed-text</code>, <code>fn:unparsed-text-lines</code>, <code>fn:unparsed-text-available</code>), and environment variables (<code>fn:environment-variable</code>, <code>fn:available-environment-variables</code>). These functions are defined in <a href="https://qt4cg.org/specifications/xpath-functions-40/#fns-on-docs">Section 14.6 Functions giving access to external information</a><sup><small>FO40</small></sup>.</span><span style="display: none;" class="add_version">XQuery 4.0 has a set of functions that provide access to XML documents (<code>fn:doc</code>, <code>fn:doc-available</code>), collections (<code>fn:collection</code>, <code>fn:uri-collection</code>), text files (<code>fn:unparsed-text</code>, <code>fn:unparsed-text-lines</code>, <code>fn:unparsed-text-available</code>), and environment variables (<code>fn:environment-variable</code>, <code>fn:available-environment-variables</code>). These functions are defined in <a href="https://www.w3.org/TR/xpath-functions-31/#fns-on-docs">Section 14.6 Functions giving access to external information </a><sup><small>FO31</small></sup>.</span><span class="modify_version">XQuery 4.0 has a set of functions that provide access to XML documents (<code>fn:doc</code>, <code>fn:doc-available</code>), collections (<code>fn:collection</code>, <code>fn:uri-collection</code>), text files (<code>fn:unparsed-text</code>, <code>fn:unparsed-text-lines</code>, <code>fn:unparsed-text-available</code>), and environment variables (<code>fn:environment-variable</code>, <code>fn:available-environment-variables</code>). These functions are defined in <a href="https://www.w3.org/TR/xpath-functions-31/#fns-on-docs">Section 14.6 Functions giving access to external information<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>.</span></p><p>An expression can access input data either by calling one of these input functions or by referencing some part of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> that is initialized by the external environment, such as a <a title="variable values" class="termref" href="#dt-variable-values">variable</a> or <a class="termref" title="context item" href="#dt-context-item">context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span></a>.</p></div><div class="div3"><h4><a id="id-uri-literals"></a>2.5.5 URI Literals</h4><p>XQuery 4.0 requires a statically known, valid URI in <span class="xquery">a <a href="#doc-xquery40-URILiteral">URILiteral</a> or </span>a <a href="#doc-xquery40-BracedURILiteral">BracedURILiteral</a>. An implementation may raise a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0046" title="err:XQST0046">err:XQST0046</a>] if the value of <span class="xquery">a URI Literal or</span> a Braced URI Literal is of nonzero length and is neither an absolute URI nor a relative URI.</p><p class="xquery">As in a string literal, any <a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference">predefined entity reference</a> (such as <code>&amp;amp;</code>), <a title="character reference" class="termref" href="#dt-character-reference">character reference</a> (such as <code>&amp;#x2022;</code>), or <a href="#doc-xquery40-EscapeQuot">EscapeQuot</a> or <a href="#doc-xquery40-EscapeApos">EscapeApos</a> (for example, <code>""</code>) is replaced by its appropriate expansion. Certain characters, notably the ampersand, can only be represented using a <a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference">predefined entity reference</a> or a <a title="character reference" class="termref" href="#dt-character-reference">character reference</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">The <code>xs:anyURI</code> type is designed to anticipate the introduction of Internationalized Resource Identifiers (IRIs) as defined in <a href="#RFC3987">[RFC3987]</a>.</span><span style="display: none;" class="add_version">The <code>xs:anyURI</code> type is designed to anticipate the introduction of Internationalized Resource Identifiers (IRI's) as defined in <a href="#RFC3987">[RFC3987]</a>.</span><span class="modify_version">The <code>xs:anyURI</code> type is designed to anticipate the introduction of Internationalized Resource Identifiers (<span class="deltaxml-old">IRIs</span><span class="deltaxml-new">IRI's</span>) as defined in <a href="#RFC3987">[RFC3987]</a>.</span></p></div><p>Whitespace is normalized using the whitespace normalization rules of <code>fn:normalize-space</code>. If the result of whitespace normalization contains only whitespace, the corresponding URI consists of the empty string. <span class="xquery">Whitespace normalization is done after the expansion of <a title="character reference" class="termref" href="#dt-character-reference">character references</a>, so writing a newline (for example) as <code>&amp;#xA;</code> does not prevent its being normalized to a space character.</span></p><p>A Braced URI Literal or URI Literal is not subjected to percent-encoding or decoding as defined in <a href="#RFC3986">[RFC3986]</a>.</p></div><div class="div3"><h4><a id="id-resolve-relative-uri"></a>2.5.6 Resolving a Relative URI Reference</h4><p> [<a id="dt-resolve-relative-uri" title="resolve">Definition</a>: To <b>resolve a relative URI</b><code>$rel</code> against a base URI <code>$base</code> is to expand it to an absolute URI, as if by calling the function <code>fn:resolve-uri($rel, $base)</code>.] During static analysis, the base URI is the Static Base URI. During dynamic evaluation, the base URI used to resolve a relative URI reference depends on the semantics of the expression.</p><p>Any process that attempts to <a title="resolve" href="#dt-resolve-relative-uri" class="termref">resolve <span class="deltaxml-old">a </span>URI</a> against a base URI, or to dereference the URI, may apply percent-encoding or decoding as defined in the relevant RFCs.</p></div></div></div><div class="div1"><h2><a id="id-types"></a>3 Types</h2><p>The type system of XQuery 4.0 is based on <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>. </p><p> [<a id="dt-sequence-type" title="sequence type">Definition</a>: A <b>sequence type</b> is a type that can be expressed using the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax. Sequence types are used whenever it is necessary to refer to a type in an XQuery 4.0 expression. The term <b>sequence type</b> suggests that this syntax is used to describe the type of an XQuery 4.0 value, which is always a sequence.] </p><p><span style="display: none;" class="delete_version"> [<a id="dt-item-type" title="item type">Definition</a>: An <b>item type</b> is a type that can be expressed using the <a href="#doc-xquery40-ItemType">ItemType</a> syntax, which forms part of the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax. Item types match individual <a title="item" class="termref" href="#dt-item">items</a>.] With the exception of the generic types <code>item()</code>, which matches all items, and <code>xs:error</code>, which matches no items, the set of items matched by an item type consists either exclusively of <a title="atomic value" class="termref" href="#dt-atomic-value">atomic values</a>, exclusively of <a title="node" class="termref" href="#dt-node">nodes</a>, or exclusively of <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-function-item">function items</a><sup><small>DM40</small></sup>. </span><span style="display: none;" class="add_version"> [<a id="dt-item-type" title="item type">Definition</a>: An <b>item type</b> is a type that can be expressed using the <a href="#doc-xquery40-ItemType">ItemType</a> syntax, which forms part of the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax. Item types match individual <a title="item" class="termref" href="#dt-item">items</a>.] With the exception of the generic types <code>item()</code>, which matches all items, and <code>xs:error</code>, which matches no items, the set of items matched by an item type consists either exclusively of <a title="atomic value" class="termref" href="#dt-atomic-value">atomic values</a>, exclusively of <a title="node" class="termref" href="#dt-node">nodes</a>, or exclusively of <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function items</a><sup><small>DM31</small></sup>. </span><span class="modify_version"> [<a id="dt-item-type" title="item type">Definition</a>: An <b>item type</b> is a type that can be expressed using the <a href="#doc-xquery40-ItemType">ItemType</a> syntax, which forms part of the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax. Item types match individual <a title="item" class="termref" href="#dt-item">items</a>.] With the exception of the generic types <code>item()</code>, which matches all items, and <code>xs:error</code>, which matches no items, the set of items matched by an item type consists either exclusively of <a title="atomic value" class="termref" href="#dt-atomic-value">atomic values</a>, exclusively of <a title="node" class="termref" href="#dt-node">nodes</a>, or exclusively of <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-function-item">function items</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>. </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>These definitions require a caveat: types defined in a schema may be anonymous, in which case they cannot be referenced directly using the <a href="#doc-xquery40-ItemType">ItemType</a> or <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax. For example an element that is validated against an anonymous complex type <var>A</var> conforms to an item type which could be written <code>element(*, A)</code> but for the fact that <var>A</var> is anonymous.</p></div><p><span class="deltaxml-old">In many situations the terms </span><b><span class="deltaxml-old">item type</span></b><span class="deltaxml-old"> and </span><b><span class="deltaxml-old">sequence type</span></b><span class="deltaxml-old"> are used interchangeably to refer either to the type itself, or to the syntactic construct that designates the type: so in the expression </span><code><span class="deltaxml-old">$x instance of xs:string*</span></code><span class="deltaxml-old">, the construct </span><code><span class="deltaxml-old">xs:string*</span></code><span class="deltaxml-old"> uses the </span><a href="#doc-xquery40-SequenceType"><span class="deltaxml-old">SequenceType</span></a><span class="deltaxml-old"> syntax to designate a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-old">sequence type</span></a><span class="deltaxml-old"> whose instances are sequences of strings. When more precision is required, the specification is careful to use the terms </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-old">item type</span></a><span class="deltaxml-old"> and </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-old">sequence type</span></a><span class="deltaxml-old"> to refer to the actual types, while using the production names </span><a href="#doc-xquery40-ItemType"><span class="deltaxml-old">ItemType</span></a><span class="deltaxml-old"> and </span><a href="#doc-xquery40-SequenceType"><span class="deltaxml-old">SequenceType</span></a><span class="deltaxml-old"> to refer to the syntactic designators of these types.</span></p><p><span class="deltaxml-old"> [</span><a id="dt-sequence-type-designator" title="sequence type designator"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">sequence type designator</span></b><span class="deltaxml-old"> is a syntactic construct conforming to the grammar rule </span><a href="#doc-xquery40-SequenceType"><span class="deltaxml-old">SequenceType</span></a><span class="deltaxml-old">. A sequence type designator is said to </span><b><span class="deltaxml-old">designate</span></b><span class="deltaxml-old"> a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-old">sequence type</span></a><span class="deltaxml-old">.] </span></p><p><span class="deltaxml-old"> [</span><a id="dt-item-type-designator" title="item type designator"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: An </span><b><span class="deltaxml-old">item type designator</span></b><span class="deltaxml-old"> is a syntactic construct conforming to the grammar rule </span><a href="#doc-xquery40-ItemType"><span class="deltaxml-old">ItemType</span></a><span class="deltaxml-old">. An item type designator is said to </span><b><span class="deltaxml-old">designate</span></b><span class="deltaxml-old"> an </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-old">item type</span></a><span class="deltaxml-old">.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Two </span><a title="item type designator" class="termref" href="#dt-item-type-designator"><span class="deltaxml-old">item type designators</span></a><span class="deltaxml-old"> may designate the same item type. For example, </span><code><span class="deltaxml-old">element()</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">element(*)</span></code><span class="deltaxml-old"> are equivalent, as are </span><code><span class="deltaxml-old">attribute(A)</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">attribute(A, xs:anySimpleType)</span></code><span class="deltaxml-old">.</span></p></div><p> [<a id="dt-schema-type" title="schema type">Definition</a>: A <b>schema type</b> is a type that is (or could be) defined using the facilities of <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> (including the built-in types).] A schema type can be used as a type annotation on an element or attribute node (unless it is a non-instantiable type such as <code>xs:NOTATION</code> or <code>xs:anyAtomicType</code>, in which case its derived types can be so used). Every schema type is either a <b>complex type</b> or a <b>simple type</b>; simple types are further subdivided into <b>list types</b>, <b>union types</b>, and <b>atomic types</b> (see <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> for definitions and explanations of these terms.)</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Local union types (see <a href="#id-local-union-types"><b>3.6.2.1 Local Union Types</b></a>) and enumeration types (see <a href="#id-enumeration-types"><b>3.6.2.2 Enumeration Types</b></a>) are classified as <a title="schema type" class="termref" href="#dt-schema-type">schema types</a>, even though they are not defined in any XSD schema.</p></div><p> [<a id="dt-generalized-atomic-type" title="generalized atomic type">Definition</a>: A <b>generalized atomic type</b> is a <span><a title="schema type" class="termref" href="#dt-schema-type">schema type</a></span> that is either (a) an atomic type or (b) a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a> ].</p><p> [<a id="dt-pure-union-type" title="pure union type">Definition</a>: A <b>pure union type</b> is a <span><b>simple type</b></span> that satisfies the following constraints: (1) <code>{variety}</code> is <code>union</code>, (2) the <code>{facets}</code> property is empty, (3) no type in the transitive membership of the union type has <code>{variety}</code><code>list</code>, and (4) no type in the transitive membership of the union type is a type with <code>{variety}</code><code>union</code> having a non-empty <code>{facets}</code> property].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The definition of <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a> excludes union types derived by non-trivial restriction from other union types, as well as union types that include list types in their membership. Pure union types have the property that every instance of an atomic type defined as one of the member types of the union is also a valid instance of the union type.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The current (second) edition of XML Schema 1.0 contains an error in respect of the substitutability of a union type by one of its members: it fails to recognize that this is unsafe if the union is derived by restriction from another union.</p><p>This problem is fixed in XSD 1.1, but the effect of the resolution is that an atomic value labeled with an atomic type cannot be treated as being substitutable for a union type without explicit validation. This specification therefore allows union types to be used as item types only if they are defined directly as the union of a number of atomic types.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>A local union type (see <a href="#id-local-union-types"><b>3.6.2.1 Local Union Types</b></a>) is always a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a></p></div><p><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">Generalized atomic types</a> represent the intersection between the categories of <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> and <a title="schema type" class="termref" href="#dt-schema-type">schema type</a>. A generalized atomic type, such as <code>xs:integer</code> or <code>my:hatsize</code>, is both a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> and a <a title="schema type" class="termref" href="#dt-schema-type">schema type</a>.</p><div class="div2"><h3><a id="id-predefined-types"></a>3.1 Predefined Schema Types</h3><p><span style="display: none;" class="delete_version">The schema types defined in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#types-predefined">Section 2.8.3 Predefined Types</a><sup><small>DM40</small></sup> are summarized below.</span><span style="display: none;" class="add_version">The schema types defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types-predefined">Section 2.7.2 Predefined Types </a><sup><small>DM31</small></sup> are summarized below.</span><span class="modify_version">The schema types defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types-predefined">Section <span class="deltaxml-old">2.8.3</span><span class="deltaxml-new">2.7.2</span> Predefined Types<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup> are summarized below.</span></p><p class="xquery"><span style="display: none;" class="delete_version">The <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> are initialized with certain predefined schema types, including the built-in schema types in the namespace <code>http://www.w3.org/2001/XMLSchema</code>, which has the predefined namespace prefix <code>xs</code>. The schema types in this namespace are defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> and augmented by additional types defined in <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>. Element and attribute declarations in the <code>xs</code> namespace are not implicitly included in the static context. The schema types defined in <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a> are summarized below.</span><span style="display: none;" class="add_version">The <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> are initialized with certain predefined schema types, including the built-in schema types in the namespace <code>http://www.w3.org/2001/XMLSchema</code>, which has the predefined namespace prefix <code>xs</code>. The schema types in this namespace are defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> and augmented by additional types defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>. Element and attribute declarations in the <code>xs</code> namespace are not implicitly included in the static context. The schema types defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a> are summarized below.</span><span class="modify_version">The <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> are initialized with certain predefined schema types, including the built-in schema types in the namespace <code>http://www.w3.org/2001/XMLSchema</code>, which has the predefined namespace prefix <code>xs</code>. The schema types in this namespace are defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> and augmented by additional types defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a>. Element and attribute declarations in the <code>xs</code> namespace are not implicitly included in the static context. The schema types defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a> are summarized below.</span></p><ol class="enumar"><li><p> [<a id="dt-untyped" title="xs:untyped">Definition</a>: <code>xs:untyped</code> is used as the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of an element node that has not been validated, or has been validated in <code>skip</code> mode.] No predefined schema types are derived from <code>xs:untyped</code>.</p></li><li><p> [<a id="dt-untypedAtomic" title="xs:untypedAtomic">Definition</a>: <code>xs:untypedAtomic</code> is an atomic type that is used to denote untyped atomic data, such as text that has not been assigned a more specific type.] An attribute that has been validated in <code>skip</code> mode is represented in the <a title="data model" class="termref" href="#dt-datamodel">data model</a> by an attribute node with the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><code>xs:untypedAtomic</code>. No predefined schema types are derived from <code>xs:untypedAtomic</code>.</p></li><li><p> [<a id="dt-dayTimeDuration" title="xs:dayTimeDuration">Definition</a>: <code>xs:dayTimeDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:dayTimeDuration</code> is restricted to contain only day, hour, minute, and second components.] </p></li><li><p> [<a id="dt-yearMonthDuration" title="xs:yearMonthDuration">Definition</a>: <code>xs:yearMonthDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:yearMonthDuration</code> is restricted to contain only year and month components.] </p></li><li><p> [<a id="dt-anyAtomicType" title="xs:anyAtomicType">Definition</a>: <code>xs:anyAtomicType</code> is an atomic type that includes all atomic values (and no values that are not atomic). Its base type is <code>xs:anySimpleType</code> from which all simple types, including atomic, list, and union types, are derived. All primitive atomic types, such as <code>xs:decimal</code> and <code>xs:string</code>, have <code>xs:anyAtomicType</code> as their base type.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p><code>xs:anyAtomicType</code> will not appear as the type of an actual value in an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a>.</p></div></li><li><p> [<a id="dt-xs-error" title="xs:error">Definition</a>: <code>xs:error</code> is a simple type with no value space. It is defined in <a href="https://www.w3.org/TR/xmlschema11-1/#xsd-error">Section 3.16.7.3 xs:error </a><sup><small>XS11-1</small></sup> and can be used in the <a href="#id-sequencetype-syntax"><b>3.4 Sequence Types</b></a> to raise errors.] </p></li></ol><p><span style="display: none;" class="delete_version">The relationships among the schema types in the <code>xs</code> namespace are illustrated in Figure 2. A more complete description of the XQuery 4.0 type hierarchy can be found in <a href="https://qt4cg.org/specifications/xpath-functions-40/#datatypes">Section 1.7 Type System</a><sup><small>FO40</small></sup>.</span><span style="display: none;" class="add_version">The relationships among the schema types in the <code>xs</code> namespace are illustrated in Figure 2. A more complete description of the XQuery 4.0 type hierarchy can be found in <a href="https://www.w3.org/TR/xpath-functions-31/#datatypes">Section 1.6 Type System </a><sup><small>FO31</small></sup>.</span><span class="modify_version">The relationships among the schema types in the <code>xs</code> namespace are illustrated in Figure 2. A more complete description of the XQuery 4.0 type hierarchy can be found in <a href="https://www.w3.org/TR/xpath-functions-31/#datatypes">Section <span class="deltaxml-old">1.7</span><span class="deltaxml-new">1.6</span> Type System<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>.</span></p><img src="types.jpg" alt="Type Hierarchy Diagram"><p>Figure 2: Hierarchy of Schema Types used in XQuery 4.0.</p></div><div class="div2"><h3><a id="id-namespace-sensitive"></a>3.2 Namespace-sensitive Types</h3><p> [<a id="dt-namespace-sensitive" title="namespace-sensitive">Definition</a>: The <b>namespace-sensitive</b> types are <code>xs:QName</code>, <code>xs:NOTATION</code>, types derived by restriction from <code>xs:QName</code> or <code>xs:NOTATION</code>, list types that have a namespace-sensitive item type, and union types with a namespace-sensitive type in their transitive membership.] </p><p><span style="display: none;" class="delete_version">It is not possible to preserve the type of a <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a> value without also preserving the namespace binding that defines the meaning of each namespace prefix used in the value. Therefore, XQuery 4.0 defines some error conditions that occur only with <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a> values. For instance, casting to a <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a> type raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FONS0004" href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFONS0004">err:FONS0004</a>]<sup><small>FO40</small></sup> if the namespace bindings for the result cannot be determined. </span><span style="display: none;" class="add_version">It is not possible to preserve the type of a <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a> value without also preserving the namespace binding that defines the meaning of each namespace prefix used in the value. Therefore, XQuery 4.0 defines some error conditions that occur only with <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a> values. For instance, casting to a <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a> type raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FONS0004" href="https://www.w3.org/TR/xpath-functions-31/#ERRFONS0004">err:FONS0004</a>]<sup><small>FO31</small></sup> if the namespace bindings for the result cannot be determined. </span><span class="modify_version">It is not possible to preserve the type of a <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a> value without also preserving the namespace binding that defines the meaning of each namespace prefix used in the value. Therefore, XQuery 4.0 defines some error conditions that occur only with <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a> values. For instance, casting to a <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a> type raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FONS0004" href="https://www.w3.org/TR/xpath-functions-31/#ERRFONS0004">err:FONS0004</a>]<sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup> if the namespace bindings for the result cannot be determined. </span></p></div><div class="div2"><h3><a id="id-typed-value"></a>3.3 Typed Value and String Value</h3><p><span style="display: none;" class="delete_version">Every node has a <b>typed value</b> and a <b>string value</b>, except for nodes whose value is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>. [<a id="dt-typed-value" title="typed value">Definition</a>: The <b>typed value</b> of a node is a sequence of atomic values and can be extracted by applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-data">Section 2.4 fn:data</a><sup><small>FO40</small></sup> function to the node.] [<a id="dt-string-value" title="string value">Definition</a>: The <b>string value</b> of a node is a string and can be extracted by applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-string">Section 2.3 fn:string</a><sup><small>FO40</small></sup> function to the node.] </span><span style="display: none;" class="add_version">Every node has a <b>typed value</b> and a <b>string value</b>, except for nodes whose value is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. [<a id="dt-typed-value" title="typed value">Definition</a>: The <b>typed value</b> of a node is a sequence of atomic values and can be extracted by applying the <a href="https://www.w3.org/TR/xpath-functions-31/#func-data">Section 2.4 fn:data </a><sup><small>FO31</small></sup> function to the node.] [<a id="dt-string-value" title="string value">Definition</a>: The <b>string value</b> of a node is a string and can be extracted by applying the <a href="https://www.w3.org/TR/xpath-functions-31/#func-string">Section 2.3 fn:string </a><sup><small>FO31</small></sup> function to the node.] </span><span class="modify_version">Every node has a <b>typed value</b> and a <b>string value</b>, except for nodes whose value is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>. [<a id="dt-typed-value" title="typed value">Definition</a>: The <b>typed value</b> of a node is a sequence of atomic values and can be extracted by applying the <a href="https://www.w3.org/TR/xpath-functions-31/#func-data">Section 2.4 fn:data<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup> function to the node.] [<a id="dt-string-value" title="string value">Definition</a>: The <b>string value</b> of a node is a string and can be extracted by applying the <a href="https://www.w3.org/TR/xpath-functions-31/#func-string">Section 2.3 fn:string<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup> function to the node.] </span></p><p><span style="display: none;" class="delete_version">An implementation may store both the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> and the <a title="string value" class="termref" href="#dt-string-value">string value</a> of a node, or it may store only one of these and derive the other as needed. The string value of a node must be a valid lexical representation of the typed value of the node, but the node is not required to preserve the string representation from the original source document. For example, if the typed value of a node is the <code>xs:integer</code> value <code>30</code>, its string value might be <code>"30"</code> or <code>"0030"</code>.</span><span style="display: none;" class="add_version">An implementation may store both the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> and the <a title="string value" class="termref" href="#dt-string-value">string value</a> of a node, or it may store only one of these and derive the other as needed. The string value of a node must be a valid lexical representation of the typed value of the node, but the node is not required to preserve the string representation from the original source document. For example, if the typed value of a node is the <code>xs:integer</code> value <code>30</code>, its string value might be "<code>30</code>" or "<code>0030</code>".</span><span class="modify_version">An implementation may store both the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> and the <a title="string value" class="termref" href="#dt-string-value">string value</a> of a node, or it may store only one of these and derive the other as needed. The string value of a node must be a valid lexical representation of the typed value of the node, but the node is not required to preserve the string representation from the original source document. For example, if the typed value of a node is the <code>xs:integer</code> value <code>30</code>, its string value might be "<code>30<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span> or "<code>0030<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p><p class="xquery">The <a title="typed value" class="termref" href="#dt-typed-value">typed value</a>, <a title="string value" class="termref" href="#dt-string-value">string value</a>, and <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of a node are closely related, and are defined by rules found in the following locations:</p><ul class="xquery"><li><p><span style="display: none;" class="delete_version">If the node was created by mapping from an Infoset or PSVI, see rules in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#types">Section 2.8 Schema Information</a><sup><small>DM40</small></sup>.</span><span style="display: none;" class="add_version">If the node was created by mapping from an Infoset or PSVI, see rules in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types">Section 2.7 Schema Information </a><sup><small>DM31</small></sup>.</span><span class="modify_version">If the node was created by mapping from an Infoset or PSVI, see rules in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types">Section <span class="deltaxml-old">2.8</span><span class="deltaxml-new">2.7</span> Schema Information<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>.</span></p></li><li><p>If the node was created by an XQuery node constructor, see rules in <a href="#id-element-constructor"><span style="display: none;" class="delete_version"><b>4.13.1 Direct Element Constructors</b></span><span style="display: none;" class="add_version"><b>4.12.1 Direct Element Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1</span><span class="deltaxml-new">4.12.1</span> Direct Element Constructors</b></span></a>, <a href="#id-computedElements"><span style="display: none;" class="delete_version"><b>4.13.3.1 Computed Element Constructors</b></span><span style="display: none;" class="add_version"><b>4.12.3.1 Computed Element Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.3.1</span><span class="deltaxml-new">4.12.3.1</span> Computed Element Constructors</b></span></a>, or <a href="#id-computedAttributes"><span style="display: none;" class="delete_version"><b>4.13.3.2 Computed Attribute Constructors</b></span><span style="display: none;" class="add_version"><b>4.12.3.2 Computed Attribute Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.3.2</span><span class="deltaxml-new">4.12.3.2</span> Computed Attribute Constructors</b></span></a>.</p></li><li><p><span style="display: none;" class="delete_version">If the node was created by a <code>validate</code> expression, see rules in <a href="#id-validate"><span class="delete_version"><b>4.25 Validate Expressions</b></span><span class="modify_version"><b>4.25 Validate Expressions</b></span></a>.</span><span style="display: none;" class="add_version">If the node was created by a <code>validate</code> expression, see rules in <a href="#id-validate"><span class="add_version"><b>4.24 Validate Expressions</b></span><span class="modify_version"><b>4.24 Validate Expressions</b></span></a>.</span><span class="modify_version">If the node was created by a <code>validate</code> expression, see rules in <a href="#id-validate"><span style="display: none;" class="delete_version"><b>4.25 Validate Expressions</b></span><span style="display: none;" class="add_version"><b>4.24 Validate Expressions</b></span><span class="modify_version"><b><span class="deltaxml-old">4.25</span><span class="deltaxml-new">4.24</span> Validate Expressions</b></span></a>.</span></p></li></ul><p>As a convenience to the reader, the relationship between <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> and <a title="string value" class="termref" href="#dt-string-value">string value</a> for various kinds of nodes is summarized and illustrated by examples below.</p><ol class="enumar"><li><p>For text and document nodes, the typed value of the node is the same as its string value, as an instance of the type <code>xs:untypedAtomic</code>. The string value of a document node is formed by concatenating the string values of all its descendant text nodes, in <a title="document order" class="termref" href="#dt-document-order">document order</a>.</p></li><li><p>The typed value of a comment or processing instruction node is the same as its string value. It is an instance of the type <code>xs:string</code>.</p></li><li><p>The typed value of an attribute node with the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><code>xs:anySimpleType</code> or <code>xs:untypedAtomic</code> is the same as its string value, as an instance of <code>xs:untypedAtomic</code>. The typed value of an attribute node with any other type annotation is derived from its string value and type annotation using the lexical-to-value-space mapping defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 2 for the relevant type.</p><p>Example: A1 is an attribute having string value <code>"3.14E-2"</code> and type annotation <code>xs:double</code>. The typed value of A1 is the <code>xs:double</code> value whose lexical representation is <code>3.14E-2</code>. </p><p><span style="display: none;" class="delete_version">Example: A2 is an attribute with type annotation <code>xs:IDREFS</code>, which is a list datatype whose item type is the atomic datatype <code>xs:IDREF</code>. Its string value is <code>"bar baz faz"</code>. The typed value of A2 is a sequence of three atomic values (<code>"bar"</code>, <code>"baz"</code>", <code>"faz"</code>"), each of type <code>xs:IDREF</code>. The typed value of a node is never treated as an instance of a named list type. Instead, if the type annotation of a node is a list type (such as <code>xs:IDREFS</code>), its typed value is treated as a sequence of the <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> from which it is derived (such as <code>xs:IDREF</code>).</span><span style="display: none;" class="add_version">Example: A2 is an attribute with type annotation <code>xs:IDREFS</code>, which is a list datatype whose item type is the atomic datatype <code>xs:IDREF</code>. Its string value is "<code>bar baz faz</code>". The typed value of A2 is a sequence of three atomic values ("<code>bar</code>", "<code>baz</code>", "<code>faz</code>"), each of type <code>xs:IDREF</code>. The typed value of a node is never treated as an instance of a named list type. Instead, if the type annotation of a node is a list type (such as <code>xs:IDREFS</code>), its typed value is treated as a sequence of the <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> from which it is derived (such as <code>xs:IDREF</code>).</span><span class="modify_version">Example: A2 is an attribute with type annotation <code>xs:IDREFS</code>, which is a list datatype whose item type is the atomic datatype <code>xs:IDREF</code>. Its string value is "<code>bar baz faz<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>. The typed value of A2 is a sequence of three atomic values ("<code>bar<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>, "<code>baz<span class="deltaxml-old">"</span></code>", "<code>faz<span class="deltaxml-old">"</span></code>"), each of type <code>xs:IDREF</code>. The typed value of a node is never treated as an instance of a named list type. Instead, if the type annotation of a node is a list type (such as <code>xs:IDREFS</code>), its typed value is treated as a sequence of the <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> from which it is derived (such as <code>xs:IDREF</code>).</span></p></li><li><p>For an element node, the relationship between typed value and string value depends on the <span class="deltaxml-old">node’s</span><span class="deltaxml-new">node's</span> <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>, as follows:</p><ol class="enumla"><li><p>If the type annotation is <code>xs:untyped</code> or <code>xs:anySimpleType</code> or denotes a complex type with mixed content (including <code>xs:anyType</code>), then the typed value of the node is equal to its string value, as an instance of <code>xs:untypedAtomic</code>. However, if the <code>nilled</code> property of the node is <code>true</code>, then its typed value is the empty sequence.</p><p><span style="display: none;" class="delete_version">Example: E1 is an element node having type annotation <code>xs:untyped</code> and string value <code>"1999-05-31"</code>. The typed value of E1 is <code>"1999-05-31"</code>, as an instance of <code>xs:untypedAtomic</code>.</span><span style="display: none;" class="add_version">Example: E1 is an element node having type annotation <code>xs:untyped</code> and string value "<code>1999-05-31</code>". The typed value of E1 is "<code>1999-05-31</code>", as an instance of <code>xs:untypedAtomic</code>.</span><span class="modify_version">Example: E1 is an element node having type annotation <code>xs:untyped</code> and string value "<code>1999-05-31<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>. The typed value of E1 is "<code>1999-05-31<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>, as an instance of <code>xs:untypedAtomic</code>.</span></p><p><span style="display: none;" class="delete_version">Example: E2 is an element node with the type annotation <code>formula</code>, which is a complex type with mixed content. The content of E2 consists of the character <code>H</code>, a child element named <code>subscript</code> with string value <code>"2"</code>, and the character <code>O</code>. The typed value of E2 is <code>"H2O"</code> as an instance of <code>xs:untypedAtomic</code>.</span><span style="display: none;" class="add_version">Example: E2 is an element node with the type annotation <code>formula</code>, which is a complex type with mixed content. The content of E2 consists of the character "<code>H</code>", a child element named <code>subscript</code> with string value "<code>2</code>", and the character "<code>O</code>". The typed value of E2 is "<code>H2O</code>" as an instance of <code>xs:untypedAtomic</code>.</span><span class="modify_version">Example: E2 is an element node with the type annotation <code>formula</code>, which is a complex type with mixed content. The content of E2 consists of the character <span class="deltaxml-new">"</span><code>H</code><span class="deltaxml-new">"</span>, a child element named <code>subscript</code> with string value "<code>2<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>, and the character <span class="deltaxml-new">"</span><code>O</code><span class="deltaxml-new">"</span>. The typed value of E2 is "<code>H2O<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span> as an instance of <code>xs:untypedAtomic</code>.</span></p></li><li><p>If the type annotation denotes a simple type or a complex type with simple content, then the typed value of the node is derived from its string value and its type annotation in a way that is consistent with schema validation. However, if the <code>nilled</code> property of the node is <code>true</code>, then its typed value is the empty sequence.</p><p><span style="display: none;" class="delete_version">Example: E3 is an element node with the type annotation <code>cost</code>, which is a complex type that has several attributes and a simple content type of <code>xs:decimal</code>. The string value of E3 is <code>"74.95"</code>. The typed value of E3 is <code>74.95</code>, as an instance of <code>xs:decimal</code>.</span><span style="display: none;" class="add_version">Example: E3 is an element node with the type annotation <code>cost</code>, which is a complex type that has several attributes and a simple content type of <code>xs:decimal</code>. The string value of E3 is "<code>74.95</code>". The typed value of E3 is <code>74.95</code>, as an instance of <code>xs:decimal</code>.</span><span class="modify_version">Example: E3 is an element node with the type annotation <code>cost</code>, which is a complex type that has several attributes and a simple content type of <code>xs:decimal</code>. The string value of E3 is "<code>74.95<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>. The typed value of E3 is <code>74.95</code>, as an instance of <code>xs:decimal</code>.</span></p><p><span style="display: none;" class="delete_version">Example: E4 is an element node with the type annotation <code>hatsizelist</code>, which is a simple type derived from the atomic type <code>hatsize</code>, which in turn is derived from <code>xs:integer</code>. The string value of E4 is <code>"7 8 9"</code>. The typed value of E4 is a sequence of three values (<code>7</code>, <code>8</code>, <code>9</code>), each of type <code>hatsize</code>.</span><span style="display: none;" class="add_version">Example: E4 is an element node with the type annotation <code>hatsizelist</code>, which is a simple type derived from the atomic type <code>hatsize</code>, which in turn is derived from <code>xs:integer</code>. The string value of E4 is "<code>7 8 9</code>". The typed value of E4 is a sequence of three values (<code>7</code>, <code>8</code>, <code>9</code>), each of type <code>hatsize</code>.</span><span class="modify_version">Example: E4 is an element node with the type annotation <code>hatsizelist</code>, which is a simple type derived from the atomic type <code>hatsize</code>, which in turn is derived from <code>xs:integer</code>. The string value of E4 is "<code>7 8 9<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>. The typed value of E4 is a sequence of three values (<code>7</code>, <code>8</code>, <code>9</code>), each of type <code>hatsize</code>.</span></p><p><span style="display: none;" class="delete_version">Example: E5 is an element node with the type annotation <code>my:integer-or-string</code> which is a union type with member types <code>xs:integer</code> and <code>xs:string</code>. The string value of E5 is <code>"47"</code>. The typed value of E5 is <code>47</code> as a <code>xs:integer</code>, since <code>xs:integer</code> is the member type that validated the content of E5. In general, when the type annotation of a node is a union type, the typed value of the node will be an instance of one of the member types of the union.</span><span style="display: none;" class="add_version">Example: E5 is an element node with the type annotation <code>my:integer-or-string</code> which is a union type with member types <code>xs:integer</code> and <code>xs:string</code>. The string value of E5 is "<code>47</code>". The typed value of E5 is <code>47</code> as an <code>xs:integer</code>, since <code>xs:integer</code> is the member type that validated the content of E5. In general, when the type annotation of a node is a union type, the typed value of the node will be an instance of one of the member types of the union.</span><span class="modify_version">Example: E5 is an element node with the type annotation <code>my:integer-or-string</code> which is a union type with member types <code>xs:integer</code> and <code>xs:string</code>. The string value of E5 is "<code>47<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>. The typed value of E5 is <code>47</code> as <span class="deltaxml-old">a</span><span class="deltaxml-new">an</span> <code>xs:integer</code>, since <code>xs:integer</code> is the member type that validated the content of E5. In general, when the type annotation of a node is a union type, the typed value of the node will be an instance of one of the member types of the union.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>If an implementation stores only the string value of a node, and the type annotation of the node is a union type, the implementation must be able to deliver the typed value of the node as an instance of the appropriate member type.</p></div></li><li><p>If the type annotation denotes a complex type with empty content, then the typed value of the node is the empty sequence and its string value is the zero-length string.</p></li><li><p><span style="display: none;" class="delete_version">If the type annotation denotes a complex type with element-only content, then the typed value of the node is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>. The <code>fn:data</code> function raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FOTY0012" href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOTY0012">err:FOTY0012</a>]<sup><small>FO40</small></sup> when applied to such a node. The string value of such a node is equal to the concatenated string values of all its text node descendants, in document order.</span><span style="display: none;" class="add_version">If the type annotation denotes a complex type with element-only content, then the typed value of the node is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. The <code>fn:data</code> function raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FOTY0012" href="https://www.w3.org/TR/xpath-functions-31/#ERRFOTY0012">err:FOTY0012</a>]<sup><small>FO31</small></sup> when applied to such a node. The string value of such a node is equal to the concatenated string values of all its text node descendants, in document order.</span><span class="modify_version">If the type annotation denotes a complex type with element-only content, then the typed value of the node is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>. The <code>fn:data</code> function raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a title="err:FOTY0012" href="https://www.w3.org/TR/xpath-functions-31/#ERRFOTY0012">err:FOTY0012</a>]<sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup> when applied to such a node. The string value of such a node is equal to the concatenated string values of all its text node descendants, in document order.</span></p><p><span style="display: none;" class="delete_version">Example: E6 is an element node with the type annotation <code>weather</code>, which is a complex type whose content type specifies <code>element-only</code>. E6 has two child elements named <code>temperature</code> and <code>precipitation</code>. The typed value of E6 is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>, and the <code>fn:data</code> function applied to E6 raises an error. </span><span style="display: none;" class="add_version">Example: E6 is an element node with the type annotation <code>weather</code>, which is a complex type whose content type specifies <code>element-only</code>. E6 has two child elements named <code>temperature</code> and <code>precipitation</code>. The typed value of E6 is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>, and the <code>fn:data</code> function applied to E6 raises an error. </span><span class="modify_version">Example: E6 is an element node with the type annotation <code>weather</code>, which is a complex type whose content type specifies <code>element-only</code>. E6 has two child elements named <code>temperature</code> and <code>precipitation</code>. The typed value of E6 is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>, and the <code>fn:data</code> function applied to E6 raises an error. </span></p></li></ol></li></ol></div><div class="div2"><h3><a id="id-sequencetype-syntax"></a>3.4 Sequence Types</h3><p>Whenever it is necessary to refer to a type in an XQuery 4.0 expression, the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax is used.</p><a id="d3e5200"></a><a id="d3e4923"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SequenceType"></a>[<span class="deltaxml-old">225</span><span class="deltaxml-new">212</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SequenceType">SequenceType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xquery40-ItemType">ItemType</a><a href="#doc-xquery40-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType"></a>[<span class="deltaxml-old">227</span><span class="deltaxml-new">214</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ItemType">ItemType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AnyItemTest">AnyItemTest</a> | <a href="#doc-xquery40-TypeName">TypeName</a> | <a href="#doc-xquery40-KindTest">KindTest</a> | <a href="#doc-xquery40-FunctionTest">FunctionTest</a> | <a href="#doc-xquery40-MapTest">MapTest</a> | <a href="#doc-xquery40-ArrayTest">ArrayTest</a> | <a href="#doc-xquery40-AtomicOrUnionType">AtomicOrUnionType</a> | <a href="#doc-xquery40-RecordTest">RecordTest</a> | <a href="#doc-xquery40-LocalUnionType">LocalUnionType</a> | <a href="#doc-xquery40-EnumerationType">EnumerationType</a> | <a href="#doc-xquery40-ParenthesizedItemType">ParenthesizedItemType</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-OccurrenceIndicator"></a>[<span class="deltaxml-old">226</span><span class="deltaxml-new">213</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"?" | "*" | "+"</code></td><td><i>/* <a href="#parse-note-occurrence-indicators">xgc: occurrence-indicators</a> */</i></td></tr></tbody></table><p><span style="display: none;" class="delete_version">With the exception of the special type <code>empty-sequence()</code>, a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> consists of an <b>item type</b> that constrains the type of each item in the sequence, and a <b>cardinality</b> that constrains the number of items in the sequence. Apart from the item type <code>item()</code>, which permits any kind of item, item types divide into <b>node types</b> (such as <code>element()</code>), <b>generalized atomic types</b> (such as <code>xs:integer</code>) and function types (such as <code>function() as item()*</code>).</span><span style="display: none;" class="add_version">With the exception of the special type <code>empty-sequence()</code>, a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> consists of an <b>item type</b> that constrains the type of each item in the sequence, and a <b>cardinality</b> that constrains the number of items in the sequence. Apart from the item type <code>item()</code>, which permits any kind of item, item types divide into <b>node types</b> (such as <code>element()</code>), <b>generalized atomic types</b> (such as <code>xs:integer</code>) and function types (such as function() as item()*).</span><span class="modify_version">With the exception of the special type <code>empty-sequence()</code>, a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> consists of an <b>item type</b> that constrains the type of each item in the sequence, and a <b>cardinality</b> that constrains the number of items in the sequence. Apart from the item type <code>item()</code>, which permits any kind of item, item types divide into <b>node types</b> (such as <code>element()</code>), <b>generalized atomic types</b> (such as <code>xs:integer</code>) and function types (such as function() as item()*).</span></p><p><span style="display: none;" class="delete_version"><a title="lexical QName" class="termref" href="#dt-qname">Lexical QNames</a> appearing in a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> have their prefixes expanded to namespace URIs by means of the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> and (where applicable) the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>. Equality of QNames is defined by the <code>eq</code> operator.</span><span style="display: none;" class="add_version"><a title="lexical QName" class="termref" href="#dt-qname">Lexical QNames</a> appearing in a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> have their prefixes expanded to namespace URIs by means of the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> and (where applicable) the <span><a class="termref" title="default element namespace" href="#dt-def-element-ns">default element namespace</a> or <a title="default type namespace" class="termref" href="#dt-def-type-ns">default type namespace</a></span>. Equality of QNames is defined by the <code>eq</code> operator.</span><span class="modify_version"><a title="lexical QName" class="termref" href="#dt-qname">Lexical QNames</a> appearing in a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> have their prefixes expanded to namespace URIs by means of the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> and (where applicable) the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span><a class="termref" title="default element namespace" href="#dt-def-element-ns"><span class="deltaxml-new">default element namespace</span></a><span class="deltaxml-new"> or </span><a title="default type namespace" class="termref" href="#dt-def-type-ns"><span class="deltaxml-new">default type namespace</span></a></span>. Equality of QNames is defined by the <code>eq</code> operator.</span></p><p><span style="display: none;" class="delete_version">Item types representing element and attribute nodes may specify the required <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> of those nodes in the form of a <a title="schema type" class="termref" href="#dt-schema-type">schema type</a>. Thus the item type <code>element(*, us:address)</code> denotes any element node whose type annotation is (or is derived from) the schema type named <code>us:address</code>.</span><span style="display: none;" class="add_version">Item types representing element and attribute nodes may specify the required <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> of those nodes, in the form of a <a title="schema type" class="termref" href="#dt-schema-type">schema type</a>. Thus the item type <code>element(*, us:address)</code> denotes any element node whose type annotation is (or is derived from) the schema type named <code>us:address</code>.</span><span class="modify_version">Item types representing element and attribute nodes may specify the required <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> of those nodes<span class="deltaxml-new">,</span> in the form of a <a title="schema type" class="termref" href="#dt-schema-type">schema type</a>. Thus the item type <code>element(*, us:address)</code> denotes any element node whose type annotation is (or is derived from) the schema type named <code>us:address</code>.</span></p><p><span style="display: none;" class="delete_version">The occurrence indicators <code>+</code>, <code>*</code>, and <code>?</code> bind to the last <a href="#doc-xquery40-ItemType">ItemType</a> in the <a href="#doc-xquery40-SequenceType">SequenceType</a>, as described in <a href="#parse-note-occurrence-indicators">occurrence-indicators</a> constraint.</span><span style="display: none;" class="add_version">The occurrence indicators '+', '*', and '?' bind to the last <a href="#doc-xquery40-ItemType">ItemType</a> in the <a href="#doc-xquery40-SequenceType">SequenceType</a>, as described in <a href="#parse-note-occurrence-indicators">occurrence-indicators</a> constraint.</span><span class="modify_version">The occurrence indicators <span class="deltaxml-new">'</span>+<span class="deltaxml-new">'</span>, <span class="deltaxml-new">'</span>*<span class="deltaxml-new">'</span>, and <span class="deltaxml-new">'</span>?<span class="deltaxml-new">'</span> bind to the last <a href="#doc-xquery40-ItemType">ItemType</a> in the <a href="#doc-xquery40-SequenceType">SequenceType</a>, as described in <a href="#parse-note-occurrence-indicators">occurrence-indicators</a> constraint.</span></p><p>Here are some examples of <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> that might be used in XQuery 4.0:</p><ul><li><p><code>xs:date</code> refers to the built-in atomic schema type named <code>xs:date</code></p></li><li><p><code>attribute()?</code> refers to an optional attribute node</p></li><li><p><code>element()</code> refers to any element node</p></li><li><p><code>element(po:shipto, po:address)</code> refers to an element node that has the name <code>po:shipto</code> and has the type annotation <code>po:address</code> (or a schema type derived from <code>po:address</code>)</p></li><li><p><code>element(*, po:address)</code> refers to an element node of any name that has the type annotation <code>po:address</code> (or a type derived from <code>po:address</code>)</p></li><li><p><code>element(customer)</code> refers to an element node named <code>customer</code> with any type annotation</p></li><li><p><code>schema-element(customer)</code> refers to an element node whose name is <code>customer</code> (or is in the substitution group headed by <code>customer</code>) and whose type annotation matches the schema type declared for a <code>customer</code> element in the <a title="in-scope element declarations" class="termref" href="#dt-is-elems">in-scope element declarations</a></p></li><li><p><code>node()*</code> refers to a sequence of zero or more nodes of any kind</p></li><li><p><code>item()+</code> refers to a sequence of one or more <a title="item" class="termref" href="#dt-item">items</a></p></li><li><p><code>function(*)</code> refers to any <a title="function item" class="termref" href="#dt-function-item">function item</a>, regardless of arity or type</p></li><li><p><code>function(node()) as xs:string*</code> refers to a <a title="function item" class="termref" href="#dt-function-item">function item</a> that takes a single argument whose value is a single node, and returns a sequence of zero or more <code>xs:string</code> values</p></li><li><p><code>(function(node()) as xs:string)*</code> refers to a sequence of zero or more <a title="function item" class="termref" href="#dt-function-item">function items</a>, each of which takes a single argument whose value is a single node, and returns as its result a single <code>xs:string</code> value</p></li></ul></div><div class="div2"><h3><a id="id-sequencetype-matching"></a>3.5 Sequence Type Matching</h3><p><span style="display: none;" class="delete_version"> [<a id="dt-sequencetype-matching" title="SequenceType matching">Definition</a>: <b>SequenceType matching</b> compares a value with an expected <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>. ] For example, an <code>instance of</code> expression returns <code>true</code> if a given value matches a given <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>, and <code>false</code> if it does not.</span><span style="display: none;" class="add_version"> [<a id="dt-sequencetype-matching" title="SequenceType matching">Definition</a>: <b>SequenceType matching</b> compares a value with an expected <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>. ] For example, an <code>instance of</code> expression returns <code>true</code> if a given value matches a given <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>, or <code>false</code> if it does not.</span><span class="modify_version"> [<a id="dt-sequencetype-matching" title="SequenceType matching">Definition</a>: <b>SequenceType matching</b> compares a value with an expected <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>. ] For example, an <code>instance of</code> expression returns <code>true</code> if a given value matches a given <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>, <span class="deltaxml-old">and</span><span class="deltaxml-new">or</span> <code>false</code> if it does not.</span></p><p>An XQuery 4.0 implementation must be able to determine relationships among the types in type annotations in an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> and the types in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> (ISSD). <span class="xquery">An XQuery 4.0 implementation must be able to determine relationships among the types in ISSDs used in different modules of the same query.</span></p><p> [<a id="dt-subtype-substitution" title="subtype substitution">Definition</a>: The use of a value that has a <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> that is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the expected type is known as <b>subtype substitution</b>.] Subtype substitution does not change the actual type of a value. For example, if an <code>xs:integer</code> value is used where an <code>xs:decimal</code> value is expected, the value retains its type as <code>xs:integer</code>.</p><p>The definition of <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType matching</a> relies on a pseudo-function named <code>derives-from(</code><em>AT</em>, <em>ET</em><code>)</code>, which takes an actual simple or complex schema type <em>AT</em> and an expected simple or complex schema type <em>ET</em>, and either returns a boolean value or raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. This function is defined as follows:</p><ul><li><p><code>derives-from(</code><em>AT</em>, <em>ET</em><code>)</code> raises a type error [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] if <em>ET</em> is not present in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> (ISSD). </p></li><li><p><code>derives-from(</code><em>AT</em>, <em>ET</em><code>)</code> returns <code>true</code> if any of the following conditions applies: </p><ul><li><p><em>AT</em> is <em>ET</em></p></li><li><p><em>ET</em> is the base type of <em>AT</em></p></li><li><p><em>ET</em> is a pure union type of which <em>AT</em> is a member type</p></li><li><p>There is a type <em>MT</em> such that <code>derives-from(</code><em>AT</em>, <em>MT</em><code>)</code> and <code>derives-from(</code><em>MT</em>, <em>ET</em><code>)</code></p></li></ul></li><li><p>Otherwise, <code>derives-from(</code><em>AT</em>, <em>ET</em><code>)</code> returns <code>false</code></p></li></ul><p>The rules for <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType matching</a> are given below, with examples (the examples are for purposes of illustration, and do not cover all possible cases).</p><ul><li><p>The <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a><code>empty-sequence()</code> matches a value that is the empty sequence.</p></li><li><p>An <a href="#doc-xquery40-ItemType">ItemType</a> with no <a href="#doc-xquery40-OccurrenceIndicator">OccurrenceIndicator</a> matches any value that contains exactly one item if the <a href="#doc-xquery40-ItemType">ItemType</a> matches that item (see <a href="#id-matching-item"><b>3.6 Item Types</b></a>).</p></li><li><p>An <a href="#doc-xquery40-ItemType">ItemType</a> with an <a href="#doc-xquery40-OccurrenceIndicator">OccurrenceIndicator</a> matches a value if the number of items in the value matches the <a href="#doc-xquery40-OccurrenceIndicator">OccurrenceIndicator</a> and the <a href="#doc-xquery40-ItemType">ItemType</a> matches each of the items in the value.</p></li></ul><p>An <a href="#doc-xquery40-OccurrenceIndicator">OccurrenceIndicator</a> specifies the number of items in a sequence, as follows:</p><ul><li><p><code>?</code> matches zero or one items</p></li><li><p><code>*</code> matches zero or more items</p></li><li><p><code>+</code> matches one or more items</p></li></ul><p>As a consequence of these rules, any <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> whose <a href="#doc-xquery40-OccurrenceIndicator">OccurrenceIndicator</a> is <code>*</code> or <code>?</code> matches a value that is an empty sequence.</p></div><div class="div2"><h3><a id="id-matching-item"></a>3.6 Item Types</h3><a id="d3e5677"></a><a id="d3e5397"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5527.doc-xquery40-ItemType"></a><a id="noid_d4e5247.doc-xquery40-ItemType"></a>[<span class="deltaxml-old">227</span><span class="deltaxml-new">214</span>]&nbsp;&nbsp;&nbsp;</td><td><code>ItemType</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AnyItemTest">AnyItemTest</a> | <a href="#doc-xquery40-TypeName">TypeName</a> | <a href="#doc-xquery40-KindTest">KindTest</a> | <a href="#doc-xquery40-FunctionTest">FunctionTest</a> | <a href="#doc-xquery40-MapTest">MapTest</a> | <a href="#doc-xquery40-ArrayTest">ArrayTest</a> | <a href="#doc-xquery40-AtomicOrUnionType">AtomicOrUnionType</a> | <a href="#doc-xquery40-RecordTest">RecordTest</a> | <a href="#doc-xquery40-LocalUnionType">LocalUnionType</a> | <a href="#doc-xquery40-EnumerationType">EnumerationType</a> | <a href="#doc-xquery40-ParenthesizedItemType">ParenthesizedItemType</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AnyItemTest"></a>[<span class="deltaxml-old">228</span><span class="deltaxml-new">215</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AnyItemTest">AnyItemTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"item" "(" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeName"></a>[<span class="deltaxml-old">246</span><span class="deltaxml-new">233</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-TypeName">TypeName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-KindTest"></a>[<span class="deltaxml-old">230</span><span class="deltaxml-new">217</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-KindTest">KindTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DocumentTest">DocumentTest</a><br>| <a href="#doc-xquery40-ElementTest">ElementTest</a><br>| <a href="#doc-xquery40-AttributeTest">AttributeTest</a><br>| <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a><br>| <a href="#doc-xquery40-SchemaAttributeTest">SchemaAttributeTest</a><br>| <a href="#doc-xquery40-PITest">PITest</a><br>| <a href="#doc-xquery40-CommentTest">CommentTest</a><br>| <a href="#doc-xquery40-TextTest">TextTest</a><br>| <a href="#doc-xquery40-NamespaceNodeTest">NamespaceNodeTest</a><br>| <a href="#doc-xquery40-AnyKindTest">AnyKindTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DocumentTest"></a>[<span class="deltaxml-old">232</span><span class="deltaxml-new">219</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DocumentTest">DocumentTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"document-node" "(" (<a href="#doc-xquery40-ElementTest">ElementTest</a> | <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a>)? ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5532.doc-xquery40-ElementTest"></a><a id="noid_d4e5252.doc-xquery40-ElementTest"></a>[<span class="deltaxml-old">240</span><span class="deltaxml-new">227</span>]&nbsp;&nbsp;&nbsp;</td><td><code>ElementTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"element" "(" (<a href="#doc-xquery40-NameTestUnion">NameTestUnion</a> ("," <a href="#doc-xquery40-TypeName">TypeName</a> "?"?)?)? ")"</code></span><span style="display: none;" class="add_version"><code>"element" "(" (<a href="#doc-xquery40-NameTest">NameTest</a> ("," <a href="#doc-xquery40-TypeName">TypeName</a> "?"?)?)? ")"</code></span><span class="modify_version"><code>"element" "(" (<a href="#doc-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a><a href="#doc-xquery40-NameTest"><span class="deltaxml-new">NameTest</span></a> ("," <a href="#doc-xquery40-TypeName">TypeName</a> "?"?)?)? ")"</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5533.doc-xquery40-SchemaElementTest"></a><a id="noid_d4e5253.doc-xquery40-SchemaElementTest"></a>[<span class="deltaxml-old">241</span><span class="deltaxml-new">228</span>]&nbsp;&nbsp;&nbsp;</td><td><code>SchemaElementTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"schema-element" "(" <a href="#doc-xquery40-ElementDeclaration">ElementDeclaration</a> ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5534.doc-xquery40-ElementDeclaration"></a><a id="noid_d4e5254.doc-xquery40-ElementDeclaration"></a>[<span class="deltaxml-old">242</span><span class="deltaxml-new">229</span>]&nbsp;&nbsp;&nbsp;</td><td><code>ElementDeclaration</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ElementName">ElementName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5535.doc-xquery40-AttributeTest"></a><a id="noid_d4e5255.doc-xquery40-AttributeTest"></a>[<span class="deltaxml-old">237</span><span class="deltaxml-new">224</span>]&nbsp;&nbsp;&nbsp;</td><td><code>AttributeTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"attribute" "(" (<a href="#doc-xquery40-NameTestUnion">NameTestUnion</a> ("," <a href="#doc-xquery40-TypeName">TypeName</a>)?)? ")"</code></span><span style="display: none;" class="add_version"><code>"attribute" "(" (<a href="#doc-xquery40-NameTest">NameTest</a> ("," <a href="#doc-xquery40-TypeName">TypeName</a>)?)? ")"</code></span><span class="modify_version"><code>"attribute" "(" (<a href="#doc-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a><a href="#doc-xquery40-NameTest"><span class="deltaxml-new">NameTest</span></a> ("," <a href="#doc-xquery40-TypeName">TypeName</a>)?)? ")"</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5536.doc-xquery40-SchemaAttributeTest"></a><a id="noid_d4e5256.doc-xquery40-SchemaAttributeTest"></a>[<span class="deltaxml-old">238</span><span class="deltaxml-new">225</span>]&nbsp;&nbsp;&nbsp;</td><td><code>SchemaAttributeTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"schema-attribute" "(" <a href="#doc-xquery40-AttributeDeclaration">AttributeDeclaration</a> ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5538.doc-xquery40-AttributeDeclaration"></a><a id="noid_d4e5258.doc-xquery40-AttributeDeclaration"></a>[<span class="deltaxml-old">239</span><span class="deltaxml-new">226</span>]&nbsp;&nbsp;&nbsp;</td><td><code>AttributeDeclaration</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AttributeName">AttributeName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ElementName"></a>[<span class="deltaxml-old">244</span><span class="deltaxml-new">231</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ElementName">ElementName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AttributeName"></a>[<span class="deltaxml-old">243</span><span class="deltaxml-new">230</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AttributeName">AttributeName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PITest"></a>[<span class="deltaxml-old">236</span><span class="deltaxml-new">223</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-PITest">PITest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"processing-instruction" "(" (<a href="#prod-xquery40-NCName">NCName</a> | <a href="#doc-xquery40-StringLiteral">StringLiteral</a>)? ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CommentTest"></a>[<span class="deltaxml-old">234</span><span class="deltaxml-new">221</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CommentTest">CommentTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"comment" "(" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NamespaceNodeTest"></a>[<span class="deltaxml-old">235</span><span class="deltaxml-new">222</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NamespaceNodeTest">NamespaceNodeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"namespace-node" "(" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TextTest"></a>[<span class="deltaxml-old">233</span><span class="deltaxml-new">220</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-TextTest">TextTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"text" "(" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AnyKindTest"></a>[<span class="deltaxml-old">231</span><span class="deltaxml-new">218</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AnyKindTest">AnyKindTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"node" "(" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5548.doc-xquery40-FunctionTest"></a><a id="noid_d4e5268.doc-xquery40-FunctionTest"></a>[<span class="deltaxml-old">247</span><span class="deltaxml-new">234</span>]&nbsp;&nbsp;&nbsp;</td><td><code>FunctionTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Annotation">Annotation</a>* (<a href="#doc-xquery40-AnyFunctionTest">AnyFunctionTest</a><br>| <a href="#doc-xquery40-TypedFunctionTest">TypedFunctionTest</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5550.doc-xquery40-AnyFunctionTest"></a><a id="noid_d4e5270.doc-xquery40-AnyFunctionTest"></a>[<span class="deltaxml-old">248</span><span class="deltaxml-new">235</span>]&nbsp;&nbsp;&nbsp;</td><td><code>AnyFunctionTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"function" "(" "*" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5551.doc-xquery40-TypedFunctionTest"></a><a id="noid_d4e5271.doc-xquery40-TypedFunctionTest"></a>[<span class="deltaxml-old">249</span><span class="deltaxml-new">236</span>]&nbsp;&nbsp;&nbsp;</td><td><code>TypedFunctionTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"function" "(" (<a href="#doc-xquery40-SequenceType">SequenceType</a> ("," <a href="#doc-xquery40-SequenceType">SequenceType</a>)*)? ")" "as" <a href="#doc-xquery40-SequenceType">SequenceType</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ParenthesizedItemType"></a>[<span class="deltaxml-old">264</span><span class="deltaxml-new">250</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ParenthesizedItemType">ParenthesizedItemType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" <a href="#doc-xquery40-ItemType">ItemType</a> ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5553.doc-xquery40-MapTest"></a><a id="noid_d4e5273.doc-xquery40-MapTest"></a>[<span class="deltaxml-old">250</span><span class="deltaxml-new">237</span>]&nbsp;&nbsp;&nbsp;</td><td><code>MapTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AnyMapTest">AnyMapTest</a> | <a href="#doc-xquery40-TypedMapTest">TypedMapTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5554.doc-xquery40-RecordTest"></a><a id="noid_d4e5274.doc-xquery40-RecordTest"></a>[<span class="deltaxml-old">253</span><span class="deltaxml-new">240</span>]&nbsp;&nbsp;&nbsp;</td><td><code>RecordTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-AnyRecordTest">AnyRecordTest</a> | <a href="#doc-xquery40-TypedRecordTest">TypedRecordTest</a></code></span><span style="display: none;" class="add_version"><code>"record" "(" <a href="#doc-xquery40-FieldDeclaration">FieldDeclaration</a> ("," <a href="#doc-xquery40-FieldDeclaration">FieldDeclaration</a>)* <a href="#doc-xquery40-ExtensibleFlag">ExtensibleFlag</a>? ")"</code></span><span class="modify_version"><code><a href="#doc-xquery40-AnyRecordTest"><span class="deltaxml-old">AnyRecordTest</span></a><span class="deltaxml-old"> |</span><span class="deltaxml-new">"record" "("</span> <a href="#doc-xquery40-TypedRecordTest"><span class="deltaxml-old">TypedRecordTest</span></a><a href="#doc-xquery40-FieldDeclaration"><span class="deltaxml-new">FieldDeclaration</span></a><span class="deltaxml-new"> ("," </span><a href="#doc-xquery40-FieldDeclaration"><span class="deltaxml-new">FieldDeclaration</span></a><span class="deltaxml-new">)* </span><a href="#doc-xquery40-ExtensibleFlag"><span class="deltaxml-new">ExtensibleFlag</span></a><span class="deltaxml-new">? ")"</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5555.doc-xquery40-ArrayTest"></a><a id="noid_d4e5275.doc-xquery40-ArrayTest"></a>[<span class="deltaxml-old">261</span><span class="deltaxml-new">247</span>]&nbsp;&nbsp;&nbsp;</td><td><code>ArrayTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AnyArrayTest">AnyArrayTest</a> | <a href="#doc-xquery40-TypedArrayTest">TypedArrayTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AtomicOrUnionType"></a>[<span class="deltaxml-old">229</span><span class="deltaxml-new">216</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AtomicOrUnionType">AtomicOrUnionType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5557.doc-xquery40-LocalUnionType"></a><a id="noid_d4e5277.doc-xquery40-LocalUnionType"></a>[<span class="deltaxml-old">259</span><span class="deltaxml-new">245</span>]&nbsp;&nbsp;&nbsp;</td><td><code>LocalUnionType</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"union" "(" <a href="#doc-xquery40-ItemType">ItemType</a> ("," <a href="#doc-xquery40-ItemType">ItemType</a>)* ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e5558.doc-xquery40-EnumerationType"></a><a id="noid_d4e5278.doc-xquery40-EnumerationType"></a>[<span class="deltaxml-old">260</span><span class="deltaxml-new">246</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnumerationType</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"enum" "(" <a href="#doc-xquery40-StringLiteral">StringLiteral</a> ("," <a href="#doc-xquery40-StringLiteral">StringLiteral</a>)* ")"</code></td><td></td></tr></tbody></table><p>This section defines the semantics of different <code>ItemTypes</code> in terms of the values that they match.</p><p><span style="display: none;" class="delete_version">An <a title="item type designator" class="termref" href="#dt-item-type-designator">item type designator</a> written simply as an <code>EQName</code> (that is, a <code>NamedType</code>) is interpreted as follows:</span><span style="display: none;" class="add_version">An item type written simply as an <code>EQName</code> (that is, a <code>NamedType</code>) is interpreted as follows:</span><span class="modify_version">An <a title="item type designator" class="termref" href="#dt-item-type-designator"><span class="deltaxml-old">item type designator</span></a><span class="deltaxml-new">item type</span> written simply as an <code>EQName</code> (that is, a <code>NamedType</code>) is interpreted as follows:</span></p><ol class="enumar"><li><p><span style="display: none;" class="delete_version">If the name is written as a lexical QName, then it is expanded using the <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>. If the name is an unprefixed <code>NCName</code>, then it is expanded according to the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>.</span><span style="display: none;" class="add_version">If the name is written as a lexical QName, then it is expanded using the <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>. If the name is an unprefixed <code>NCName</code>, then it is taken as being in the <a class="termref" title="default type namespace" href="#dt-def-type-ns">default type namespace</a>.</span><span class="modify_version">If the name is written as a lexical QName, then it is expanded using the <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>. If the name is an unprefixed <code>NCName</code>, then it is <span class="deltaxml-old">expanded according to</span><span class="deltaxml-new">taken as being in</span> the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><a class="termref" title="default type namespace" href="#dt-def-type-ns"><span class="deltaxml-new">default type namespace</span></a>.</span></p></li><li><p>If the name matches <span class="deltaxml-old">a</span><span class="deltaxml-new">an entry in the</span> <a class="termref" title="item type aliases" href="#dt-item-type-aliases"><span class="deltaxml-old">named </span>item type<span class="deltaxml-new"> aliases</span></a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, then it is taken as a reference to the corresponding item type. The rules that apply are the rules for the expanded item type definition.</p></li><li><p>Otherwise, it must match the name of a type in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>: specifically, an atomic type or a plain union type. See <a href="#id-atomic-and-union-types"><b>3.6.2 Atomic and Union Types</b></a> for details. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>A name in the <code>xs</code> namespace will always fall into this category, since the namespace is reserved.</p></div></li><li><p>If the name cannot be resolved to a type, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0051" title="err:XPST0051">err:XPST0051</a>].</p></li></ol><div class="div3"><h4><a id="general-item-types"></a>3.6.1 General item types</h4><ul><li><p><code>item()</code> matches any single <a title="item" class="termref" href="#dt-item">item</a>.</p><p>Example: <code>item()</code> matches the atomic value <code>1</code>, the element <code>&lt;a/&gt;</code>, or the function <code>fn:concat#3</code>.</p></li><li><p>A <a href="#doc-xquery40-ParenthesizedItemType">ParenthesizedItemType</a> <span class="deltaxml-old">designates the same</span><span class="deltaxml-new">matches an item if and only if the item</span> <a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-old">item type</span></a><span class="deltaxml-old"> as</span><span class="deltaxml-new">matches</span> the <a href="#doc-xquery40-ItemType">ItemType</a> that is in parentheses.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">Parenthesized item types are used primarily when defining nested item types in a function signature. For example, a sequence of functions that each return a single boolean might be denoted <code>(function() as xs:boolean)*</code>. In this example the parentheses are needed to indicate where the occurrence indicator belongs.</span><span style="display: none;" class="add_version">Parenthesized item types are used primarily when defining nested item types in a function signature: for example a sequence of functions that return booleans might be denoted <code>(function () as xs:boolean)*</code>. In this example the parentheses are needed to indicate where the occurrence indicator belongs.</span><span class="modify_version">Parenthesized item types are used primarily when defining nested item types in a function signature<span class="deltaxml-old">. For example,</span><span class="deltaxml-new">: for example</span> a sequence of functions that <span class="deltaxml-old">each return a single boolean</span><span class="deltaxml-new">return booleans</span> might be denoted <code>(function<span class="deltaxml-new"> </span>() as xs:boolean)*</code>. In this example the parentheses are needed to indicate where the occurrence indicator belongs.</span></p></div></li></ul></div><div class="div3"><h4><a id="id-atomic-and-union-types"></a>3.6.2 Atomic and Union Types</h4><p>A <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> may be <span class="deltaxml-old">designated by</span><span class="deltaxml-new">expressed as</span> an <a href="#doc-xquery40-ItemType">ItemType</a> in any of the following ways:</p><ul><li><p>Using the QName of a type in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> that is an atomic type or a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a>.</p></li><li><p>Using a QName that identifies a <a class="termref" title="named item type" href="#dt-named-item-type"><span class="deltaxml-old">named item type</span></a><a class="termref" title="type alias" href="#dt-type-alias"><span class="deltaxml-new">type alias</span></a> that resolves to a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a>.</p></li><li><p>Using a <a href="#doc-xquery40-ParenthesizedItemType">ParenthesizedItemType</a> where the parentheses enclose a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a>.</p></li><li><p>Using a <a href="#doc-xquery40-LocalUnionType">LocalUnionType</a> as described below.</p></li><li><p>Using an <a href="#doc-xquery40-EnumerationType">EnumerationType</a> as described below.</p></li></ul><p>An atomic value <var>A</var> matches the <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a><var>GAT</var> if the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of <var>A</var> (call it <var>T</var>) satisfies the condition <code>derives-from(T, GAT)</code>.</p><p>Example: The <a href="#doc-xquery40-ItemType">ItemType</a><code>xs:decimal</code> matches any value of type <code>xs:decimal</code>. It also matches any value of type <code>shoesize</code>, if <code>shoesize</code> is an atomic type derived by restriction from <code>xs:decimal</code>.</p><p><span style="display: none;" class="delete_version">Example: Suppose <a href="#doc-xquery40-ItemType">ItemType</a><code>dress-size</code> is a union type that allows either <code>xs:decimal</code> values for numeric sizes (for example: 4, 6, 10, 12), or one of an enumerated set of <code>xs:strings</code> (for example: <code>small</code>, <code>medium</code>, <code>large</code>). The <a href="#doc-xquery40-ItemType">ItemType</a><code>dress-size</code> matches any of these values.</span><span style="display: none;" class="add_version">Example: Suppose <a href="#doc-xquery40-ItemType">ItemType</a><code>dress-size</code> is a union type that allows either <code>xs:decimal</code> values for numeric sizes (e.g. 4, 6, 10, 12), or one of an enumerated set of <code>xs:strings</code> (e.g. "small", "medium", "large"). The <a href="#doc-xquery40-ItemType">ItemType</a><code>dress-size</code> matches any of these values.</span><span class="modify_version">Example: Suppose <a href="#doc-xquery40-ItemType">ItemType</a><code>dress-size</code> is a union type that allows either <code>xs:decimal</code> values for numeric sizes (<span class="deltaxml-old">for example:</span><span class="deltaxml-new">e.g.</span> 4, 6, 10, 12), or one of an enumerated set of <code>xs:strings</code> (<span class="deltaxml-old">for example: </span><span class="deltaxml-new">e.g. "</span>small<span class="deltaxml-new">"</span>, <span class="deltaxml-new">"</span>medium<span class="deltaxml-new">"</span>, <span class="deltaxml-new">"</span>large<span class="deltaxml-new">"</span>). The <a href="#doc-xquery40-ItemType">ItemType</a><code>dress-size</code> matches any of these values.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The names of <span>list</span> types such as <code>xs:IDREFS</code> are not accepted in this context, but can often be replaced by a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> with an occurrence indicator, such as <code>xs:IDREF+</code>.</p></div><div class="div4"><h5><a id="id-local-union-types"></a>3.6.2.1 Local Union Types</h5><p>A <code>LocalUnionType</code> defines an anonymous union type locally (for example, within a function signature) which may be more convenient than defining the type in an imported schema.</p><a id="d3e6186"></a><a id="d3e5899"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LocalUnionType"></a>[<span class="deltaxml-old">259</span><span class="deltaxml-new">245</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-LocalUnionType">LocalUnionType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"union" "(" <a href="#doc-xquery40-ItemType">ItemType</a> ("," <a href="#doc-xquery40-ItemType">ItemType</a>)* ")"</code></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version">Although the grammar allows any <code>ItemType</code> to appear, each <code>ItemType</code> must identify a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> [<a href="#ERRXPST0147" title="err:XPST0147">err:XPST0147</a>].</span><span style="display: none;" class="add_version">Although the grammar allows any <code>ItemType</code> to appear, each <code>ItemType</code> must identify a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a>. [TODO: error code]</span><span class="modify_version">Although the grammar allows any <code>ItemType</code> to appear, each <code>ItemType</code> must identify a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a><span class="deltaxml-new">.</span> [<a href="#ERRXPST0147" title="err:XPST0147"><span class="deltaxml-old">err:XPST0147</span></a><span class="deltaxml-old">].</span><span class="deltaxml-new">TODO: error code]</span></span></p><p>A <code>LocalUnionType</code> is a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a>. It is classified as a <a title="schema type" class="termref" href="#dt-schema-type">schema type</a> even though it is not defined in any XSD schema.</p><p>An item matches a <code>LocalUnionType</code> if it matches any of the <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic types</a> listed within the parentheses.</p><p>For example, the type <code>union(xs:date, xs:dateTime, xs:time)</code> matches any value that is an instance of <code>xs:date</code>, <code>xs:dateTime</code>, or <code>xs:time</code>.</p><p>Similarly, the type <code>union(xs:NCName, enum(""))</code> matches any value that is either an instance of <code>xs:NCName</code>, or a zero-length string. This might be a suitable type for a variable that holds a namespace prefix.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Local union types are particularly useful in function signatures, allowing a function to take arguments of a variety of types. The semantics are identical to using a named union type, but a local union type is more convenient because it does not need to be defined in a schema, and does not require a schema-aware processor.</p><p>A local union type can also be used in a cast expression: <code>cast @when as union(xs:date, xs:dateTime)</code> allows the attribute <code>@when</code> to be either a date, or a dateTime.</p><p><span style="display: none;" class="delete_version">An <code>instance of</code> expression can be used to test whether a value belongs to one of a number of specified types: <code>$x instance of union(xs:string, xs:anyURI, xs:untypedAtomic)</code> returns <code>true</code> if <code>$x</code> is an instance of any of these three atomic types.</span><span style="display: none;" class="add_version">An <code>instance of</code> expression can be used to test whether a value belongs to one of a number of specified types: <code>$x instance of union(xs:string, xs:anyURI, xs:untypedAtomic)</code> returns true if <code>$x</code> is an instance of any of these three atomic types.</span><span class="modify_version">An <code>instance of</code> expression can be used to test whether a value belongs to one of a number of specified types: <code>$x instance of union(xs:string, xs:anyURI, xs:untypedAtomic)</code> returns true if <code>$x</code> is an instance of any of these three atomic types.</span></p></div></div><div class="div4"><h5><a id="id-enumeration-types"></a>3.6.2.2 Enumeration Types</h5><p> [<a id="dt-EnumerationType" title="EnumerationType">Definition</a>: An <b>EnumerationType</b> accepts a fixed set of string values.] </p><a id="d3e6268"></a><a id="d3e5977"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-EnumerationType"></a>[<span class="deltaxml-old">260</span><span class="deltaxml-new">246</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EnumerationType">EnumerationType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"enum" "(" <a href="#doc-xquery40-StringLiteral">StringLiteral</a> ("," <a href="#doc-xquery40-StringLiteral">StringLiteral</a>)* ")"</code></td><td></td></tr></tbody></table><p><span class="deltaxml-old">An </span><code><span class="deltaxml-old">EnumerationType</span></code><span class="deltaxml-old"> has a value space consisting of a set of </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> values. When matching strings against an enumeration type, strings are always compared using the Unicode codepoint collation.</span></p><p><span class="deltaxml-new">An item matches an </span><code><span class="deltaxml-new">EnumerationType</span></code><span class="deltaxml-new"> if it is an instance of </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new">, and is equal to one of the string literals listed within the parentheses, when compared using the codepoint collation.</span></p><p><span style="display: none;" class="delete_version">For example, if an argument of a function declares the required type as <code>enum("red", "green", "blue")</code>, then the string <code>"green"</code> is accepted, while <code>"yellow"</code> is rejected with a type error.</span><span style="display: none;" class="add_version">For example, the type <code>enum("red", "green", "blue")</code> matches the string "green".</span><span class="modify_version">For example, <span class="deltaxml-old">if an argument of a function declares the required type as</span><span class="deltaxml-new">the type</span> <code>enum("red", "green", "blue")</code><span class="deltaxml-old">, then</span><span class="deltaxml-new"> matches</span> the string "green"<span class="deltaxml-old"> is accepted, while </span><span class="deltaxml-old">"yellow"</span><span class="deltaxml-old"> is rejected with a type error</span>.</span></p><p><span class="deltaxml-old">Technically, enumeration types are defined as follows:</span></p><ul><li><p><span class="deltaxml-old">An enumeration type with a single enumerated value (such as </span><code><span class="deltaxml-old">enum("red")</span></code><span class="deltaxml-old">) is an atomic type derived from </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> by restriction using an enumeration facet that permits only the value </span><code><span class="deltaxml-old">"red"</span></code><span class="deltaxml-old">. This is referred to as a </span><b><span class="deltaxml-old">singleton enumeration type</span></b><span class="deltaxml-old">. It is equivalent to the XSD-defined type:</span></p><div class="exampleInner"><pre><span class="deltaxml-old"> &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:enumeration value="red"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt;</span></pre></div></li><li><p><span class="deltaxml-old">Two singleton enumeration types are the same type if and only if they have the same (single) enumerated value, as determined using the Unicode codepoint collation.</span></p></li><li><p><span class="deltaxml-old">An enumeration type with multiple enumerated values is a union of singleton enumeration types, so </span><code><span class="deltaxml-old">enum("red", "green", "blue")</span></code><span class="deltaxml-old"> is equivalent to </span><code><span class="deltaxml-old">union(enum("red"), enum("green"), enum("blue"))</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">In consequence, an enumeration type </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> is a subtype of an enumeration type </span><var><span class="deltaxml-old">U</span></var><span class="deltaxml-old"> if the enumerated values of </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> are a subset of the enumerated values of </span><var><span class="deltaxml-old">U</span></var><span class="deltaxml-old">: see </span><a href="#id-itemtype-subtype"><b><span class="deltaxml-old">3.7.2 Subtypes of Item Types</span></b></a><span class="deltaxml-old">.</span></p></li></ul><p><span class="deltaxml-old">An enumeration type is thus a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-old">generalized atomic type</span></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">It follows from these rules that an atomic value will only satisfy an </span><code><span class="deltaxml-old">instance of</span></code><span class="deltaxml-old"> test if it has the correct type annotation, and this can only be achieved using an explicit cast or constructor function. So the expression </span><code><span class="deltaxml-old">"red" instance of enum("red", "green", "blue")</span></code><span class="deltaxml-old"> returns </span><code><span class="deltaxml-old">false</span></code><span class="deltaxml-old">. However, the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-old">coercion rules</span></a><span class="deltaxml-old"> ensure that where a variable or function declaration specifies an enumeration type as the required type, a string (or indeed an </span><code><span class="deltaxml-old">xs:untypedAtomic</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">xs:anyURI</span></code><span class="deltaxml-old"> value) equal to one of the enumerated values will be accepted.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">Unlike a schema-defined type that restricts </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> with an enumeration facet, matching of an </span><code><span class="deltaxml-new">EnumerationType</span></code><span class="deltaxml-new"> is based purely on value comparison, and not on type annotations. For example, if </span><code><span class="deltaxml-new">color</span></code><span class="deltaxml-new"> is a schema-defined atomic type derived from </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> with an enumeration facet permitting the values ("red", "green", "blue"), the expression </span><code><span class="deltaxml-new">"green" instance of color</span></code><span class="deltaxml-new"> is false, because the type annotation does not match. By contrast, </span><code><span class="deltaxml-new">"green" instance of enum("red", "green", "blue")</span></code><span class="deltaxml-new"> is true.</span></p><p><span class="deltaxml-new">An </span><b><span class="deltaxml-new">EnumerationType</span></b><span class="deltaxml-new"> only matches </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> values, not </span><code><span class="deltaxml-new">xs:untypedAtomic</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new"> values, even though these might compare equal. However, the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new">coercion rules</span></a><span class="deltaxml-new"> allow </span><code><span class="deltaxml-new">xs:untypedAtomic</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new"> values to be supplied where the required type is an enumeration type.</span></p></div></div></div><div class="div3"><h4><a id="node-types"></a>3.6.3 Node Types</h4><p>Some of the constructs described in this section include a <a href="#doc-xquery40-TypeName">TypeName</a>. This appears as <var>T</var> in:</p><ul><li><p><code>element(N, T)</code></p></li><li><p><code>attribute(N, T)</code></p></li><li><p><code>document-node(element(N, T))</code></p></li></ul><p><span style="display: none;" class="delete_version">In these constructs, the type name <var>T</var> is expanded using the <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, using the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> if it is unprefixed. The resulting QName must identify a type in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>. This can be any <a title="schema type" class="termref" href="#dt-schema-type">schema type</a>: either a simple type, or (except in the case of attributes) a complex type. If it is a simple type then it can be an atomic, union, or list type. It can be a built-in type (such as <code>xs:integer</code>) or a user-defined type. It must however be the name of a type defined in a schema; it cannot be a <a class="termref" title="named item type" href="#dt-named-item-type">named item type</a>.</span><span style="display: none;" class="add_version">In these constructs, the type name <var>T</var> is expanded using the <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, using the <a class="termref" title="default type namespace" href="#dt-def-type-ns">default type namespace</a> if it is unprefixed. The resulting QName must identify a type in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>. This can be any <a title="schema type" class="termref" href="#dt-schema-type">schema type</a>: either a simple type, or (except in the case of attributes) a complex type. If it is a simple type then it can be an atomic, union, or list type. It can be a built-in type (such as <code>xs:integer</code>) or a user-defined type. It must however be the name of a type defined in a schema; it cannot be a <a class="termref" title="type alias" href="#dt-type-alias">type alias</a>.</span><span class="modify_version">In these constructs, the type name <var>T</var> is expanded using the <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, using the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><a class="termref" title="default type namespace" href="#dt-def-type-ns"><span class="deltaxml-new">default type namespace</span></a> if it is unprefixed. The resulting QName must identify a type in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>. This can be any <a title="schema type" class="termref" href="#dt-schema-type">schema type</a>: either a simple type, or (except in the case of attributes) a complex type. If it is a simple type then it can be an atomic, union, or list type. It can be a built-in type (such as <code>xs:integer</code>) or a user-defined type. It must however be the name of a type defined in a schema; it cannot be a <a class="termref" title="named item type" href="#dt-named-item-type"><span class="deltaxml-old">named item type</span></a><a class="termref" title="type alias" href="#dt-type-alias"><span class="deltaxml-new">type alias</span></a>.</span></p><div class="div4"><h5><a id="id-simple-node-tests"></a>3.6.3.1 Simple Node Tests</h5><ul><li><p><code>node()</code> matches any node.</p></li><li><p><code>text()</code> matches any text node.</p></li><li><p><code>processing-instruction()</code> matches any processing-instruction node.</p></li><li><p><span style="display: none;" class="delete_version"><code>processing-instruction(</code><em>N</em><code>)</code> matches any processing-instruction node whose PITarget is equal to <code>fn:normalize-space(N)</code>. If the result of <code>fn:normalize-space(N)</code> is not in the lexical space of NCName, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] </span><span style="display: none;" class="add_version"><code>processing-instruction(</code><em>N</em><code>)</code> matches any processing-instruction node whose PITarget is equal to <code>fn:normalize-space(N)</code>. If <code>fn:normalize-space(N)</code> is not in the lexical space of NCName, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] </span><span class="modify_version"><code>processing-instruction(</code><em>N</em><code>)</code> matches any processing-instruction node whose PITarget is equal to <code>fn:normalize-space(N)</code>. If <span class="deltaxml-old">the result of </span><code>fn:normalize-space(N)</code> is not in the lexical space of NCName, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] </span></p><p>Example: <code>processing-instruction(xml-stylesheet)</code> matches any processing instruction whose PITarget is <code>xml-stylesheet</code>.</p><p>For backward compatibility with XPath 1.0, the PITarget of a processing instruction may also be expressed as a string literal, as in this example: <code>processing-instruction("xml-stylesheet")</code>.</p><p>If the specified PITarget is not a syntactically valid NCName, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p><code>comment()</code> matches any comment node.</p></li><li><p><code>namespace-node()</code> matches any namespace node.</p></li><li><p><code>document-node()</code> matches any document node.</p></li><li><p><code>document-node(</code><em>E</em><code>)</code> matches any document node that contains exactly one element node, optionally accompanied by one or more comment and processing instruction nodes, if <em>E</em> is an <a href="#doc-xquery40-ElementTest">ElementTest</a> or <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a> that matches the element node (see <a href="#id-element-test"><b>3.6.3.2 Element Test</b></a> and <a href="#id-schema-element-test"><b>3.6.3.3 Schema Element Test</b></a>).</p><p>Example: <code>document-node(element(book))</code> matches a document node containing exactly one element node that is matched by the ElementTest <code>element(book)</code>.</p></li><li><p>An <a href="#doc-xquery40-ItemType">ItemType</a> that is an <a href="#doc-xquery40-ElementTest">ElementTest</a>, <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a>, <a href="#doc-xquery40-AttributeTest">AttributeTest</a>, <a href="#doc-xquery40-SchemaAttributeTest">SchemaAttributeTest</a>, or <a href="#doc-xquery40-FunctionTest">FunctionTest</a> matches an item as described in the following sections. </p></li></ul></div><div class="div4"><h5><a id="id-element-test"></a>3.6.3.2 Element Test</h5><a id="d3e6517"></a><a id="d3e6200"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ElementTest"></a>[<span class="deltaxml-old">240</span><span class="deltaxml-new">227</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ElementTest">ElementTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"element" "(" (<a href="#doc-xquery40-NameTestUnion">NameTestUnion</a> ("," <a href="#doc-xquery40-TypeName">TypeName</a> "?"?)?)? ")"</code></span><span style="display: none;" class="add_version"><code>"element" "(" (<a href="#doc-xquery40-NameTest">NameTest</a> ("," <a href="#doc-xquery40-TypeName">TypeName</a> "?"?)?)? ")"</code></span><span class="modify_version"><code>"element" "(" (<a href="#doc-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a><a href="#doc-xquery40-NameTest"><span class="deltaxml-new">NameTest</span></a> ("," <a href="#doc-xquery40-TypeName">TypeName</a> "?"?)?)? ")"</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NameTestUnion"></a><span class="deltaxml-old">[104]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-NameTest"><span class="deltaxml-old">NameTest</span></a><span class="deltaxml-old"> ("|" </span><a href="#doc-xquery40-NameTest"><span class="deltaxml-old">NameTest</span></a><span class="deltaxml-old">)*</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e6087.doc-xquery40-NameTest"></a><a id="noid_d4e5766.doc-xquery40-NameTest"></a>[<span class="deltaxml-old">148</span><span class="deltaxml-new">139</span>]&nbsp;&nbsp;&nbsp;</td><td><code>NameTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a> | <a href="#doc-xquery40-Wildcard">Wildcard</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e6088.doc-xquery40-Wildcard"></a><a id="noid_d4e5767.doc-xquery40-ElementName"></a>[<span class="deltaxml-old">149</span><span class="deltaxml-new">231</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>Wildcard</code></span><span style="display: none;" class="add_version"><code>ElementName</code></span><span class="modify_version"><code><span class="deltaxml-old">Wildcard</span><span class="deltaxml-new">ElementName</span></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"*"<br>| (<a href="#prod-xquery40-NCName">NCName</a> ":*")<br>| ("*:" <a href="#prod-xquery40-NCName">NCName</a>)<br>| (<a href="#doc-xquery40-BracedURILiteral">BracedURILiteral</a> "*")</code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-EQName">EQName</a></code></span><span class="modify_version"><code><span class="deltaxml-old">"*"</span><span class="deltaxml-old">| (</span><a href="#prod-xquery40-NCName"><span class="deltaxml-old">NCName</span></a><span class="deltaxml-old"> ":*")</span><span class="deltaxml-old">| ("*:" </span><a href="#prod-xquery40-NCName"><span class="deltaxml-old">NCName</span></a><span class="deltaxml-old">)</span><span class="deltaxml-old">| (</span><a href="#doc-xquery40-BracedURILiteral"><span class="deltaxml-old">BracedURILiteral</span></a><span class="deltaxml-old"> "*")</span><a href="#doc-xquery40-EQName"><span class="deltaxml-new">EQName</span></a></code></span></td><td><span style="display: none;" class="delete_version"><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></span><span style="display: none;" class="add_version"></span><span class="modify_version"><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></span></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e6089.doc-xquery40-TypeName"></a><a id="noid_d4e5768.doc-xquery40-TypeName"></a>[<span class="deltaxml-old">246</span><span class="deltaxml-new">233</span>]&nbsp;&nbsp;&nbsp;</td><td><code>TypeName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody></table><p> An <a href="#doc-xquery40-ElementTest">ElementTest</a> is used to match an element node by its name and/or <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>. </p><p><span class="deltaxml-old">An unprefixed </span><a href="#doc-xquery40-EQName"><span class="deltaxml-old">EQName</span></a><span class="deltaxml-old"> within the </span><code><span class="deltaxml-old">NameTestUnion</span></code><span class="deltaxml-old"> is interpreted according to the </span><a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old">. The name need not be present in the </span><a class="termref" title="in-scope attribute declarations" href="#dt-is-attrs"><span class="deltaxml-old">in-scope element declarations</span></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">An unprefixed </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-old">TypeName</span></a><span class="deltaxml-old"> is interpreted according to the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old">. The </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-old">TypeName</span></a><span class="deltaxml-old"> must be present in the </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-old">in-scope schema types</span></a><span class="deltaxml-old"> [</span><a href="#ERRXPST0008" title="err:XPST0008"><span class="deltaxml-old">err:XPST0008</span></a><span class="deltaxml-old">] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><a title="substitution group" class="termref" href="#dt-substitution-group"><span class="deltaxml-old">Substitution groups</span></a><span class="deltaxml-old"> do not affect the semantics of </span><a href="#doc-xquery40-ElementTest"><span class="deltaxml-old">ElementTest</span></a><span class="deltaxml-old">.</span></p></div><p><span class="deltaxml-new"> The </span><a href="#doc-xquery40-ElementName"><span class="deltaxml-new">ElementName</span></a><span class="deltaxml-new"> and </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><span class="deltaxml-new"> of an </span><a href="#doc-xquery40-ElementTest"><span class="deltaxml-new">ElementTest</span></a><span class="deltaxml-new"> have their prefixes expanded to namespace URIs by means of the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new">statically known namespaces</span></a><span class="deltaxml-new">, or if unprefixed, </span><span><span class="deltaxml-new">the </span><a class="termref" title="default element namespace" href="#dt-def-element-ns"><span class="deltaxml-new">default element namespace</span></a><span class="deltaxml-new"> or </span><a title="default type namespace" class="termref" href="#dt-def-type-ns"><span class="deltaxml-new">default type namespace</span></a><span class="deltaxml-new"> respectively</span></span><span class="deltaxml-new">. The </span><a href="#doc-xquery40-ElementName"><span class="deltaxml-new">ElementName</span></a><span class="deltaxml-new"> need not be present in the </span><a class="termref" title="in-scope element declarations" href="#dt-is-elems"><span class="deltaxml-new">in-scope element declarations</span></a><span class="deltaxml-new">, but the </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><span class="deltaxml-new"> must be present in the </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-new">in-scope schema types</span></a><span class="deltaxml-new"> [</span><a href="#ERRXPST0008" title="err:XPST0008"><span class="deltaxml-new">err:XPST0008</span></a><span class="deltaxml-new">]. Note that </span><a title="substitution group" class="termref" href="#dt-substitution-group"><span class="deltaxml-new">substitution groups</span></a><span class="deltaxml-new"> do not affect the semantics of </span><a href="#doc-xquery40-ElementTest"><span class="deltaxml-new">ElementTest</span></a><span class="deltaxml-new">. </span></p><p><span style="display: none;" class="delete_version">An <a href="#doc-xquery40-ElementTest">ElementTest</a><var>ET</var> matches an item <var>E</var> if the following conditions are satisfied:</span><span style="display: none;" class="add_version"> An <a href="#doc-xquery40-ElementTest">ElementTest</a> may take any of the following forms: </span><span class="modify_version"><span class="deltaxml-new"> </span>An <a href="#doc-xquery40-ElementTest">ElementTest</a><span class="deltaxml-old">ET</span> <span class="deltaxml-old">matches an item</span><span class="deltaxml-new">may take any</span> <span class="deltaxml-old">E</span><span class="deltaxml-new">of</span> <span class="deltaxml-old">if </span>the following <span class="deltaxml-old">conditions are satisfied:</span><span class="deltaxml-new">forms: </span></span></p><ol class="enumar"><li><p><var><span class="deltaxml-old">E</span></var><span class="deltaxml-old"> is an element node.</span></p></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">ET</span></var><span class="deltaxml-old"> includes a </span><a href="#doc-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a><span class="deltaxml-old">, then the name of the element node </span><var><span class="deltaxml-old">E</span></var><span class="deltaxml-old"> matches one or more of the </span><a href="#doc-xquery40-NameTest"><span class="deltaxml-old">NameTests</span></a><span class="deltaxml-old"> in the </span><a href="#doc-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a><span class="deltaxml-old">. A name </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> matches a </span><a href="#doc-xquery40-NameTest"><span class="deltaxml-old">NameTest</span></a><var><span class="deltaxml-old">NT</span></var><span class="deltaxml-old"> if one of the following conditions is true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-old">NT</span></var><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">*</span></code></p></li><li><p><var><span class="deltaxml-old">NT</span></var><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">*:</span><em><span class="deltaxml-old">local</span></em></code><span class="deltaxml-old"> and the local part of </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> is </span><var><span class="deltaxml-old">local</span></var><span class="deltaxml-old">.</span></p></li><li><p><var><span class="deltaxml-old">NT</span></var><span class="deltaxml-old"> is </span><code><em><span class="deltaxml-old">prefix</span></em><span class="deltaxml-old">:*</span></code><span class="deltaxml-old"> and the namespace URI of </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> matches the namespace URI bound to </span><var><span class="deltaxml-old">prefix</span></var><span class="deltaxml-old"> in the static context.</span></p></li><li><p><var><span class="deltaxml-old">NT</span></var><span class="deltaxml-old"> is </span><code><em><span class="deltaxml-old">BracedURILiteral</span></em><span class="deltaxml-old">*</span></code><span class="deltaxml-old"> and the namespace URI of </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> matches the namespace URI found in the </span><code><span class="deltaxml-old">BracedURILiteral</span></code><span class="deltaxml-old">.</span></p></li><li><p><var><span class="deltaxml-old">NT</span></var><span class="deltaxml-old"> is an </span><code><span class="deltaxml-old">EQName</span></code><span class="deltaxml-old"> equal to </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old">.</span></p></li></ol></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">ET</span></var><span class="deltaxml-old"> includes a </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-old">TypeName</span></a><span class="deltaxml-old">, then the </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-old">type annotation</span></a><span class="deltaxml-old"> of the element node </span><var><span class="deltaxml-old">E</span></var><span class="deltaxml-old"> is either the schema type identified by that type name, or a type derived from that type by restriction.</span></p></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">E</span></var><span class="deltaxml-old"> has the </span><code><span class="deltaxml-old">nilled</span></code><span class="deltaxml-old"> property, then </span><var><span class="deltaxml-old">ET</span></var><span class="deltaxml-old"> either includes no </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-old">TypeName</span></a><span class="deltaxml-old">, or includes a </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-old">TypeName</span></a><span class="deltaxml-old"> followed by the symbol </span><code><span class="deltaxml-old">?</span></code><span class="deltaxml-old">.</span></p></li></ol><p><span class="deltaxml-old">Here are some examples of </span><a href="#doc-xquery40-ElementTest"><span class="deltaxml-old">ElementTests</span></a><span class="deltaxml-old">:</span></p><ol class="enumar"><li><p><code>element()</code> and <code>element(*)</code> match any single element node, regardless of its name or type annotation.</p></li><li><p><code><span class="deltaxml-new">element(</span></code><a href="#doc-xquery40-ElementName"><span class="deltaxml-new">ElementName</span></a><code><span class="deltaxml-new">)</span></code><span class="deltaxml-new"> matches any element node whose name is </span><a href="#doc-xquery40-ElementName"><span class="deltaxml-new">ElementName</span></a><span class="deltaxml-new">, regardless of its type annotation or </span><code><span class="deltaxml-new">nilled</span></code><span class="deltaxml-new"> property.</span></p><p><span style="display: none;" class="delete_version"><code>element(person)</code> matches any element node whose name is <code>person</code>, in the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>.</span><span style="display: none;" class="add_version">Example: <code>element(person)</code> matches any element node whose name is <code>person</code>.</span><span class="modify_version"><span class="deltaxml-new">Example: </span><code>element(person)</code> matches any element node whose name is <code>person</code><span class="deltaxml-old">, in the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a>.</span></p></li><li class="delete_version" style="display: none;"><p><code>element(doctor|nurse)</code> matches any element node whose name is <code>doctor</code> or <code>nurse</code>, in the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>.</p></li><li class="modify_version"><p><code><span class="deltaxml-old">element(doctor|nurse)</span></code><span class="deltaxml-old"> matches any element node whose name is </span><code><span class="deltaxml-old">doctor</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">nurse</span></code><span class="deltaxml-old">, in the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old">.</span></p></li><li><p><code><span class="deltaxml-new">element(prefix:*)</span></code><span class="deltaxml-new"> matches any element node whose name is in the namespace bound to the given prefix, regardless of its type annotation or </span><code><span class="deltaxml-new">nilled</span></code><span class="deltaxml-new"> property.</span></p><p><span style="display: none;" class="delete_version"><code>element(xhtml:*)</code> matches any element node whose name is in the namespace bound to the prefix <code>xhtml</code>.</span><span style="display: none;" class="add_version">Example: <code>element(xhtml:*)</code> matches any element node whose name is in the namespace bound to the prefix <code>xhtml</code>.</span><span class="modify_version"><span class="deltaxml-new">Example: </span><code>element(xhtml:*)</code> matches any element node whose name is in the namespace bound to the prefix <code>xhtml</code>.</span></p></li><li class="delete_version" style="display: none;"><p><code>element(xhtml:*|svg:*|mathml|*)</code> matches any element node whose name is one of the three namespaces identified, specifically the namespaces bound to the prefixes <code>xhtml</code>, <code>svg</code>, and <code>mathml</code>.</p></li><li class="modify_version"><p><code><span class="deltaxml-old">element(xhtml:*|svg:*|mathml|*)</span></code><span class="deltaxml-old"> matches any element node whose name is one of the three namespaces identified, specifically the namespaces bound to the prefixes </span><code><span class="deltaxml-old">xhtml</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">svg</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">mathml</span></code><span class="deltaxml-old">.</span></p></li><li><p><code><span class="deltaxml-new">element(Q{uri}*)</span></code><span class="deltaxml-new"> matches any element node whose name is in the namespace given as </span><code><span class="deltaxml-new">uri</span></code><span class="deltaxml-new">, regardless of its type annotation or </span><code><span class="deltaxml-new">nilled</span></code><span class="deltaxml-new"> property.</span></p><p><span style="display: none;" class="delete_version"><code>element(Q{"http://www.w3.org/2000/svg"}*)</code> matches any element node whose name is in the SVG namespace.</span><span style="display: none;" class="add_version">Example: <code>element(Q{"http://www.w3.org/2000/svg"}*)</code> matches any element node whose name is in the SVG namespace.</span><span class="modify_version"><span class="deltaxml-new">Example: </span><code>element(Q{"http://www.w3.org/2000/svg"}*)</code> matches any element node whose name is in the SVG namespace.</span></p></li><li><p><code><span class="deltaxml-new">element(*:local)</span></code><span class="deltaxml-new"> matches any element node whose local name is the name given as </span><code><span class="deltaxml-new">local</span></code><span class="deltaxml-new">, regardless of its namespace, type annotation or </span><code><span class="deltaxml-new">nilled</span></code><span class="deltaxml-new"> property.</span></p><p><span style="display: none;" class="delete_version"><code>element(*:html)</code> matches any element node whose local name is <code>"html"</code>, in any namespace.</span><span style="display: none;" class="add_version">Example: <code>element(*:html)</code> matches any element node whose local name is "html".</span><span class="modify_version"><span class="deltaxml-new">Example: </span><code>element(*:html)</code> matches any element node whose local name is "html"<span class="deltaxml-old">, in any namespace</span>.</span></p></li><li><p><code><span class="deltaxml-new">element(</span></code><a href="#doc-xquery40-ElementName"><span class="deltaxml-new">ElementName</span></a><code><span class="deltaxml-new">,</span></code><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><code><span class="deltaxml-new">)</span></code><span class="deltaxml-new"> matches an element node whose name is </span><a href="#doc-xquery40-ElementName"><span class="deltaxml-new">ElementName</span></a><span class="deltaxml-new"> if </span><code><span class="deltaxml-new">derives-from(</span></code><em><span class="deltaxml-new">AT</span></em><span class="deltaxml-new">, </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><code><span class="deltaxml-new">)</span></code><span class="deltaxml-new"> is </span><code><span class="deltaxml-new">true</span></code><span class="deltaxml-new">, where </span><em><span class="deltaxml-new">AT</span></em><span class="deltaxml-new"> is the type annotation of the element node, and the </span><code><span class="deltaxml-new">nilled</span></code><span class="deltaxml-new"> property of the node is </span><code><span class="deltaxml-new">false</span></code><span class="deltaxml-new">.</span></p><p><span style="display: none;" class="delete_version"><code>element(person, surgeon)</code> matches a non-nilled element node whose name is <code>person</code> and whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>). </span><span style="display: none;" class="add_version">Example: <code>element(person, surgeon)</code> matches a non-nilled element node whose name is <code>person</code> and whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>). </span><span class="modify_version"><span class="deltaxml-new">Example: </span><code>element(person, surgeon)</code> matches a non-nilled element node whose name is <code>person</code> and whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>). </span></p><p><span class="deltaxml-new">The </span><code><span class="deltaxml-new">ElementName</span></code><span class="deltaxml-new"> in this example can also be replaced by one of the forms </span><code><span class="deltaxml-new">prefix:*</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">Q{uri}*</span></code><span class="deltaxml-new">, or </span><code><span class="deltaxml-new">*:local</span></code><span class="deltaxml-new">.</span></p></li><li><p><code><span class="deltaxml-new">element(</span></code><a href="#doc-xquery40-ElementName"><span class="deltaxml-new">ElementName</span></a><span class="deltaxml-new">, </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><code><span class="deltaxml-new"> ?)</span></code><span class="deltaxml-new"> matches an element node whose name is </span><a href="#doc-xquery40-ElementName"><span class="deltaxml-new">ElementName</span></a><span class="deltaxml-new"> if </span><code><span class="deltaxml-new">derives-from(</span></code><em><span class="deltaxml-new">AT</span></em><span class="deltaxml-new">, </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><code><span class="deltaxml-new">)</span></code><span class="deltaxml-new"> is </span><code><span class="deltaxml-new">true</span></code><span class="deltaxml-new">, where </span><em><span class="deltaxml-new">AT</span></em><span class="deltaxml-new"> is the type annotation of the element node. The </span><code><span class="deltaxml-new">nilled</span></code><span class="deltaxml-new"> property of the node may be either </span><code><span class="deltaxml-new">true</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">false</span></code><span class="deltaxml-new">.</span></p><p><span style="display: none;" class="delete_version"><code>element(person, surgeon?)</code> matches a nilled or non-nilled element node whose name is <code>person</code> and whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>).</span><span style="display: none;" class="add_version">Example: <code>element(person, surgeon?)</code> matches a nilled or non-nilled element node whose name is <code>person</code> and whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>).</span><span class="modify_version"><span class="deltaxml-new">Example: </span><code>element(person, surgeon?)</code> matches a nilled or non-nilled element node whose name is <code>person</code> and whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>).</span></p><p><span class="deltaxml-new">The </span><code><span class="deltaxml-new">ElementName</span></code><span class="deltaxml-new"> in this example can also be replaced by one of the forms </span><code><span class="deltaxml-new">prefix:*</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">Q{uri}*</span></code><span class="deltaxml-new">, or </span><code><span class="deltaxml-new">*:local</span></code><span class="deltaxml-new">.</span></p></li><li><p><code><span class="deltaxml-new">element(*, </span></code><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><code><span class="deltaxml-new">)</span></code><span class="deltaxml-new"> matches an element node regardless of its name, if </span><code><span class="deltaxml-new">derives-from(</span></code><em><span class="deltaxml-new">AT</span></em><span class="deltaxml-new">, </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><code><span class="deltaxml-new">)</span></code><span class="deltaxml-new"> is </span><code><span class="deltaxml-new">true</span></code><span class="deltaxml-new">, where </span><em><span class="deltaxml-new">AT</span></em><span class="deltaxml-new"> is the type annotation of the element node, and the </span><code><span class="deltaxml-new">nilled</span></code><span class="deltaxml-new"> property of the node is </span><code><span class="deltaxml-new">false</span></code><span class="deltaxml-new">.</span></p><p><span style="display: none;" class="delete_version"><code>element(*, surgeon)</code> matches any non-nilled element node whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</span><span style="display: none;" class="add_version">Example: <code>element(*, surgeon)</code> matches any non-nilled element node whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</span><span class="modify_version"><span class="deltaxml-new">Example: </span><code>element(*, surgeon)</code> matches any non-nilled element node whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</span></p></li><li><p><code><span class="deltaxml-new">element(*,</span></code><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><code><span class="deltaxml-new"> ?)</span></code><span class="deltaxml-new"> matches an element node regardless of its name, if </span><code><span class="deltaxml-new">derives-from(</span></code><em><span class="deltaxml-new">AT</span></em><span class="deltaxml-new">, </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><code><span class="deltaxml-new">)</span></code><span class="deltaxml-new"> is </span><code><span class="deltaxml-new">true</span></code><span class="deltaxml-new">, where </span><em><span class="deltaxml-new">AT</span></em><span class="deltaxml-new"> is the type annotation of the element node. The </span><code><span class="deltaxml-new">nilled</span></code><span class="deltaxml-new"> property of the node may be either </span><code><span class="deltaxml-new">true</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">false</span></code><span class="deltaxml-new">.</span></p><p><span style="display: none;" class="delete_version"><code>element(*, surgeon?)</code> matches any nilled or non-nilled element node whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</span><span style="display: none;" class="add_version">Example: <code>element(*, surgeon?)</code> matches any nilled or non-nilled element node whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</span><span class="modify_version"><span class="deltaxml-new">Example: </span><code>element(*, surgeon?)</code> matches any nilled or non-nilled element node whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</span></p></li></ol><p><span class="deltaxml-old"> Where a </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-old">TypeName</span></a><span class="deltaxml-old"> is included in an </span><a href="#doc-xquery40-ElementTest"><span class="deltaxml-old">ElementTest</span></a><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old">, and element node will only match the test if it has been validated against a schema that defines type </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old">; furthermore, </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> must be present in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-old">in-scope schema definitions</span></a><span class="deltaxml-old"> of the static context of the </span><a href="#doc-xquery40-ElementTest"><span class="deltaxml-old">ElementTest</span></a><span class="deltaxml-old">. Although it is guaranteed that type </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> will have </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible"><span class="deltaxml-old">compatible</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old"> definitions in the schema that was used for validation and in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-old">in-scope schema definitions</span></a><span class="deltaxml-old">, it is not guaranteed that revalidation using the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-old">in-scope schema definitions</span></a><span class="deltaxml-old"> would succeed. For example, if substitution group membership varies between the two schemas, the element node may contain children or descendants that the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-old">in-scope schema definitions</span></a><span class="deltaxml-old"> would not allow. </span></p></div><div class="div4"><h5><a id="id-schema-element-test"></a>3.6.3.3 Schema Element Test</h5><a id="d3e6902"></a><a id="d3e6563"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SchemaElementTest"></a>[<span class="deltaxml-old">241</span><span class="deltaxml-new">228</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SchemaElementTest">SchemaElementTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"schema-element" "(" <a href="#doc-xquery40-ElementDeclaration">ElementDeclaration</a> ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ElementDeclaration"></a>[<span class="deltaxml-old">242</span><span class="deltaxml-new">229</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ElementDeclaration">ElementDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ElementName">ElementName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e6415.doc-xquery40-ElementName"></a><a id="noid_d4e6100.doc-xquery40-ElementName"></a>[<span class="deltaxml-old">244</span><span class="deltaxml-new">231</span>]&nbsp;&nbsp;&nbsp;</td><td><code>ElementName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody></table><p> A <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a> matches an element node against a corresponding element declaration found in the <a title="in-scope element declarations" class="termref" href="#dt-is-elems">in-scope element declarations</a>. </p><p><span style="display: none;" class="delete_version"> The <a href="#doc-xquery40-ElementName">ElementName</a> of a <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a> has its prefixes expanded to a namespace URI by means of the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>, or if unprefixed, the is interpreted according to the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>. If the <a href="#doc-xquery40-ElementName">ElementName</a> specified in the <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a> is not found in the <a title="in-scope element declarations" class="termref" href="#dt-is-elems">in-scope element declarations</a>, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>]. </span><span style="display: none;" class="add_version"> The <a href="#doc-xquery40-ElementName">ElementName</a> of a <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a> has its prefixes expanded to a namespace URI by means of the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>, or if unprefixed, the <span><a class="termref" title="default element namespace" href="#dt-def-element-ns">default element namespace</a></span>. If the <a href="#doc-xquery40-ElementName">ElementName</a> specified in the <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a> is not found in the <a title="in-scope element declarations" class="termref" href="#dt-is-elems">in-scope element declarations</a>, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>]. </span><span class="modify_version"> The <a href="#doc-xquery40-ElementName">ElementName</a> of a <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a> has its prefixes expanded to a namespace URI by means of the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>, or if unprefixed, the <span class="deltaxml-old">is</span><span class="deltaxml-old"> interpreted according to the </span><a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span><a class="termref" title="default element namespace" href="#dt-def-element-ns"><span class="deltaxml-new">default element namespace</span></a></span>. If the <a href="#doc-xquery40-ElementName">ElementName</a> specified in the <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a> is not found in the <a title="in-scope element declarations" class="termref" href="#dt-is-elems">in-scope element declarations</a>, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>]. </span></p><p> A <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a> matches a candidate element node if all of the following conditions are satisfied: </p><ol class="enumar"><li><p>Either:</p><ol class="enumla"><li><p>The name <em>N</em> of the candidate node matches the specified <a href="#doc-xquery40-ElementName">ElementName</a>, or</p></li><li><p>The name <em>N</em> of the candidate node matches the name of an element declaration that is a member of the actual substitution group headed by the declaration of element <a href="#doc-xquery40-ElementName">ElementName</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">The term “actual substitution group” is defined in <a href="#XMLSchema11">[XML Schema 1.1]</a>. The actual substitution group of an element declaration <em>H</em> includes those element declarations <em>P</em> that are declared to have <em>H</em> as their direct or indirect substitution group head, provided that <em>P</em> is not declared as abstract, and that <em>P</em> is validly substitutable for <em>H</em>, which means that there must be no blocking constraints that prevent substitution.</span><span style="display: none;" class="add_version">The term "actual substitution group" is defined in <a href="#XMLSchema11">[XML Schema 1.1]</a>. The actual substitution group of an element declaration <em>H</em> includes those element declarations <em>P</em> that are declared to have <em>H</em> as their direct or indirect substitution group head, provided that <em>P</em> is not declared as abstract, and that <em>P</em> is validly substitutable for <em>H</em>, which means that there must be no blocking constraints that prevent substitution.</span><span class="modify_version">The term <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>actual substitution group<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> is defined in <a href="#XMLSchema11">[XML Schema 1.1]</a>. The actual substitution group of an element declaration <em>H</em> includes those element declarations <em>P</em> that are declared to have <em>H</em> as their direct or indirect substitution group head, provided that <em>P</em> is not declared as abstract, and that <em>P</em> is validly substitutable for <em>H</em>, which means that there must be no blocking constraints that prevent substitution.</span></p></div></li><li><p>The schema element declaration named <em>N</em> is not abstract.</p></li><li><p><code>derives-from( AT, ET )</code> is true, where <em>AT</em> is the type annotation of the candidate node and <em>ET</em> is the schema type declared in the schema element declaration named <em>N</em>.</p></li><li><p><span style="display: none;" class="delete_version">If the schema element declaration named <em>N</em> is not nillable, then the nilled property of the candidate node is <code>false</code>.</span><span style="display: none;" class="add_version">If the schema element declaration named <em>N</em> is not nillable, then the nilled property of the candidate node is false.</span><span class="modify_version">If the schema element declaration named <em>N</em> is not nillable, then the nilled property of the candidate node is false.</span></p></li></ol><p>Example: The <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a><code>schema-element(customer)</code> matches a candidate element node in the following two situations: </p><ol class="enumar"><li><p>customer is a top-level element declaration in the in-scope element declarations; the name of the candidate node is customer; the element declaration of customer is not abstract; the type annotation of the candidate node is the same as or derived from the schema type declared in the customer element declaration; and either the candidate node is not nilled, or customer is declared to be nillable.</p></li><li><p>customer is a top-level element declaration in the in-scope element declarations; the name of the candidate node is client; client is an actual (non-abstract and non-blocked) member of the substitution group of customer; the type annotation of the candidate node is the same as or derived from the schema type declared for the client element; and either the candidate node is not nilled, or client is declared to be nillable.</p></li></ol><p><span class="deltaxml-old"> In the case where the schema </span><var><span class="deltaxml-old">X</span></var><span class="deltaxml-old"> used to validate an element node </span><var><span class="deltaxml-old">E</span></var><span class="deltaxml-old"> (whose name is </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old">) differs from the schema </span><var><span class="deltaxml-old">Y</span></var><span class="deltaxml-old"> represented by the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-old">in-scope schema definitions</span></a><span class="deltaxml-old"> in the static context of the </span><a href="#doc-xquery40-SchemaElementTest"><span class="deltaxml-old">SchemaElementTest</span></a><span class="deltaxml-old">, the following considerations apply:</span></p><ul><li><p><span class="deltaxml-old">In applying the test </span><code><span class="deltaxml-old">derives-from( AT, ET )</span></code><span class="deltaxml-old">, note that </span><var><span class="deltaxml-old">AT</span></var><span class="deltaxml-old"> will necessarily be present in </span><var><span class="deltaxml-old">X</span></var><span class="deltaxml-old">, but not necessarily in </span><var><span class="deltaxml-old">Y</span></var><span class="deltaxml-old">. However, </span><var><span class="deltaxml-old">ET</span></var><span class="deltaxml-old"> will necessarily be present in both; and because the two schemas must be </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible"><span class="deltaxml-old">compatible</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">, </span><var><span class="deltaxml-old">ET</span></var><span class="deltaxml-old"> will be the present in both schemas, will have the same definition in both, and will be the declared type of </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> in both. The test can therefore be applied from knowledge of type </span><var><span class="deltaxml-old">AT</span></var><span class="deltaxml-old"> as defined in schema </span><var><span class="deltaxml-old">X</span></var><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The test as to whether the element name </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> is a member of the actual substitution group is performed entirely by reference to schema </span><var><span class="deltaxml-old">Y</span></var><span class="deltaxml-old">. Although the two schemas are compatible, substitution group membership can vary.</span></p></li></ul></div><div class="div4"><h5><a id="id-attribute-test"></a>3.6.3.4 Attribute Test</h5><a id="d3e7094"></a><a id="d3e6706"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AttributeTest"></a>[<span class="deltaxml-old">237</span><span class="deltaxml-new">224</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AttributeTest">AttributeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"attribute" "(" (<a href="#doc-xquery40-NameTestUnion">NameTestUnion</a> ("," <a href="#doc-xquery40-TypeName">TypeName</a>)?)? ")"</code></span><span style="display: none;" class="add_version"><code>"attribute" "(" (<a href="#doc-xquery40-NameTest">NameTest</a> ("," <a href="#doc-xquery40-TypeName">TypeName</a>)?)? ")"</code></span><span class="modify_version"><code>"attribute" "(" (<a href="#doc-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a><a href="#doc-xquery40-NameTest"><span class="deltaxml-new">NameTest</span></a> ("," <a href="#doc-xquery40-TypeName">TypeName</a>)?)? ")"</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e6588.doc-xquery40-NameTestUnion"></a><span class="deltaxml-old">[104]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">NameTestUnion</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-NameTest"><span class="deltaxml-old">NameTest</span></a><span class="deltaxml-old"> ("|" </span><a href="#doc-xquery40-NameTest"><span class="deltaxml-old">NameTest</span></a><span class="deltaxml-old">)*</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e6589.doc-xquery40-NameTest"></a><a id="noid_d4e6224.doc-xquery40-NameTest"></a>[<span class="deltaxml-old">148</span><span class="deltaxml-new">139</span>]&nbsp;&nbsp;&nbsp;</td><td><code>NameTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a> | <a href="#doc-xquery40-Wildcard">Wildcard</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e6590.doc-xquery40-Wildcard"></a><a id="noid_d4e6225.doc-xquery40-AttributeName"></a>[<span class="deltaxml-old">149</span><span class="deltaxml-new">230</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>Wildcard</code></span><span style="display: none;" class="add_version"><code>AttributeName</code></span><span class="modify_version"><code><span class="deltaxml-old">Wildcard</span><span class="deltaxml-new">AttributeName</span></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"*"<br>| (<a href="#prod-xquery40-NCName">NCName</a> ":*")<br>| ("*:" <a href="#prod-xquery40-NCName">NCName</a>)<br>| (<a href="#doc-xquery40-BracedURILiteral">BracedURILiteral</a> "*")</code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-EQName">EQName</a></code></span><span class="modify_version"><code><span class="deltaxml-old">"*"</span><span class="deltaxml-old">| (</span><a href="#prod-xquery40-NCName"><span class="deltaxml-old">NCName</span></a><span class="deltaxml-old"> ":*")</span><span class="deltaxml-old">| ("*:" </span><a href="#prod-xquery40-NCName"><span class="deltaxml-old">NCName</span></a><span class="deltaxml-old">)</span><span class="deltaxml-old">| (</span><a href="#doc-xquery40-BracedURILiteral"><span class="deltaxml-old">BracedURILiteral</span></a><span class="deltaxml-old"> "*")</span><a href="#doc-xquery40-EQName"><span class="deltaxml-new">EQName</span></a></code></span></td><td><span style="display: none;" class="delete_version"><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></span><span style="display: none;" class="add_version"></span><span class="modify_version"><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></span></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e6591.doc-xquery40-TypeName"></a><a id="noid_d4e6226.doc-xquery40-TypeName"></a>[<span class="deltaxml-old">246</span><span class="deltaxml-new">233</span>]&nbsp;&nbsp;&nbsp;</td><td><code>TypeName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody></table><p> An <a href="#doc-xquery40-AttributeTest">AttributeTest</a> is used to match an attribute node by its name and/or <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>. </p><p><span class="deltaxml-old">An unprefixed </span><a href="#doc-xquery40-EQName"><span class="deltaxml-old">EQName</span></a><span class="deltaxml-old"> within the </span><code><span class="deltaxml-old">NameTestUnion</span></code><span class="deltaxml-old"> refers to a name in no namespace. The name need not be present in the </span><a title="in-scope attribute declarations" class="termref" href="#dt-is-attrs"><span class="deltaxml-old">in-scope attribute declarations</span></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">An unprefixed </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-old">TypeName</span></a><span class="deltaxml-old"> is interpreted according to the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old">. The </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-old">TypeName</span></a><span class="deltaxml-old"> must be present in the </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-old">in-scope schema types</span></a><span class="deltaxml-old"> [</span><a href="#ERRXPST0008" title="err:XPST0008"><span class="deltaxml-old">err:XPST0008</span></a><span class="deltaxml-old">] </span></p><p><span class="deltaxml-new"> The </span><a href="#doc-xquery40-AttributeName"><span class="deltaxml-new">AttributeName</span></a><span class="deltaxml-new"> and </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><span class="deltaxml-new"> of an </span><a href="#doc-xquery40-AttributeTest"><span class="deltaxml-new">AttributeTest</span></a><span class="deltaxml-new"> have their prefixes expanded to namespace URIs by means of the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new">statically known namespaces</span></a><span class="deltaxml-new">. If unprefixed, the </span><a href="#doc-xquery40-AttributeName"><span class="deltaxml-new">AttributeName</span></a><span class="deltaxml-new"> is in no namespace, but an unprefixed </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><span class="deltaxml-new"> is in the </span><span><a title="default type namespace" class="termref" href="#dt-def-type-ns"><span class="deltaxml-new">default type namespace</span></a></span><span class="deltaxml-new">. The </span><a href="#doc-xquery40-AttributeName"><span class="deltaxml-new">AttributeName</span></a><span class="deltaxml-new"> need not be present in the </span><a title="in-scope attribute declarations" class="termref" href="#dt-is-attrs"><span class="deltaxml-new">in-scope attribute declarations</span></a><span class="deltaxml-new">, but the </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><span class="deltaxml-new"> must be present in the </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-new">in-scope schema types</span></a><span class="deltaxml-new"> [</span><a href="#ERRXPST0008" title="err:XPST0008"><span class="deltaxml-new">err:XPST0008</span></a><span class="deltaxml-new">]. </span></p><p><span style="display: none;" class="delete_version">An <a href="#doc-xquery40-AttributeTest">AttributeTest</a><var>AT</var> matches an item <var>A</var> if the following conditions are satisfied:</span><span style="display: none;" class="add_version"> An <a href="#doc-xquery40-AttributeTest">AttributeTest</a> may take any of the following forms: </span><span class="modify_version"><span class="deltaxml-new"> </span>An <a href="#doc-xquery40-AttributeTest">AttributeTest</a><span class="deltaxml-old">AT</span> <span class="deltaxml-old">matches an item</span><span class="deltaxml-new">may take any</span> <span class="deltaxml-old">A</span><span class="deltaxml-new">of</span> <span class="deltaxml-old">if </span>the following <span class="deltaxml-old">conditions are satisfied:</span><span class="deltaxml-new">forms: </span></span></p><ol class="enumar"><li class="add_version" style="display: none;"><p><code>attribute()</code> and <code>attribute(*)</code> match any single attribute node, regardless of its name or type annotation.</p></li><li class="modify_version"><p><code><span class="deltaxml-new">attribute()</span></code><span class="deltaxml-new"> and </span><code><span class="deltaxml-new">attribute(*)</span></code><span class="deltaxml-new"> match any single attribute node, regardless of its name or type annotation.</span></p></li><li><p><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is an attribute node.</span></p><p><code><span class="deltaxml-new">attribute(</span></code><a href="#doc-xquery40-AttributeName"><span class="deltaxml-new">AttributeName</span></a><code><span class="deltaxml-new">)</span></code><span class="deltaxml-new"> matches any attribute node whose name is </span><a href="#doc-xquery40-AttributeName"><span class="deltaxml-new">AttributeName</span></a><span class="deltaxml-new">, regardless of its type annotation.</span></p><p><span class="deltaxml-new">Example: </span><code><span class="deltaxml-new">attribute(price)</span></code><span class="deltaxml-new"> matches any attribute node whose name is </span><code><span class="deltaxml-new">price</span></code><span class="deltaxml-new">.</span></p></li><li class="add_version" style="display: none;"><p><code>attribute(prefix:*)</code> matches any attribute node whose name is in the namespace bound to the given prefix, regardless of its type annotation.</p><p>Example: <code>attribute(xlink:*)</code> matches any attribute node whose name is in the namespace bound to the prefix <code>xlink</code>.</p></li><li class="modify_version"><p><code><span class="deltaxml-new">attribute(prefix:*)</span></code><span class="deltaxml-new"> matches any attribute node whose name is in the namespace bound to the given prefix, regardless of its type annotation.</span></p><p><span class="deltaxml-new">Example: </span><code><span class="deltaxml-new">attribute(xlink:*)</span></code><span class="deltaxml-new"> matches any attribute node whose name is in the namespace bound to the prefix </span><code><span class="deltaxml-new">xlink</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">AT</span></var><span class="deltaxml-old"> includes a </span><a href="#doc-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a><span class="deltaxml-old">, then the name of the attribute node </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> matches one or more of the </span><a href="#doc-xquery40-NameTest"><span class="deltaxml-old">NameTests</span></a><span class="deltaxml-old"> in the </span><a href="#doc-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a><span class="deltaxml-old">. A name </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> matches a </span><a href="#doc-xquery40-NameTest"><span class="deltaxml-old">NameTest</span></a><var><span class="deltaxml-old">NT</span></var><span class="deltaxml-old"> if one of the following conditions is true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-old">NT</span></var><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">*</span></code></p></li><li><p><var><span class="deltaxml-old">NT</span></var><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">*:</span><em><span class="deltaxml-old">local</span></em></code><span class="deltaxml-old"> and the local part of </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> matches </span><var><span class="deltaxml-old">local</span></var><span class="deltaxml-old">.</span></p></li><li><p><var><span class="deltaxml-old">NT</span></var><span class="deltaxml-old"> is </span><code><em><span class="deltaxml-old">prefix</span></em><span class="deltaxml-old">:*</span></code><span class="deltaxml-old"> and the namespace URI of </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> matches the namespace URI bound to </span><var><span class="deltaxml-old">prefix</span></var><span class="deltaxml-old"> in the static context.</span></p></li><li><p><var><span class="deltaxml-old">NT</span></var><span class="deltaxml-old"> is </span><code><em><span class="deltaxml-old">BracedURILiteral</span></em><span class="deltaxml-old">*</span></code><span class="deltaxml-old"> and the namespace URI of </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> matches the namespace URI found in the </span><code><span class="deltaxml-old">BracedURILiteral</span></code><span class="deltaxml-old">.</span></p></li><li><p><var><span class="deltaxml-old">NT</span></var><span class="deltaxml-old"> is an </span><code><span class="deltaxml-old">EQName</span></code><span class="deltaxml-old"> equal to </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old">.</span></p></li></ol><p><code><span class="deltaxml-new">attribute(Q{uri}*)</span></code><span class="deltaxml-new"> matches any attribute node whose name is in the namespace given as </span><code><span class="deltaxml-new">uri</span></code><span class="deltaxml-new">, regardless of its type annotation.</span></p><p><span class="deltaxml-new">Example: </span><code><span class="deltaxml-new">element(Q{"http://www.w3.org/2000/svg"}*)</span></code><span class="deltaxml-new"> matches any attribute node whose name is in the SVG namespace.</span></p></li><li class="add_version" style="display: none;"><p><code>attribute(*:local)</code> matches any attribute node whose local name is the name given as <code>local</code>, regardless of its namespace or type annotation.</p><p>Example: <code>attribute(*:default-collation)</code> matches any attribute node whose local name is "default-collation".</p></li><li class="modify_version"><p><code><span class="deltaxml-new">attribute(*:local)</span></code><span class="deltaxml-new"> matches any attribute node whose local name is the name given as </span><code><span class="deltaxml-new">local</span></code><span class="deltaxml-new">, regardless of its namespace or type annotation.</span></p><p><span class="deltaxml-new">Example: </span><code><span class="deltaxml-new">attribute(*:default-collation)</span></code><span class="deltaxml-new"> matches any attribute node whose local name is "default-collation".</span></p></li><li class="add_version" style="display: none;"><p><code>attribute(</code><a href="#doc-xquery40-AttributeName">AttributeName</a>, <a href="#doc-xquery40-TypeName">TypeName</a><code>)</code> matches an attribute node whose name is <a href="#doc-xquery40-AttributeName">AttributeName</a> if <code>derives-from(</code><em>AT</em>, <a href="#doc-xquery40-TypeName">TypeName</a><code>)</code> is <code>true</code>, where <em>AT</em> is the type annotation of the attribute node.</p><p>Example: <code>attribute(price, currency)</code> matches an attribute node whose name is <code>price</code> and whose type annotation is <code>currency</code> (or is derived from <code>currency</code>).</p><p>The <code>AttributeName</code> in this example can also be replaced by one of the forms <code>prefix:*</code>, <code>Q{uri}*</code>, or <code>*:local</code>.</p></li><li class="modify_version"><p><code><span class="deltaxml-new">attribute(</span></code><a href="#doc-xquery40-AttributeName"><span class="deltaxml-new">AttributeName</span></a><span class="deltaxml-new">, </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><code><span class="deltaxml-new">)</span></code><span class="deltaxml-new"> matches an attribute node whose name is </span><a href="#doc-xquery40-AttributeName"><span class="deltaxml-new">AttributeName</span></a><span class="deltaxml-new"> if </span><code><span class="deltaxml-new">derives-from(</span></code><em><span class="deltaxml-new">AT</span></em><span class="deltaxml-new">, </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><code><span class="deltaxml-new">)</span></code><span class="deltaxml-new"> is </span><code><span class="deltaxml-new">true</span></code><span class="deltaxml-new">, where </span><em><span class="deltaxml-new">AT</span></em><span class="deltaxml-new"> is the type annotation of the attribute node.</span></p><p><span class="deltaxml-new">Example: </span><code><span class="deltaxml-new">attribute(price, currency)</span></code><span class="deltaxml-new"> matches an attribute node whose name is </span><code><span class="deltaxml-new">price</span></code><span class="deltaxml-new"> and whose type annotation is </span><code><span class="deltaxml-new">currency</span></code><span class="deltaxml-new"> (or is derived from </span><code><span class="deltaxml-new">currency</span></code><span class="deltaxml-new">).</span></p><p><span class="deltaxml-new">The </span><code><span class="deltaxml-new">AttributeName</span></code><span class="deltaxml-new"> in this example can also be replaced by one of the forms </span><code><span class="deltaxml-new">prefix:*</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">Q{uri}*</span></code><span class="deltaxml-new">, or </span><code><span class="deltaxml-new">*:local</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">AT</span></var><span class="deltaxml-old"> includes a </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-old">TypeName</span></a><span class="deltaxml-old">, then the </span><a href="#dt-type-annotation" title="type annotation" class="termref"><span class="deltaxml-old">type annotation</span></a><span class="deltaxml-old"> of the attribute node </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is either the schema type identified by that type name, or a type derived from that type by restriction.</span></p><p><code><span class="deltaxml-new">attribute(*, </span></code><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><code><span class="deltaxml-new">)</span></code><span class="deltaxml-new"> matches an attribute node regardless of its name, if </span><code><span class="deltaxml-new">derives-from(</span></code><em><span class="deltaxml-new">AT</span></em><span class="deltaxml-new">, </span><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><code><span class="deltaxml-new">)</span></code><span class="deltaxml-new"> is </span><code><span class="deltaxml-new">true</span></code><span class="deltaxml-new">, where </span><em><span class="deltaxml-new">AT</span></em><span class="deltaxml-new"> is the type annotation of the attribute node.</span></p><p><span class="deltaxml-new">Example: </span><code><span class="deltaxml-new">attribute(*, currency)</span></code><span class="deltaxml-new"> matches any attribute node whose type annotation is </span><code><span class="deltaxml-new">currency</span></code><span class="deltaxml-new"> (or is derived from </span><code><span class="deltaxml-new">currency</span></code><span class="deltaxml-new">), regardless of its name.</span></p></li></ol><p><span class="deltaxml-old">Here are some examples of </span><a href="#doc-xquery40-AttributeTest"><span class="deltaxml-old">AttributeTests</span></a><span class="deltaxml-old">: </span></p><ul><li><p><code><span class="deltaxml-old">attribute()</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">attribute(*)</span></code><span class="deltaxml-old"> match any single attribute node, regardless of its name or type annotation.</span></p></li><li><p><code><span class="deltaxml-old">attribute(price)</span></code><span class="deltaxml-old"> matches any attribute node whose name is </span><code><span class="deltaxml-old">price</span></code><span class="deltaxml-old"> (in no namespace), regardless of its type annotation.</span></p></li><li><p><code><span class="deltaxml-old">attribute(price|discount)</span></code><span class="deltaxml-old"> matches any attribute node whose name is </span><code><span class="deltaxml-old">price</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">discount</span></code><span class="deltaxml-old"> (in no namespace).</span></p></li><li><p><code><span class="deltaxml-old">attribute(xlink:*)</span></code><span class="deltaxml-old"> matches any attribute node whose name is in the namespace bound to the prefix </span><code><span class="deltaxml-old">xlink</span></code><span class="deltaxml-old">.</span></p></li><li><p><code><span class="deltaxml-old">element(Q{"http://www.w3.org/2000/svg"}*)</span></code><span class="deltaxml-old"> matches any attribute node whose name is in the SVG namespace.</span></p></li><li><p><code><span class="deltaxml-old">attribute(*:default-collation)</span></code><span class="deltaxml-old"> matches any attribute node whose local name is </span><code><span class="deltaxml-old">default-collation</span></code><span class="deltaxml-old">, regardless of namespace, and regardless of type annotation.</span></p></li><li><p><code><span class="deltaxml-old">attribute(*:price|*:discount)</span></code><span class="deltaxml-old"> matches any attribute node whose local name is </span><code><span class="deltaxml-old">price</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">discount</span></code><span class="deltaxml-old">, regardless of namespace, and regardless of type annotation.</span></p></li><li><p><code><span class="deltaxml-old">attribute(price, currency)</span></code><span class="deltaxml-old"> matches an attribute node whose name is </span><code><span class="deltaxml-old">price</span></code><span class="deltaxml-old"> (in no namespace) and whose type annotation is </span><code><span class="deltaxml-old">currency</span></code><span class="deltaxml-old"> (or is derived from </span><code><span class="deltaxml-old">currency</span></code><span class="deltaxml-old">).</span></p></li><li><p><code><span class="deltaxml-old">attribute(xlink:*, xs:string)</span></code><span class="deltaxml-old"> matches any attribute node whose name is in the namespace bound to the prefix </span><code><span class="deltaxml-old">xlink</span></code><span class="deltaxml-old">, and whose type annotation is </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> or a type derived from </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">.</span></p></li><li><p><code><span class="deltaxml-old">attribute(*, currency)</span></code><span class="deltaxml-old"> matches any attribute node whose type annotation is </span><code><span class="deltaxml-old">currency</span></code><span class="deltaxml-old"> (or is derived from </span><code><span class="deltaxml-old">currency</span></code><span class="deltaxml-old">), regardless of its name.</span></p></li></ul><p><span class="deltaxml-old"> Unlike the situation with an </span><a href="#doc-xquery40-ElementTest"><span class="deltaxml-old">ElementTest</span></a><span class="deltaxml-old">, few problems arise if the attribute was validated using a different schema. This is because simple types can never be derived by extension, and attributes do not have substitution groups.</span></p></div><div class="div4"><h5><a id="id-schema-attribute-test"></a>3.6.3.5 Schema Attribute Test</h5><a id="d3e7405"></a><a id="d3e6949"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SchemaAttributeTest"></a>[<span class="deltaxml-old">238</span><span class="deltaxml-new">225</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SchemaAttributeTest">SchemaAttributeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"schema-attribute" "(" <a href="#doc-xquery40-AttributeDeclaration">AttributeDeclaration</a> ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AttributeDeclaration"></a>[<span class="deltaxml-old">239</span><span class="deltaxml-new">226</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AttributeDeclaration">AttributeDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AttributeName">AttributeName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e6843.doc-xquery40-AttributeName"></a><a id="noid_d4e6438.doc-xquery40-AttributeName"></a>[<span class="deltaxml-old">243</span><span class="deltaxml-new">230</span>]&nbsp;&nbsp;&nbsp;</td><td><code>AttributeName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody></table><p> A <a href="#doc-xquery40-SchemaAttributeTest">SchemaAttributeTest</a> matches an attribute node against a corresponding attribute declaration found in the <a title="in-scope attribute declarations" class="termref" href="#dt-is-attrs">in-scope attribute declarations</a>. </p><p> The <a href="#doc-xquery40-AttributeName">AttributeName</a> of a <a href="#doc-xquery40-SchemaAttributeTest">SchemaAttributeTest</a> has its prefixes expanded to a namespace URI by means of the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>. If unprefixed, an <a href="#doc-xquery40-AttributeName">AttributeName</a> is in no namespace. If the <a href="#doc-xquery40-AttributeName">AttributeName</a> specified in the <a href="#doc-xquery40-SchemaAttributeTest">SchemaAttributeTest</a> is not found in the <a title="in-scope attribute declarations" class="termref" href="#dt-is-attrs">in-scope attribute declarations</a>, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>]. </p><p> A <a href="#doc-xquery40-SchemaAttributeTest">SchemaAttributeTest</a> matches a candidate attribute node if both of the following conditions are satisfied: </p><ol class="enumar"><li><p>The name of the candidate node matches the specified <a href="#doc-xquery40-AttributeName">AttributeName</a>.</p></li><li><p><code>derives-from(</code><em>AT, ET</em><code>)</code> is <code>true</code>, where <em>AT</em> is the type annotation of the candidate node and <em>ET</em> is the schema type declared for attribute <a href="#doc-xquery40-AttributeName">AttributeName</a> in the <a title="in-scope attribute declarations" class="termref" href="#dt-is-attrs">in-scope attribute declarations</a>.</p></li></ol><p>Example: The <a href="#doc-xquery40-SchemaAttributeTest">SchemaAttributeTest</a><code>schema-attribute(color)</code> matches a candidate attribute node if <code>color</code> is a top-level attribute declaration in the <a title="in-scope attribute declarations" class="termref" href="#dt-is-attrs">in-scope attribute declarations</a>, the name of the candidate node is <code>color</code>, and the type annotation of the candidate node is the same as or derived from the schema type declared for the <code>color</code> attribute.</p><p><span class="deltaxml-old"> Unlike the situation with a </span><a href="#doc-xquery40-SchemaElementTest"><span class="deltaxml-old">SchemaElementTest</span></a><span class="deltaxml-old">, few problems arise if the attribute was validated using a different schema. This is because attributes do not have substitution groups.</span></p></div></div><div class="div3"><h4><a id="id-function-map-array-tests"></a>3.6.4 Function, Map, and Array Tests</h4><p>The following sections describe the syntax for <a title="item type" class="termref" href="#dt-item-type">item types</a> for <span class="deltaxml-old">functions</span><span class="deltaxml-new">function</span>, including arrays and maps.</p><p>The <a title="subtype" class="termref" href="#dt-subtype">subtype</a> relation among these types is described in the various subsections of <a href="#id-itemtype-subtype"><b>3.7.2 Subtypes of Item Types</b></a>.</p><div class="div4"><h5><a id="id-function-test"></a>3.6.4.1 Function Test</h5><a id="d3e7537"></a><a id="d3e7077"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionTest"></a>[<span class="deltaxml-old">247</span><span class="deltaxml-new">234</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-FunctionTest">FunctionTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Annotation">Annotation</a>* (<a href="#doc-xquery40-AnyFunctionTest">AnyFunctionTest</a><br>| <a href="#doc-xquery40-TypedFunctionTest">TypedFunctionTest</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AnyFunctionTest"></a>[<span class="deltaxml-old">248</span><span class="deltaxml-new">235</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AnyFunctionTest">AnyFunctionTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"function" "(" "*" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypedFunctionTest"></a>[<span class="deltaxml-old">249</span><span class="deltaxml-new">236</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-TypedFunctionTest">TypedFunctionTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"function" "(" (<a href="#doc-xquery40-SequenceType">SequenceType</a> ("," <a href="#doc-xquery40-SequenceType">SequenceType</a>)*)? ")" "as" <a href="#doc-xquery40-SequenceType">SequenceType</a></code></td><td></td></tr></tbody></table><p><span class="deltaxml-old">A </span><a href="#doc-xquery40-FunctionTest"><span class="deltaxml-old">FunctionTest</span></a><span class="deltaxml-old"> matches selected </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-old">function items</span></a><span class="deltaxml-old">, potentially checking their </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-signature"><span class="deltaxml-old">signature</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old"> (which includes the types of the arguments and results</span><span class="xquery"><span class="deltaxml-old">, and also their annotations, as described in </span><a href="#id-annotations"><b><span class="deltaxml-old">5.15 Annotations</span></b></a><span class="deltaxml-old">)</span></span><span class="deltaxml-old">).</span></p><p><span class="deltaxml-old">An </span><a href="#doc-xquery40-AnyFunctionTest"><span class="deltaxml-old">AnyFunctionTest</span></a><span class="deltaxml-old"> matches any item that is a function.</span></p><p><span style="display: none;" class="delete_version">A <a href="#doc-xquery40-TypedFunctionTest">TypedFunctionTest</a> matches an item if it is a <a title="function item" href="#dt-function-item" class="termref">function item</a> and the function’s type signature (as defined in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items">Section 2.9.4 Function Items</a><sup><small>DM40</small></sup>) is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the <a href="#doc-xquery40-TypedFunctionTest">TypedFunctionTest</a>.</span><span style="display: none;" class="add_version"> A <a href="#doc-xquery40-FunctionTest">FunctionTest</a> matches a <a title="function item" class="termref" href="#dt-function-item">function item</a>, potentially also checking its <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-signature">function signature</a><sup><small>DM31</small></sup><span class="xquery">and annotations (see <a href="#id-annotations"><b>5.15 Annotations</b></a>)</span>. An <a href="#doc-xquery40-AnyFunctionTest">AnyFunctionTest</a> matches any item that is a function. A <a href="#doc-xquery40-TypedFunctionTest">TypedFunctionTest</a> matches an item if it is a <a title="function item" href="#dt-function-item" class="termref">function</a> and the function's type signature (as defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items">Section 2.8.1 Functions </a><sup><small>DM31</small></sup>) is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the <a href="#doc-xquery40-TypedFunctionTest">TypedFunctionTest</a>. </span><span class="modify_version"><span class="deltaxml-new"> </span>A <a href="#doc-xquery40-FunctionTest"><span class="deltaxml-new">FunctionTest</span></a><span class="deltaxml-new"> matches a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new">function item</span></a><span class="deltaxml-new">, potentially also checking its </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-signature"><span class="deltaxml-new">function signature</span></a><sup><small><span class="deltaxml-new">DM31</span></small></sup><span class="xquery"><span class="deltaxml-new">and annotations (see </span><a href="#id-annotations"><b><span class="deltaxml-new">5.15 Annotations</span></b></a><span class="deltaxml-new">)</span></span><span class="deltaxml-new">. An </span><a href="#doc-xquery40-AnyFunctionTest"><span class="deltaxml-new">AnyFunctionTest</span></a><span class="deltaxml-new"> matches any item that is a function. A </span><a href="#doc-xquery40-TypedFunctionTest">TypedFunctionTest</a> matches an item if it is a <a title="function item" href="#dt-function-item" class="termref">function<span class="deltaxml-old"> item</span></a> and the <span class="deltaxml-old">function’s</span><span class="deltaxml-new">function's</span> type signature (as defined in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items"><span class="deltaxml-old">Section 2.9.4 Function Items</span></a><a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items"><span class="deltaxml-new">Section 2.8.1 Functions </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>) is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the <a href="#doc-xquery40-TypedFunctionTest">TypedFunctionTest</a>.<span class="deltaxml-new"> </span></span></p><p><span class="deltaxml-old">In addition, a </span><a href="#doc-xquery40-TypedFunctionTest"><span class="deltaxml-old">TypedFunctionTest</span></a><span class="deltaxml-old"> may match certain maps and arrays, as described in </span><a href="#id-map-test"><b><span class="deltaxml-old">3.6.4.2 Map Test</span></b></a><span class="deltaxml-old"> and </span><a href="#id-array-test"><b><span class="deltaxml-old">3.6.4.5 Array Test</span></b></a></p><p> Here are some examples of <a href="#doc-xquery40-FunctionTest">FunctionTest</a>s: </p><ol class="enumar"><li><p><code>function(*)</code> matches any function, including maps and arrays.</p></li><li class="xquery"><p><code>%assertion function(*)</code> matches any <a title="function item" class="termref" href="#dt-function-item">function</a> if the implementation-defined function assertion <code>%assertion</code> is satisfied. </p></li><li><p><code>function(int, int) as int</code> matches any <a title="function item" class="termref" href="#dt-function-item">function item</a> with the function signature <code>function(int, int) as int</code>. </p></li><li class="xquery"><p><code>%assertion function(int, int) as int</code> matches any <a title="function item" class="termref" href="#dt-function-item">function item</a> with the function signature <code>function(int, int) as int</code> if the implementation-defined function assertion <code>%assertion</code> is satisfied. </p></li><li><p><code>function(xs:anyAtomicType) as item()*</code> matches any map, or any function with the required signature.</p></li><li><p><code>function(xs:integer) as item()*</code> matches any array, or any function with the required signature.</p></li></ol><p id="id-function-assertion" class="xquery"> [<a id="dt-function-assertion" title="function assertion">Definition</a>: A <b>function assertion</b> is a predicate that restricts the set of functions matched by a FunctionTest. It uses the same syntax as <a href="#id-annotations"><b>5.15 Annotations</b></a>.] XQuery 4.0 does not currently define any function assertions, but future versions may. Other specifications in the XQuery family may also use function assertions in the future.</p><p class="xquery">Implementations are free to define their own function assertions, whose behavior is completely implementation-defined. Implementations may also provide a way for users to define their own function assertions.</p><p class="xquery">An implementation may raise implementation-defined errors or warnings for function assertions, <span class="deltaxml-old">for example</span><span class="deltaxml-new">e.g.</span> if the parameters are not correct for a given assertion. If the namespace URI of a function <span class="deltaxml-old">assertion’s</span><span class="deltaxml-new">assertion's</span> <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is not recognized by an implementation, it is ignored, and has no effect on the semantics of the function test.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An implementation is free to raise warnings for function assertions that it does not recognize.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Although function assertions use the same syntax as annotations, they are not directly related to annotations. If an implementation defines the annotation <code>blue</code> and uses it in function declarations, there is no guarantee that it will also define a function assertion <code>blue</code>, or that a function assertion named <code>blue</code> matches a function declared with the annotation <code>blue</code>. Of course, an implementation that does so may be more intuitive to users.</p></div><p class="xquery"> Implementations must not define function assertions in <a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces">reserved namespaces</a>; it is is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0045" title="err:XQST0045">err:XQST0045</a>] for a user to define a function assertion in a <a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces">reserved namespace</a>. </p></div><div class="div4"><h5><a id="id-map-test"></a>3.6.4.2 Map Test</h5><a id="d3e7712"></a><a id="d3e7239"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-MapTest"></a>[<span class="deltaxml-old">250</span><span class="deltaxml-new">237</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-MapTest">MapTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AnyMapTest">AnyMapTest</a> | <a href="#doc-xquery40-TypedMapTest">TypedMapTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AnyMapTest"></a>[<span class="deltaxml-old">251</span><span class="deltaxml-new">238</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AnyMapTest">AnyMapTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"map" "(" "*" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypedMapTest"></a>[<span class="deltaxml-old">252</span><span class="deltaxml-new">239</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-TypedMapTest">TypedMapTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"map" "(" <a href="#doc-xquery40-ItemType">ItemType</a> "," <a href="#doc-xquery40-SequenceType">SequenceType</a> ")"</code></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version">The <a href="#doc-xquery40-MapTest">MapTest</a><code>map(*)</code> matches any map. The <a href="#doc-xquery40-MapTest">MapTest</a><code>map(K, V)</code> matches any map where every key is an instance of <code>K</code> and every value is an instance of <code>V</code>.</span><span style="display: none;" class="add_version">The <a href="#doc-xquery40-MapTest">MapTest</a><code>map(*)</code> matches any map. The <a href="#doc-xquery40-MapTest">MapTest</a><code>map(X, Y)</code> matches any map where the type of every key is an instance of <code>X</code> and the type of every value is an instance of <code>Y</code>.</span><span class="modify_version">The <a href="#doc-xquery40-MapTest">MapTest</a><code>map(*)</code> matches any map. The <a href="#doc-xquery40-MapTest">MapTest</a><code>map(<span class="deltaxml-old">K, V</span><span class="deltaxml-new">X, Y</span>)</code> matches any map where <span class="deltaxml-new">the type of </span>every key is an instance of <code><span class="deltaxml-old">K</span><span class="deltaxml-new">X</span></code> and <span class="deltaxml-new">the type of </span>every value is an instance of <code><span class="deltaxml-old">V</span><span class="deltaxml-new">Y</span></code>.</span></p><p>Although the grammar for <code>TypedMapTest</code> allows the key to be described using the full <code>ItemType</code> syntax, the item type used must be a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a>. [TODO: error code].</p><p>Examples:</p><p>Given a map <code>$M</code> whose keys are integers and whose results are strings, such as <code>map{0:"no", 1:"yes"}</code>, consider the results of the following expressions: </p><ul><li><p><code>$M instance of map(*)</code> returns <code>true()</code></p></li><li><p><code>$M instance of map(xs:integer, xs:string)</code> returns <code>true()</code></p></li><li><p><code>$M instance of map(xs:decimal, xs:anyAtomicType)</code> returns <code>true()</code></p></li><li><p><code>not($M instance of map(xs:int, xs:string))</code> returns <code>true()</code></p></li><li><p><code>not($M instance of map(xs:integer, xs:token))</code> returns <code>true()</code></p></li></ul><p><span class="deltaxml-old">A map is also a function item, and therefore matches certain function tests. Specifically, a map that matches </span><code><span class="deltaxml-old">map(K, V)</span></code><span class="deltaxml-old"> also matches a function test of the form </span><code><span class="deltaxml-old">function(xs:anyAtomicType) as R</span></code><span class="deltaxml-old"> provided that both the following conditions are satisfied:</span></p><ul><li><p><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old"> is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-old">subtype</span></a><span class="deltaxml-old"> of </span><var><span class="deltaxml-old">R</span></var></p></li><li><p><code><span class="deltaxml-old">empty-sequence()</span></code><span class="deltaxml-old"> is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-old">subtype</span></a><span class="deltaxml-old"> of </span><var><span class="deltaxml-old">R</span></var></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">To understand this rule, consider the use of a map </span><code><span class="deltaxml-old">$M</span></code><span class="deltaxml-old"> in a function call </span><code><span class="deltaxml-old">$M($K)</span></code><span class="deltaxml-old">, which is equivalent to the function call </span><code><span class="deltaxml-old">map:get($M, $K)</span></code><span class="deltaxml-old">. This function accepts any atomic value for the argument </span><code><span class="deltaxml-old">$K</span></code><span class="deltaxml-old">, and hence satisfies a function test that requires an argument type of </span><code><span class="deltaxml-old">xs:anyAtomicType</span></code><span class="deltaxml-old">. If the key </span><code><span class="deltaxml-old">$K</span></code><span class="deltaxml-old"> is present in the map, the result of the function will be a value of type </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old">; if not, it will be an empty sequence. The map is therefore substitutable for the function test provided that the function test allows both a value of type </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old"> and the empty sequence as possible results.</span></p><p><span class="deltaxml-old">The key type </span><var><span class="deltaxml-old">K</span></var><span class="deltaxml-old"> does not enter into this rule. That is because in the function call </span><code><span class="deltaxml-old">$M($K)</span></code><span class="deltaxml-old">, the sought key </span><code><span class="deltaxml-old">$K</span></code><span class="deltaxml-old"> does not have to be of the same type as the keys actually present in the map.</span></p><p><span class="deltaxml-old">The transitivity rules for item type matching mean that if an item </span><var><span class="deltaxml-old">M</span></var><span class="deltaxml-old"> matches a type </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old">, and </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-old">subtype</span></a><span class="deltaxml-old"> of </span><var><span class="deltaxml-old">U</span></var><span class="deltaxml-old">, then </span><var><span class="deltaxml-old">M</span></var><span class="deltaxml-old"> also matches type </span><var><span class="deltaxml-old">U</span></var><span class="deltaxml-old">. So the fact that a map from integers to strings (</span><code><span class="deltaxml-old">map(xs:integer, xs:string)</span></code><span class="deltaxml-old">) matches </span><code><span class="deltaxml-old">function(xs:anyAtomicType) as xs:string?</span></code><span class="deltaxml-old"> means that it will also match other function tests such as </span><code><span class="deltaxml-old">function(xs:integer) as xs:string?</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">function(xs:decimal) as xs:anyAtomicType?</span></code></p><p><span class="deltaxml-old">Furthermore, the rules for </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-old">function coercion</span></a><span class="deltaxml-old"> mean that any map can be supplied as a value in a context where it does not actually match the required function type, but can be coerced to a function that does. For example a map of type </span><code><span class="deltaxml-old">map(xs:integer, xs:string)</span></code><span class="deltaxml-old"> can be coerced to a function of type </span><code><span class="deltaxml-old">function(xs:integer) as xs:string</span></code><span class="deltaxml-old">; in this situation a type error will occur only if a call on the function actually returns an empty sequence. </span></p></div><p><span class="deltaxml-new">Because of the rules for subtyping of function types according to their signature, it follows that the item type </span><code><span class="deltaxml-new">function(A) as item()*</span></code><span class="deltaxml-new">, where A is an atomic type, also matches any map, regardless of the type of the keys actually found in the map. For example, a map whose keys are all strings can be supplied where the required type is </span><code><span class="deltaxml-new">function(xs:integer) as item()*</span></code><span class="deltaxml-new">; a call on the map that treats it as a function with an integer argument will always succeed, and will always return an empty sequence.</span></p><p><span class="deltaxml-new">The function signature of a map matching type </span><code><span class="deltaxml-new">map(K, V)</span></code><span class="deltaxml-new">, treated as a function, is </span><code><span class="deltaxml-new">function(xs:anyAtomicType) as V?</span></code><span class="deltaxml-new">. It is thus always a subtype of </span><code><span class="deltaxml-new">function(xs:anyAtomicType) as item()*</span></code><span class="deltaxml-new"> regardless of the actual types of the keys and values in the map. The rules for </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new">function coercion</span></a><span class="deltaxml-new"> mean that any map can be supplied as a value in a context where the required type has a more specific return type, such as </span><code><span class="deltaxml-new">function(xs:anyAtomicType) as xs:integer</span></code><span class="deltaxml-new">, even when the map does not match in the sense required to satisfy the instance of operator. In such cases, a type error will only occur if an actual call on the map (treated as a function) returns a value that is not an instance of the required return type. </span></p><p>Examples:</p><ul><li><p><code>$M instance of function(*)</code> returns <code>true()</code></p></li><li><p><code>$M instance of function(xs:anyAtomicType) as item()*</code> returns <code>true()</code></p></li><li><p><code>$M instance of function(xs:integer) as item()*</code> returns <code>true()</code></p></li><li><p><code>$M instance of function(xs:int) as item()*</code> returns <code>true()</code></p></li><li><p><code>$M instance of function(xs:string) as item()*</code> returns <code>true()</code></p></li><li><p><code>not($M instance of function(xs:integer) as xs:string)</code> returns <code>true()</code></p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">The last case might seem surprising; however, <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> ensures that <code>$M</code> can be used successfully anywhere that the required type is <code>function(xs:integer) as xs:string</code>.</span><span style="display: none;" class="add_version">The last case might seem surprising; however, <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a>n ensures that <code>$M</code> can be used successfully anywhere that the required type is <code>function(xs:integer) as xs:string</code>.</span><span class="modify_version">The last case might seem surprising; however, <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a><span class="deltaxml-new">n</span> ensures that <code>$M</code> can be used successfully anywhere that the required type is <code>function(xs:integer) as xs:string</code>.</span></p></div><p>Rules defining whether one map type is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of another are given in <a href="#id-item-subtype-maps"><b>3.7.2.7 Maps</b></a>.</p></div><div class="div4"><h5><a id="id-record-test"></a>3.6.4.3 Record Test</h5><a id="d3e7982"></a><a id="d3e7414"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordTest"></a><span class="deltaxml-old">[253]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-RecordTest"><span class="deltaxml-old">RecordTest</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-AnyRecordTest"><span class="deltaxml-old">AnyRecordTest</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-TypedRecordTest"><span class="deltaxml-old">TypedRecordTest</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AnyRecordTest"></a><span class="deltaxml-old">[254]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-AnyRecordTest"><span class="deltaxml-old">AnyRecordTest</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"record" "(" "*" ")"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypedRecordTest"></a><a id="doc-xquery40-RecordTest"></a>[<span class="deltaxml-old">255</span><span class="deltaxml-new">240</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-TypedRecordTest">TypedRecordTest</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-RecordTest">RecordTest</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-TypedRecordTest"><span class="deltaxml-old">TypedRecordTest</span></a><a href="#prod-xquery40-RecordTest"><span class="deltaxml-new">RecordTest</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"record" "(" <a href="#doc-xquery40-FieldDeclaration">FieldDeclaration</a> ("," <a href="#doc-xquery40-FieldDeclaration">FieldDeclaration</a>)* <a href="#doc-xquery40-ExtensibleFlag">ExtensibleFlag</a>? ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FieldDeclaration"></a>[<span class="deltaxml-old">256</span><span class="deltaxml-new">241</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-FieldDeclaration">FieldDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-FieldName">FieldName</a> "?"? ("as" <a href="#doc-xquery40-SequenceType">SequenceType</a>)?</code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-FieldName">FieldName</a> "?"? ("as" (<a href="#doc-xquery40-SequenceType">SequenceType</a> | <a href="#doc-xquery40-SelfReference">SelfReference</a>))?</code></span><span class="modify_version"><code><a href="#doc-xquery40-FieldName">FieldName</a> "?"? ("as" <span class="deltaxml-new">(</span><a href="#doc-xquery40-SequenceType">SequenceType</a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-SelfReference"><span class="deltaxml-new">SelfReference</span></a>)<span class="deltaxml-new">)</span>?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FieldName"></a>[<span class="deltaxml-old">257</span><span class="deltaxml-new">242</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-FieldName">FieldName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NCName">NCName</a> | <a href="#doc-xquery40-StringLiteral">StringLiteral</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SelfReference"></a><span class="deltaxml-new">[243]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-SelfReference"><span class="deltaxml-new">SelfReference</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">".." </span><a href="#doc-xquery40-OccurrenceIndicator"><span class="deltaxml-new">OccurrenceIndicator</span></a><span class="deltaxml-new">?</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ExtensibleFlag"></a>[<span class="deltaxml-old">258</span><span class="deltaxml-new">244</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ExtensibleFlag">ExtensibleFlag</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"," "*"</code></td><td></td></tr></tbody></table><p>A <a href="#doc-xquery40-RecordTest">RecordTest</a> matches maps that meet specific criteria.</p><p>For example, the <code>RecordTest</code><code>record(r as xs:double, i as xs:double)</code> matches a map if the map has exactly two entries: an entry with key <code>"r"</code> whose value is a singleton <code>xs:double</code> value, and an entry with key <code>"i"</code> whose value is also a singleton <code>xs:double</code> value.</p><p>If the list of fields ends with <code>",*"</code> then the record test is said to be <b>extensible</b>. For example, the <code>RecordTest</code><code>record(e as element(Employee), *)</code> matches a map if it has an entry with key <code>"e"</code> whose value matches <code>element(Employee)</code>, regardless what other entries the map might contain.</p><p><span class="deltaxml-old">For generality, the syntax </span><code><span class="deltaxml-old">record(*)</span></code><span class="deltaxml-old"> defines an extensible record type that has no explicit field declarations. The item type denoted by </span><code><span class="deltaxml-old">record(*)</span></code><span class="deltaxml-old"> is equivalent to the item type </span><code><span class="deltaxml-old">map(*)</span></code><span class="deltaxml-old">: that is, it allows any map. </span></p><p>A record test can <span class="deltaxml-old">constrain </span>only <span class="deltaxml-old">those</span><span class="deltaxml-new">constrain</span> entries whose keys are strings, but when the record test is marked as extensible, then other entries may be present in the map with non-string keys. Entries whose key is a string can be expressed using an (unquoted) NCName if the key conforms to NCName syntax, or using a (quoted) string literal otherwise.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">Lookup expressions have been extended in 4.0 so that non-NCName keys can be used without parentheses: <code>employee?"middle name"</code></span><span style="display: none;" class="add_version">Lookup expressions have been extended so that non-NCName keys can be used without parentheses: <code>employee?"middle name"</code></span><span class="modify_version">Lookup expressions have been extended <span class="deltaxml-old">in 4.0 </span>so that non-NCName keys can be used without parentheses: <code>employee?"middle name"</code></span></p></div><p>If the type declaration for a field is omitted, then <code>item()*</code> is assumed: that is, the map entry may have any type.</p><p>If the field name is followed by a question mark, then the value must have the specified type if it is present, but it may also be absent. For example, the <code>RecordTest</code><code>record(first as xs:string, middle? as xs:string, last as xs:string, *)</code> requires the map to have string-valued entries with keys <code>"first"</code> and <code>"last"</code>; it also declares that if the map has an entry with key <code>"middle"</code>, the value of that entry must be a single <code>xs:string</code>. Declaring the type as <code>record(first as xs:string, middle? as xs:string?, last as xs:string, *)</code> also allows the entry with key <code>"middle"</code> to be present but empty.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Within an extensible record test, a <code>FieldDeclaration</code> that is marked optional and has no declared type does not constrain the map in any way, so it serves no practical purpose, but it is permitted because it may have documentary value.</p></div><p><span class="deltaxml-new">If a field is declared using </span><code><span class="deltaxml-new">..</span></code><span class="deltaxml-new"> (optionally followed by an occurrence indicator) in place of a </span><code><span class="deltaxml-new">SequenceType</span></code><span class="deltaxml-new">, this indicates that the record type is recursive: the value of this field, if present, must be an instance of the record type being declared. For example, a record designed to hold error information might be declared as:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">record(error-code as xs:QName, message as xs:string, cause? as ..)</span></pre></div><p><span class="deltaxml-new">A map conforms to this type if it has entries with keys </span><code><span class="deltaxml-new">error-code</span></code><span class="deltaxml-new"> and </span><code><span class="deltaxml-new">message</span></code><span class="deltaxml-new"> of the correct types, and if the </span><code><span class="deltaxml-new">cause</span></code><span class="deltaxml-new"> entry is either absent, or is a map that itself conforms to this type.</span></p><p><span class="deltaxml-new">A </span><code><span class="deltaxml-new">FieldDeclaration</span></code><span class="deltaxml-new"> that a </span><code><span class="deltaxml-new">SelfReference</span></code><span class="deltaxml-new"> to identify its type must either be optional (marked with a question mark after the name), or must allow the empty sequence as a permitted value (marked by using the occurrence indicator </span><code><span class="deltaxml-new">?</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">*</span></code><span class="deltaxml-new"> after the item type). If the field is not optional and does not allow an empty sequence, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new">static error</span></a><span class="deltaxml-new"> is raised [</span><a href="#ERRXPST0140" title="err:XPST0140"><span class="deltaxml-new">err:XPST0140</span></a><span class="deltaxml-new">]. This rule ensures that finite instances of the type can be constructed.</span></p><div class="example"><p><span class="deltaxml-new">A record used to represent a node in a binary tree might be represented as:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">record(left? as .., value, right? as ..)</span></pre></div><p><span class="deltaxml-new">A function to walk this tree and enumerate all the values in depth-first order might be written (using XQuery syntax) as:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">declare item-type binary-tree as record(left? as .., value, right? as ..); declare function flatten($tree as binary-tree?) as item()* { $tree ! (flatten(?left), ?value, flatten(?right)) }</span></pre></div></div><p><span class="deltaxml-new">&nbsp;</span></p><div class="example"><p><span class="deltaxml-new">A record used to represent a node in a tree where each node has an arbitrary number of children might be represented as:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">record(value, children as ..*)</span></pre></div><p><span class="deltaxml-new">A function to walk this tree and enumerate all the values in order might be written (using XQuery syntax) as:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">declare item-type tree as record(value, children as ..*); declare function flatten($tree as tree) as item()* { $tree?value, $tree?children ! flatten(.)) }</span></pre></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">If a </span><code><span class="deltaxml-new">RecordTest</span></code><span class="deltaxml-new"> contains a </span><code><span class="deltaxml-new">SelfReference</span></code><span class="deltaxml-new"> field that is not optional, and whose type does not permit an empty sequence, then it will not be possible to construct an instance. So a </span><code><span class="deltaxml-new">RecordTest</span></code><span class="deltaxml-new"> such as </span><code><span class="deltaxml-new">record(a as ..)</span></code><span class="deltaxml-new"> serves no practical purpose; but it is not disallowed.</span></p></div><p>Record tests describe a subset of the value space of maps. They do not define any new kinds of values, or any additional operations. They are useful in many cases to describe more accurately the type of a variable, function parameter, or function result, giving benefits both in the readability of the code, and in the ability of the processor to detect and diagnose type errors and to optimize execution.</p><p><span style="display: none;" class="delete_version">If a variable <code>$rec</code> is known to conform to a particular record type, then when a lookup expression <code>$rec?field</code> is used, (a) the processor can report a type error if <code>$rec</code> cannot contain an entry with name <code>field</code> (see <a href="#id-implausible-lookup-expressions"><b>4.14.3.4 Implausible Lookup Expressions</b></a>), and (b) the processor can make static type inferences about the type of value returned by <code>$rec?field</code>.</span><span style="display: none;" class="add_version">In particular, if a variable <code>$rec</code> is known to conform to a particular record type, then when a lookup expression <code>$rec?field</code> is used, (a) the processor can report a type error if <code>$rec</code> cannot contain an entry with name <code>field</code>, and (b) the processor can make static type inferences about the type of value returned by <code>$rec?field</code>.</span><span class="modify_version"><span class="deltaxml-old">If</span><span class="deltaxml-new">In particular, if</span> a variable <code>$rec</code> is known to conform to a particular record type, then when a lookup expression <code>$rec?field</code> is used, (a) the processor can report a type error if <code>$rec</code> cannot contain an entry with name <code>field</code><span class="deltaxml-old"> (see </span><a href="#id-implausible-lookup-expressions"><b><span class="deltaxml-old">4.14.3.4 Implausible Lookup Expressions</span></b></a><span class="deltaxml-old">)</span>, and (b) the processor can make static type inferences about the type of value returned by <code>$rec?field</code>.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">(TODO: change function signatures as suggested here!) A number of functions in the standard function library use maps as function arguments; this is a useful technique where the information to be supplied across the interface is highly variable. However, the type signature for such functions typically declares the argument type as <code>map(*)</code>, which gives very little information (and places very few constraints) on the values that are actually passed across. Using record tests offers the possibility of improving this: for example, the options argument of <code>fn:parse-json</code>, previously given as <code>map(*)</code>, can now be expressed as <code>record(liberal? as xs:boolean, duplicates? as xs:string, escape? as xs:boolean, fallback as function(xs:string) as xs:string, *)</code>. In principle the <code>xs:string</code> type used to describe the <code>duplicates</code> option could also be replaced by a schema-defined subtype of <code>xs:string</code> that enumerates the permitted values (<code>"reject"</code>, <code>"use-first"</code>, <code>"use-last"</code>). </span><span style="display: none;" class="add_version">A number of functions in the standard function library use maps as function arguments; this is a useful technique where the information to be supplied across the interface is highly variable. However, the type signature for such functions typically declares the argument type as <code>map(*)</code>, which gives very little information (and places very few constraints) on the values that are actually passed across. Using record tests offers the possibility of improving this: for example, the options argument of <code>fn:parse-json</code>, previously given as <code>map(*)</code>, can now be expressed as <code>record(liberal? as xs:boolean, duplicates? as xs:string, escape? as xs:boolean, fallback as function(xs:string) as xs:string, *)</code>. In principle the <code>xs:string</code> type used to describe the <code>duplicates</code> option could also be replaced by a schema-defined subtype of <code>xs:string</code> that enumerates the permitted values (<code>"reject"</code>, "<code>use-first"</code>, "<code>use-last"</code>). </span><span class="modify_version"><span class="deltaxml-old">(TODO: change function signatures as suggested here!) </span>A number of functions in the standard function library use maps as function arguments; this is a useful technique where the information to be supplied across the interface is highly variable. However, the type signature for such functions typically declares the argument type as <code>map(*)</code>, which gives very little information (and places very few constraints) on the values that are actually passed across. Using record tests offers the possibility of improving this: for example, the options argument of <code>fn:parse-json</code>, previously given as <code>map(*)</code>, can now be expressed as <code>record(liberal? as xs:boolean, duplicates? as xs:string, escape? as xs:boolean, fallback as function(xs:string) as xs:string, *)</code>. In principle the <code>xs:string</code> type used to describe the <code>duplicates</code> option could also be replaced by a schema-defined subtype of <code>xs:string</code> that enumerates the permitted values (<code>"reject"</code>, "<code>use-first"</code>, "<code>use-last"</code>). </span></p><p><span style="display: none;" class="delete_version">The use of a record test in the signature of such a function causes the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to be invoked. So, for example, if the function expects an entry in the map to be an <code>xs:double</code> value, it becomes possible to supply a map in which the corresponding entry has type <code>xs:integer</code>.</span><span style="display: none;" class="add_version">The use of a record test in the signature of such a function causes the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to be invoked: so, for example, if the function expects an entry in the map to be an <code>xs:double</code> value, it becomes possible to supply a map in which the corresponding entry has type <code>xs:integer</code>.</span><span class="modify_version">The use of a record test in the signature of such a function causes the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to be invoked<span class="deltaxml-old">. So</span><span class="deltaxml-new">: so</span>, for example, if the function expects an entry in the map to be an <code>xs:double</code> value, it becomes possible to supply a map in which the corresponding entry has type <code>xs:integer</code>.</span></p><p>Greater precision in defining the types of such arguments also enables better type checking, better diagnostics, better optimization, better documentation, and better syntax-directed editing tools.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">One of the motivations for introducing record tests is to enable better pattern matching in XSLT when processing JSON input. With XML input, patterns are often based around XML element names. JSON has no direct equivalent of XML’s element names; matching a JSON object such as <code>{longitude: 130.2, latitude: 53.4}</code> relies instead on recognizing the property names appearing in the object. XSLT 4.0, by integrating record tests into pattern matching syntax, allows such an object to be matched with a pattern of the form <code>match="record(longitude, latitude)"</code></span><span style="display: none;" class="add_version">One of the motivations for introducing record tests is to enable better pattern matching in XSLT when processing JSON input. With XML input, patterns are often based around XML element names. JSON has no direct equivalent of XML's element names; matching a JSON object such as <code>{longitude: 130.2, latitude: 53.4}</code> relies instead on recognizing the property names appearing in the object. XSLT 4.0, by integrating record tests into pattern matching syntax, allows such an object to be matched with a pattern of the form <code>match="record(longitude, latitude)"</code></span><span class="modify_version">One of the motivations for introducing record tests is to enable better pattern matching in XSLT when processing JSON input. With XML input, patterns are often based around XML element names. JSON has no direct equivalent of <span class="deltaxml-old">XML’s</span><span class="deltaxml-new">XML's</span> element names; matching a JSON object such as <code>{longitude: 130.2, latitude: 53.4}</code> relies instead on recognizing the property names appearing in the object. XSLT 4.0, by integrating record tests into pattern matching syntax, allows such an object to be matched with a pattern of the form <code>match="record(longitude, latitude)"</code></span></p></div><p>Rules defining whether one record <span class="deltaxml-old">test</span><span class="deltaxml-new">type</span> is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of another are given in <a href="#id-item-subtype-records"><b>3.7.2.9 Record Tests</b></a>.</p></div><div class="div4"><h5><a id="id-recursive-record-tests"></a><span class="deltaxml-old">3.6.4.4 Recursive Record Tests</span></h5><p><span class="deltaxml-old">A </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-old">named item type</span></a><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> is said to be recursive if its definition includes a direct or indirect reference to </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old">. </span></p><p><span class="deltaxml-old">For example, the following XQuery declaration defines a linked list:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">declare item type my:list as record(value as item()*, next? as my:list);</span></pre></div><p><span class="deltaxml-old">The equivalent in XSLT is:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">&lt;xsl:item-type name="my:list" as="record(value as item()*, next? as my:list)"/&gt;</span></pre></div><p><span class="deltaxml-old">A recursive named item type </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> is permitted only if it satisfies all the following conditions:</span></p><ul><li><p><span class="deltaxml-old">The item type must be a record test.</span></p></li><li><p><span class="deltaxml-old">Within the record test, every item type reference </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> that refers directly or indirectly to </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> must satisfy one or more of the following conditions, where </span><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old"> is the field declaration of </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> in which </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> appears:</span></p><ul><li><p><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old"> is an optional field declaration: for example </span><code><span class="deltaxml-old">next? as N</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The SequenceType of </span><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old"> has an occurrence indicator of </span><code><span class="deltaxml-old">?</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">*</span></code><span class="deltaxml-old">: for example </span><code><span class="deltaxml-old">next as N?</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">next as N*</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The item type of </span><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old"> is a function test, map test, or array test: for example </span><code><span class="deltaxml-old">next as (function() as N)</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">next as array(N)</span></code><span class="deltaxml-old">.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">These conditions are designed to ensure that finite instances of </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> can be constructed.</span></p></div></li></ul><p><span class="deltaxml-old">Instances of recursive record types can be constructed and interrogated in the normal way. For example a list of length 3 can be constructed as:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">map{"value":1, "next":map{"value":2, "next":map{"value":3}}}</span></pre></div><p><span class="deltaxml-old">and the third value in the map can be retrieved as </span><code><span class="deltaxml-old">$list?next?next?value</span></code><span class="deltaxml-old">. In practice, recursive data structures are usually manipulated using recursive functions.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">For an example of a practical use of recursive record types, see the specification of the function </span><code><span class="deltaxml-old">fn:random-number-generator</span></code><span class="deltaxml-old">.</span></p></div><p><span class="deltaxml-old">Recursive type definitions need to be handled specially by the subtyping rules; a naïve approach of simply replacing each reference to a named item type with its definition would make the assessment of the subtype relationship non-terminating. For details see </span><a href="#id-itemtype-subtype"><b><span class="deltaxml-old">3.7.2 Subtypes of Item Types</span></b></a><span class="deltaxml-old">.</span></p><div class="example"><div class="exampleHeader"><a id="e-binary-tree"></a><span class="deltaxml-old">Example: A Binary Tree</span></div><p><span class="deltaxml-old">A record used to represent a node in a binary tree might be represented (using XQuery syntax) as:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">declare item-type t:binary-tree as record(left? as t:binary-tree, value, right? as t:binary-tree)</span></pre></div><p><span class="deltaxml-old">A function to walk this tree and enumerate all the values in depth-first order might be written (again using XQuery syntax) as:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">declare function t:values($tree as t:binary-tree?) as item()* { $tree ! (t:values(?left), ?value, t:values(?right)) }</span></pre></div></div><p><span class="deltaxml-old">&nbsp;</span></p><div class="example"><div class="exampleHeader"><a id="e-arbitrary-tree"></a><span class="deltaxml-old">Example: An Arbitrary Tree</span></div><p><span class="deltaxml-old">A record used to represent a node in a tree where each node has an arbitrary number of children might be represented (using XQuery syntax) as:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">declare item-type t:tree as record(value, children as t:tree*);</span></pre></div><p><span class="deltaxml-old">A function to walk this tree and enumerate all the values in order might be written as:</span></p><div class="exampleInner"><pre><span class="deltaxml-old"> declare function t:flatten($tree as t:tree) as item()* { $tree?value, $tree?children ! t:flatten(.)) }</span></pre></div></div><p><span class="deltaxml-old">&nbsp;</span></p><div class="example"><div class="exampleHeader"><a id="e-mutually-recursive-types"></a><span class="deltaxml-old">Example: Mutually Recursive Types</span></div><p><span class="deltaxml-old">The usual textbook example of mutually-recursive types is that of a </span><em><span class="deltaxml-old">forest</span></em><span class="deltaxml-old"> consisting of a list of </span><em><span class="deltaxml-old">trees</span></em><span class="deltaxml-old">, where each </span><em><span class="deltaxml-old">tree</span></em><span class="deltaxml-old"> is a record comprising a value and a </span><em><span class="deltaxml-old">forest</span></em><span class="deltaxml-old">. As the previous example shows, this structure can be defined straightforwardly in XQuery 4.0 without recourse to mutual recursion.</span></p><p><span class="deltaxml-old">A more realistic example where mutual recursion is needed is for the schema component model used in </span><a href="#XMLSchema10"><span class="deltaxml-old">[XML Schema 1.0]</span></a><span class="deltaxml-old"> or </span><a href="#XMLSchema11"><span class="deltaxml-old">[XML Schema 1.1]</span></a><span class="deltaxml-old">. Simplifying greatly, the data representing an element declaration in XSD may contain references to a complex type, which in turn will typically contain references to further element declarations. The structure therefore involves mutual recursion.</span></p></div></div><div class="div4"><h5><a id="id-array-test"></a><span class="deltaxml-old">3.6.4.5</span><span class="deltaxml-new">3.6.4.4</span> Array Test</h5><a id="d3e8337"></a><a id="d3e7651"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ArrayTest"></a>[<span class="deltaxml-old">261</span><span class="deltaxml-new">247</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ArrayTest">ArrayTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AnyArrayTest">AnyArrayTest</a> | <a href="#doc-xquery40-TypedArrayTest">TypedArrayTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AnyArrayTest"></a>[<span class="deltaxml-old">262</span><span class="deltaxml-new">248</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AnyArrayTest">AnyArrayTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"array" "(" "*" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypedArrayTest"></a>[<span class="deltaxml-old">263</span><span class="deltaxml-new">249</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-TypedArrayTest">TypedArrayTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"array" "(" <a href="#doc-xquery40-SequenceType">SequenceType</a> ")"</code></td><td></td></tr></tbody></table><p>The <a href="#doc-xquery40-AnyArrayTest">AnyArrayTest</a><code>array(*)</code> matches any array. The <a href="#doc-xquery40-TypedArrayTest">TypedArrayTest</a><code>array(X)</code> matches any array in which every array member matches the <a href="#doc-xquery40-SequenceType">SequenceType</a><code>X</code>.</p><p>Examples:</p><ul><li><p><code>[ 1, 2 ] instance array(*)</code> returns <code>true()</code></p></li><li><p><code>[] instance of array(xs:string)</code> returns <code>true()</code></p></li><li><p><code>[ "foo" ] instance of array(xs:string)</code> returns <code>true()</code></p></li><li><p><code>[ "foo" ] instance of array(xs:integer)</code> returns <code>false()</code></p></li><li><p><code>[(1,2),(3,4)] instance of array(xs:integer)</code> returns <code>false()</code></p></li><li><p><code>[(1,2),(3,4)] instance of array(xs:integer+)</code> returns <code>true()</code></p></li></ul><p>An array also matches certain other <a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-old">item types</span></a><span class="deltaxml-new">ItemTypes</span>, including:</p><ul><li><p><code>item()</code></p></li><li><p><code>function(*)</code></p></li><li><p><code>function(xs:integer) as item()*</code></p></li></ul><p><span class="deltaxml-old">An array that matches </span><code><span class="deltaxml-old">array(T)</span></code><span class="deltaxml-old"> also matches the function test </span><code><span class="deltaxml-old">function(xs:integer) as T</span></code><span class="deltaxml-old">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">To understand this rule, consider the use of an array </span><code><span class="deltaxml-old">$A</span></code><span class="deltaxml-old"> in a function call </span><code><span class="deltaxml-old">$A($I)</span></code><span class="deltaxml-old">, which is equivalent to the function call </span><code><span class="deltaxml-old">array:get($A, $I)</span></code><span class="deltaxml-old">. This function accepts any integer for the argument </span><code><span class="deltaxml-old">$I</span></code><span class="deltaxml-old">, and the result will either be an instance of </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old">, or an error.</span></p><p><span class="deltaxml-old">The transitivity rules for item type matching mean that if an item </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> matches a type </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old">, and </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-old">subtype</span></a><span class="deltaxml-old"> of </span><var><span class="deltaxml-old">U</span></var><span class="deltaxml-old">, then </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> also matches type </span><var><span class="deltaxml-old">U</span></var><span class="deltaxml-old">. So the fact that an array of strings (</span><code><span class="deltaxml-old">array(xs:string)</span></code><span class="deltaxml-old">) matches </span><code><span class="deltaxml-old">function(xs:integer) as xs:string</span></code><span class="deltaxml-old"> means that it will also match other function tests such as </span><code><span class="deltaxml-old">function(xs:long) as item()*</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">Furthermore, the rules for </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-old">function coercion</span></a><span class="deltaxml-old"> mean that any array can be supplied as a value in a context where it does not actually match the required function type, but can be coerced to a function that does. For example an array of type </span><code><span class="deltaxml-old">array(node())</span></code><span class="deltaxml-old"> can be coerced to a function of type </span><code><span class="deltaxml-old">function(xs:integer) as element()</span></code><span class="deltaxml-old">; in this situation a type error will occur only if a call on the function actually returns a node that is not an element node.</span></p></div><p><span class="deltaxml-new">The function signature of an array matching </span><code><span class="deltaxml-new">array(X)</span></code><span class="deltaxml-new">, treated as a function, is </span><code><span class="deltaxml-new">function(xs:integer) as X</span></code><span class="deltaxml-new">. It is thus always a subtype of </span><code><span class="deltaxml-new">function(xs:integer) as item()*</span></code><span class="deltaxml-new"> regardless of the actual member types in the array. The rules for </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new">function coercion</span></a><span class="deltaxml-new"> mean that any array can be supplied as a value in a context where the required type has a more specific return type, such as </span><code><span class="deltaxml-new">function(xs:integer) as xs:integer</span></code><span class="deltaxml-new">, even when the array does not match in the sense required to satisfy the instance of operator. In such cases, a type error will only occur if an actual call on the array (treated as a function) returns a value that is not an instance of the required return type.</span></p><p>Rules defining whether one array type is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of another are given in <a href="#id-item-subtype-arrays"><b>3.7.2.8 Arrays</b></a>.</p></div></div><div class="div3"><h4><a id="id-xs-error"></a>3.6.5 xs:error</h4><p>The type <code>xs:error</code> has an empty value space; it never appears as a dynamic type or as the content type of a dynamic element or attribute type. It was defined in XML Schema in the interests of making the type system complete and closed, and it is also available in XQuery 4.0 for similar reasons.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">Even though it cannot occur in an instance, <code>xs:error</code> is a valid type name in a sequence type. The practical uses of <code>xs:error</code> as a sequence type are limited, but they do exist. For instance, an error-handling function that always raises a dynamic error never returns a value, so <code>xs:error</code> is a good choice for the return type of the function.</span><span style="display: none;" class="add_version">Even though it cannot occur in an instance, <code>xs:error</code> is a valid type name in a sequence type. The practical uses of <code>xs:error</code> as a sequence type are limited, but they do exist. For instance, an error handling function that always raises a dynamic error never returns a value, so <code>xs:error</code> is a good choice for the return type of the function.</span><span class="modify_version">Even though it cannot occur in an instance, <code>xs:error</code> is a valid type name in a sequence type. The practical uses of <code>xs:error</code> as a sequence type are limited, but they do exist. For instance, an error<span class="deltaxml-old">-</span><span class="deltaxml-new"> </span>handling function that always raises a dynamic error never returns a value, so <code>xs:error</code> is a good choice for the return type of the function.</span></p><p><span style="display: none;" class="delete_version">The semantics of <code>xs:error</code> are well defined as a consequence of the fact that <code>xs:error</code> is defined as a union type with no member types. For example:</span><span style="display: none;" class="add_version">The semantics of <code>xs:error</code> are well-defined as a consequence of the fact that <code>xs:error</code> is defined as a union type with no member types. For example:</span><span class="modify_version">The semantics of <code>xs:error</code> are well<span class="deltaxml-old"> </span><span class="deltaxml-new">-</span>defined as a consequence of the fact that <code>xs:error</code> is defined as a union type with no member types. For example:</span></p><ul><li><p><span style="display: none;" class="delete_version"><code>$x instance of xs:error</code> always returns <code>false</code>, regardless of the value of <code>$x</code>.</span><span style="display: none;" class="add_version"><code>$x instance of xs:error</code> always returns false, regardless of the value of <code>$x</code>.</span><span class="modify_version"><code>$x instance of xs:error</code> always returns false, regardless of the value of <code>$x</code>.</span></p></li><li><p><span style="display: none;" class="delete_version"><code>$x cast as xs:error</code> fails dynamically with error [<a title="err:FORG0001" href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0001">err:FORG0001</a>]<sup><small>FO40</small></sup>, regardless of the value of <code>$x</code>.</span><span style="display: none;" class="add_version"><code>$x cast as xs:error</code> fails dynamically with error [<a title="err:FORG0001" href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0001">err:FORG0001</a>]<sup><small>FO31</small></sup>, regardless of the value of <code>$x</code>.</span><span class="modify_version"><code>$x cast as xs:error</code> fails dynamically with error [<a title="err:FORG0001" href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0001">err:FORG0001</a>]<sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>, regardless of the value of <code>$x</code>.</span></p></li><li><p><span style="display: none;" class="delete_version"><code>$x cast as xs:error?</code> raises a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a title="err:FORG0001" href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0001">err:FORG0001</a>]<sup><small>FO40</small></sup> if <code>exists($x)</code> returns <code>true</code>, and evaluates to the empty sequence if <code>empty($x)</code> returns <code>true</code>.</span><span style="display: none;" class="add_version"><code>$x cast as xs:error?</code> raises a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a title="err:FORG0001" href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0001">err:FORG0001</a>]<sup><small>FO31</small></sup> if <code>exists($x)</code>, evaluates to the empty sequence if <code>empty($x)</code>.</span><span class="modify_version"><code>$x cast as xs:error?</code> raises a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a title="err:FORG0001" href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0001">err:FORG0001</a>]<sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup> if <code>exists($x)</code><span class="deltaxml-old"> returns </span><span class="deltaxml-old">true</span>, <span class="deltaxml-old">and </span>evaluates to the empty sequence if <code>empty($x)</code><span class="deltaxml-old"> returns </span><span class="deltaxml-old">true</span>.</span></p></li><li><p><code>xs:error($x)</code> has the same semantics as <code>$x cast as xs:error?</code> (see the previous bullet point)</p></li><li><p><code>$x castable as xs:error</code> evaluates to <code>false</code>, regardless of the value of <code>$x</code>.</p></li><li><p><code>$x treat as xs:error</code> raises a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>] if evaluated, regardless of the value of <code>$x</code>. It never fails statically.</p></li><li class="xquery"><p><code>let $x as xs:error := 1 return 2</code> raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>], which can be raised statically or dynamically, and need not be raised if the variable <code>$x</code> is never evaluated by the query processor.</p></li><li class="xquery"><p><code>declare function ns:f($arg as xs:error) {...};</code> is a valid function declaration, but it always raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] if the function is called.</p></li></ul><p><span style="display: none;" class="delete_version">All of the above examples assume that <code>$x</code> is actually evaluated. The rules specified in <a href="#id-errors-and-opt"><b>2.4.4 Errors and Optimization</b></a> permit an implementation to avoid evaluating <code>$x</code> if the result of the query does not depend upon the value of <code>$x</code> and thus to avoid raising an error.</span><span style="display: none;" class="add_version">All of the above examples assume that <code>$x</code> is actually evaluated. If the result of the query does not depend on the value of <code>$x</code>. the rules specified in <a href="#id-errors-and-opt"><b>2.4.4 Errors and Optimization</b></a> permit an implementation to avoid evaluating <code>$x</code> and thus to avoid raising an error.</span><span class="modify_version">All of the above examples assume that <code>$x</code> is actually evaluated. <span class="deltaxml-old">The</span><span class="deltaxml-new">If the result of the query does not depend on the value of</span> <code><span class="deltaxml-new">$x</span></code><span class="deltaxml-new">. the </span>rules specified in <a href="#id-errors-and-opt"><b>2.4.4 Errors and Optimization</b></a> permit an implementation to avoid evaluating <code>$x</code> <span class="deltaxml-old">if the result of the query does not depend upon the value of </span><span class="deltaxml-old">$x</span><span class="deltaxml-old"> </span>and thus to avoid raising an error.</span></p></div></div></div><div class="div2"><h3><a id="id-sequencetype-subtype"></a>3.7 Subtype Relationships</h3><p> [<a id="dt-subtype" title="subtype">Definition</a>: Given two <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> or <a title="item type" class="termref" href="#dt-item-type">item types</a>, the rules in this section determine if one is a <b>subtype</b> of the other. If a type <var>A</var> is a subtype of type <var>B</var>, it follows that every value matched by <var>A</var> is also matched by <var>B</var>.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The relationship <code>subtype(A, A)</code> is always true: every type is a subtype of itself.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The converse is not necessarily true: we cannot infer that if every value matched by <var>A</var> is also matched by <var>B</var>, then <var>A</var> is a subtype of type <var>B</var>. For example, <var>A</var> might be defined as the set of strings matching the regular expression <code>[A-Z]*</code>, while <var>B</var> is the set of strings matching the regular expression <code>[A-Za-z]*</code>; no subtype relationship holds between these types.</p></div><p>The rules for deciding whether one <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> is a subtype of another are given in <a href="#id-seqtype-subtype"><b>3.7.1 Subtypes of Sequence Types</b></a>. The rules for deciding whether one <a title="item type" class="termref" href="#dt-item-type">item type</a> is a subtype of another are given in <a href="#id-itemtype-subtype"><b>3.7.2 Subtypes of Item Types</b></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The subtype relationship is not acyclic. There are cases where <code>subtype(A, B)</code> and <code>subtype(B, A)</code> are both true. This implies that <var>A</var> and <var>B</var> have the same value space, but they can still be different types. For example this applies when <var>A</var> is a union type with member types <code>xs:string</code> and <code>xs:integer</code>, while <var>B</var> is a union type with member types <code>xs:integer</code> and <code>xs:string</code>. These are different types (<code>"23" cast as A</code> produces a string, while <code>"23" cast as B</code> produces an integer, because casting is attempted to each member type in order) but both types have the same value space. </p></div><div class="div3"><h4><a id="id-seqtype-subtype"></a>3.7.1 Subtypes of Sequence Types</h4><p>We use the notation <code>A ⊑ B</code>, or <code>subtype(A, B)</code> to indicate that a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a><code>A</code> is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of a sequence type <code>B</code>. This section defines the rules for deciding whether any two sequence types have this relationship.</p><p>To define the rules, we divide sequence types into six categories:</p><ul><li><p>The category <code>empty</code> includes the sequence types <code>empty-sequence()</code>, <code>xs:error*</code> and <code>xs:error?</code>. All these sequence types match the empty sequence as their only instance.</p></li><li><p>The category <code>void</code> includes the sequence types <code>xs:error</code> and <code>xs:error+</code>, which have no instances (not even the empty sequence).</p></li><li><p>The categories <code>X?</code>, <code>X*</code>, <code>X</code> and <code>X+</code> includes all sequence types having an item type <code>X</code> other than <code>xs:error</code>, together with an occurrence indicator of <code>?</code> (zero or more), <code>*</code> (one or more), absent (exactly one), or <code>+</code> (one or more) respectively. We use the notation <var>X<sub>i</sub></var> to indicate the item type of such a sequence type.</p></li></ul><p>The judgement <code>A ⊑ B</code> is then determined by the categories of the two sequence types, as defined in the table below. In many cases this depends on the relationship between the item types of <code>A</code> and <code>B</code>. This is denoted using the notation <code><var>A<sub>i</sub></var> ⊆ <var>B<sub>i</sub></var></code>, as defined in <a href="#id-itemtype-subtype"><b>3.7.2 Subtypes of Item Types</b></a>.</p><table class="medium"><tbody><tr><th rowspan="2" colspan="2"></th><th colspan="6"><a title="sequence type" class="termref" href="#dt-sequence-type">Sequence type</a><var>B</var></th></tr><tr><th><code>empty</code></th><th><code><var>B<sub>i</sub></var>?</code></th><th><code><var>B<sub>i</sub></var>*</code></th><th><code><var>B<sub>i</sub></var></code></th><th><code><var>B<sub>i</sub></var>+</code></th><th><code>void</code></th></tr><tr><th rowspan="6"><a title="sequence type" class="termref" href="#dt-sequence-type">Sequence type</a><var>A</var></th><th><code>empty</code></th><td>true</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td></tr><tr><th><code><var>A<sub>i</sub></var>?</code></th><td>false</td><td><code><var>A<sub>i</sub></var> ⊆ <var>B<sub>i</sub></var></code></td><td><code><var>A<sub>i</sub></var> ⊆ <var>B<sub>i</sub></var></code></td><td>false</td><td>false</td><td>false</td></tr><tr><th><code><var>A<sub>i</sub></var>*</code></th><td>false</td><td>false</td><td><code><var>A<sub>i</sub></var> ⊆ <var>B<sub>i</sub></var></code></td><td>false</td><td>false</td><td>false</td></tr><tr><th><code><var>A<sub>i</sub></var></code></th><td>false</td><td><code><var>A<sub>i</sub></var> ⊆ <var>B<sub>i</sub></var></code></td><td><code><var>A<sub>i</sub></var> ⊆ <var>B<sub>i</sub></var></code></td><td><code><var>A<sub>i</sub></var> ⊆ <var>B<sub>i</sub></var></code></td><td><code><var>A<sub>i</sub></var> ⊆ <var>B<sub>i</sub></var></code></td><td>false</td></tr><tr><th><code><var>A<sub>i</sub></var>+</code></th><td>false</td><td>false</td><td><code><var>A<sub>i</sub></var> ⊆ <var>B<sub>i</sub></var></code></td><td>false</td><td><code><var>A<sub>i</sub></var> ⊆ <var>B<sub>i</sub></var></code></td><td>false</td></tr><tr><th><code>void</code></th><td>true</td><td>true</td><td>true</td><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><div class="div3"><h4><a id="id-itemtype-subtype"></a>3.7.2 Subtypes of Item Types</h4><p>We use the notation <code>A ⊆ B</code>, or <code>itemtype-subtype(A, B)</code> to indicate that an <a title="item type" class="termref" href="#dt-item-type">item type</a><code>A</code> is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of an item type <code>B</code>. This section defines the rules for deciding whether any two item types have this relationship.</p><p><span class="deltaxml-old">The rules in this section apply to </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-old">item types</span></a><span class="deltaxml-old">, not to </span><a title="item type designator" class="termref" href="#dt-item-type-designator"><span class="deltaxml-old">item type designators</span></a><span class="deltaxml-old">. For example, if the name </span><code><span class="deltaxml-old">STR</span></code><span class="deltaxml-old"> has been defined in the static context as a </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-old">named item type</span></a><span class="deltaxml-old"> referring to the type </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">, then anything said here about the type </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> applies equally whether it is designated as </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> or as </span><code><span class="deltaxml-old">STR</span></code><span class="deltaxml-old">, or indeed as the parenthesized forms </span><code><span class="deltaxml-old">(xs:string)</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">(STR)</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">References to </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-old">named item types</span></a><span class="deltaxml-old"> are handled as described in </span><a href="#id-itemtype-subtype-aliases"><b><span class="deltaxml-old">3.7.2.10 Named Item Types</span></b></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-new">Before applying these rules, any ItemType written as </span><code><span class="deltaxml-new">item-type(N)</span></code><span class="deltaxml-new"> is replaced with the definition of the named item type </span><code><span class="deltaxml-new">N</span></code><span class="deltaxml-new">, recursively. The rules are written in terms of the lexical form of the two </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new">item types</span></a><span class="deltaxml-new">, but it is assumed that trivial variations are first eliminated: comments and unnecessary whitespace are removed, lexical QNames are replaced by URI-qualified names applying appropriate defaults in the case of unprefixed names, equivalent forms such as </span><code><span class="deltaxml-new">element()</span></code><span class="deltaxml-new"> and </span><code><span class="deltaxml-new">element(*)</span></code><span class="deltaxml-new"> are normalized.</span></p><p>The relationship <code>A ⊆ B</code> is true if and only if at least one of the conditions listed in the following subsections applies:</p><div class="div4"><h5><a id="id-item-subtype-general"></a>3.7.2.1 General Rules</h5><p><span style="display: none;" class="delete_version">Given <a title="item type" class="termref" href="#dt-item-type">item types</a><var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</span><span style="display: none;" class="add_version">Given <a title="item type" class="termref" href="#dt-item-type">item types</a><var>A</var> and <var>B</var>, <var>A</var><code>⊆</code><var>B</var> is true if any of the following apply:</span><span class="modify_version">Given <a title="item type" class="termref" href="#dt-item-type">item types</a><var>A</var> and <var>B</var>, <var>A</var><span class="deltaxml-old"> </span><code>⊆<span class="deltaxml-old"> </span></code><var>B</var> is true if any of the following apply:</span></p><ol class="enumar"><li><p><var>A</var> is <code>xs:error</code>.</p></li><li><p><var>B</var> is <code>item()</code>.</p></li><li><p><var>A</var> and <var>B</var> are the same <a title="item type" class="termref" href="#dt-item-type">item type</a>.</p></li><li><p>There is an <a title="item type" class="termref" href="#dt-item-type">item type</a><var>X</var> such that <code><var>A</var> ⊆ <var>X</var></code> and <code><var>X</var> ⊆ <var>B</var></code>. (This is referred to below as the <b>transitivity rule</b>).</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The first rule is technically redundant: it is implied by the second rule in <a href="#id-item-subtype-atomic"><b>3.7.2.2 Atomic and Union Types</b></a>. The type <code>xs:error</code> is defined as a union type with no member types; therefore it is automatically true that every member type <var>T</var> satisfies <code><var>T</var> ⊆ <var>B</var></code>.</p></div></div><div class="div4"><h5><a id="id-item-subtype-atomic"></a>3.7.2.2 Atomic and Union Types</h5><p><span style="display: none;" class="delete_version">Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</span><span style="display: none;" class="add_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><code>⊆</code><var>B</var> is true if any of the following apply:</span><span class="modify_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><span class="deltaxml-old"> </span><code>⊆<span class="deltaxml-old"> </span></code><var>B</var> is true if any of the following apply:</span></p><ol class="enumar"><li><p><var>A</var> and <var>B</var> are <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic types</a>, and <code>derives-from(<var>A</var>, <var>B</var>)</code> returns <code>true</code>.</p><p>The <code>derives-from</code> relationship is defined in <a href="#id-sequencetype-matching"><b>3.5 Sequence Type Matching</b></a>.</p><div class="example"><div class="exampleHeader"><a id="d3e9216"></a><a id="d3e8448"></a>Examples:</div><ul><li><p><code>xs:integer ⊆ xs:decimal</code> because <code>xs:integer</code> is derived by restriction from <code>xs:decimal</code>.</p></li><li><p><code>xs:decimal ⊆ xs:numeric</code> because <code>xs:numeric</code> is a pure union type that includes <code>xs:decimal</code> as a member type.</p></li><li class="delete_version" style="display: none;"><p><code>enum("red") ⊆ xs:string</code> because the singleton enumeration type <code>enum("red")</code> is defined to be an atomic type derived from <code>xs:string</code>.</p></li><li class="modify_version"><p><code><span class="deltaxml-old">enum("red") ⊆ xs:string</span></code><span class="deltaxml-old"> because the singleton enumeration type </span><code><span class="deltaxml-old">enum("red")</span></code><span class="deltaxml-old"> is defined to be an atomic type derived from </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">.</span></p></li><li class="delete_version" style="display: none;"><p><code>enum("red") ⊆ enum("red", "green")</code> because the enumeration type <code>enum("red", "green")</code> is defined to be a union type that has the atomic type <code>enum("red")</code> as a member type.</p></li><li class="modify_version"><p><code><span class="deltaxml-old">enum("red") ⊆ enum("red", "green")</span></code><span class="deltaxml-old"> because the enumeration type </span><code><span class="deltaxml-old">enum("red", "green")</span></code><span class="deltaxml-old"> is defined to be a union type that has the atomic type </span><code><span class="deltaxml-old">enum("red")</span></code><span class="deltaxml-old"> as a member type.</span></p></li></ul></div></li><li><p><var>A</var> is a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a>, and every type <var>T</var> in the transitive membership of <var>A</var> satisfies <code><var>T</var> ⊆ <var>B</var></code>.</p><div class="example"><div class="exampleHeader"><a id="d3e9273"></a><a id="d3e8487"></a>Examples:</div><ul><li><p><code>union(xs:short, xs:long) ⊆ xs:integer</code> because <code>xs:short ⊆ xs:integer</code> and <code>xs:long ⊆ xs:integer</code>.</p></li><li><p><code>union(P, Q) ⊆ union(P, Q, R)</code> because <code>P ⊆ union(P, Q, R)</code> and <code>Q ⊆ union(P, Q, R)</code>.</p></li><li class="delete_version" style="display: none;"><p><code>enum("red", "green") ⊆ xs:string</code> because the enumeration type <code>enum("red") ⊆ xs:string</code> and <code>enum("green") ⊆ xs:string</code>.</p></li><li class="modify_version"><p><code><span class="deltaxml-old">enum("red", "green") ⊆ xs:string</span></code><span class="deltaxml-old"> because the enumeration type </span><code><span class="deltaxml-old">enum("red") ⊆ xs:string</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">enum("green") ⊆ xs:string</span></code><span class="deltaxml-old">.</span></p></li><li class="delete_version" style="display: none;"><p><code>enum("red", "green") ⊆ enum("red", "green", "blue")</code> because <code>enum("red") ⊆ enum("red", "green", "blue")</code> and <code>enum("green") ⊆ enum("red", "green", "blue")</code>.</p></li><li class="modify_version"><p><code><span class="deltaxml-old">enum("red", "green") ⊆ enum("red", "green", "blue")</span></code><span class="deltaxml-old"> because </span><code><span class="deltaxml-old">enum("red") ⊆ enum("red", "green", "blue")</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">enum("green") ⊆ enum("red", "green", "blue")</span></code><span class="deltaxml-old">.</span></p></li><li class="delete_version" style="display: none;"><p><code>enum("red", "green", "blue") ⊆ union(enum("red", "green"), enum("blue"))</code> because each of the types <code>enum("red")</code>, <code>enum("green")</code>, and <code>enum("blue")</code> is a subtype of one of the two members of the union type.</p></li><li class="modify_version"><p><code><span class="deltaxml-old">enum("red", "green", "blue") ⊆ union(enum("red", "green"), enum("blue"))</span></code><span class="deltaxml-old"> because each of the types </span><code><span class="deltaxml-old">enum("red")</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">enum("green")</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">enum("blue")</span></code><span class="deltaxml-old"> is a subtype of one of the two members of the union type.</span></p></li></ul></div><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">This rule applies both when <code>A</code> is a schema-defined union type and when it is a <a href="#doc-xquery40-LocalUnionType">LocalUnionType</a>; in addition it applies when <code>A</code> is an enumeration type with multiple enumerated values, which is defined to be equivalent to a union type. </span><span style="display: none;" class="add_version">This rule applies both when <code>A</code> is a schema-defined union type and when it is a <a href="#doc-xquery40-LocalUnionType">LocalUnionType</a>. </span><span class="modify_version">This rule applies both when <code>A</code> is a schema-defined union type and when it is a <a href="#doc-xquery40-LocalUnionType">LocalUnionType</a><span class="deltaxml-old">; in addition it applies when </span><span class="deltaxml-old">A</span><span class="deltaxml-old"> is an enumeration type with multiple enumerated values, which is defined to be equivalent to a union type</span>. </span></p></div></li><li class="add_version" style="display: none;"><p><var>A</var> is an <a title="EnumerationType" class="termref" href="#dt-EnumerationType">EnumerationType</a>, and <var>B</var> matches every string literal in the enumeration of <var>A</var>.</p><div class="example"><div class="exampleHeader"><a id="d3e8527"></a>Examples:</div><ul><li><p><code>enum("red", "green", "blue") ⊆ xs:string</code></p></li><li><p><code>enum("red", "green", "blue") ⊆ enum("red", "green", "blue", "yellow")</code></p></li></ul></div></li><li class="modify_version"><p><var><span class="deltaxml-new">A</span></var><span class="deltaxml-new"> is an </span><a title="EnumerationType" class="termref" href="#dt-EnumerationType"><span class="deltaxml-new">EnumerationType</span></a><span class="deltaxml-new">, and </span><var><span class="deltaxml-new">B</span></var><span class="deltaxml-new"> matches every string literal in the enumeration of </span><var><span class="deltaxml-new">A</span></var><span class="deltaxml-new">.</span></p><div class="example"><div class="exampleHeader"><a id="d3e8527"></a><span class="deltaxml-new">Examples:</span></div><ul><li><p><code><span class="deltaxml-new">enum("red", "green", "blue") ⊆ xs:string</span></code></p></li><li><p><code><span class="deltaxml-new">enum("red", "green", "blue") ⊆ enum("red", "green", "blue", "yellow")</span></code></p></li></ul></div></li></ol></div><div class="div4"><h5><a id="id-item-subtype-nodes"></a>3.7.2.3 Node Types: General Rules</h5><p><span style="display: none;" class="delete_version">Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</span><span style="display: none;" class="add_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><code>⊆</code><var>B</var> is true if any of the following apply:</span><span class="modify_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><span class="deltaxml-old"> </span><code>⊆<span class="deltaxml-old"> </span></code><var>B</var> is true if any of the following apply:</span></p><ol class="enumar"><li><p><var>A</var> is a <a href="#doc-xquery40-KindTest">KindTest</a> and <var>B</var> is <code>node()</code>.</p><div class="example"><div class="exampleHeader"><a id="d3e9361"></a><a id="d3e8567"></a>Example:</div><p><code>comment() ⊆ node()</code></p></div></li><li><p><var>A</var> is <code>processing-instruction(<var>N</var>)</code> for any name <var>N</var>, and <var>B</var> is <code>processing-instruction()</code>.</p><div class="example"><div class="exampleHeader"><a id="d3e9383"></a><a id="d3e8589"></a>Example:</div><p><code>processing-instruction('pi') ⊆ processing-instruction()</code></p></div></li><li><p><var>A</var> is <code>document-node(<var>E</var>)</code> for any <a href="#doc-xquery40-ElementTest">ElementTest</a><var>E</var>, and <var>B</var> is <code>document-node()</code>.</p><div class="example"><div class="exampleHeader"><a id="d3e9409"></a><a id="d3e8615"></a>Example:</div><p><code>document-node(element(chap)) ⊆ document-node()</code></p></div></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>document-node(<var>A<sub>e</sub></var>)</code></p></li><li><p><var>B</var> is <code>document-node(<var>B<sub>e</sub></var>)</code></p></li><li><p><code><var>A<sub>e</sub></var> ⊆ <var>B<sub>e</sub></var></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e9448"></a><a id="d3e8654"></a>Example:</div><p><code>document-node(element(title)) ⊆ document-node(element(*))</code>.</p></div></li></ol></div><div class="div4"><h5><a id="id-item-subtype-elements"></a>3.7.2.4 Node Types: Element Tests</h5><p><span style="display: none;" class="delete_version"> [<a id="dt-wildcard-matches" title="wildcard-matches">Definition</a>: In these rules, if <var>MU</var> and <var>NU</var> are <a href="#doc-xquery40-NameTestUnion">NameTestUnions</a>, then <var>MU</var><b>wildcard-matches</b><var>NU</var> is true if every name that matches <var>MU</var> also matches <var>NU</var>.] </span><span style="display: none;" class="add_version"> [<a id="dt-wildcard-matches" title="wildcard-matches">Definition</a>: In these rules, if <var>M</var> and <var>N</var> are <a href="#doc-xquery40-NameTest">NameTests</a>, then <var>M</var><b>wildcard-matches</b><var>N</var> is true if every name that matches <var>M</var> also matches <var>N</var>.] More specifically, this is the case if any of the following apply:</span><span class="modify_version"> [<a id="dt-wildcard-matches" title="wildcard-matches">Definition</a>: In these rules, if <var><span class="deltaxml-old">MU</span><span class="deltaxml-new">M</span></var> and <var><span class="deltaxml-old">NU</span><span class="deltaxml-new">N</span></var> are <a href="#doc-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnions</span></a><a href="#doc-xquery40-NameTest"><span class="deltaxml-new">NameTests</span></a>, then <var><span class="deltaxml-old">MU</span><span class="deltaxml-new">M</span></var><b>wildcard-matches</b><var><span class="deltaxml-old">NU</span><span class="deltaxml-new">N</span></var> is true if every name that matches <var><span class="deltaxml-old">MU</span><span class="deltaxml-new">M</span></var> also matches <var><span class="deltaxml-old">NU</span><span class="deltaxml-new">N</span></var>.] <span class="deltaxml-new">More specifically, this is the case if any of the following apply:</span></span></p><p><span class="deltaxml-old">More specifically, this is the case if for every </span><a href="#doc-xquery40-NameTest"><span class="deltaxml-old">NameTest</span></a><var><span class="deltaxml-old">M</span></var><span class="deltaxml-old"> in </span><var><span class="deltaxml-old">MU</span></var><span class="deltaxml-old"> there is a </span><a href="#doc-xquery40-NameTest"><span class="deltaxml-old">NameTest</span></a><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> in </span><var><span class="deltaxml-old">NU</span></var><span class="deltaxml-old"> where at least one of the following applies:</span></p><ol class="enumar"><li><p><var>M</var> and <var>N</var> are the same <code>NameTest</code>.</p></li><li><p><var>M</var> is an <code>EQName</code> and <var>N</var> is a <a href="#doc-xquery40-Wildcard">Wildcard</a> that matches <var>M</var>.</p></li><li><p><var>N</var> is the <a href="#doc-xquery40-Wildcard">Wildcard</a><code>*</code>.</p></li></ol><p><span style="display: none;" class="delete_version">Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply.</span><span style="display: none;" class="add_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><code>⊆</code><var>B</var> is true if any of the following apply.</span><span class="modify_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><span class="deltaxml-old"> </span><code>⊆<span class="deltaxml-old"> </span></code><var>B</var> is true if any of the following apply.</span></p><ol class="enumar"><li><p><var>A</var> is an <a href="#doc-xquery40-ElementTest">ElementTest</a> and <var>B</var> is either <code>element()</code> or <code>element(*)</code></p></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is either <code>element(<var>A<sub>n</sub></var>)</code> or <code>element(<var>A<sub>n</sub></var>, <var>T</var>)</code> or <code>element(<var>A<sub>n</sub></var>, <var>T</var>?)</code> for any type <var>T</var></p></li><li><p><var>B</var> is either <code>element(<var>B<sub>n</sub></var>)</code> or <code>element(<var>B<sub>n</sub></var>, xs:anyType?)</code></p></li><li><p><var>A<sub>n</sub></var><a title="wildcard-matches" class="termref" href="#dt-wildcard-matches">wildcard-matches</a><var>B<sub>n</sub></var></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e9611"></a><a id="d3e8799"></a>Examples:</div><ul><li><p><code>element(title) ⊆ element(*)</code></p></li><li><p><code>element(title, xs:string) ⊆ element(*)</code></p></li><li class="delete_version" style="display: none;"><p><code>element(title|heading, xs:string) ⊆ element(*)</code></p></li><li class="modify_version"><p><code><span class="deltaxml-old">element(title|heading, xs:string) ⊆ element(*)</span></code></p></li><li class="delete_version" style="display: none;"><p><code>element(title, xs:string) ⊆ element(title|heading)</code></p></li><li class="modify_version"><p><code><span class="deltaxml-old">element(title, xs:string) ⊆ element(title|heading)</span></code></p></li><li><p><code>element(title, xs:string?) ⊆ element(*)</code></p></li><li><p><span style="display: none;" class="delete_version"><code>element(title|heading, xs:string) ⊆ element(*)</code></span><span style="display: none;" class="add_version"><code>element(title) ⊆ element(title, xs:anyType?)</code></span><span class="modify_version"><code>element(title<span class="deltaxml-old">|heading, xs:string</span>) ⊆ element(<span class="deltaxml-old">*</span><span class="deltaxml-new">title, xs:anyType?</span>)</code></span></p></li><li class="delete_version" style="display: none;"><p><code>element(title) ⊆ element(title, xs:anyType?)</code></p></li><li class="modify_version"><p><code><span class="deltaxml-old">element(title) ⊆ element(title, xs:anyType?)</span></code></p></li><li><p><span style="display: none;" class="delete_version"><code>element(title, xs:integer) ⊆ element(title|heading, xs:anyType?)</code></span><span style="display: none;" class="add_version"><code>element(title, xs:integer) ⊆ element(title, xs:anyType?)</code></span><span class="modify_version"><code>element(title, xs:integer) ⊆ element(title<span class="deltaxml-old">|heading</span>, xs:anyType?)</code></span></p></li><li><p><code>element(title, xs:string?) ⊆ element(title, xs:anyType?)</code></p></li><li><p><span style="display: none;" class="delete_version"><code>element(my:title|your:title) ⊆ element(*:title)</code></span><span style="display: none;" class="add_version"><code>element(my:title) ⊆ element(*:title)</code></span><span class="modify_version"><code>element(my:title<span class="deltaxml-old">|your:title</span>) ⊆ element(*:title)</code></span></p></li><li><p><span style="display: none;" class="delete_version"><code>element(my:title|my:heading) ⊆ element(my:*)</code></span><span style="display: none;" class="add_version"><code>element(my:title) ⊆ element(my:*)</code></span><span class="modify_version"><code>element(my:title<span class="deltaxml-old">|my:heading</span>) ⊆ element(my:*)</code></span></p></li></ul></div></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>element(<var>A<sub>n</sub></var>, <var>A<sub>t</sub></var>)</code></p></li><li><p><var>B</var> is <code>element(<var>B<sub>n</sub></var>, <var>B<sub>t</sub></var>)</code></p></li><li><p><var>A<sub>n</sub></var><a title="wildcard-matches" class="termref" href="#dt-wildcard-matches">wildcard-matches</a><var>B<sub>n</sub></var></p></li><li><p><code>derives-from(<var>A<sub>t</sub></var>, <var>B<sub>t</sub></var>)</code>.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e9715"></a><a id="d3e8888"></a>Examples:</div><ul><li><p><code>element(size, xs:integer) ⊆ element(size, xs:decimal)</code></p></li><li><p><span style="display: none;" class="delete_version"><code>element(size, xs:integer) ⊆ element(size|größe, xs:decimal)</code></span><span style="display: none;" class="add_version"><code>element(size, xs:integer) ⊆ element(*, xs:decimal)</code></span><span class="modify_version"><code>element(size, xs:integer) ⊆ element(<span class="deltaxml-old">size|größe</span><span class="deltaxml-new">*</span>, xs:decimal)</code></span></p></li><li class="delete_version" style="display: none;"><p><code>element(size, xs:integer) ⊆ element(*, xs:decimal)</code></p></li><li class="modify_version"><p><code><span class="deltaxml-old">element(size, xs:integer) ⊆ element(*, xs:decimal)</span></code></p></li><li><p><code>element(*, xs:integer) ⊆ element(*, xs:decimal)</code></p></li><li><p><code>element(my:*, xs:integer) ⊆ element(*, xs:decimal)</code></p></li></ul></div></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is either <code>element(<var>A<sub>n</sub></var>, <var>A<sub>t</sub></var>)</code> or <code>element(<var>A<sub>n</sub></var>, <var>A<sub>t</sub></var>?)</code></p></li><li><p><var>B</var> is <code>element(<var>B<sub>n</sub></var>, <var>B<sub>t</sub></var>?)</code></p></li><li><p><var>A<sub>n</sub></var><a title="wildcard-matches" class="termref" href="#dt-wildcard-matches">wildcard-matches</a><var>B<sub>n</sub></var></p></li><li><p><code>derives-from(<var>A<sub>t</sub></var>, <var>B<sub>t</sub></var>)</code>.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e9796"></a><a id="d3e8964"></a>Examples:</div><ul><li><p><code>element(size, xs:integer) ⊆ element(size, xs:decimal?)</code></p></li><li><p><code>element(size, xs:integer?) ⊆ element(*, xs:decimal?)</code></p></li><li><p><code>element(*, xs:integer) ⊆ element(*, xs:decimal?)</code></p></li><li><p><code>element(my:*, xs:integer?) ⊆ element(*, xs:decimal?)</code></p></li></ul></div></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>schema-element(<var>A<sub>n</sub></var>)</code></p></li><li><p><var>B</var> is <code>schema-element(<var>B<sub>n</sub></var>)</code></p></li><li><p>Every element declaration that is an actual member of the substitution group of <var>A<sub>n</sub></var> is also an actual member of the substitution group of <var>B<sub>n</sub></var>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The fact that <var>P</var> is a member of the substitution group of <var>Q</var> does not mean that every element declaration in the substitution group of <var>P</var> is also in the substitution group of <var>Q</var>. For example, <var>Q</var> might block substitution of elements whose type is derived by extension, while <var>P</var> does not.</p></div></li></ol></div><div class="div4"><h5><a id="id-item-subtype-attributes"></a>3.7.2.5 Node Types: Attribute Tests</h5><p><span style="display: none;" class="delete_version">Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</span><span style="display: none;" class="add_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><code>⊆</code><var>B</var> is true if any of the following apply:</span><span class="modify_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><span class="deltaxml-old"> </span><code>⊆<span class="deltaxml-old"> </span></code><var>B</var> is true if any of the following apply:</span></p><ol class="enumar"><li><p><var>A</var> is an <a href="#doc-xquery40-AttributeTest">AttributeTest</a> and <var>B</var> is either <code>attribute()</code> or <code>attribute(*)</code></p></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is either <code>attribute(<var>A<sub>n</sub></var>)</code> or <code>attribute(<var>A<sub>n</sub></var>, <var>T</var>)</code> for any type <var>T</var>.</p></li><li><p><var>B</var> is either <code>attribute(Bn)</code> or <code>attribute(<var>B<sub>n</sub></var>, xs:anyAtomicType)</code></p></li><li><p><var>A<sub>n</sub></var><a title="wildcard-matches" class="termref" href="#dt-wildcard-matches">wildcard-matches</a><var>B<sub>n</sub></var></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e9940"></a><a id="d3e9107"></a>Examples:</div><ul><li><p><code>attribute(code) ⊆ attribute(*)</code></p></li><li class="delete_version" style="display: none;"><p><code>attribute(code|status) ⊆ attribute(*)</code></p></li><li class="modify_version"><p><code><span class="deltaxml-old">attribute(code|status) ⊆ attribute(*)</span></code></p></li><li><p><code>attribute(code, xs:untypedAtomic) ⊆ attribute(*)</code></p></li><li><p><span style="display: none;" class="delete_version"><code>attribute(code|status, xs:string) ⊆ attribute(code, xs:anyAtomicType)</code></span><span style="display: none;" class="add_version"><code>attribute(code, xs:string) ⊆ attribute(code, xs:anyAtomicType)</code></span><span class="modify_version"><code>attribute(code<span class="deltaxml-old">|status</span>, xs:string) ⊆ attribute(code, xs:anyAtomicType)</code></span></p></li><li><p><span style="display: none;" class="delete_version"><code>attribute(my:code|your:code) ⊆ attribute(*:code)</code></span><span style="display: none;" class="add_version"><code>attribute(my:code) ⊆ attribute(*:code)</code></span><span class="modify_version"><code>attribute(my:code<span class="deltaxml-old">|your:code</span>) ⊆ attribute(*:code)</code></span></p></li><li><p><span style="display: none;" class="delete_version"><code>attribute(my:code|my:status) ⊆ attribute(my:*)</code></span><span style="display: none;" class="add_version"><code>attribute(my:code) ⊆ attribute(my:*)</code></span><span class="modify_version"><code>attribute(my:code<span class="deltaxml-old">|my:status</span>) ⊆ attribute(my:*)</code></span></p></li></ul></div></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>attribute(<var>A<sub>n</sub></var>, <var>A<sub>t</sub></var>)</code></p></li><li><p><var>B</var> is <code>attribute(<var>B<sub>n</sub></var>, <var>B<sub>t</sub></var>)</code></p></li><li><p><var>A<sub>n</sub></var><a title="wildcard-matches" class="termref" href="#dt-wildcard-matches">wildcard-matches</a><var>B<sub>n</sub></var></p></li><li><p><code>derives-from(<var>A<sub>t</sub></var>, <var>B<sub>t</sub></var>)</code>.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10019"></a><a id="d3e9181"></a>Examples:</div><ul><li><p><code>attribute(*, xs:ID) ⊆ attribute(*, xs:string)</code></p></li><li><p><code>attribute(my:*, xs:ID) ⊆ attribute(*, xs:string)</code></p></li><li><p><span style="display: none;" class="delete_version"><code>attribute(code, xs:ID) ⊆ attribute(code|status, xs:string)</code></span><span style="display: none;" class="add_version"><code>attribute(code, xs:ID) ⊆ attribute(code, xs:string)</code></span><span class="modify_version"><code>attribute(code, xs:ID) ⊆ attribute(code<span class="deltaxml-old">|status</span>, xs:string)</code></span></p></li><li><p><code>attribute(code, xs:ID) ⊆ attribute(*, xs:string)</code></p></li><li><p><code>attribute(code, xs:ID) ⊆ attribute(*:code, xs:ID)</code></p></li><li><p><span style="display: none;" class="delete_version"><code>attribute(my:code|my:status, xs:ID) ⊆ attribute(my:*, xs:string)</code></span><span style="display: none;" class="add_version"><code>attribute(my:code, xs:ID) ⊆ attribute(my:*, xs:string)</code></span><span class="modify_version"><code>attribute(my:code<span class="deltaxml-old">|my:status</span>, xs:ID) ⊆ attribute(my:*, xs:string)</code></span></p></li></ul></div></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>schema-attribute(<var>A<sub>n</sub></var>)</code></p></li><li><p><var>B</var> is <code>schema-attribute(<var>B<sub>n</sub></var>)</code></p></li><li><p>the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of <var>A<sub>n</sub></var> equals the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of <var>B<sub>n</sub></var></p></li></ol></li></ol></div><div class="div4"><h5><a id="id-item-subtype-functions"></a>3.7.2.6 Functions</h5><p><span style="display: none;" class="delete_version">Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</span><span style="display: none;" class="add_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><code>⊆</code><var>B</var> is true if any of the following apply:</span><span class="modify_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><span class="deltaxml-old"> </span><code>⊆<span class="deltaxml-old"> </span></code><var>B</var> is true if any of the following apply:</span></p><ol class="enumar"><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is a <a href="#doc-xquery40-FunctionTest">FunctionTest</a><span class="xquery"> with annotations <code>[AnnotationsA]</code></span></p></li><li><p><var>B</var> is <code><span class="xquery">[AnnotationsB]</span> function(*)</code></p></li><li class="xquery"><p><code>subtype-assertions(AnnotationsA, AnnotationsB)</code>, where <code>[AnnotationsB]</code> and <code>[AnnotationsA]</code> are optional lists of one or more annotations.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10141"></a><a id="d3e9302"></a>Example:</div><p><code>function(xs:integer) as xs:string ⊆ function(*)</code></p></div></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code><span class="xquery">AnnotationsA </span>function(<var>a<sub>1</sub></var>, <var>a<sub>2</sub></var>, ... <var>a<sub>M</sub></var>) as <var>R<sub>A</sub></var></code></p></li><li><p><var>B</var> is <code><span class="xquery">AnnotationsB </span>function(<var>b<sub>1</sub></var>, <var>b<sub>2</sub></var>, ... <var>b<sub>N</sub></var>) as <var>R<sub>B</sub></var></code></p></li><li class="xquery"><p><code>[AnnotationsB]</code> and <code>[AnnotationsA]</code> are optional lists of one or more annotations;</p></li><li><p><var>N</var> (the arity of <var>B</var>) equals <var>M</var> (the arity of <var>A</var>) </p></li><li><p><code><var>R<sub>A</sub></var> ⊑ <var>R<sub>B</sub></var></code></p></li><li><p>For all values of <var>p</var> between 1 and <var>N</var>, <code><var>b<sub>p</sub></var> ⊑ <var>a<sub>p</sub></var></code><span class="xquery">, and <code>subtype-assertions(AnnotationsA, AnnotationsB)</code></span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10235"></a><a id="d3e9396"></a>Examples:</div><ul><li><p><code>function(xs:integer) as xs:string ⊆ function(xs:long) as xs:string</code></p></li><li><p><code>function(xs:integer) as xs:ID ⊆ function(xs:integer) as xs:string</code></p></li><li><p><code>function(xs:integer) as xs:ID ⊆ function(xs:long) as xs:string</code></p></li></ul></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Function return types are covariant because this rule requires <code><var>R<sub>A</sub></var> ⊑ <var>R<sub>B</sub></var></code> for return types. Function parameter types are contravariant because this rule requires <code><var>b<sub>p</sub></var> ⊑ <var>a<sub>p</sub></var></code> for parameter types.</p></div></li></ol></div><div class="div4"><h5><a id="id-item-subtype-maps"></a>3.7.2.7 Maps</h5><p><span style="display: none;" class="delete_version">Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</span><span style="display: none;" class="add_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><code>⊆</code><var>B</var> is true if any of the following apply:</span><span class="modify_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><span class="deltaxml-old"> </span><code>⊆<span class="deltaxml-old"> </span></code><var>B</var> is true if any of the following apply:</span></p><ol class="enumar"><li><p>Both of the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(<var>K</var>, <var>V</var>)</code>, for any <var>K</var> and <var>V</var></p></li><li><p><var>B</var> is <code>map(*)</code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10313"></a><a id="d3e9473"></a>Example:</div><p><code>map(xs:integer, item()*) ⊆ map(*)</code></p></div></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(<var>K<sub>a</sub></var>, <var>V<sub>a</sub></var>)</code></p></li><li><p><var>B</var> is <code>map(<var>K<sub>b</sub></var>, <var>V<sub>b</sub></var>)</code></p></li><li><p><code><var>K<sub>a</sub></var> ⊆ <var>K<sub>b</sub></var></code></p></li><li><p><code><var>V<sub>a</sub></var> ⊑ <var>V<sub>b</sub></var></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10366"></a><a id="d3e9526"></a>Example:</div><p><code>map(xs:long, item()) ⊆ map(xs:integer, item()+)</code></p></div></li><li><p>Both the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(*)</code> (or, because of the transitivity rules, any other map type)</p></li><li><p><var>B</var> is <code>function(*)</code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10389"></a><a id="d3e9549"></a>Example:</div><p><code>map(xs:long, xs:string?) ⊆ function(*)</code></p></div></li><li><p>Both the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(*)</code> (or, because of the transitivity rules, any other map type)</p></li><li><p><var>B</var> is <code>function(xs:anyAtomicType) as item()*</code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10412"></a><a id="d3e9572"></a>Example:</div><p><code>map(xs:long, xs:string?) ⊆ function(xs:anyAtomicType) as item()*</code></p></div></li><li><p><span class="deltaxml-old">All</span><span class="deltaxml-new">Both</span> the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(<var>K</var>, <var>V</var>)</code></p></li><li><p><span style="display: none;" class="delete_version"><var>B</var> is <code>function(xs:anyAtomicType) as <var>R</var></code></span><span style="display: none;" class="add_version"><var>B</var> is <code>function(xs:anyAtomicType) as <var>W</var></code>, where <var>W</var> has the same item type as <var>V</var>, but also allows an empty sequence.</span><span class="modify_version"><var>B</var> is <code>function(xs:anyAtomicType) as <var><span class="deltaxml-old">R</span><span class="deltaxml-new">W</span></var></code><span class="deltaxml-new">, where </span><var><span class="deltaxml-new">W</span></var><span class="deltaxml-new"> has the same item type as </span><var><span class="deltaxml-new">V</span></var><span class="deltaxml-new">, but also allows an empty sequence.</span></span></p></li><li class="delete_version" style="display: none;"><p><var>V</var> ⊆ <var>R</var></p></li><li class="modify_version"><p><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old"> ⊆ </span><var><span class="deltaxml-old">R</span></var></p></li><li class="delete_version" style="display: none;"><p><code>empty-sequence()</code> ⊆ <var>R</var></p></li><li class="modify_version"><p><code><span class="deltaxml-old">empty-sequence()</span></code><span class="deltaxml-old"> ⊆ </span><var><span class="deltaxml-old">R</span></var></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10457"></a><a id="d3e9607"></a>Examples:</div><ul><li><p><code>map(xs:int, node()) ⊆ function(xs:anyAtomicType) as node()?</code></p></li><li><p><code>map(xs:int, node()+) ⊆ function(xs:anyAtomicType) as node()*</code></p></li></ul><p>The function accepts type <code>xs:anyAtomicType</code> rather than <code>xs:int</code>, because <code>$M("xyz")</code> is a valid call on a map (treated as a function) even when all the keys in the map are integers.</p><p>The return type of the function is extended from <code>node()</code> or <code>node()+</code> to allow an empty sequence because <code>$M("xyz")</code> can return an empty sequence even if none of the entries in the map contains an empty sequence.</p></div></li></ol></div><div class="div4"><h5><a id="id-item-subtype-arrays"></a>3.7.2.8 Arrays</h5><p><span style="display: none;" class="delete_version">Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</span><span style="display: none;" class="add_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><code>⊆</code><var>B</var> is true if any of the following apply:</span><span class="modify_version">Given item types <var>A</var> and <var>B</var>, <var>A</var><span class="deltaxml-old"> </span><code>⊆<span class="deltaxml-old"> </span></code><var>B</var> is true if any of the following apply:</span></p><ol class="enumar"><li><p>Both the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>array(<var>X</var>)</code></p></li><li><p><var>B</var> is <code>array(*)</code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10522"></a><a id="d3e9671"></a>Example:</div><p><code>array(xs:integer) ⊆ array(*)</code></p></div></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>array(<var>X</var>)</code></p></li><li><p><var>B</var> is <code>array(<var>Y</var>)</code></p></li><li><p><code><var>X</var> ⊑ <var>Y</var></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10561"></a><a id="d3e9710"></a>Example:</div><p><code>array(xs:integer) ⊆ array(xs:decimal+)</code></p></div></li><li><p>Both the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>array(*)</code> (or, because of the transitivity rules, any other array type)</p></li><li><p><var>B</var> is <code>function(*)</code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10584"></a><a id="d3e9733"></a>Example:</div><p><code>array(xs:integer) ⊆ function(*)</code></p></div></li><li><p>Both the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>array(*)</code> (or, because of the transitivity rules, any other array type)</p></li><li><p><var>B</var> is <code>function(xs:integer) as item()*</code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10607"></a><a id="d3e9756"></a>Example:</div><p><code>array(*) ⊆ function(xs:integer) as item()*</code></p></div></li><li><p>Both the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>array(<var>X</var>)</code></p></li><li><p><var>B</var> is <code>function(xs:integer) as <var>X</var></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10636"></a><a id="d3e9785"></a>Example:</div><p><code>array(xs:string) ⊆ function(xs:integer) as xs:string</code></p></div></li></ol></div><div class="div4"><h5><a id="id-item-subtype-records"></a>3.7.2.9 Record Tests</h5><p>Given item types <var>A</var> and <var>B</var>, <var>A</var><code>⊆</code><var>B</var> is true if any of the following apply:</p><ol class="enumar"><li class="delete_version" style="display: none;"><p><var>A</var> is <code>map(*)</code> and <var>B</var> is <code>record(*)</code>.</p></li><li class="modify_version"><p><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">map(*)</span></code><span class="deltaxml-old"> and </span><var><span class="deltaxml-old">B</span></var><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">record(*)</span></code><span class="deltaxml-old">.</span></p></li><li><p>All of the following are true:</p><ol class="enumla"><li><p><span style="display: none;" class="delete_version"><var>A</var> is a record test.</span><span style="display: none;" class="add_version"><var>A</var> is a record test</span><span class="modify_version"><var>A</var> is a record test<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><var>B</var> is <code>map(*)</code> or <code>record(*)</code>.</span><span style="display: none;" class="add_version"><var>B</var> is <code>map(*)</code></span><span class="modify_version"><var>B</var> is <code>map(*)</code><span class="deltaxml-old"> or </span><span class="deltaxml-old">record(*)</span><span class="deltaxml-old">.</span></span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10685"></a><span class="deltaxml-old">Examples:</span></div><div class="exampleHeader"><a id="d3e9821"></a><span class="deltaxml-new">Example:</span></div><p><code>record(longitude, latitude)</code> ⊆ <code>map(*)</code></p><p><code><span class="deltaxml-old">record(longitude, latitude, *)</span></code><span class="deltaxml-old"> ⊆ </span><code><span class="deltaxml-old">record(*)</span></code></p><p><code><span class="deltaxml-old">record(*)</span></code><span class="deltaxml-old"> ⊆ </span><code><span class="deltaxml-old">map(*)</span></code></p></div></li><li><p>All of the following are true:</p><ol class="enumla"><li><p><var>A</var> is a non-extensible record test</p></li><li><p><var>B</var> is <code>map(<var>K</var>, <var>V</var>)</code></p></li><li><p><var>K</var> is either <code>xs:string</code> or <code>xs:anyAtomicType</code></p></li><li><p>For every field <var>F</var> in <var>A</var>, where <var>T</var> is the declared type of <var>F</var> (or its default, <code>item()*</code>), <code><var>T</var> ⊑ <var>V</var></code>.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10755"></a><a id="d3e9879"></a>Examples:</div><ul><li><p><code>record(x, y)</code> ⊆ <code>map(xs:string, item()*)</code></p></li><li><p><code>record(x as xs:double, y as xs:double)</code> ⊆ <code>map(xs:string, xs:double)</code></p></li></ul></div></li><li><p>All of the following are true:</p><ol class="enumla"><li><p><var>A</var> is a non-extensible record test.</p></li><li><p><var>B</var> is a non-extensible record test.</p></li><li><p>Every field in <var>A</var> is also declared in <var>B</var>.</p></li><li><p>Every mandatory field in <var>B</var> is also declared in <var>A</var>.</p></li><li><p>For every field that is declared in both <var>A</var> and <var>B</var>, where the declared type in <var>A</var> is <var>T</var> and the declared type in <var>B</var> is <var>U</var>, <code><var>T</var> ⊑ <var>U</var></code>.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10822"></a><a id="d3e9946"></a>Examples:</div><ul><li><p><code>record(x, y as xs:integer) ⊆ record(x, y as xs:decimal)</code></p></li><li><p><code>record(x, y) ⊆ record(x, y, z?)</code></p></li></ul></div></li><li><p>All of the following are true:</p><ol class="enumla"><li><p><var>A</var> is an extensible record test</p></li><li><p><var>B</var> is an extensible record test</p></li><li><p>Every mandatory field in <var>B</var> is also declared in <var>A</var>.</p></li><li><p>For every field that is declared in both <var>A</var> and <var>B</var>, where the declared type in <var>A</var> is <var>T</var> and the declared type in <var>B</var> is <var>U</var>, <code><var>T</var> ⊑ <var>U</var></code>.</p></li><li><p>For every field that is declared in <var>B</var> but not in <var>A</var>, the declared type in <var>B</var> is <code>item()*</code>.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10889"></a><a id="d3e10013"></a>Examples:</div><ul><li><p><code>record(x, y, z, *) ⊆ record(x, y, *)</code></p></li><li><p><code>record(x?, y?, z?, *) ⊆ record(x, y, *)</code></p></li><li><p><code>record(x as xs:integer, y as xs:integer, *) ⊆ record(x as xs:decimal, y as xs:integer*, *)</code></p></li><li><p><code>record(x as xs:integer, *) ⊆ record(x as xs:decimal, y as item(), *)</code></p></li></ul></div></li><li><p>All of the following are true:</p><ol class="enumla"><li><p><var>A</var> is a non-extensible record test.</p></li><li><p><var>B</var> is an extensible record test.</p></li><li><p>Every mandatory field in <var>B</var> is also declared in <var>A</var>.</p></li><li><p>Every field that is declared in <var>B</var> with a type other than <code>item()*</code> is also declared in <var>A</var>.</p></li><li><p>For every field that is declared in both <var>A</var> and <var>B</var>, where the declared type in <var>A</var> is <var>T</var> and the declared type in <var>B</var> is <var>U</var>, <code><var>T</var> ⊑ <var>U</var></code>.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e10964"></a><a id="d3e10088"></a>Examples:</div><ul><li><p><code>record(x, y as xs:integer) ⊆ record(x, y as xs:decimal, *)</code></p></li><li><p><code>record(y as xs:integer) ⊆ record(x?, y as xs:decimal, *)</code></p></li></ul></div></li></ol></div><div class="div4"><h5><a id="id-itemtype-subtype-aliases"></a><span class="deltaxml-old">3.7.2.10 Named Item Types</span></h5><p><span class="deltaxml-old">This section describes how references to </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-old">named item types</span></a><span class="deltaxml-old"> are handled when evaluating the subtype relationship.</span></p><p><span class="deltaxml-old">Named item types can be classified as recursive or non-recursive. A recursive type is one that references itself, directly or indirectly. Only record tests are allowed to be recursive.</span></p><p><span class="deltaxml-old">Where an item type contains a reference to a named item type that is non-recursive, the reference is expanded, recursively, as the first step in evaluating the subtype relationship. For example this means that if </span><var><span class="deltaxml-old">U</span></var><span class="deltaxml-old"> is a named item type with the expansion </span><code><span class="deltaxml-old">union(xs:integer, xs:double)</span></code><span class="deltaxml-old">, then </span><code><span class="deltaxml-old">xs:integer ⊆ U</span></code><span class="deltaxml-old"> is true, because </span><code><span class="deltaxml-old">xs:integer ⊆ union(xs:integer, xs:double)</span></code><span class="deltaxml-old"> is true.</span></p><p><span class="deltaxml-old">Recursive types are considered to be, in the terminology of the computer science literature, </span><b><span class="deltaxml-old">iso-recursive</span></b><span class="deltaxml-old"> (rather than </span><b><span class="deltaxml-old">equi-recursive</span></b><span class="deltaxml-old">). This means that a recursive type name is not treated as being equivalent to its expansion (at any depth). For example, if the named item type </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> has the expansion </span><code><span class="deltaxml-old">record(A as item()*, B as T?)</span></code><span class="deltaxml-old">, then the type </span><code><span class="deltaxml-old">array(T)</span></code><span class="deltaxml-old"> is not considered to be equivalent to </span><code><span class="deltaxml-old">array(record(A as item()*, B as T?))</span></code><span class="deltaxml-old">, despite the fact that the two types have exactly the same instances.</span></p><p><span class="deltaxml-old">The rules are therefore defined as follows:</span></p><ul><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">B</span></var><span class="deltaxml-old"> is a reference to a recursive named item type, then </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> ⊆ </span><var><span class="deltaxml-old">B</span></var><span class="deltaxml-old"> is true if and only if </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> and </span><var><span class="deltaxml-old">B</span></var><span class="deltaxml-old"> are references to the same named item type.</span></p></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is a reference to a recursive named item type, then </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> ⊆ </span><var><span class="deltaxml-old">B</span></var><span class="deltaxml-old"> is true if either:</span></p><ul><li><p><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> and </span><var><span class="deltaxml-old">B</span></var><span class="deltaxml-old"> are references to the same named item type.</span></p></li><li><p><code><span class="deltaxml-old">record(*) ⊆ B</span></code><span class="deltaxml-old">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">This is because only record tests are allowed to be recursive.</span></p></div></li></ul></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The decision to make recursive types iso-recursive rather than equi-recursive was made largely because it saves a great deal of implementation complexity without any serious adverse effects for users. In practice, problems can be avoided by using named item type references consistently (for example, avoiding having two named item types with different names but identical definitions).</span></p></div></div></div><div class="div3"><h4><a id="id-assertions-subtype"></a>3.7.3 The judgement <code>subtype-assertions(AnnotationsA, AnnotationsB)</code></h4><p> The judgement <code>subtype-assertions(AnnotationsA, AnnotationsB)</code> determines if <code>AnnotationsA</code> is a subtype of <code>AnnotationsB</code>, where <code>AnnotationsA</code> and <code>AnnotationsB</code> are annotation lists from two FunctionTests. It is defined to ignore function assertions in namespaces not understood by the XQuery implementation. For assertions that are understood, their effect on the result of <code>subtype-assertions()</code> is implementation defined. </p><p> The following examples are some possible ways to define <code>subtype-assertions()</code> for some implementation defined assertions in the <code>local</code> namespace. These examples assume that some implementation uses annotations to label functions as deterministic or nondeterministic, and treats deterministic functions as a subset of nondeterministic functions. In this implementation, nondeterministic functions are not a subset of deterministic functions. </p><ul><li><p> AnnotationsA is </p><div class="exampleInner"><pre>%local:inline</pre></div><p> It has no influence on the outcome of <code>subtype-assertions()</code>. </p></li><li><p> AnnotationsA is </p><div class="exampleInner"><pre>%local:deterministic</pre></div><p> AnnotationsB is </p><div class="exampleInner"><pre>%local:nondeterministic</pre></div><p> Since deterministic functions are a subset of nondeterministic functions, <code>subtype-assertions()</code> is true. </p></li><li><p> AnnotationsA contains </p><div class="exampleInner"><pre>%local:nondeterministic</pre></div><p> AnnotationsB is empty. If FunctionTests without the <code>%local:nondeterministic</code> annotation only match deterministic functions, <code>subtype-assertions()</code> must be false. </p></li></ul></div></div><div class="div2"><h3><a id="id-coercion-rules"></a><span class="deltaxml-old">3.8 Coercion Rules</span></h3><p><span class="deltaxml-old"> [</span><a id="dt-coercion-rules" title="coercion rules"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: The </span><b><span class="deltaxml-old">coercion rules</span></b><span class="deltaxml-old"> are rules used to convert a supplied value to a required type, for example when converting an argument of a function call to the declared type of the function parameter. ] The required type is expressed as a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-old">sequence type</span></a><span class="deltaxml-old">. The effect of the coercion rules may be to accept the value as supplied, to convert it to a value that matches the required type, or to reject it with a type error.</span></p><p><span class="deltaxml-old">This section defines how the coercion rules operate; the situations in which the rules apply are defined elsewhere, by reference to this section.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">In previous versions of this specification, the coercion rules were referred to as the </span><em><span class="deltaxml-old">function conversion</span></em><span class="deltaxml-old"> rules. The terminology has changed because the rules are not exclusively associated with functions or function calling.</span></p></div><p><span class="deltaxml-old">If the required type is </span><code><span class="deltaxml-old">empty-sequence()</span></code><span class="deltaxml-old">, no coercion takes place (the supplied value must be an empty sequence, or a type error occurs). In all other cases, the required </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-old">sequence type</span></a><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> comprises a required </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-old">item type</span></a><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> and an optional occurrence indicator.</span></p><p><span class="deltaxml-old">The coercion rules are applied to a supplied value </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old"> and the required type </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> is a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-old">generalized atomic type</span></a><span class="deltaxml-old">, then the following conversions are applied, </span><span><span class="deltaxml-old">in order</span></span><span class="deltaxml-old">:</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Enumeration types are generalized atomic types, so these rules apply.</span></p></div><ol class="enumla"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-old">Atomization</span></a><span class="deltaxml-old"> is applied to </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old">, resulting in a sequence of atomic values </span><var><span class="deltaxml-old">V</span><sub><span class="deltaxml-old">1</span></sub></var><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">Each item </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> in </span><var><span class="deltaxml-old">V</span><sub><span class="deltaxml-old">1</span></sub></var><span class="deltaxml-old"> is processed using the first rule in the following list that is applicable.</span></p><ol class="enumlr"><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is an instance of </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> then it is used unchanged.</span></p></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is an instance of type </span><code><span class="deltaxml-old">xs:untypedAtomic</span></code><span class="deltaxml-old"> then:</span></p><ol class="enumua"><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> is an </span><a title="EnumerationType" class="termref" href="#dt-EnumerationType"><span class="deltaxml-old">EnumerationType</span></a><span class="deltaxml-old"> then </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is cast to </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> is </span><a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive"><span class="deltaxml-old">namespace-sensitive</span></a><span class="deltaxml-old"> then:</span></p><ol class="enumur"><li><p><span class="deltaxml-old">If the result of casting </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> to </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> is an instance of </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old">, then </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is cast to </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">This rule is new in 4.0. It allows an </span><code><span class="deltaxml-old">xs:untypedAtomic</span></code><span class="deltaxml-old"> value to be supplied where the required type is </span><code><span class="deltaxml-old">union(xs:string, xs:QName)</span></code><span class="deltaxml-old">, which was previously an error.</span></p></div></li><li><p><span class="deltaxml-old">Otherwise, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-old">type error</span></a><span class="deltaxml-old"> [</span><a href="#ERRXPTY0117" title="err:XPTY0117"><span class="deltaxml-old">err:XPTY0117</span></a><span class="deltaxml-old">] is raised.</span></p></li></ol></li><li><p><span class="deltaxml-old">Otherwise, </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is cast to type </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old">.</span></p></li></ol></li><li><p><span class="deltaxml-old">If there is an entry (</span><var><span class="deltaxml-old">from</span></var><span class="deltaxml-old">, </span><var><span class="deltaxml-old">to</span></var><span class="deltaxml-old">) in the following table such that </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is an instance of </span><var><span class="deltaxml-old">from</span></var><span class="deltaxml-old">, and </span><var><span class="deltaxml-old">to</span></var><span class="deltaxml-old"> is </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old">, then </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is cast to type </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old">.</span></p><table style="border:1px solid" class="medium"><caption><span class="deltaxml-old">Implicit Casting</span></caption><thead><tr><th><span class="deltaxml-old">from</span></th><th><span class="deltaxml-old">to</span></th></tr></thead><tbody><tr><td><code><span class="deltaxml-old">xs:decimal</span></code></td><td><code><span class="deltaxml-old">xs:double</span></code></td></tr><tr><td><code><span class="deltaxml-old">xs:double</span></code></td><td><code><span class="deltaxml-old">xs:decimal</span></code></td></tr><tr><td><code><span class="deltaxml-old">xs:decimal</span></code></td><td><code><span class="deltaxml-old">xs:float</span></code></td></tr><tr><td><code><span class="deltaxml-old">xs:float</span></code></td><td><code><span class="deltaxml-old">xs:decimal</span></code></td></tr><tr><td><code><span class="deltaxml-old">xs:float</span></code></td><td><code><span class="deltaxml-old">xs:double</span></code></td></tr><tr><td><code><span class="deltaxml-old">xs:double</span></code></td><td><code><span class="deltaxml-old">xs:float</span></code></td></tr><tr><td><code><span class="deltaxml-old">xs:string</span></code></td><td><code><span class="deltaxml-old">xs:anyURI</span></code></td></tr><tr><td><code><span class="deltaxml-old">xs:anyURI</span></code></td><td><code><span class="deltaxml-old">xs:string</span></code></td></tr><tr><td><code><span class="deltaxml-old">xs:hexBinary</span></code></td><td><code><span class="deltaxml-old">xs:base64Binary</span></code></td></tr><tr><td><code><span class="deltaxml-old">xs:base64Binary</span></code></td><td><code><span class="deltaxml-old">xs:hexBinary</span></code></td></tr></tbody></table><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The item type in the </span><var><span class="deltaxml-old">to</span></var><span class="deltaxml-old"> column must match </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> exactly; however, </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> may belong to a subtype of the type in the </span><var><span class="deltaxml-old">from</span></var><span class="deltaxml-old"> column.</span></p><p><span class="deltaxml-old">For example, an </span><code><span class="deltaxml-old">xs:NCName</span></code><span class="deltaxml-old"> will be cast to type </span><code><span class="deltaxml-old">xs:anyURI</span></code><span class="deltaxml-old">, but an </span><code><span class="deltaxml-old">xs:anyURI</span></code><span class="deltaxml-old"> will not be cast to type </span><code><span class="deltaxml-old">xs:NCName</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">Similarly, an </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old"> will be cast to type </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old">, but an </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old"> will not be cast to type </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old">.</span></p></div></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> is derived from some primitive atomic type </span><var><span class="deltaxml-old">P</span></var><span class="deltaxml-old">, then </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is </span><b><span class="deltaxml-old">relabeled</span></b><span class="deltaxml-old"> as an instance of </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> if it satisfies all the following conditions:</span></p><ul><li><p><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is an instance of </span><var><span class="deltaxml-old">P</span></var><span class="deltaxml-old">.</span></p></li><li><p><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is not an instance of </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-datum"><span class="deltaxml-old">datum</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old"> of </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is within the value space of </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old">.</span></p></li></ul><p><span class="deltaxml-old">Relabeling an atomic value changes the </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-old">type annotation</span></a><span class="deltaxml-old"> but not the </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-datum"><span class="deltaxml-old">datum</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">. For example, the </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old"> value 3 can be relabeled as an instance of </span><code><span class="deltaxml-old">xs:unsignedByte</span></code><span class="deltaxml-old">, because the datum is within the value space of </span><code><span class="deltaxml-old">xs:unsignedByte</span></code><span class="deltaxml-old">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Relabeling is not the same as casting. For example, the </span><code><span class="deltaxml-old">xs:decimal</span></code><span class="deltaxml-old"> value 10.1 can be cast to </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old">, but it cannot be relabeled as </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old">, because its datum not within the value space of </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old">.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The effect of this rule is that if, for example, a function parameter is declared with an expected type of </span><code><span class="deltaxml-old">xs:positiveInteger</span></code><span class="deltaxml-old">, then a call that supplies the literal value 3 will succeed, whereas a call that supplies -3 will fail.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">This differs from previous versions of this specification, where both these calls would fail.</span></p><p><span class="deltaxml-old">This change allows the arguments of existing functions to be defined with a more precise type. For example, the </span><code><span class="deltaxml-old">$position</span></code><span class="deltaxml-old"> argument of </span><code><span class="deltaxml-old">array:get</span></code><span class="deltaxml-old"> can be defined as </span><code><span class="deltaxml-old">xs:positiveInteger</span></code><span class="deltaxml-old"> rather than </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old">. To enable this to be done without breaking backwards compatibility in respect of error behavior, system functions in many cases define custom error codes to be raised where relabeling of argument values fails.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Numeric promotion and </span><code><span class="deltaxml-old">xs:anyURI</span></code><span class="deltaxml-old"> promotion occur only when </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> is a primitive type (</span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">xs:float</span></code><span class="deltaxml-old">, or </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">). Relabeling occurs only when </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> is a derived type. Promotion and relabeling are therefore never combined.</span></p></div></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> is a </span><a title="pure union type" class="termref" href="#dt-pure-union-type"><span class="deltaxml-old">pure union type</span></a><span class="deltaxml-old">, then </span><var><span class="deltaxml-old">A</span></var><span class="deltaxml-old"> is </span><b><span class="deltaxml-old">relabeled</span></b><span class="deltaxml-old"> as an instance of some member type </span><var><span class="deltaxml-old">M</span></var><span class="deltaxml-old"> in the transitive membership of </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> if </span><var><span class="deltaxml-old">M</span></var><span class="deltaxml-old"> satisfies all the conditions for relabeling defined in the previous rule, and if it is the first member type in the transitive membership of </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> to satisfy those conditions.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">For example, if </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> is the type </span><code><span class="deltaxml-old">union(xs:negativeInteger, xs:positiveInteger)*</span></code><span class="deltaxml-old"> and the supplied value is the sequence </span><code><span class="deltaxml-old">(20, -20)</span></code><span class="deltaxml-old">, then the first item </span><code><span class="deltaxml-old">20</span></code><span class="deltaxml-old"> is relabeled as type </span><code><span class="deltaxml-old">xs:positiveInteger</span></code><span class="deltaxml-old"> and the second item </span><code><span class="deltaxml-old">-20</span></code><span class="deltaxml-old">is relabeled as type </span><code><span class="deltaxml-old">xs:negativeInteger</span></code><span class="deltaxml-old">.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">This rule also ensures that if the required type is </span><code><span class="deltaxml-old">enum("red", "green", "blue")</span></code><span class="deltaxml-old"> and the supplied value is </span><code><span class="deltaxml-old">"green"</span></code><span class="deltaxml-old">, then the supplied value will be accepted, and will be relabeled as an instance of </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">.</span></p></div></li></ol></li></ol></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> is a </span><a href="#doc-xquery40-RecordTest"><span class="deltaxml-old">RecordTest</span></a><span class="deltaxml-old">, then any item in </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old"> that is a map is converted to a new map as follows:</span></p><ol class="enumla"><li><p><span class="deltaxml-old">The keys in the supplied map are unchanged.</span></p></li><li><p><span class="deltaxml-old">In any map entry whose key is an </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> equal to the name of one of the field declarations in </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old">, then the corresponding value is converted to the required type defined by that field declaration, by applying the coercion rules recursively (but with XPath 1.0 compatibility mode treated as false).</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">For example, if the required type is </span><code><span class="deltaxml-old">record(longitude as xs:double, latitude as xs:double)</span></code><span class="deltaxml-old"> and the supplied value is </span><code><span class="deltaxml-old">map{"longitude": 0, "latitude":53.2}</span></code><span class="deltaxml-old">, then the map is converted to </span><code><span class="deltaxml-old">map{"longitude": 0.0e0, "latitude": 53.2e0}</span></code><span class="deltaxml-old">.</span></p></div></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> is a </span><a href="#doc-xquery40-TypedFunctionTest"><span class="deltaxml-old">TypedFunctionTest</span></a><span class="deltaxml-old">, </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-old">function coercion</span></a><span class="deltaxml-old"> is applied to each function in </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Maps and arrays are functions, so function coercion applies to them as well.</span></p></div></li><li><p><span class="deltaxml-old"> If, after the above conversions, the resulting value does not match the expected type </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old"> according to the rules for </span><a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching"><span class="deltaxml-old">SequenceType Matching</span></a><span class="deltaxml-old">, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-old">type error</span></a><span class="deltaxml-old"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-old">err:XPTY0004</span></a><span class="deltaxml-old">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Under the general rules for type errors (see </span><a href="#id-kinds-of-errors"><b><span class="deltaxml-old">2.4.1 Kinds of Errors</span></b></a><span class="deltaxml-old">), a processor </span><strong><span class="deltaxml-old">may</span></strong><span class="deltaxml-old"> report a type error during static analysis if it will necessarily occur when the expression is evaluated. For example, the function call </span><code><span class="deltaxml-old">fn:abs("beer")</span></code><span class="deltaxml-old"> will necessarily fail when evaluated, because the function requires a numeric value as its argument; this </span><strong><span class="deltaxml-old">may</span></strong><span class="deltaxml-old"> be detected and reported as a static error.</span></p></div></li></ol><div class="div3"><h4><a id="id-implausible-coercions"></a><span class="deltaxml-old">3.8.1 Implausible Coercions</span></h4><p><span class="deltaxml-old">An expression is deemed to be </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-old">implausible</span></a><span class="deltaxml-old"> [</span><a href="#ERRXPTY0006" title="err:XPTY0006"><span class="deltaxml-old">err:XPTY0006</span></a><span class="deltaxml-old">] if the static type of the expression, after applying all necessary coercions, is </span><b><span class="deltaxml-old">substantively disjoint</span></b><span class="deltaxml-old"> with the required type </span><var><span class="deltaxml-old">T</span></var><span class="deltaxml-old">. Two sequence types are considered to be substantively disjoint if (a) neither is a subtype of the other (see </span><a href="#id-seqtype-subtype"><b><span class="deltaxml-old">3.7.1 Subtypes of Sequence Types</span></b></a><span class="deltaxml-old">) and (b) the only values that are instances of both types are one or more of the following:</span></p><ul><li><p><span class="deltaxml-old">The empty sequence, </span><code><span class="deltaxml-old">()</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The empty map, </span><code><span class="deltaxml-old">map{}</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The empty array, </span><code><span class="deltaxml-old">[]</span></code><span class="deltaxml-old">.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Examples of pairs of sequence types that are substantively disjoint include:</span></p><ul><li><p><code><span class="deltaxml-old">xs:integer*</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:string*</span></code></p></li><li><p><code><span class="deltaxml-old">map(xs:integer, node())</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">map(xs:string, node())</span></code></p></li><li><p><code><span class="deltaxml-old">array(xs:integer)</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">array(xs:string)</span></code></p></li></ul></div><p><span class="deltaxml-old">For example, supplying a value whose static type is </span><code><span class="deltaxml-old">xs:integer*</span></code><span class="deltaxml-old"> when the required type is </span><code><span class="deltaxml-old">xs:string*</span></code><span class="deltaxml-old"> is </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-old">implausible</span></a><span class="deltaxml-old">, because it can succeed only in the special case where the actual value supplied is an empty sequence.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The case where the supplied type and the required type are completely disjoint (for example </span><code><span class="deltaxml-old">map(*)</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">array(*)</span></code><span class="deltaxml-old">) is covered by the general rules for type errors: that case can always be reported as a static error.</span></p></div><p><span class="deltaxml-old">Examples of implausible coercions include the following:</span></p><ul><li><p><code><span class="deltaxml-old">round(timezone-from-time($now))</span></code><span class="deltaxml-old">. The result of </span><code><span class="deltaxml-old">fn:timezone-from-time</span></code><span class="deltaxml-old"> is of type </span><code><span class="deltaxml-old">xs:dayTimeDuration?</span></code><span class="deltaxml-old">, which is substantively disjoint with the required type of </span><code><span class="deltaxml-old">fn:round</span></code><span class="deltaxml-old">, namely </span><code><span class="deltaxml-old">xs:numeric?</span></code><span class="deltaxml-old">.</span></p></li><li><p><code><span class="deltaxml-old">function($x as xs:integer) as array(xs:string) { array{1 to $x} }</span></code><span class="deltaxml-old">. The type of the function body is </span><code><span class="deltaxml-old">array(xs:integer)</span></code><span class="deltaxml-old">, which is substantively disjoint with the required type </span><code><span class="deltaxml-old">array(xs:string)</span></code><span class="deltaxml-old">: the function can succeed only in the exceptional case where the function body delivers an empty array.</span></p></li></ul></div><div class="div3"><h4><a id="id-function-coercion"></a><span class="deltaxml-old">3.8.2 Function Coercion</span></h4><p><span class="deltaxml-old"> Function coercion is a transformation applied to </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-old">function items</span></a><span class="deltaxml-old"> during application of the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-old">coercion rules</span></a><span class="deltaxml-old">. [</span><a id="dt-function-coercion" title="function coercion"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: </span><b><span class="deltaxml-old">Function coercion</span></b><span class="deltaxml-old"> wraps a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-old">function item</span></a><span class="deltaxml-old"> in a new function whose signature is the same as the expected type. This effectively delays the checking of the argument and return types until the function is called.] </span></p><p><span class="deltaxml-old">Given a function </span><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old">, and an expected function type, </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-old">function coercion</span></a><span class="deltaxml-old"> proceeds as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old"> has higher arity than the expected type, a type error is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-old">err:XPTY0004</span></a><span class="deltaxml-old">] </span></p></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old"> has lower arity than the expected type, then </span><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old"> is wrapped in a new function that declares and ignores the additional argument; the following steps are then applied to this new function.</span></p><p><span class="deltaxml-old">For example, if the expected type is </span><code><span class="deltaxml-old">function(node(), xs:boolean) as xs:string</span></code><span class="deltaxml-old">, and the supplied function is </span><code><span class="deltaxml-old">fn:name#1</span></code><span class="deltaxml-old">, then the supplied function is effectively replaced by </span><code><span class="deltaxml-old">function($n as node(), $b as xs:boolean) as xs:string {fn:name($n)}</span></code></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">This mechanism makes it easier to design versatile and extensible higher-order functions. For example, in previous versions of this specification, the second argument of the </span><code><span class="deltaxml-old">fn:filter</span></code><span class="deltaxml-old"> function expected an argument of type </span><code><span class="deltaxml-old">function(item()) as xs:boolean</span></code><span class="deltaxml-old">. This has now been extended to </span><code><span class="deltaxml-old">function(item(), xs:integer) as xs:boolean</span></code><span class="deltaxml-old">, but existing code continues to work, because callback functions that are not interested in the value of the second argument simply ignore it. </span></p></div></li><li><p><span class="deltaxml-old">Function coercion then returns a new </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-old">function item</span></a><span class="deltaxml-old"> with the following properties (as defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items"><span class="deltaxml-old">Section 2.9.4 Function Items</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">): </span></p><ul><li><p><b><span class="deltaxml-old">name</span></b><span class="deltaxml-old">: The name of </span><var><span class="deltaxml-old">F</span></var><span><span class="deltaxml-old">(if not absent)</span></span><span class="deltaxml-old">. </span></p></li><li><p><b><span class="deltaxml-old">identity</span></b><span class="deltaxml-old">: A new function identity distinct from the identity of any other function item.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">See also </span><a href="#id-function-identity"><b><span class="deltaxml-old">4.6.2.7 Function Identity</span></b></a><span class="deltaxml-old">.</span></p></div></li><li><p><b><span class="deltaxml-old">parameter names</span></b><span class="deltaxml-old">: The parameter names of </span><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old">. </span></p></li><li><p><b><span class="deltaxml-old">signature</span></b><span class="deltaxml-old">: </span><code><span class="deltaxml-old">Annotations</span></code><span class="deltaxml-old"> is set to the annotations of </span><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old">. </span><code><span class="deltaxml-old">TypedFunctionTest</span></code><span class="deltaxml-old"> is set to the expected type. </span></p></li><li><p><b><span class="deltaxml-old">implementation</span></b><span class="deltaxml-old">: In effect, a </span><code><span class="deltaxml-old">FunctionBody</span></code><span class="deltaxml-old"> that calls </span><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old">, passing it the parameters of this new function, in order. </span></p></li><li><p><b><span class="deltaxml-old">nonlocal variable bindings</span></b><span class="deltaxml-old">: An empty mapping. </span></p></li></ul></li></ol><p><span class="deltaxml-old"> If the result of invoking the new function would necessarily result in a type error, that error may be raised during </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-old">function coercion</span></a><span class="deltaxml-old">. It is implementation dependent whether this happens or not. </span></p><p><span class="deltaxml-old"> These rules have the following consequences: </span></p><ul><li><p><span class="deltaxml-old"> SequenceType matching of the function’s arguments and result are delayed until that function is called. </span></p></li><li><p><span class="deltaxml-old"> The </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-old">coercion rules</span></a><span class="deltaxml-old"> rules applied to the function’s arguments and result are defined by the SequenceType it has most recently been coerced to. Additional coercion rules could apply when the wrapped function is called. </span></p></li><li><p><span class="deltaxml-old"> If an implementation has static type information about a function, that can be used to type check the function’s argument and return types during static analysis. </span></p></li></ul><p class="xquery"><span class="deltaxml-old"> For instance, consider the following query: </span></p><div class="exampleInner"><pre><span class="deltaxml-old">declare function local:filter($s as item()*, $p as function(xs:string) as xs:boolean) as item()* { $s[$p(.)] }; let $f := function($a) { starts-with($a, "E") } return local:filter(("Ethel", "Enid", "Gertrude"), $f)</span></pre></div><p class="xquery"><span class="deltaxml-old"> The function </span><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old"> has a static type of </span><code><span class="deltaxml-old">function(item()*) as item()*</span></code><span class="deltaxml-old">. When the </span><code><span class="deltaxml-old">local:filter()</span></code><span class="deltaxml-old"> function is called, the following occurs to the function: </span></p><ol class="enumar"><li><p><span class="deltaxml-old"> The </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-old">coercion rules</span></a><span class="deltaxml-old"> result in applying </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-old">function coercion</span></a><span class="deltaxml-old"> to </span><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old">, wrapping $f in a new function (</span><code><span class="deltaxml-old">$p</span></code><span class="deltaxml-old">) with the signature </span><code><span class="deltaxml-old">function(xs:string) as xs:boolean</span></code><span class="deltaxml-old">. </span></p></li><li><p><code><span class="deltaxml-old">$p</span></code><span class="deltaxml-old"> is matched against the SequenceType of </span><code><span class="deltaxml-old">function(xs:string) as xs:boolean</span></code><span class="deltaxml-old">, and succeeds. </span></p></li><li><p><span class="deltaxml-old"> When </span><code><span class="deltaxml-old">$p</span></code><span class="deltaxml-old"> is called inside the predicate, </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-old">coercion</span></a><span class="deltaxml-old"> and SequenceType matching rules are applied to the context value argument, resulting in an </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> value or a type error. </span></p></li><li><p><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old"> is called with the </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">, which returns an </span><code><span class="deltaxml-old">xs:boolean</span></code><span class="deltaxml-old">. </span></p></li><li><p><code><span class="deltaxml-old">$p</span></code><span class="deltaxml-old"> applies </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-old">coercion rules</span></a><span class="deltaxml-old"> to the result sequence from </span><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old">, which already matches its declared return type of </span><code><span class="deltaxml-old">xs:boolean</span></code><span class="deltaxml-old">. </span></p></li><li><p><span class="deltaxml-old"> The </span><code><span class="deltaxml-old">xs:boolean</span></code><span class="deltaxml-old"> is returned as the result of </span><code><span class="deltaxml-old">$p</span></code><span class="deltaxml-old">. </span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old"> Although the semantics of </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-old">function coercion</span></a><span class="deltaxml-old"> are specified in terms of wrapping the functions, static typing will often be able to reduce the number of places where this is actually necessary. </span></p></div><p><span class="deltaxml-old">Since maps and arrays are also functions in XQuery 4.0, </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-old">function coercion</span></a><span class="deltaxml-old"> applies to them as well. For instance, consider the following expression: </span></p><div class="exampleInner"><pre><span class="deltaxml-old">let $m := map { "Monday" : true(), "Wednesday" : true(), "Friday" : true(), "Saturday" : false(), "Sunday" : false() }, $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday") return filter($days,$m)</span></pre></div><p><span class="deltaxml-old"> The map </span><code><span class="deltaxml-old">$m</span></code><span class="deltaxml-old"> has a function signature of </span><code><span class="deltaxml-old">function(xs:anyAtomicType) as item()*</span></code><span class="deltaxml-old">. When the </span><code><span class="deltaxml-old">fn:filter()</span></code><span class="deltaxml-old"> function is called, the following occurs to the map: </span></p><ol class="enumar"><li><p><span class="deltaxml-old">The map </span><code><span class="deltaxml-old">$m</span></code><span class="deltaxml-old"> is treated as </span><code><span class="deltaxml-old">function($f)</span></code><span class="deltaxml-old">, equivalent to </span><code><span class="deltaxml-old">map:get($m,?)</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-old">coercion rules</span></a><span class="deltaxml-old"> result in applying </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-old">function coercion</span></a><span class="deltaxml-old"> to </span><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old">, wrapping </span><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old"> in a new function (</span><code><span class="deltaxml-old">$p</span></code><span class="deltaxml-old">) with the signature </span><code><span class="deltaxml-old">function(item()) as xs:boolean</span></code><span class="deltaxml-old">.</span></p></li><li><p><code><span class="deltaxml-old">$p</span></code><span class="deltaxml-old"> is matched against the SequenceType </span><code><span class="deltaxml-old">function(item()) as xs:boolean</span></code><span class="deltaxml-old">, and succeeds.</span></p></li><li><p><span class="deltaxml-old">When </span><code><span class="deltaxml-old">$p</span></code><span class="deltaxml-old"> is called by </span><code><span class="deltaxml-old">fn:filter()</span></code><span class="deltaxml-old">, </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-old">coercion</span></a><span class="deltaxml-old"> and SequenceType matching rules are applied to the argument, resulting in an </span><code><span class="deltaxml-old">item()</span></code><span class="deltaxml-old"> value (</span><code><span class="deltaxml-old">$a</span></code><span class="deltaxml-old">) or a type error.</span></p></li><li><p><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old"> is called with </span><code><span class="deltaxml-old">$a</span></code><span class="deltaxml-old">, which returns an </span><code><span class="deltaxml-old">xs:boolean</span></code><span class="deltaxml-old"> or the empty sequence.</span></p></li><li><p><code><span class="deltaxml-old">$p</span></code><span class="deltaxml-old"> applies </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-old">coercion rule</span></a><span class="deltaxml-old"> and SequenceType matching to the result sequence from </span><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old">. When the result is an </span><code><span class="deltaxml-old">xs:boolean</span></code><span class="deltaxml-old"> the SequenceType matching succeeds. When it is an empty sequence (such as when </span><code><span class="deltaxml-old">$m</span></code><span class="deltaxml-old"> does not contain a key for </span><code><span class="deltaxml-old">"Tuesday"</span></code><span class="deltaxml-old">), SequenceType matching results in a type error [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-old">err:XPTY0004</span></a><span class="deltaxml-old">], since the expected type is </span><code><span class="deltaxml-old">xs:boolean</span></code><span class="deltaxml-old"> and the actual type is an empty sequence.</span></p></li></ol><p><span class="deltaxml-old">Consider the following expression: </span></p><div class="exampleInner"><pre><span class="deltaxml-old">let $m := map { "Monday" : true(), "Tuesday" : false(), "Wednesday" : true(), "Thursday" : false(), "Friday" : true(), "Saturday" : false(), "Sunday" : false() } let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday") return filter($days,$m)</span></pre></div><p><span class="deltaxml-old">The result of the expression is the sequence </span><code><span class="deltaxml-old">("Monday", "Wednesday", "Friday")</span></code></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Function coercion applies even if the supplied function matches the required type.</span></p><p><span class="deltaxml-old">For example, consider this case:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">declare function local:filter($s as item()*, $p as function(xs:string) as xs:boolean) as item()* { $s[$p(.)] }; let $f := function($a) { $a mod 2 = 0 } return local:filter(1 to 10, $f)</span></pre></div><p><span class="deltaxml-old">Here the supplied function </span><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old"> is an instance of the required type, because its signature defaults the argument type to </span><code><span class="deltaxml-old">item()*</span></code><span class="deltaxml-old">, which is a supertype of </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">. The expression </span><code><span class="deltaxml-old">$s[$p(.)]</span></code><span class="deltaxml-old"> could in principle succeed. However, function coercion ensures that the supplied function is wrapped in a function that requires the argument to be of type </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">, so the call fails with a type error when the wrapping function is invoked supplying an </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old"> as the argument.</span></p><p class="xquery"><span class="deltaxml-old">This has the consequence that in XQuery 4.0, there is a backwards incompatibility introduced because coercion rules now apply to global variable declarations (</span><code><span class="deltaxml-old">declare variable</span></code><span class="deltaxml-old">) and local variable bindings (for example </span><code><span class="deltaxml-old">let</span></code><span class="deltaxml-old"> clauses). Previously the following would execute without error:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">let $f as function(xs:integer) as item()* := function($x){$x+1} return $f(12.3)</span></pre></div><p class="xquery"><span class="deltaxml-old">With XQuery 4.0, as a consequence of function coercion, this fails with a type error because the argument supplied in the function call is not of type </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old">.</span></p></div></div></div></div><div class="div1"><h2><a id="id-expressions"></a>4 Expressions</h2><p>This section discusses each of the basic kinds of expression. Each kind of expression has a name such as <code>PathExpr</code>, which is introduced on the left side of the grammar production that defines the expression. Since XQuery 4.0 is a composable language, each kind of expression is defined in terms of other expressions whose operators have a higher precedence. In this way, the precedence of operators is represented explicitly in the grammar.</p><p>The order in which expressions are discussed in this document does not reflect the order of operator precedence. In general, this document introduces the simplest kinds of expressions first, followed by more complex expressions. For the complete grammar, see Appendix [<a href="#nt-bnf"><b>A XQuery 4.0 Grammar</b></a>].</p><p><span class="xquery"> [<a id="dt-query" title="query">Definition</a>: A <b>query</b> consists of one or more <a title="module" class="termref" href="#dt-module">modules</a>.] If a query is executable, one of its modules has a <a title="query body" class="termref" href="#dt-queryBody">Query Body</a> containing an expression whose value is the result of the query. An expression is represented in the XQuery grammar by the symbol <a href="#doc-xquery40-Expr">Expr</a>.</span></p><a id="d3e12095"></a><a id="d3e10186"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Expr"></a>[<span class="deltaxml-old">45</span><span class="deltaxml-new">44</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Expr">Expr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ExprSingle">ExprSingle</a> ("," <a href="#doc-xquery40-ExprSingle">ExprSingle</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ExprSingle"></a>[<span class="deltaxml-old">46</span><span class="deltaxml-new">45</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-WithExpr">WithExpr</a><br>| <a href="#doc-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a><br>| <a href="#doc-xquery40-OrExpr">OrExpr</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-WithExpr">WithExpr</a><br>| <a href="#doc-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-WithExpr">WithExpr</a><br>| <a href="#doc-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a><span class="deltaxml-old">| </span><a href="#doc-xquery40-OrExpr"><span class="deltaxml-old">OrExpr</span></a></code></span></td><td></td></tr></tbody></table><p>The XQuery 4.0 operator that has lowest precedence is the <a title="comma operator" class="termref" href="#dt-comma-operator">comma operator</a>, which is used to combine two operands to form a sequence. As shown in the grammar, a general expression (<a href="#doc-xquery40-Expr">Expr</a>) can consist of multiple <a href="#doc-xquery40-ExprSingle">ExprSingle</a> operands, separated by commas. The name <a href="#doc-xquery40-ExprSingle">ExprSingle</a> denotes an expression that does not contain a top-level <a title="comma operator" class="termref" href="#dt-comma-operator">comma operator</a> (despite its name, an <a href="#doc-xquery40-ExprSingle">ExprSingle</a> may evaluate to a sequence containing more than one item.)</p><p>The symbol <a href="#doc-xquery40-ExprSingle">ExprSingle</a> is used in various places in the grammar where an expression is not allowed to contain a top-level comma. For example, each of the arguments of a function call must be an <a href="#doc-xquery40-ExprSingle">ExprSingle</a>, because commas are used to separate the arguments of a function call.</p><p>After the comma, the expressions that have next lowest precedence are <span class="xquery"><a href="#doc-xquery40-FLWORExpr">FLWORExpr</a>,</span><a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a>, <span class="xquery"><a href="#doc-xquery40-SwitchExpr">SwitchExpr</a>, <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a>, </span><a href="#doc-xquery40-IfExpr">IfExpr</a>, <span class="xquery"><a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a>, </span> and <a href="#doc-xquery40-OrExpr">OrExpr</a>. Each of these expressions is described in a separate section of this document.</p><div class="div2"><h3><a id="with-expressions"></a>4.1 Setting Namespace Context</h3><a id="d3e12215"></a><a id="d3e10301"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-WithExpr"></a>[<span class="deltaxml-old">47</span><span class="deltaxml-new">46</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-WithExpr">WithExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"with" <a href="#doc-xquery40-NamespaceDeclaration">NamespaceDeclaration</a> ("," <a href="#doc-xquery40-NamespaceDeclaration">NamespaceDeclaration</a>)* <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NamespaceDeclaration"></a>[<span class="deltaxml-old">48</span><span class="deltaxml-new">47</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NamespaceDeclaration">NamespaceDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-QName">QName</a> "=" <a href="#doc-xquery40-URILiteral">URILiteral</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e11475.doc-xquery40-URILiteral"></a><a id="noid_d4e9619.doc-xquery40-URILiteral"></a>[<span class="deltaxml-old">265</span><span class="deltaxml-new">251</span>]&nbsp;&nbsp;&nbsp;</td><td><code>URILiteral</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-StringLiteral">StringLiteral</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e11476.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e9620.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p>The namespace context for an expression can be set using a construct of the form:</p><div class="exampleInner"><pre>with xmlns="http://example.com/, xmlns:a="http://example.com/a" { /doc/a:element/b }</pre></div><p>The static context for the enclosed expression will be the same as the static context for the <a href="#doc-xquery40-WithExpr">WithExpr</a> itself, except for modifications defined below.</p><p>The <code>QName</code> used in a <a href="#doc-xquery40-NamespaceDeclaration">NamespaceDeclaration</a> must be either <code>xmlns</code> or <code>xmlns:prefix</code> where <code>prefix</code> is some <code>NCName</code>.</p><p>If more than one <a href="#doc-xquery40-NamespaceDeclaration">NamespaceDeclaration</a> specifies the same <code>QName</code>, all but the last of the duplicates are ignored.</p><p>If the QName is <code>"xmlns"</code> then:</p><ul><li><p>If the <code>URILiteral</code> is a zero-length string:</p><ul><li><p><span style="display: none;" class="delete_version">The <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> is set to <em>absent</em>, meaning that unprefixed element names are treated as being in no namespace.</span><span style="display: none;" class="add_version">The <a class="termref" title="default element namespace" href="#dt-def-element-ns">default element namespace</a> is set to <em>absent</em>, meaning that unprefixed element names are treated as being in no namespace.</span><span class="modify_version">The <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><a class="termref" title="default element namespace" href="#dt-def-element-ns"><span class="deltaxml-new">default element namespace</span></a> is set to <em>absent</em>, meaning that unprefixed element names are treated as being in no namespace.</span></p><p><span class="deltaxml-old">TODO: reconcile this with the "fixed" setting in the XQuery prolog.</span></p></li><li><p>Any binding for the zero-length prefix in the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> is removed.</p></li></ul></li><li><p>If the <code>URILiteral</code> is not zero-length:</p><ul><li><p>The <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><a class="termref" title="default element namespace" href="#dt-def-element-ns"><span class="deltaxml-new">default element namespace</span></a> is set to the supplied namespace URI, meaning that unprefixed element names are treated as being in that namespace.</p><p><span class="deltaxml-old">TODO: reconcile this with the "fixed" setting in the XQuery prolog.</span></p></li><li><p>A binding that maps the zero-length prefix to the specified namespace URI is added to the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>.</p></li></ul></li></ul><p>If the QName is in the form <code>xmlns:prefix</code> then the <code>URILiteral</code> must not be zero-length; the effect is that a binding that maps the given <code>prefix</code> to the specified namespace URI is added to the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>.</p><p>For example, the expression:</p><div class="exampleInner"><pre>with xmlns="http://www.acme.com/" {a/b[c=3]}</pre></div><p>is equivalent to the expression:</p><div class="exampleInner"><pre>Q{http://www.acme.com/}a/Q{http://www.acme.com/}b[Q{http://www.acme.com/}c=3]</pre></div></div><div class="div2"><h3><a id="comments"></a>4.2 Comments</h3><a id="d3e12348"></a><a id="d3e10432"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Comment"></a>[<span class="deltaxml-old">283</span><span class="deltaxml-new">267</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Comment">Comment</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(:" (<a href="#doc-xquery40-CommentContents">CommentContents</a> | <a href="#doc-xquery40-Comment">Comment</a>)* ":)"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr><tr style="vertical-align:baseline;"><td></td><td></td><td></td><td></td><td><i>/* <a href="#parse-note-comments">gn: comments</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CommentContents"></a>[<span class="deltaxml-old">296</span><span class="deltaxml-new">275</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CommentContents">CommentContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a>+ - (Char* ('(:' | ':)') Char*))</code></td><td></td></tr></tbody></table><p>Comments may be used to provide information relevant to programmers who read <span class="xquery">a query, either in the <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> or in the <a title="query body" class="termref" href="#dt-queryBody">Query Body</a></span> . Comments are lexical constructs only, and do not affect <span class="xquery">query</span> processing.</p><p>Comments are strings, delimited by the symbols <code>(:</code> and <code>:)</code>. Comments may be nested.</p><p>A comment may be used anywhere <a title="ignorable whitespace" class="termref" href="#IgnorableWhitespace">ignorable whitespace</a> is allowed (see <a href="#DefaultWhitespaceHandling"><span style="display: none;" class="delete_version"><b>A.3.5.1 Default Whitespace Handling</b></span><span style="display: none;" class="add_version"><b>A.2.4.1 Default Whitespace Handling</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">3.5.1</span><span class="deltaxml-new">2.4.1</span> Default Whitespace Handling</b></span></a>).</p><p>The following is an example of a comment:</p><div class="exampleInner"><pre>(: Houston, we have a problem :)</pre></div></div><div class="div2"><h3><a id="id-primary-expressions"></a>4.3 Primary Expressions</h3><p><span style="display: none;" class="delete_version"> [<a id="dt-primary-expression" title="primary expression">Definition</a>: <b>Primary expressions</b> are the basic primitives of the language. They include literals, variable references, context value references, <span class="xquery">constructors, </span> and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.] <span class="xquery">Node Constructors are described in <a href="#id-constructors"><span class="delete_version"><b>4.13 Node Constructors</b></span><span class="modify_version"><b>4.13 Node Constructors</b></span></a>.</span>Map and Array Constructors are described in <a href="#id-maps-and-arrays"><span class="delete_version"><b>4.14 Maps and Arrays</b></span><span class="modify_version"><b>4.14 Maps and Arrays</b></span></a>. <span class="xquery">String Constructors are described in <a href="#id-string-constructors"><span class="delete_version"><b>4.10.3 String Constructors</b></span><span class="modify_version"><b>4.10.3 String Constructors</b></span></a>.</span></span><span style="display: none;" class="add_version"> [<a id="dt-primary-expression" title="primary expression">Definition</a>: <b>Primary expressions</b> are the basic primitives of the language. They include literals, variable references, context item expressions, <span class="xquery">constructors, </span> and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.] <span class="xquery">Node Constructors are described in <a href="#id-constructors"><span class="add_version"><b>4.12 Node Constructors</b></span><span class="modify_version"><b>4.12 Node Constructors</b></span></a>.</span>Map and Array Constructors are described in <a href="#id-maps-and-arrays"><span class="add_version"><b>4.13 Maps and Arrays</b></span><span class="modify_version"><b>4.13 Maps and Arrays</b></span></a>. <span class="xquery">String Constructors are described in <a href="#id-string-constructors"><span class="add_version"><b>4.9.3 String Constructors</b></span><span class="modify_version"><b>4.9.3 String Constructors</b></span></a>.</span></span><span class="modify_version"> [<a id="dt-primary-expression" title="primary expression">Definition</a>: <b>Primary expressions</b> are the basic primitives of the language. They include literals, variable references, context <span class="deltaxml-old">value references</span><span class="deltaxml-new">item expressions</span>, <span class="xquery">constructors, </span> and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.] <span class="xquery">Node Constructors are described in <a href="#id-constructors"><span style="display: none;" class="delete_version"><b>4.13 Node Constructors</b></span><span style="display: none;" class="add_version"><b>4.12 Node Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13</span><span class="deltaxml-new">4.12</span> Node Constructors</b></span></a>.</span>Map and Array Constructors are described in <a href="#id-maps-and-arrays"><span style="display: none;" class="delete_version"><b>4.14 Maps and Arrays</b></span><span style="display: none;" class="add_version"><b>4.13 Maps and Arrays</b></span><span class="modify_version"><b><span class="deltaxml-old">4.14</span><span class="deltaxml-new">4.13</span> Maps and Arrays</b></span></a>. <span class="xquery">String Constructors are described in <a href="#id-string-constructors"><span style="display: none;" class="delete_version"><b>4.10.3 String Constructors</b></span><span style="display: none;" class="add_version"><b>4.9.3 String Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.10.3</span><span class="deltaxml-new">4.9.3</span> String Constructors</b></span></a>.</span></span></p><a id="d3e12431"></a><a id="d3e10515"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr"></a>[<span class="deltaxml-old">166</span><span class="deltaxml-new">153</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-PrimaryExpr">PrimaryExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-Literal">Literal</a><br>| <a href="#doc-xquery40-VarRef">VarRef</a><br>| <a href="#doc-xquery40-ParenthesizedExpr">ParenthesizedExpr</a><br>| <a href="#doc-xquery40-ContextValueRef">ContextValueRef</a><br>| <a href="#doc-xquery40-FunctionCall">FunctionCall</a><br>| <a href="#doc-xquery40-OrderedExpr">OrderedExpr</a><br>| <a href="#doc-xquery40-UnorderedExpr">UnorderedExpr</a><br>| <a href="#doc-xquery40-NodeConstructor">NodeConstructor</a><br>| <a href="#doc-xquery40-FunctionItemExpr">FunctionItemExpr</a><br>| <a href="#doc-xquery40-MapConstructor">MapConstructor</a><br>| <a href="#doc-xquery40-ArrayConstructor">ArrayConstructor</a><br>| <a href="#doc-xquery40-StringTemplate">StringTemplate</a><br>| <a href="#doc-xquery40-StringConstructor">StringConstructor</a><br>| <a href="#doc-xquery40-UnaryLookup">UnaryLookup</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-Literal">Literal</a><br>| <a href="#doc-xquery40-VarRef">VarRef</a><br>| <a href="#doc-xquery40-ParenthesizedExpr">ParenthesizedExpr</a><br>| <a href="#doc-xquery40-ContextItemExpr">ContextItemExpr</a><br>| <a href="#doc-xquery40-FunctionCall">FunctionCall</a><br>| <a href="#doc-xquery40-OrderedExpr">OrderedExpr</a><br>| <a href="#doc-xquery40-UnorderedExpr">UnorderedExpr</a><br>| <a href="#doc-xquery40-NodeConstructor">NodeConstructor</a><br>| <a href="#doc-xquery40-FunctionItemExpr">FunctionItemExpr</a><br>| <a href="#doc-xquery40-MapConstructor">MapConstructor</a><br>| <a href="#doc-xquery40-ArrayConstructor">ArrayConstructor</a><br>| <a href="#doc-xquery40-StringTemplate">StringTemplate</a><br>| <a href="#doc-xquery40-StringConstructor">StringConstructor</a><br>| <a href="#doc-xquery40-UnaryLookup">UnaryLookup</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-Literal">Literal</a><br>| <a href="#doc-xquery40-VarRef">VarRef</a><br>| <a href="#doc-xquery40-ParenthesizedExpr">ParenthesizedExpr</a><br>| <a href="#doc-xquery40-ContextValueRef"><span class="deltaxml-old">ContextValueRef</span></a><a href="#doc-xquery40-ContextItemExpr"><span class="deltaxml-new">ContextItemExpr</span></a><br>| <a href="#doc-xquery40-FunctionCall">FunctionCall</a><br>| <a href="#doc-xquery40-OrderedExpr">OrderedExpr</a><br>| <a href="#doc-xquery40-UnorderedExpr">UnorderedExpr</a><br>| <a href="#doc-xquery40-NodeConstructor">NodeConstructor</a><br>| <a href="#doc-xquery40-FunctionItemExpr">FunctionItemExpr</a><br>| <a href="#doc-xquery40-MapConstructor">MapConstructor</a><br>| <a href="#doc-xquery40-ArrayConstructor">ArrayConstructor</a><br>| <a href="#doc-xquery40-StringTemplate">StringTemplate</a><br>| <a href="#doc-xquery40-StringConstructor">StringConstructor</a><br>| <a href="#doc-xquery40-UnaryLookup">UnaryLookup</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionItemExpr"></a>[<span class="deltaxml-old">205</span><span class="deltaxml-new">192</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-FunctionItemExpr">FunctionItemExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-NamedFunctionRef">NamedFunctionRef</a> | <a href="#doc-xquery40-InlineFunctionExpr">InlineFunctionExpr</a></code></td><td></td></tr></tbody></table><div class="div3"><h4><a id="id-literals"></a>4.3.1 Literals</h4><a id="d3e12523"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Literal"></a><span class="deltaxml-old">[167]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-Literal"><span class="deltaxml-old">Literal</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-NumericLiteral"><span class="deltaxml-old">NumericLiteral</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a></code></td><td></td></tr></tbody></table><p> [<a id="dt-literal" title="literal">Definition</a>: A <b>literal</b> is a direct syntactic representation of an atomic value.] XQuery 4.0 supports two kinds of literals: numeric literals and string literals.</p><a id="d3e10614"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Literal"></a><span class="deltaxml-new">[154]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-Literal"><span class="deltaxml-new">Literal</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-NumericLiteral"><span class="deltaxml-new">NumericLiteral</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-StringLiteral"><span class="deltaxml-new">StringLiteral</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NumericLiteral"></a><span class="deltaxml-new">[155]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-NumericLiteral"><span class="deltaxml-new">NumericLiteral</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-IntegerLiteral"><span class="deltaxml-new">IntegerLiteral</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-HexIntegerLiteral"><span class="deltaxml-new">HexIntegerLiteral</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-BinaryIntegerLiteral"><span class="deltaxml-new">BinaryIntegerLiteral</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-DecimalLiteral"><span class="deltaxml-new">DecimalLiteral</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-DoubleLiteral"><span class="deltaxml-new">DoubleLiteral</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-IntegerLiteral"></a><span class="deltaxml-new">[253]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-IntegerLiteral"><span class="deltaxml-new">IntegerLiteral</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-Digits"><span class="deltaxml-new">Digits</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-HexIntegerLiteral"></a><span class="deltaxml-new">[254]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-HexIntegerLiteral"><span class="deltaxml-new">HexIntegerLiteral</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">"0x" </span><a href="#doc-xquery40-HexDigits"><span class="deltaxml-new">HexDigits</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-BinaryIntegerLiteral"></a><span class="deltaxml-new">[255]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-BinaryIntegerLiteral"><span class="deltaxml-new">BinaryIntegerLiteral</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">"0b" </span><a href="#doc-xquery40-BinaryDigits"><span class="deltaxml-new">BinaryDigits</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DecimalLiteral"></a><span class="deltaxml-new">[256]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-DecimalLiteral"><span class="deltaxml-new">DecimalLiteral</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">("." </span><a href="#doc-xquery40-Digits"><span class="deltaxml-new">Digits</span></a><span class="deltaxml-new">) | (</span><a href="#doc-xquery40-Digits"><span class="deltaxml-new">Digits</span></a><span class="deltaxml-new"> "." [0-9]*)</span></code></td><td><i><span class="deltaxml-new">/* </span><a href="#ws-explicit"><span class="deltaxml-new">ws: explicit</span></a><span class="deltaxml-new"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DoubleLiteral"></a><span class="deltaxml-new">[257]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-DoubleLiteral"><span class="deltaxml-new">DoubleLiteral</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">(("." </span><a href="#doc-xquery40-Digits"><span class="deltaxml-new">Digits</span></a><span class="deltaxml-new">) | (</span><a href="#doc-xquery40-Digits"><span class="deltaxml-new">Digits</span></a><span class="deltaxml-new"> ("." [0-9]*)?)) [eE] [+-]? </span><a href="#doc-xquery40-Digits"><span class="deltaxml-new">Digits</span></a></code></td><td><i><span class="deltaxml-new">/* </span><a href="#ws-explicit"><span class="deltaxml-new">ws: explicit</span></a><span class="deltaxml-new"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringLiteral"></a><span class="deltaxml-new">[258]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-StringLiteral"><span class="deltaxml-new">StringLiteral</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">('"' (</span><a href="#doc-xquery40-PredefinedEntityRef"><span class="deltaxml-new">PredefinedEntityRef</span></a><span class="deltaxml-new"> | </span><a href="#prod-xquery40-CharRef"><span class="deltaxml-new">CharRef</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-EscapeQuot"><span class="deltaxml-new">EscapeQuot</span></a><span class="deltaxml-new"> | [^"&amp;])* '"') | ("'" (</span><a href="#doc-xquery40-PredefinedEntityRef"><span class="deltaxml-new">PredefinedEntityRef</span></a><span class="deltaxml-new"> | </span><a href="#prod-xquery40-CharRef"><span class="deltaxml-new">CharRef</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-EscapeApos"><span class="deltaxml-new">EscapeApos</span></a><span class="deltaxml-new"> | [^'&amp;])* "'")</span></code></td><td><i><span class="deltaxml-new">/* </span><a href="#ws-explicit"><span class="deltaxml-new">ws: explicit</span></a><span class="deltaxml-new"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PredefinedEntityRef"></a><span class="deltaxml-new">[261]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-PredefinedEntityRef"><span class="deltaxml-new">PredefinedEntityRef</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">"&amp;" ("lt" | "gt" | "amp" | "quot" | "apos") ";"</span></code></td><td><i><span class="deltaxml-new">/* </span><a href="#ws-explicit"><span class="deltaxml-new">ws: explicit</span></a><span class="deltaxml-new"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-EscapeQuot"></a><span class="deltaxml-new">[262]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-EscapeQuot"><span class="deltaxml-new">EscapeQuot</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">'""'</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-EscapeApos"></a><span class="deltaxml-new">[263]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-EscapeApos"><span class="deltaxml-new">EscapeApos</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">"''"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Digits"></a><span class="deltaxml-new">[274]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-Digits"><span class="deltaxml-new">Digits</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">[0-9]+ [0-9_]*</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-HexDigits"></a><span class="deltaxml-new">[276]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-HexDigits"><span class="deltaxml-new">HexDigits</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">[0-9a-fA-F_]+</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-BinaryDigits"></a><span class="deltaxml-new">[277]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-BinaryDigits"><span class="deltaxml-new">BinaryDigits</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">[01_]+</span></code></td><td></td></tr></tbody></table><p><span class="deltaxml-new">The value of a numeric literal is determined as follows (taking the rules in order):</span></p><ol class="enumar"><li><p><span class="deltaxml-new">Underscore characters are stripped out. Underscores may be included in a numeric literal to aid readability, but have no effect on the value. For example, </span><code><span class="deltaxml-new">1_000_000</span></code><span class="deltaxml-new"> is equivalent to </span><code><span class="deltaxml-new">1000000</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">A </span><code><span class="deltaxml-new">HexIntegerLiteral</span></code><span class="deltaxml-new"> represents a non-negative integer expressed in hexadecimal: for example </span><code><span class="deltaxml-new">0xffff</span></code><span class="deltaxml-new"> represents the integer 65535, and </span><code><span class="deltaxml-new">0xFFFF_FFFF</span></code><span class="deltaxml-new"> represents the integer 4294967295.</span></p></li><li><p><span class="deltaxml-new">A </span><code><span class="deltaxml-new">BinaryIntegerLiteral</span></code><span class="deltaxml-new"> represents a non-negative integer expressed in binary: for example </span><code><span class="deltaxml-new">0b101</span></code><span class="deltaxml-new"> represents the integer 5, and </span><code><span class="deltaxml-new">0b1111_1111</span></code><span class="deltaxml-new"> represents the integer 255.</span></p></li><li><p><span class="deltaxml-new">The value of a </span><b><span class="deltaxml-new">numeric literal</span></b><span class="deltaxml-new"> containing no "</span><code><span class="deltaxml-new">.</span></code><span class="deltaxml-new">" and no </span><code><span class="deltaxml-new">e</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">E</span></code><span class="deltaxml-new"> character is an atomic value of type </span><code><span class="deltaxml-new">xs:integer</span></code><span class="deltaxml-new">; the value is obtained by casting from </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> to </span><code><span class="deltaxml-new">xs:integer</span></code><span class="deltaxml-new"> as specified in </span><a href="https://www.w3.org/TR/xpath-functions-31/#casting-from-strings"><span class="deltaxml-new">Section 19.2 Casting from xs:string and xs:untypedAtomic </span></a><sup><small><span class="deltaxml-new">FO31</span></small></sup><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">The value of a numeric literal containing "</span><code><span class="deltaxml-new">.</span></code><span class="deltaxml-new">" but no </span><code><span class="deltaxml-new">e</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">E</span></code><span class="deltaxml-new"> character is an atomic value of type </span><code><span class="deltaxml-new">xs:decimal</span></code><span class="deltaxml-new">; the value is obtained by casting from </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> to </span><code><span class="deltaxml-new">xs:decimal</span></code><span class="deltaxml-new"> as specified in </span><a href="https://www.w3.org/TR/xpath-functions-31/#casting-from-strings"><span class="deltaxml-new">Section 19.2 Casting from xs:string and xs:untypedAtomic </span></a><sup><small><span class="deltaxml-new">FO31</span></small></sup><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">The value of a numeric literal containing an </span><code><span class="deltaxml-new">e</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">E</span></code><span class="deltaxml-new"> character is an atomic value of type </span><code><span class="deltaxml-new">xs:double</span></code><span class="deltaxml-new">; the value is obtained by casting from </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> to </span><code><span class="deltaxml-new">xs:double</span></code><span class="deltaxml-new"> as specified in </span><a href="https://www.w3.org/TR/xpath-functions-31/#casting-from-strings"><span class="deltaxml-new">Section 19.2 Casting from xs:string and xs:untypedAtomic </span></a><sup><small><span class="deltaxml-new">FO31</span></small></sup><span class="deltaxml-new">.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">The value of a numeric literal is always non-negative. An expression may appear to include a negative number such as </span><code><span class="deltaxml-new">-1</span></code><span class="deltaxml-new">, but this is technically an arithmetic expression comprising a unary minus operator followed by a numeric literal.</span></p></div><div class="note"><h5><a id="id-numeric-literals"></a><span class="deltaxml-old">4.3.1.1 Numeric Literals</span></h5><a id="d3e12544"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NumericLiteral"></a><span class="deltaxml-old">[168]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-NumericLiteral"><span class="deltaxml-old">NumericLiteral</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-IntegerLiteral"><span class="deltaxml-old">IntegerLiteral</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-HexIntegerLiteral"><span class="deltaxml-old">HexIntegerLiteral</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-BinaryIntegerLiteral"><span class="deltaxml-old">BinaryIntegerLiteral</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-DecimalLiteral"><span class="deltaxml-old">DecimalLiteral</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-DoubleLiteral"><span class="deltaxml-old">DoubleLiteral</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-IntegerLiteral"></a><span class="deltaxml-old">[267]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-IntegerLiteral"><span class="deltaxml-old">IntegerLiteral</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-Digits"><span class="deltaxml-old">Digits</span></a></code></td><td><i><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-HexIntegerLiteral"></a><span class="deltaxml-old">[268]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-HexIntegerLiteral"><span class="deltaxml-old">HexIntegerLiteral</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"0x" </span><a href="#doc-xquery40-HexDigits"><span class="deltaxml-old">HexDigits</span></a></code></td><td><i><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-BinaryIntegerLiteral"></a><span class="deltaxml-old">[269]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-BinaryIntegerLiteral"><span class="deltaxml-old">BinaryIntegerLiteral</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"0b" </span><a href="#doc-xquery40-BinaryDigits"><span class="deltaxml-old">BinaryDigits</span></a></code></td><td><i><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DecimalLiteral"></a><span class="deltaxml-old">[270]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-DecimalLiteral"><span class="deltaxml-old">DecimalLiteral</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">("." </span><a href="#doc-xquery40-Digits"><span class="deltaxml-old">Digits</span></a><span class="deltaxml-old">) | (</span><a href="#doc-xquery40-Digits"><span class="deltaxml-old">Digits</span></a><span class="deltaxml-old"> "." </span><a href="#doc-xquery40-Digits"><span class="deltaxml-old">Digits</span></a><span class="deltaxml-old">?)</span></code></td><td><i><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DoubleLiteral"></a><span class="deltaxml-old">[271]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-DoubleLiteral"><span class="deltaxml-old">DoubleLiteral</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">(("." </span><a href="#doc-xquery40-Digits"><span class="deltaxml-old">Digits</span></a><span class="deltaxml-old">) | (</span><a href="#doc-xquery40-Digits"><span class="deltaxml-old">Digits</span></a><span class="deltaxml-old"> ("." </span><a href="#doc-xquery40-Digits"><span class="deltaxml-old">Digits</span></a><span class="deltaxml-old">?)?)) [eE] [+-]? </span><a href="#doc-xquery40-Digits"><span class="deltaxml-old">Digits</span></a></code></td><td><i><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Digits"></a><span class="deltaxml-old">[290]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-Digits"><span class="deltaxml-old">Digits</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-DecDigit"><span class="deltaxml-old">DecDigit</span></a><span class="deltaxml-old"> ((</span><a href="#doc-xquery40-DecDigit"><span class="deltaxml-old">DecDigit</span></a><span class="deltaxml-old"> | "_")* </span><a href="#doc-xquery40-DecDigit"><span class="deltaxml-old">DecDigit</span></a><span class="deltaxml-old">)?</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DecDigit"></a><span class="deltaxml-old">[291]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-DecDigit"><span class="deltaxml-old">DecDigit</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">[0-9]</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-HexDigits"></a><span class="deltaxml-old">[292]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-HexDigits"><span class="deltaxml-old">HexDigits</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-HexDigit"><span class="deltaxml-old">HexDigit</span></a><span class="deltaxml-old"> ((</span><a href="#doc-xquery40-HexDigit"><span class="deltaxml-old">HexDigit</span></a><span class="deltaxml-old"> | "_")* </span><a href="#doc-xquery40-HexDigit"><span class="deltaxml-old">HexDigit</span></a><span class="deltaxml-old">)?</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-HexDigit"></a><span class="deltaxml-old">[293]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-HexDigit"><span class="deltaxml-old">HexDigit</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">[0-9a-fA-F]</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-BinaryDigits"></a><span class="deltaxml-old">[294]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-BinaryDigits"><span class="deltaxml-old">BinaryDigits</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-BinaryDigit"><span class="deltaxml-old">BinaryDigit</span></a><span class="deltaxml-old"> ((</span><a href="#doc-xquery40-BinaryDigit"><span class="deltaxml-old">BinaryDigit</span></a><span class="deltaxml-old"> | "_")* </span><a href="#doc-xquery40-BinaryDigit"><span class="deltaxml-old">BinaryDigit</span></a><span class="deltaxml-old">)?</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-BinaryDigit"></a><span class="deltaxml-old">[295]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-BinaryDigit"><span class="deltaxml-old">BinaryDigit</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">[01]</span></code></td><td></td></tr></tbody></table><p><span class="deltaxml-old">The value of a numeric literal is determined as follows (taking the rules in order):</span></p><ol class="enumar"><li><p><span class="deltaxml-old">Underscore characters are stripped out. Underscores may be included in a numeric literal to aid readability, but have no effect on the value. For example, </span><code><span class="deltaxml-old">1_000_000</span></code><span class="deltaxml-old"> is equivalent to </span><code><span class="deltaxml-old">1000000</span></code><span class="deltaxml-old">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Underscores must not appear at the beginning or end of a sequence of digits, only in intermediate positions. Multiple adjacent underscores are allowed.</span></p></div></li><li><p><span class="deltaxml-old">A </span><code><span class="deltaxml-old">HexIntegerLiteral</span></code><span class="deltaxml-old"> represents a non-negative integer expressed in hexadecimal: for example </span><code><span class="deltaxml-old">0xffff</span></code><span class="deltaxml-old"> represents the integer 65535, and </span><code><span class="deltaxml-old">0xFFFF_FFFF</span></code><span class="deltaxml-old"> represents the integer 4294967295.</span></p></li><li><p><span class="deltaxml-old">A </span><code><span class="deltaxml-old">BinaryIntegerLiteral</span></code><span class="deltaxml-old"> represents a non-negative integer expressed in binary: for example </span><code><span class="deltaxml-old">0b101</span></code><span class="deltaxml-old"> represents the integer 5, and </span><code><span class="deltaxml-old">0b1111_1111</span></code><span class="deltaxml-old"> represents the integer 255.</span></p></li><li><p><span class="deltaxml-old">The value of a </span><b><span class="deltaxml-old">numeric literal</span></b><span class="deltaxml-old"> containing no </span><code><span class="deltaxml-old">.</span></code><span class="deltaxml-old"> and no </span><code><span class="deltaxml-old">e</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">E</span></code><span class="deltaxml-old"> character is an atomic value of type </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old">; the value is obtained by casting from </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> to </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old"> as specified in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#casting-from-strings"><span class="deltaxml-old">Section 21.2 Casting from xs:string and xs:untypedAtomic</span></a><sup><small><span class="deltaxml-old">FO40</span></small></sup><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The value of a numeric literal containing </span><code><span class="deltaxml-old">.</span></code><span class="deltaxml-old"> but no </span><code><span class="deltaxml-old">e</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">E</span></code><span class="deltaxml-old"> character is an atomic value of type </span><code><span class="deltaxml-old">xs:decimal</span></code><span class="deltaxml-old">; the value is obtained by casting from </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> to </span><code><span class="deltaxml-old">xs:decimal</span></code><span class="deltaxml-old"> as specified in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#casting-from-strings"><span class="deltaxml-old">Section 21.2 Casting from xs:string and xs:untypedAtomic</span></a><sup><small><span class="deltaxml-old">FO40</span></small></sup><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The value of a numeric literal containing an </span><code><span class="deltaxml-old">e</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">E</span></code><span class="deltaxml-old"> character is an atomic value of type </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old">; the value is obtained by casting from </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> to </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old"> as specified in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#casting-from-strings"><span class="deltaxml-old">Section 21.2 Casting from xs:string and xs:untypedAtomic</span></a><sup><small><span class="deltaxml-old">FO40</span></small></sup><span class="deltaxml-old">.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The value of a numeric literal is always non-negative. An expression may appear to include a negative number such as </span><code><span class="deltaxml-old">-1</span></code><span class="deltaxml-old">, but this is technically an arithmetic expression comprising a unary minus operator followed by a numeric literal.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The effect of the above rules is that in the case of an integer or decimal literal, a dynamic error [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOAR0002" title="err:FOAR0002"><span class="deltaxml-old">err:FOAR0002</span></a><span class="deltaxml-old">]</span><sup><small><span class="deltaxml-old">FO40</span></small></sup><span class="deltaxml-old"> will generally be raised if the literal is outside the range of values supported by the implementation (other options are available: see </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#op.numeric"><span class="deltaxml-old">Section 4.2 Arithmetic operators on numeric values</span></a><sup><small><span class="deltaxml-old">FO40</span></small></sup><span class="deltaxml-old"> for details.)</span></p><p class="xquery"><span class="deltaxml-old">The limits of numeric datatypes are specified in </span><a href="#id-data-model-conformance"><b><span class="deltaxml-old">6.3 Data Model Conformance</span></b></a><span class="deltaxml-old">.</span></p></div><p><span class="deltaxml-old">Here are some examples of numeric literals:</span></p><ul><li><p><code><span class="deltaxml-old">12</span></code><span class="deltaxml-old"> denotes the </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old"> value twelve.</span></p></li><li><p><code><span class="deltaxml-old">1_000_000</span></code><span class="deltaxml-old"> denotes the </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old"> value one million.</span></p></li><li><p><code><span class="deltaxml-old">12.5</span></code><span class="deltaxml-old"> denotes the </span><code><span class="deltaxml-old">xs:decimal</span></code><span class="deltaxml-old"> value twelve and one half.</span></p></li><li><p><code><span class="deltaxml-old">3.14159_26535_89793e0</span></code><span class="deltaxml-old"> is an </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old"> value representing the mathematical constant </span><var><span class="deltaxml-old">π</span></var><span class="deltaxml-old"> to 15 decimal places. </span></p></li><li><p><code><span class="deltaxml-old">125E2</span></code><span class="deltaxml-old"> denotes the </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old"> value twelve thousand, five hundred.</span></p></li><li><p><code><span class="deltaxml-old">0xffff</span></code><span class="deltaxml-old"> denotes the </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old"> value 65535.</span></p></li><li><p><code><span class="deltaxml-old">0b1000_0001</span></code><span class="deltaxml-old"> denotes the </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old"> value 129.</span></p></li></ul><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">The effect of the above rules is that in the case of an integer or decimal literal, a dynamic error [</span><a href="https://www.w3.org/TR/xpath-functions-31/#ERRFOAR0002" title="err:FOAR0002"><span class="deltaxml-new">err:FOAR0002</span></a><span class="deltaxml-new">]</span><sup><small><span class="deltaxml-new">FO31</span></small></sup><span class="deltaxml-new"> will generally be raised if the literal is outside the range of values supported by the implementation (other options are available: see </span><a href="https://www.w3.org/TR/xpath-functions-31/#op.numeric"><span class="deltaxml-new">Section 4.2 Arithmetic operators on numeric values </span></a><sup><small><span class="deltaxml-new">FO31</span></small></sup><span class="deltaxml-new"> for details.)</span></p><p class="xquery"><span class="deltaxml-new">The limits of numeric datatypes are specified in </span><a href="#id-data-model-conformance"><b><span class="deltaxml-new">6.3 Data Model Conformance</span></b></a><span class="deltaxml-new">.</span></p></div><div class="div4"><h5><a id="id-string-literal"></a><span class="deltaxml-old">4.3.1.2 String Literals</span></h5><a id="d3e12852"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringLiteral"></a><span class="deltaxml-old">[272]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-AposStringLiteral"><span class="deltaxml-old">AposStringLiteral</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-QuotStringLiteral"><span class="deltaxml-old">QuotStringLiteral</span></a></code></td><td><i><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AposStringLiteral"></a><span class="deltaxml-old">[273]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-AposStringLiteral"><span class="deltaxml-old">AposStringLiteral</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"'" (</span><a href="#doc-xquery40-PredefinedEntityRef"><span class="deltaxml-old">PredefinedEntityRef</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-CharRef"><span class="deltaxml-old">CharRef</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-EscapeApos"><span class="deltaxml-old">EscapeApos</span></a><span class="deltaxml-old"> | [^'&amp;])* "'"</span></code></td><td><i><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QuotStringLiteral"></a><span class="deltaxml-old">[274]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-QuotStringLiteral"><span class="deltaxml-old">QuotStringLiteral</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">'"' (</span><a href="#doc-xquery40-PredefinedEntityRef"><span class="deltaxml-old">PredefinedEntityRef</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-CharRef"><span class="deltaxml-old">CharRef</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-EscapeQuot"><span class="deltaxml-old">EscapeQuot</span></a><span class="deltaxml-old"> | [^"&amp;])* '"'</span></code></td><td><i><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PredefinedEntityRef"></a><span class="deltaxml-old">[277]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-PredefinedEntityRef"><span class="deltaxml-old">PredefinedEntityRef</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"&amp;" ("lt" | "gt" | "amp" | "quot" | "apos") ";"</span></code></td><td><i><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CharRef"></a><span class="deltaxml-old">[285]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-CharRef"><span class="deltaxml-old">CharRef</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="https://www.w3.org/TR/REC-xml/#NT-CharRef"><span class="deltaxml-old">[http://www.w3.org/TR/REC-xml#NT-CharRef]</span></a><sup><small><span class="deltaxml-old">XML</span></small></sup></code></td><td><i><span class="deltaxml-old">/* </span><a href="#parse-note-xml-version"><span class="deltaxml-old">xgc: xml-version</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-EscapeQuot"></a><span class="deltaxml-old">[278]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-EscapeQuot"><span class="deltaxml-old">EscapeQuot</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">'""'</span></code></td><td><i><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-EscapeApos"></a><span class="deltaxml-old">[279]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-EscapeApos"><span class="deltaxml-old">EscapeApos</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"''"</span></code></td><td><i><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody></table><p><span class="deltaxml-old">The value of a </span><b><span class="deltaxml-old">string literal</span></b><span class="deltaxml-old"> is an atomic value whose type is </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> and whose value is the string denoted by the characters between the delimiting apostrophes or quotation marks. If the literal is delimited by apostrophes, two adjacent apostrophes within the literal are interpreted as a single apostrophe. Similarly, if the literal is delimited by quotation marks, two adjacent quotation marks within the literal are interpreted as one quotation mark.</span></p><p class="xquery"><span class="deltaxml-old"> [</span><a id="dt-predefined-entity-reference" title="predefined entity reference"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">predefined entity reference</span></b><span class="deltaxml-old"> is a short sequence of characters, beginning with an ampersand, that represents a single character that might otherwise have syntactic significance.] Each predefined entity reference is replaced by the character it represents when the string literal is processed. The predefined entity references recognized by XPath and XQuery are as follows:</span></p><table style="width:60%; border:1px solid" class="medium"><tbody><tr><th style="text-align:center"><span class="deltaxml-old">Entity Reference</span></th><th style="text-align:center"><span class="deltaxml-old">Character Represented</span></th></tr><tr><td style="text-align:center"><code><span class="deltaxml-old">&amp;lt;</span></code></td><td style="text-align:center"><code><span class="deltaxml-old">&lt;</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-old">&amp;gt;</span></code></td><td style="text-align:center"><code><span class="deltaxml-old">&gt;</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-old">&amp;amp;</span></code></td><td style="text-align:center"><code><span class="deltaxml-old">&amp;</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-old">&amp;quot;</span></code></td><td style="text-align:center"><code><span class="deltaxml-old">"</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-old">&amp;apos;</span></code></td><td style="text-align:center"><code><span class="deltaxml-old">'</span></code></td></tr></tbody></table><p class="xquery"><span class="deltaxml-old"> [</span><a id="dt-character-reference" title="character reference"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">character reference</span></b><span class="deltaxml-old"> is an XML-style reference to a </span><a href="#Unicode"><span class="deltaxml-old">[Unicode]</span></a><span class="deltaxml-old"> character, identified by its decimal or hexadecimal codepoint.] For example, the Euro symbol (€) can be represented by the character reference </span><code><span class="deltaxml-old">&amp;#8364;</span></code><span class="deltaxml-old">. Character references are normatively defined in Section 4.1 of the XML specification (it is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-old">implementation-defined</span></a><span class="deltaxml-old"> whether the rules in </span><a href="#XML"><span class="deltaxml-old">[XML 1.0]</span></a><span class="deltaxml-old"> or </span><a href="#XML1.1"><span class="deltaxml-old">[XML 1.1]</span></a><span class="deltaxml-old"> apply.) A </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-old">static error</span></a><span class="deltaxml-old"> [</span><a href="#ERRXQST0090" title="err:XQST0090"><span class="deltaxml-old">err:XQST0090</span></a><span class="deltaxml-old">] is raised if a character reference does not identify a valid character in the version of XML that is in use.</span></p><p><span class="deltaxml-old">Here are some examples of string literals:</span></p><ul><li><p><code><span class="deltaxml-old">"He said, ""I don't like it."""</span></code><span class="deltaxml-old"> denotes a string containing two quotation marks and one apostrophe.</span></p></li><li class="xquery"><p><code><span class="deltaxml-old">"Ben &amp;amp; Jerry&amp;apos;s"</span></code><span class="deltaxml-old"> denotes the </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> value </span><code><span class="deltaxml-old">"Ben &amp; Jerry's"</span></code><span class="deltaxml-old">.</span></p></li><li class="xquery"><p><code><span class="deltaxml-old">"&amp;#8364;99.50"</span></code><span class="deltaxml-old"> denotes the </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> value </span><code><span class="deltaxml-old">"€99.50"</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">In XQuery, the string literal </span><code><span class="deltaxml-old">"&amp;lt;"</span></code><span class="deltaxml-old"> denotes a string of length 1 containing the single character </span><code><span class="deltaxml-old">"&lt;"</span></code><span class="deltaxml-old">. In XPath, the string literal </span><code><span class="deltaxml-old">"&amp;lt;"</span></code><span class="deltaxml-old"> denotes a string of length 4 containing the four characters </span><code><span class="deltaxml-old">"&amp;"</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">"l"</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">"t"</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">";"</span></code><span class="deltaxml-old">. (However, when the XPath expression is embedded in an XML document, the sequence </span><code><span class="deltaxml-old">"&amp;lt;"</span></code><span class="deltaxml-old"> will typically have already been converted to </span><code><span class="deltaxml-old">"&lt;"</span></code><span class="deltaxml-old"> by the XML parser.)</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">When XPath or XQuery expressions are embedded in contexts where quotation marks have special significance, such as inside XML attributes, or in string literals in a host language such as Java or C#, then additional escaping may be needed.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Fixed string values can also be written as string templates: see </span><a href="#id-string-templates"><b><span class="deltaxml-old">4.10.2 String Templates</span></b></a><span class="deltaxml-old">. A string template with no enclosed expressions, such as </span><code><span class="deltaxml-old">`Jamaica`</span></code><span class="deltaxml-old"> evaluates to the same value as the string literals </span><code><span class="deltaxml-old">"Jamaica"</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">'Jamaica'</span></code><span class="deltaxml-old">. A string template can contain both single and double quotation marks: </span><code><span class="deltaxml-old">`He said: "I don't like it"`</span></code><span class="deltaxml-old">. However, there there are some subtle differences:</span></p><ul><li><p><span class="deltaxml-old">In string literals, the treatment of character and entity references such as </span><code><span class="deltaxml-old">&amp;amp;</span></code><span class="deltaxml-old"> varies between XQuery and XPath; in string templates, such references are not expanded in either language.</span></p></li><li><p><span class="deltaxml-old">String templates can only be used where an expression is expected. String literals are also used in some non-expression contexts, for example in defining an enumeration type: see </span><a href="#id-enumeration-types"><b><span class="deltaxml-old">3.6.2.2 Enumeration Types</span></b></a><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">Curly braces (</span><code><span class="deltaxml-old">{</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">}</span></code><span class="deltaxml-old">) and backticks (</span><code><span class="deltaxml-old">`</span></code><span class="deltaxml-old">) have a reserved meaning in string templates.</span></p></li></ul></div></div><div class="div4"><h5><a id="id-constants-other-types"></a><span class="deltaxml-old">4.3.1.3 Constants of Other Types</span></h5><p><span class="deltaxml-old"> The </span><code><span class="deltaxml-old">xs:boolean</span></code><span class="deltaxml-old"> values </span><code><span class="deltaxml-old">true</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">false</span></code><span class="deltaxml-old"> can be constructed by calls to the </span><a title="system function" class="termref" href="#dt-system-function"><span class="deltaxml-old">system functions</span></a><code><span class="deltaxml-old">fn:true()</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">fn:false()</span></code><span class="deltaxml-old">, respectively. </span></p><p><span class="deltaxml-old">Values of other simple types can be constructed by calling the </span><a title="constructor function" class="termref" href="#dt-constructor-function"><span class="deltaxml-old">constructor function</span></a><span class="deltaxml-old"> for the given type. The constructor functions for XML Schema built-in types are defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#constructor-functions-for-xsd-types"><span class="deltaxml-old">Section 20.1 Constructor functions for XML Schema built-in atomic types</span></a><sup><small><span class="deltaxml-old">FO40</span></small></sup><span class="deltaxml-old">. In general, the name of a constructor function for a given type is the same as the name of the type (including its namespace). For example:</span></p><ul><li><p><code><span class="deltaxml-old">xs:integer("12")</span></code><span class="deltaxml-old"> returns the integer value twelve.</span></p></li><li><p><code><span class="deltaxml-old">xs:date("2001-08-25")</span></code><span class="deltaxml-old"> returns an item whose type is </span><code><span class="deltaxml-old">xs:date</span></code><span class="deltaxml-old"> and whose value represents the date 25th August 2001.</span></p></li><li><p><code><span class="deltaxml-old">xs:dayTimeDuration("PT5H")</span></code><span class="deltaxml-old"> returns an item whose type is </span><code><span class="deltaxml-old">xs:dayTimeDuration</span></code><span class="deltaxml-old"> and whose value represents a duration of five hours.</span></p></li></ul><p><span class="deltaxml-old">Constructor functions can also be used to create special values that have no literal representation, as in the following examples: </span></p><ul><li><p><code><span class="deltaxml-old">xs:float("NaN")</span></code><span class="deltaxml-old"> returns the special floating-point value, "Not a Number."</span></p></li><li><p><code><span class="deltaxml-old">xs:double("INF")</span></code><span class="deltaxml-old"> returns the special double-precision value, "positive infinity."</span></p></li></ul><p><span class="deltaxml-old">Constructor functions are available for all simple types, including union types. For example, if </span><code><span class="deltaxml-old">my:dt</span></code><span class="deltaxml-old"> is a user-defined union type whose member types are </span><code><span class="deltaxml-old">xs:date</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">xs:time</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">xs:dateTime</span></code><span class="deltaxml-old">, then the expression </span><code><span class="deltaxml-old">my:dt("2011-01-10")</span></code><span class="deltaxml-old"> creates an atomic value of type </span><code><span class="deltaxml-old">xs:date</span></code><span class="deltaxml-old">. The rules follow XML Schema validation rules for union types: the effect is to choose the first member type that accepts the given string in its lexical space.</span></p><p><span class="deltaxml-old">It is also possible to construct values of various types by using a </span><code><span class="deltaxml-old">cast</span></code><span class="deltaxml-old"> expression. For example:</span></p><ul><li><p><code><span class="deltaxml-old">9 cast as hatsize</span></code><span class="deltaxml-old"> returns the atomic value </span><code><span class="deltaxml-old">9</span></code><span class="deltaxml-old"> whose type is </span><code><span class="deltaxml-old">hatsize</span></code><span class="deltaxml-old">.</span></p></li></ul></div><p id="id-string-literal"><span class="deltaxml-new">The value of a </span><b><span class="deltaxml-new">string literal</span></b><span class="deltaxml-new"> is an atomic value whose type is </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> and whose value is the string denoted by the characters between the delimiting apostrophes or quotation marks. If the literal is delimited by apostrophes, two adjacent apostrophes within the literal are interpreted as a single apostrophe. Similarly, if the literal is delimited by quotation marks, two adjacent quotation marks within the literal are interpreted as one quotation mark.</span></p><p class="xquery"><span class="deltaxml-new">A string literal may contain a </span><b><span class="deltaxml-new">predefined entity reference</span></b><span class="deltaxml-new">. [</span><a id="dt-predefined-entity-reference" title="predefined entity reference"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: A </span><b><span class="deltaxml-new">predefined entity reference</span></b><span class="deltaxml-new"> is a short sequence of characters, beginning with an ampersand, that represents a single character that might otherwise have syntactic significance.] Each predefined entity reference is replaced by the character it represents when the string literal is processed. The predefined entity references recognized by XQuery are as follows:</span></p><table style="width:60%; border:1px solid" class="medium"><tbody><tr><th style="text-align:center"><span class="deltaxml-new">Entity Reference</span></th><th style="text-align:center"><span class="deltaxml-new">Character Represented</span></th></tr><tr><td style="text-align:center"><code><span class="deltaxml-new">&amp;lt;</span></code></td><td style="text-align:center"><code><span class="deltaxml-new">&lt;</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-new">&amp;gt;</span></code></td><td style="text-align:center"><code><span class="deltaxml-new">&gt;</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-new">&amp;amp;</span></code></td><td style="text-align:center"><code><span class="deltaxml-new">&amp;</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-new">&amp;quot;</span></code></td><td style="text-align:center"><code><span class="deltaxml-new">"</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-new">&amp;apos;</span></code></td><td style="text-align:center"><code><span class="deltaxml-new">'</span></code></td></tr></tbody></table><p class="xquery"><span class="deltaxml-new">A string literal may also contain a </span><b><span class="deltaxml-new">character reference</span></b><span class="deltaxml-new">. [</span><a id="dt-character-reference" title="character reference"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: A </span><b><span class="deltaxml-new">character reference</span></b><span class="deltaxml-new"> is an XML-style reference to a </span><a href="#Unicode"><span class="deltaxml-new">[Unicode]</span></a><span class="deltaxml-new"> character, identified by its decimal or hexadecimal codepoint.] For example, the Euro symbol (€) can be represented by the character reference </span><code><span class="deltaxml-new">&amp;#8364;</span></code><span class="deltaxml-new">. Character references are normatively defined in Section 4.1 of the XML specification (it is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new">implementation-defined</span></a><span class="deltaxml-new"> whether the rules in </span><a href="#XML"><span class="deltaxml-new">[XML 1.0]</span></a><span class="deltaxml-new"> or </span><a href="#XML1.1"><span class="deltaxml-new">[XML 1.1]</span></a><span class="deltaxml-new"> apply.) A </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new">static error</span></a><span class="deltaxml-new"> [</span><a href="#ERRXQST0090" title="err:XQST0090"><span class="deltaxml-new">err:XQST0090</span></a><span class="deltaxml-new">] is raised if a character reference does not identify a valid character in the version of XML that is in use.</span></p><p><span class="deltaxml-new">Here are some examples of literal expressions:</span></p><ul><li><p><code><span class="deltaxml-new">"12.5"</span></code><span class="deltaxml-new"> denotes the string containing the characters '1', '2', '.', and '5'.</span></p></li><li><p><code><span class="deltaxml-new">12</span></code><span class="deltaxml-new"> denotes the </span><code><span class="deltaxml-new">xs:integer</span></code><span class="deltaxml-new"> value twelve.</span></p></li><li><p><code><span class="deltaxml-new">12.5</span></code><span class="deltaxml-new"> denotes the </span><code><span class="deltaxml-new">xs:decimal</span></code><span class="deltaxml-new"> value twelve and one half.</span></p></li><li><p><code><span class="deltaxml-new">125E2</span></code><span class="deltaxml-new"> denotes the </span><code><span class="deltaxml-new">xs:double</span></code><span class="deltaxml-new"> value twelve thousand, five hundred.</span></p></li><li><p><code><span class="deltaxml-new">"He said, ""I don't like it."""</span></code><span class="deltaxml-new"> denotes a string containing two quotation marks and one apostrophe.</span></p></li><li class="xquery"><p><code><span class="deltaxml-new">"Ben &amp;amp; Jerry&amp;apos;s"</span></code><span class="deltaxml-new"> denotes the </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> value "</span><code><span class="deltaxml-new">Ben &amp; Jerry's</span></code><span class="deltaxml-new">".</span></p></li><li class="xquery"><p><code><span class="deltaxml-new">"&amp;#8364;99.50"</span></code><span class="deltaxml-new"> denotes the </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> value "</span><code><span class="deltaxml-new">€99.50</span></code><span class="deltaxml-new">".</span></p></li></ul><p><span class="deltaxml-new"> The </span><code><span class="deltaxml-new">xs:boolean</span></code><span class="deltaxml-new"> values </span><code><span class="deltaxml-new">true</span></code><span class="deltaxml-new"> and </span><code><span class="deltaxml-new">false</span></code><span class="deltaxml-new"> can be constructed by calls to the </span><a title="built-in function" class="termref" href="#dt-built-in-function"><span class="deltaxml-new">built-in functions</span></a><code><span class="deltaxml-new">fn:true()</span></code><span class="deltaxml-new"> and </span><code><span class="deltaxml-new">fn:false()</span></code><span class="deltaxml-new">, respectively. </span></p><p><span class="deltaxml-new">Values of other simple types can be constructed by calling the </span><a title="constructor function" class="termref" href="#dt-constructor-function"><span class="deltaxml-new">constructor function</span></a><span class="deltaxml-new"> for the given type. The constructor functions for XML Schema built-in types are defined in </span><a href="https://www.w3.org/TR/xpath-functions-31/#constructor-functions-for-xsd-types"><span class="deltaxml-new">Section 18.1 Constructor functions for XML Schema built-in atomic types </span></a><sup><small><span class="deltaxml-new">FO31</span></small></sup><span class="deltaxml-new">. In general, the name of a constructor function for a given type is the same as the name of the type (including its namespace). For example:</span></p><ul><li><p><code><span class="deltaxml-new">xs:integer("12")</span></code><span class="deltaxml-new"> returns the integer value twelve.</span></p></li><li><p><code><span class="deltaxml-new">xs:date("2001-08-25")</span></code><span class="deltaxml-new"> returns an item whose type is </span><code><span class="deltaxml-new">xs:date</span></code><span class="deltaxml-new"> and whose value represents the date 25th August 2001.</span></p></li><li><p><code><span class="deltaxml-new">xs:dayTimeDuration("PT5H")</span></code><span class="deltaxml-new"> returns an item whose type is </span><code><span class="deltaxml-new">xs:dayTimeDuration</span></code><span class="deltaxml-new"> and whose value represents a duration of five hours.</span></p></li></ul><p><span class="deltaxml-new">Constructor functions can also be used to create special values that have no literal representation, as in the following examples: </span></p><ul><li><p><code><span class="deltaxml-new">xs:float("NaN")</span></code><span class="deltaxml-new"> returns the special floating-point value, "Not a Number."</span></p></li><li><p><code><span class="deltaxml-new">xs:double("INF")</span></code><span class="deltaxml-new"> returns the special double-precision value, "positive infinity."</span></p></li></ul><p><span class="deltaxml-new">Constructor functions are available for all simple types, including union types. For example, if </span><code><span class="deltaxml-new">my:dt</span></code><span class="deltaxml-new"> is a user-defined union type whose member types are </span><code><span class="deltaxml-new">xs:date</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">xs:time</span></code><span class="deltaxml-new">, and </span><code><span class="deltaxml-new">xs:dateTime</span></code><span class="deltaxml-new">, then the expression </span><code><span class="deltaxml-new">my:dt("2011-01-10")</span></code><span class="deltaxml-new"> creates an atomic value of type </span><code><span class="deltaxml-new">xs:date</span></code><span class="deltaxml-new">. The rules follow XML Schema validation rules for union types: the effect is to choose the first member type that accepts the given string in its lexical space.</span></p><p><span class="deltaxml-new">It is also possible to construct values of various types by using a </span><code><span class="deltaxml-new">cast</span></code><span class="deltaxml-new"> expression. For example:</span></p><ul><li><p><code><span class="deltaxml-new">9 cast as hatsize</span></code><span class="deltaxml-new"> returns the atomic value </span><code><span class="deltaxml-new">9</span></code><span class="deltaxml-new"> whose type is </span><code><span class="deltaxml-new">hatsize</span></code><span class="deltaxml-new">.</span></p></li></ul></div><div class="div3"><h4><a id="id-variables"></a>4.3.2 Variable References</h4><a id="d3e13214"></a><a id="d3e11098"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-VarRef"></a>[<span class="deltaxml-old">169</span><span class="deltaxml-new">156</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-VarRef">VarRef</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#doc-xquery40-VarName">VarName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-VarName"></a>[<span class="deltaxml-old">170</span><span class="deltaxml-new">157</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-VarName">VarName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody></table><p> [<a id="dt-variable-reference" title="variable reference">Definition</a>: A <b>variable reference</b> is an EQName preceded by a $-sign.] An unprefixed variable reference is in no namespace. Two variable references are equivalent if their <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> are equal (as defined by the <code>eq</code> operator). The scope of a variable binding is defined separately for each kind of expression that can bind variables.</p><p>Every variable reference must match a name in the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a>. </p><p>Every variable binding has a static scope. The scope defines where references to the variable can validly occur. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>] to reference a variable that is not in scope. If a variable is bound in the <a title="static context" class="termref" href="#dt-static-context">static context</a> for an expression, that variable is in scope for the entire expression except where it is occluded by another binding that uses the same name within that scope.</p><p class="xquery">A reference to a variable that was declared <code>external</code>, but was not bound to a value by the external environment, raises a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>].</p><p> At evaluation time, the value of a variable reference is the value to which the relevant variable is bound.</p></div><div class="div3"><h4><a id="id-context-value-references"></a><span class="deltaxml-old">4.3.3 Context Value References</span></h4><a id="d3e13270"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ContextValueRef"></a><span class="deltaxml-old">[172]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-ContextValueRef"><span class="deltaxml-old">ContextValueRef</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"."</span></code></td><td></td></tr></tbody></table><p><span class="deltaxml-old">A </span><b><span class="deltaxml-old">context value reference</span></b><span class="deltaxml-old"> evaluates to the </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-old">context value</span></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">In many syntactic contexts, the context value will be a single item. For example this applies on the right-hand side of the </span><code><span class="deltaxml-old">/</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">!</span></code><span class="deltaxml-old"> operators, or within a </span><a href="#doc-xquery40-Predicate"><span class="deltaxml-old">Predicate</span></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">If the </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-old">context value</span></a><span class="deltaxml-old"> is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-old">absent</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">, a context value reference raises a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-old">type error</span></a><span class="deltaxml-old"> [</span><a href="#ERRXPDY0002" title="err:XPDY0002"><span class="deltaxml-old">err:XPDY0002</span></a><span class="deltaxml-old">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Being absent is not the same thing as being empty.</span></p></div></div><div class="div3"><h4><a id="id-paren-expressions"></a><span class="deltaxml-old">4.3.4</span><span class="deltaxml-new">4.3.3</span> Parenthesized Expressions</h4><a id="d3e13304"></a><a id="d3e11154"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ParenthesizedExpr"></a>[<span class="deltaxml-old">171</span><span class="deltaxml-new">158</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ParenthesizedExpr">ParenthesizedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" <a href="#doc-xquery40-Expr">Expr</a>? ")"</code></td><td></td></tr></tbody></table><p>Parentheses may be used to override the precedence rules. For example, the expression <code>(2 + 4) * 5</code> evaluates to thirty, since the parenthesized expression <code>(2 + 4)</code> is evaluated first and its result is multiplied by five. Without parentheses, the expression <code>2 + 4 * 5</code> evaluates to twenty-two, because the multiplication operator has higher precedence than the addition operator.</p><p>Empty parentheses are used to denote an empty sequence, as described in <a href="#construct_seq"><span style="display: none;" class="delete_version"><b>4.8.1 Sequence Concatenation</b></span><span style="display: none;" class="add_version"><b>4.7.1 Sequence Concatenation</b></span><span class="modify_version"><b><span class="deltaxml-old">4.8.1</span><span class="deltaxml-new">4.7.1</span> Sequence Concatenation</b></span></a>.</p></div><div class="div3"><h4><a id="id-context-item-expression"></a><span class="deltaxml-new">4.3.4 Context Item Expression</span></h4><a id="d3e11180"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ContextItemExpr"></a><span class="deltaxml-new">[159]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-ContextItemExpr"><span class="deltaxml-new">ContextItemExpr</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">"."</span></code></td><td></td></tr></tbody></table><p><span class="deltaxml-new">A </span><b><span class="deltaxml-new">context item expression</span></b><span class="deltaxml-new"> evaluates to the </span><a title="context item" class="termref" href="#dt-context-item"><span class="deltaxml-new">context item</span></a><span class="deltaxml-new">, which may be either a node (as in the expression </span><code><span class="deltaxml-new">fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</span></code><span class="deltaxml-new">), or an atomic value or function (as in the expression </span><code><span class="deltaxml-new">(1 to 100)[. mod 5 eq 0]</span></code><span class="deltaxml-new">).</span></p><p><span class="deltaxml-new">If the </span><a title="context item" class="termref" href="#dt-context-item"><span class="deltaxml-new">context item</span></a><span class="deltaxml-new"> is </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent"><span class="deltaxml-new">absent</span></a><sup><small><span class="deltaxml-new">DM31</span></small></sup><span class="deltaxml-new">, a context item expression raises a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new">dynamic error</span></a><span class="deltaxml-new"> [</span><a href="#ERRXPDY0002" title="err:XPDY0002"><span class="deltaxml-new">err:XPDY0002</span></a><span class="deltaxml-new">].</span></p></div><div class="div3"><h4><a id="id-enclosed-expr"></a>4.3.5 Enclosed Expressions</h4><p><a id="d3e13332"></a><a id="d3e11214"></a></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p> [<a id="dt-enclosed-expression" title="enclosed expression">Definition</a>: An <b>enclosed expression</b> is an instance of the <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a> production, which allows an optional expression within curly braces.] [<a id="dt-content-expression" title="content expression">Definition</a>: In an <a title="enclosed expression" class="termref" href="#dt-enclosed-expression">enclosed expression</a>, the optional expression enclosed in curly braces is called the <b>content expression</b>.] If the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> is not provided explicitly, the content expression is <code>()</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Despite the name, an enclosed expression is not actually an expression in its own right; rather it is a construct that is used in the grammar of many other expressions.</p></div></div></div><div class="div2"><h3><a id="id-postfix-expression"></a><span class="deltaxml-old">4.4 Postfix Expressions</span></h3><a id="d3e13368"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PostfixExpr"></a><span class="deltaxml-old">[151]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-PostfixExpr"><span class="deltaxml-old">PostfixExpr</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-PrimaryExpr"><span class="deltaxml-old">PrimaryExpr</span></a><span class="deltaxml-old"> | </span><a href="#prod-xquery40-FilterExpr"><span class="deltaxml-old">FilterExpr</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-DynamicFunctionCall"><span class="deltaxml-old">DynamicFunctionCall</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-LookupExpr"><span class="deltaxml-old">LookupExpr</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12240.doc-xquery40-FilterExpr"></a><span class="deltaxml-old">[150]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">FilterExpr</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-PostfixExpr"><span class="deltaxml-old">PostfixExpr</span></a><a href="#doc-xquery40-Predicate"><span class="deltaxml-old">Predicate</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12241.doc-xquery40-DynamicFunctionCall"></a><span class="deltaxml-old">[152]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">DynamicFunctionCall</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-PostfixExpr"><span class="deltaxml-old">PostfixExpr</span></a><a href="#doc-xquery40-PositionalArgumentList"><span class="deltaxml-old">PositionalArgumentList</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12242.doc-xquery40-LookupExpr"></a><span class="deltaxml-old">[160]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">LookupExpr</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-PostfixExpr"><span class="deltaxml-old">PostfixExpr</span></a><a href="#doc-xquery40-Lookup"><span class="deltaxml-old">Lookup</span></a></code></td><td></td></tr></tbody></table><p><span class="deltaxml-old">A postfix expression takes one of the following forms:</span></p><ul><li><p><span class="deltaxml-old"> [</span><a id="dt-filter-expression" title="filter expression"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">filter expression</span></b><span class="deltaxml-old"> is an expression in the form </span><code><span class="deltaxml-old">E1[E2]</span></code><span class="deltaxml-old">: its effect is to return those items from the value of </span><code><span class="deltaxml-old">E1</span></code><span class="deltaxml-old"> that satisfy the predicate in E2.] </span></p><p><span class="deltaxml-old">Filter expressions are described in </span><a href="#id-filter-expression"><b><span class="deltaxml-old">4.5 Filter Expressions</span></b></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">An example of a filter expression is </span><code><span class="deltaxml-old">(1 to 100)[. mod 2 = 0]</span></code><span class="deltaxml-old"> which returns all even numbers in the range 1 to 100.</span></p><p><span class="deltaxml-old">The base expression </span><code><span class="deltaxml-old">E1</span></code><span class="deltaxml-old"> can itself be a postfix expression, so multiple predicates are allowed, in the form </span><code><span class="deltaxml-old">E1[E2][E3][E4]</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">An expression (other than a raw EQName) followed by an argument list in parentheses (that is, </span><code><span class="deltaxml-old">E1(E2, E3, ...)</span></code><span class="deltaxml-old">) is referred to as a </span><a title="dynamic function call" class="termref" href="#dt-dynamic-function-invocation"><span class="deltaxml-old">dynamic function call</span></a><span class="deltaxml-old">. Its effect is to evaluate </span><code><span class="deltaxml-old">E1</span></code><span class="deltaxml-old"> to obtain a function, and then call that function, with </span><code><span class="deltaxml-old">E2</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">E3</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">...</span></code><span class="deltaxml-old"> as arguments. Dynamic function calls are described in </span><a href="#id-dynamic-function-invocation"><b><span class="deltaxml-old">4.6.2.1 Dynamic Function Calls</span></b></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">An example of a dynamic function call is </span><code><span class="deltaxml-old">$f("a", 2)</span></code><span class="deltaxml-old"> where the value of variable </span><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old"> must be a function item.</span></p></li><li><p><span class="deltaxml-old">A </span><code><span class="deltaxml-old">lookup-expression</span></code><span class="deltaxml-old"> takes the form </span><code><span class="deltaxml-old">E1?K</span></code><span class="deltaxml-old">, where </span><code><span class="deltaxml-old">E1</span></code><span class="deltaxml-old"> is an expression returning a sequence of maps or arrays, and </span><code><span class="deltaxml-old">K</span></code><span class="deltaxml-old"> is a key specifier, which indicates which entries in a map, or members in an array, should be selected.</span></p><p><span class="deltaxml-old">Lookup expressions are described in </span><a href="#id-postfix-lookup"><b><span class="deltaxml-old">4.14.3.1 Postfix Lookup Expressions</span></b></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">An example of a lookup expression is </span><code><span class="deltaxml-old">$emp?name</span></code><span class="deltaxml-old">, where the value of variable </span><code><span class="deltaxml-old">$emp</span></code><span class="deltaxml-old"> is a map, and the string </span><code><span class="deltaxml-old">"name"</span></code><span class="deltaxml-old"> is the key of one of the entries in the map.</span></p></li></ul><p><span class="deltaxml-old">Postfix expressions are evaluated from left-to-right. For example, the expression </span><code><span class="deltaxml-old">$E1[E2]?(E3)(E4)</span></code><span class="deltaxml-old"> is evaluated by first evaluating the filter expression </span><code><span class="deltaxml-old">$E1[E2]</span></code><span class="deltaxml-old"> to produce a sequence of maps and arrays (say </span><code><span class="deltaxml-old">$S</span></code><span class="deltaxml-old">), then evaluating the lookup expression </span><code><span class="deltaxml-old">$S?(E3)</span></code><span class="deltaxml-old"> to produce a function item (say </span><code><span class="deltaxml-old">$F</span></code><span class="deltaxml-old">), then evaluating the dynamic function call </span><code><span class="deltaxml-old">$F(E4)</span></code><span class="deltaxml-old"> to produce the final result.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The grammar for postfix expressions is defined here in a way designed to link clearly to the semantics of the different kinds of expression. For parsing purposes, the equivalent production rule:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">PostfixExpr := PrimaryExpr (Predicate | PositionalArgumentList | Lookup)*</span></pre></div><p><span class="deltaxml-old">(as used in XPath 3.1) is probably more convenient.</span></p></div></div><div class="div2"><h3><a id="id-filter-expression"></a><span class="deltaxml-old">4.5 Filter Expressions</span></h3><a id="d3e13514"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12343.doc-xquery40-FilterExpr"></a><span class="deltaxml-old">[150]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">FilterExpr</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-PostfixExpr"><span class="deltaxml-old">PostfixExpr</span></a><a href="#doc-xquery40-Predicate"><span class="deltaxml-old">Predicate</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Predicate"></a><span class="deltaxml-old">[159]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-Predicate"><span class="deltaxml-old">Predicate</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"[" </span><a href="#doc-xquery40-Expr"><span class="deltaxml-old">Expr</span></a><span class="deltaxml-old"> "]"</span></code></td><td></td></tr></tbody></table><p><span class="deltaxml-old">A filter expression consists of a base expression followed by a predicate, which is an expression written in square brackets. The result of the filter expression consists of the items returned by the base expression, filtered by applying the predicate to each item in turn. The ordering of the items returned by a filter expression is the same as their order in the result of the primary expression.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Where the expression before the square brackets is a </span><a href="#doc-xquery40-ReverseStep"><span class="deltaxml-old">ReverseStep</span></a><span class="deltaxml-old"> or </span><a href="#doc-xquery40-ForwardStep"><span class="deltaxml-old">ForwardStep</span></a><span class="deltaxml-old">, the expression is technically not a filter expression but an </span><a href="#doc-xquery40-AxisStep"><span class="deltaxml-old">AxisStep</span></a><span class="deltaxml-old">. There are minor differences in the semantics: see </span><a href="#id-predicate"><b><span class="deltaxml-old">4.7.5 Predicates within Steps</span></b></a></p></div><p><span class="deltaxml-old">Here are some examples of filter expressions:</span></p><ul><li><p><span class="deltaxml-old">Given a sequence of products in a variable, return only those products whose price is greater than 100.</span></p><div class="exampleInner"><pre><span class="deltaxml-old">$products[price gt 100]</span></pre></div></li><li><p><span class="deltaxml-old">List all the integers from 1 to 100 that are divisible by 5. (See </span><a href="#construct_seq"><b><span class="deltaxml-old">4.8.1 Sequence Concatenation</span></b></a><span class="deltaxml-old"> for an explanation of the </span><code><span class="deltaxml-old">to</span></code><span class="deltaxml-old"> operator.)</span></p><div class="exampleInner"><pre><span class="deltaxml-old">(1 to 100)[. mod 5 eq 0]</span></pre></div></li><li><p><span class="deltaxml-old">The result of the following expression is the integer 25:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">(21 to 29)[5]</span></pre></div></li><li><p><span class="deltaxml-old">The following example returns the fifth through ninth items in the sequence bound to variable </span><code><span class="deltaxml-old">$orders</span></code><span class="deltaxml-old">.</span></p><div class="exampleInner"><pre><span class="deltaxml-old">$orders[5 to 9]</span></pre></div></li><li><p><span class="deltaxml-old">The following example illustrates the use of a filter expression as a </span><a title="step" class="termref" href="#dt-step"><span class="deltaxml-old">step</span></a><span class="deltaxml-old"> in a </span><a title="path expression" class="termref" href="#dt-path-expression"><span class="deltaxml-old">path expression</span></a><span class="deltaxml-old">. It returns the last chapter or appendix within the book bound to variable </span><code><span class="deltaxml-old">$book</span></code><span class="deltaxml-old">:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">$book/(chapter | appendix)[last()]</span></pre></div></li></ul><p><span class="deltaxml-old">For each item in the input sequence, the predicate expression is evaluated using an </span><b><span class="deltaxml-old">inner focus</span></b><span class="deltaxml-old">, defined as follows: The context value is the item currently being tested against the predicate. The context size is the number of items in the input sequence. The context position is the position of the context value within the input sequence. </span></p><p><span class="deltaxml-old">For each item in the input sequence, the result of the predicate expression is coerced to an </span><code><span class="deltaxml-old">xs:boolean</span></code><span class="deltaxml-old"> value, called the </span><b><span class="deltaxml-old">predicate truth value</span></b><span class="deltaxml-old">, as described below. Those items for which the predicate truth value is </span><code><span class="deltaxml-old">true</span></code><span class="deltaxml-old"> are retained, and those for which the predicate truth value is </span><code><span class="deltaxml-old">false</span></code><span class="deltaxml-old"> are discarded.</span></p><p><span class="deltaxml-old">The predicate truth value is derived by applying the following rules, in order:</span></p><ol class="enumar"><li><p><span class="deltaxml-old">If the value </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old"> of the predicate expression is a sequence whose first item is an instance of the type </span><code><span class="deltaxml-old">xs:numeric</span></code><span class="deltaxml-old">, then:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old"> must be an instance of the type </span><code><span class="deltaxml-old">xs:numeric+</span></code><span class="deltaxml-old"> (that is, every item in </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old"> must be numeric). A type error [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-old">err:XPTY0004</span></a><span class="deltaxml-old">] is raised if this is not the case.</span></p></li><li><p><span class="deltaxml-old">The predicate truth value is </span><code><span class="deltaxml-old">true</span></code><span class="deltaxml-old"> if </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old"> is equal (by the </span><code><span class="deltaxml-old">=</span></code><span class="deltaxml-old"> operator) to the </span><b><span class="deltaxml-old">context position</span></b><span class="deltaxml-old">, and is </span><code><span class="deltaxml-old">false</span></code><span class="deltaxml-old"> otherwise.</span></p></li></ol><p><span class="deltaxml-old">In effect this means that an item in the input sequence is selected if its position in the sequence is equal to one or more of the numeric values in the predicate. For example, the predicate </span><code><span class="deltaxml-old">[3 to 5]</span></code><span class="deltaxml-old"> is true for the third, fourth, and fifth items in the input sequence.</span></p><p><span class="deltaxml-old"> [</span><a id="dt-numeric-predicate" title="numeric predicate"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A predicate whose predicate expression returns a value of type </span><code><span class="deltaxml-old">xs:numeric+</span></code><span class="deltaxml-old"> is called a </span><b><span class="deltaxml-old">numeric predicate</span></b><span class="deltaxml-old">.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">It is possible, though not generally useful, for the value of a numeric predicate to depend on the focus, and thus to differ for different items in the input sequence. For example, the predicate </span><code><span class="deltaxml-old">[xs:integer(@seq)]</span></code><span class="deltaxml-old"> selects those items in the input sequence whose </span><code><span class="deltaxml-old">@seq</span></code><span class="deltaxml-old"> attribute is numerically equal to their position in the input sequence.</span></p><p><span class="deltaxml-old">It is also possible, and again not generally useful, for the value of the predicate to be numeric for some items in the input sequence, and boolean for others. For example, the predicate </span><code><span class="deltaxml-old">[@special otherwise xs:integer(@seq)]</span></code><span class="deltaxml-old"> is true for an item that either has an </span><code><span class="deltaxml-old">@special</span></code><span class="deltaxml-old"> attribute, or if not, has an </span><code><span class="deltaxml-old">@seq</span></code><span class="deltaxml-old"> attribute that is numerically equal to the position of the item in the input sequence.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The truth value of a numeric predicate does not depend on the order of the numbers in </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old">. The predicates </span><code><span class="deltaxml-old">[1, 2, 3]</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">[3, 2, 1]</span></code><span class="deltaxml-old"> have exactly the same effect. The items in the result of a filter expression always retain the ordering of the input sequence.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The truth value of a numeric predicate whose value is non-integral or non-positive is always false.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">In a region of a query where </span><a title="ordering mode" class="termref" href="#dt-ordering-mode"><span class="deltaxml-old">ordering mode</span></a><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">unordered</span></code><span class="deltaxml-old">, the result of a numeric predicate is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-old">implementation-dependent</span></a><span class="deltaxml-old"> , as explained in </span><a href="#id-unordered-expressions"><b><span class="deltaxml-old">4.16 Ordered and Unordered Expressions</span></b></a><span class="deltaxml-old">.</span></p></div><table class="ednote" caption="Editorial note"><tbody><tr><td style="text-align: left; vertical-align:top; width: 50%;"><b><span class="deltaxml-old">Editorial note</span></b></td><td style="text-align: right; vertical-align:top; width: 50%;"><span class="deltaxml-old">&nbsp;</span></td></tr><tr style="text-align: left; vertical-align: top;"><td colspan="2"><span class="deltaxml-old">Add entry to changes appendix.</span></td></tr></tbody></table></li><li><p><span class="deltaxml-old">Otherwise, the predicate truth value is the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-old">effective boolean value</span></a><span class="deltaxml-old"> of the predicate expression.</span></p></li></ol></div><div class="div2"><h3><a id="id-functions"></a><span class="deltaxml-old">4.6</span><span class="deltaxml-new">4.4</span> Functions</h3><p>Functions in XQuery 4.0 arise in two ways:</p><ul><li><p>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> contains information about a family of functions with the same name and a defined arity range. These functions are in most cases known statically (they appear in the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>), but there may be further function definitions that are known only dynamically (appearing in the <a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions">dynamically known function definitions</a>).</p></li><li><p><a title="function item" class="termref" href="#dt-function-item">Function items</a> are XDM items that can be called using a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a>. They are values that can be bound to variables, passed as arguments, returned as function results, and generally manipulated in the same way as other XDM values.</p></li></ul><p>The functions defined by a statically known <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> can be invoked using a <a title="static function call" class="termref" href="#dt-static-function-call">static function call</a>. <a title="function item" class="termref" href="#dt-function-item">Function items</a> corresponding to these definitions can also be obtained, as dynamic values, by evaluating a <a title="named function reference" class="termref" href="#dt-named-function-ref">named function reference</a>. <a title="function item" class="termref" href="#dt-function-item">Function items</a> can also be obtained using the <code>fn:function-lookup</code> function: in this case the function name and arity do not need to be known statically, and the function definition need not be present in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, so long as it is in the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a>.</p><p><span class="deltaxml-old">Static and dynamic function calls are described in the following sections.</span></p><p><span class="deltaxml-new">The mechanisms for making function calls by reference to function definitions and function items are described in the following sections.</span></p><div class="div3"><h4><a id="id-static-functions"></a><span class="deltaxml-old">4.6.1 Static Function Calls</span></h4><h4><a id="id-static-functions"></a><span class="deltaxml-new">4.4.1 Function Definitions</span></h4><p>The <a title="static context" class="termref" href="#dt-static-context">static context</a> for an expression includes a set of <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>. Every <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the static context has a name (which is an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>) and an <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>, which is a range of permitted arities for calls on that function. Two <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> having the same name must not have overlapping arity ranges. This means that for a given static function call, it is possible to identify the target function definition in the static context unambiguously from knowledge of the function name and the number of supplied arguments.</p><p><span style="display: none;" class="delete_version">A <a title="static function call" class="termref" href="#dt-static-function-call">static function call</a> is bound to a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the static context by matching the name and arity. If the function call has <var>P</var> positional arguments followed by <var>K</var> keyword arguments, then the required arity is <var>P+K</var>, and the static context must include a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> whose name matches the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> in the function call, and whose <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> includes this required arity. This is the function chosen to be called. The result of the function is obtained by evaluating the expression that forms its implementation, with a dynamic context that provides values for all the declared parameters, initialized as described in <a href="#id-eval-static-function-call"><span class="delete_version"><b>4.6.1.2 Evaluating Static Function Calls</b></span><span class="modify_version"><b>4.6.1.2 Evaluating Static Function Calls</b></span></a> below.</span><span style="display: none;" class="add_version">A <a title="static function call" class="termref" href="#dt-static-function-call">static function call</a> is bound to a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the static context by matching the name and arity. If the function call has <var>P</var> positional arguments followed by <var>K</var> keyword arguments, then the required arity is <var>P+K</var>, and the static context must include a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> whose name matches the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> in the function call, and whose <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> includes this required arity. This is the function chosen to be called. The result of the function is obtained by evaluating the expression that forms its implementation, with a dynamic context that provides values for all the declared parameters, initialized as described in <a href="#id-eval-static-function-call"><span class="add_version"><b>4.4.1.2 Evaluating Static Function Calls</b></span><span class="modify_version"><b>4.4.1.2 Evaluating Static Function Calls</b></span></a> below.</span><span class="modify_version">A <a title="static function call" class="termref" href="#dt-static-function-call">static function call</a> is bound to a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the static context by matching the name and arity. If the function call has <var>P</var> positional arguments followed by <var>K</var> keyword arguments, then the required arity is <var>P+K</var>, and the static context must include a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> whose name matches the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> in the function call, and whose <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> includes this required arity. This is the function chosen to be called. The result of the function is obtained by evaluating the expression that forms its implementation, with a dynamic context that provides values for all the declared parameters, initialized as described in <a href="#id-eval-static-function-call"><span style="display: none;" class="delete_version"><b>4.6.1.2 Evaluating Static Function Calls</b></span><span style="display: none;" class="add_version"><b>4.4.1.2 Evaluating Static Function Calls</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.1.2</span><span class="deltaxml-new">4.4.1.2</span> Evaluating Static Function Calls</b></span></a> below.</span></p><p>Similarly, a function reference of the form <code>f#N</code> binds to a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the static context whose name matches <var>f</var> where <code>MinP ≤ N and MaxP ≥ N</code>. The result of evaluating a function reference is a <a title="function item" class="termref" href="#dt-function-item">function item</a> which can be called using a dynamic function call. Function items are never variadic and their arguments are always supplied positionally. For example, the function reference <code>fn:concat#3</code> returns a function item with arity 3, which is always called by supplying three positional arguments, and whose effect is the same as a static call on <code>fn:concat</code> with three positional arguments. </p><p>The detailed rules for evaluating static function calls and function references are defined in subsequent sections.</p><div class="div4"><h5><a id="id-function-calls"></a><span class="deltaxml-old">4.6.1.1</span><span class="deltaxml-new">4.4.1.1</span> Static Function Call Syntax</h5><a id="d3e13799"></a><a id="d3e11358"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionCall"></a>[<span class="deltaxml-old">175</span><span class="deltaxml-new">162</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-FunctionCall">FunctionCall</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a><a href="#doc-xquery40-ArgumentList">ArgumentList</a></code></td><td><i>/* <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a> */</i></td></tr><tr style="vertical-align:baseline;"><td></td><td></td><td></td><td></td><td><i>/* <a href="#parse-note-parens">gn: parens</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ArgumentList"></a><a id="noid_d4e10387.doc-xquery40-ArgumentList"></a>[<span class="deltaxml-old">153</span><span class="deltaxml-new">142</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-ArgumentList">ArgumentList</a></code></span><span style="display: none;" class="add_version"><code>ArgumentList</code></span><span class="modify_version"><code><a href="#prod-xquery40-ArgumentList"><span class="deltaxml-old">ArgumentList</span></a><span class="deltaxml-new">ArgumentList</span></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"(" ((<a href="#doc-xquery40-PositionalArguments">PositionalArguments</a> ("," <a href="#prod-xquery40-KeywordArguments">KeywordArguments</a>)?) | <a href="#prod-xquery40-KeywordArguments">KeywordArguments</a>)? ")"</code></span><span style="display: none;" class="add_version"><code>"(" ((<a href="#doc-xquery40-PositionalArguments">PositionalArguments</a> ("," <a href="#doc-xquery40-KeywordArguments">KeywordArguments</a>)?) | <a href="#doc-xquery40-KeywordArguments">KeywordArguments</a>)? ")"</code></span><span class="modify_version"><code>"(" ((<a href="#doc-xquery40-PositionalArguments">PositionalArguments</a> ("," <a href="#doc-xquery40-KeywordArguments">KeywordArguments</a>)?) | <a href="#doc-xquery40-KeywordArguments">KeywordArguments</a>)? ")"</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12615.doc-xquery40-PositionalArguments"></a><a id="noid_d4e10388.doc-xquery40-PositionalArguments"></a>[<span class="deltaxml-old">155</span><span class="deltaxml-new">144</span>]&nbsp;&nbsp;&nbsp;</td><td><code>PositionalArguments</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Argument">Argument</a> ("," <a href="#doc-xquery40-Argument">Argument</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Argument"></a>[<span class="deltaxml-old">176</span><span class="deltaxml-new">163</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Argument">Argument</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ExprSingle">ExprSingle</a> | <a href="#doc-xquery40-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ArgumentPlaceholder"></a>[<span class="deltaxml-old">177</span><span class="deltaxml-new">164</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"?"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12618.doc-xquery40-KeywordArguments"></a><a id="noid_d4e10391.doc-xquery40-KeywordArguments"></a>[<span class="deltaxml-old">156</span><span class="deltaxml-new">145</span>]&nbsp;&nbsp;&nbsp;</td><td><code>KeywordArguments</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-KeywordArgument">KeywordArgument</a> ("," <a href="#doc-xquery40-KeywordArgument">KeywordArgument</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-KeywordArgument"></a><a id="noid_d4e10392.doc-xquery40-KeywordArgument"></a>[<span class="deltaxml-old">157</span><span class="deltaxml-new">146</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-KeywordArgument">KeywordArgument</a></code></span><span style="display: none;" class="add_version"><code>KeywordArgument</code></span><span class="modify_version"><code><a href="#prod-xquery40-KeywordArgument"><span class="deltaxml-old">KeywordArgument</span></a><span class="deltaxml-new">KeywordArgument</span></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a> ":=" <a href="#doc-xquery40-Argument">Argument</a></code></td><td></td></tr></tbody></table><p> [<a id="dt-static-function-call" title="static function call">Definition</a>: A <b>static function call</b> consists of an EQName followed by a parenthesized list of zero or more arguments.] </p><p>The argument list consists of zero or more positional arguments, followed by zero or more keyword arguments.</p><p> [<a id="dt-arg-expr" title="argument expression">Definition</a>: An argument to a function call is either an <b>argument expression</b> or an <a href="#doc-xquery40-ArgumentPlaceholder">ArgumentPlaceholder</a> (<code>?</code>); in both cases it may either be supplied positionally, or identified by a name (called a keyword).] </p><p>This section is concerned with static function calls in which none of the arguments are <a href="#doc-xquery40-ArgumentPlaceholder">ArgumentPlaceholders</a>. Calls using one or more <a href="#doc-xquery40-ArgumentPlaceholder">ArgumentPlaceholders</a> are covered in the section <a href="#id-partial-function-application"><span style="display: none;" class="delete_version"><b>4.6.2.3 Partial Function Application</b></span><span style="display: none;" class="add_version"><b>4.4.2.2 Partial Function Application</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.2.3</span><span class="deltaxml-new">4.4.2.2</span> Partial Function Application</b></span></a>.</p><p>If the function name supplied in a static function call is an unprefixed <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, it is expanded using the <a title="default function namespace" class="termref" href="#dt-default-function-namespace">default function namespace</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>. </p><p><span style="display: none;" class="delete_version"> The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> used as the function name and the number of arguments used in the static function call (the required arity) must match the name and arity range of a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a><span> using the rules defined in the previous section</span>; if there is no match, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>]. </span><span style="display: none;" class="add_version"> The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> used as the function name, and the number of arguments in the static function call (the required arity) must match the name and arity range of a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a><span> using the rules defined in the previous section</span>; if there is no match, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>]. </span><span class="modify_version"> The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> used as the function name<span class="deltaxml-new">,</span> and the number of arguments <span class="deltaxml-old">used </span>in the static function call (the required arity) must match the name and arity range of a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a><span> using the rules defined in the previous section</span>; if there is no match, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>]. </span></p><p>Evaluation of static function calls is described in <a href="#id-eval-static-function-call"><span style="display: none;" class="delete_version"><b>4.6.1.2 Evaluating Static Function Calls</b></span><span style="display: none;" class="add_version"><b>4.4.1.2 Evaluating Static Function Calls</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.1.2</span><span class="deltaxml-new">4.4.1.2</span> Evaluating Static Function Calls</b></span></a> .</p><p>Since the arguments of a function call are separated by commas, any <a title="argument expression" class="termref" href="#dt-arg-expr">argument expression</a> that contains a top-level <a title="comma operator" class="termref" href="#dt-comma-operator">comma operator</a> must be enclosed in parentheses. Here are some illustrative examples of static function calls:</p><ul><li><p><code>my:three-argument-function(1, 2, 3)</code> denotes a static function call with three <span>positional</span> arguments. <span>The corresponding function declaration must define at least three parameters, and may define more, provided they are optional.</span></p></li><li><p><code>my:two-argument-function((1,2), 3)</code> denotes a static function call with two arguments, the first of which is a sequence of two values. <span>The corresponding function declaration must define at least two parameters, and may define more, provided they are optional.</span></p></li><li><p><code>my:two-argument-function(1, ())</code> denotes a static function call with two arguments, the second of which is an empty sequence.</p></li><li><p><code>my:one-argument-function((1, 2, 3))</code> denotes a static function call with one argument that is a sequence of three values. </p></li><li><p><code>my:one-argument-function(( ))</code> denotes a static function call with one argument that is an empty sequence.</p></li><li><p><code>my:zero-argument-function( )</code> denotes a static function call with zero arguments.</p></li><li><p><span style="display: none;" class="delete_version"><code>lang(node := $n, language := 'de')</code> is a static function call with two keyword arguments. The corresponding function declaration defines two parameters, a required parameter <code>language</code> and an optional parameter <code>node</code>. This call supplies values for both parameters. It is equivalent to the call <code>fn:lang('de', $n)</code>. Note that the keyword arguments are in a different order from the parameter declarations. </span><span style="display: none;" class="add_version"><code>fn:lang(node:=$n, language:='de')</code> is a static function call with two keyword arguments. The corresponding function declaration defines two parameters, a required parameter <code>language</code> and an optional parameter <code>node</code>. This call supplies values for both parameters. It is equivalent to the call <code>fn:lang('de', $n)</code>. Note that the keyword arguments are in a different order from the parameter declarations. </span><span class="modify_version"><code><span class="deltaxml-old">lang</span><span class="deltaxml-new">fn:lang</span>(node<span class="deltaxml-old"> </span>:=<span class="deltaxml-old"> </span>$n, language<span class="deltaxml-old"> </span>:=<span class="deltaxml-old"> </span>'de')</code> is a static function call with two keyword arguments. The corresponding function declaration defines two parameters, a required parameter <code>language</code> and an optional parameter <code>node</code>. This call supplies values for both parameters. It is equivalent to the call <code>fn:lang('de', $n)</code>. Note that the keyword arguments are in a different order from the parameter declarations. </span></p></li><li><p><span style="display: none;" class="delete_version"><code>sort(//employee, key := fn($e) { xs:decimal($e/salary) })</code> is a static function call with one positional argument and one keyword argument. The corresponding function declaration defines three parameters, a required parameter <code>$input</code>, an optional parameter <code>$collation</code>, and an optional parameter <code>$key</code> This call supplies values for the first and third parameters, leaving the second parameter (<code>$collation</code>) to take its default value. The default value of the <code>$collation</code> parameter is given as <code>fn:default-collation()</code>, so the value supplied to the function is the default collation from the dynamic context of the caller. It is equivalent to the call <code>fn:sort(//employee, fn:default-collation(), fn($e) { xs:decimal($e/salary) })</code>. </span><span style="display: none;" class="add_version"><code>fn:sort(//employee, key := -&gt;{xs:decimal(salary)})</code> is a static function call with one positional argument and one keyword argument. The corresponding function declaration defines three parameters, a required parameter <code>$input</code>, an optional parameter <code>$collation</code>, and an optional parameter <code>$key</code> This call supplies values for the first and third parameters, leaving the second parameter (<code>$collation</code>) to take its default value. The default value of the <code>$collation</code> parameter is given as <code>fn:default-collation()</code>, so the value supplied to the function is the default collation from the dynamic context of the caller. It is equivalent to the call <code>fn:sort(//employee, fn:default-collation(), -&gt;{xs:decimal(salary)})</code>. </span><span class="modify_version"><code><span class="deltaxml-old">sort</span><span class="deltaxml-new">fn:sort</span>(//employee, key := <span class="deltaxml-old">fn($e) </span><span class="deltaxml-new">-&gt;</span>{<span class="deltaxml-old"> </span>xs:decimal(<span class="deltaxml-old">$e/</span>salary)<span class="deltaxml-old"> </span>})</code> is a static function call with one positional argument and one keyword argument. The corresponding function declaration defines three parameters, a required parameter <code>$input</code>, an optional parameter <code>$collation</code>, and an optional parameter <code>$key</code> This call supplies values for the first and third parameters, leaving the second parameter (<code>$collation</code>) to take its default value. The default value of the <code>$collation</code> parameter is given as <code>fn:default-collation()</code>, so the value supplied to the function is the default collation from the dynamic context of the caller. It is equivalent to the call <code>fn:sort(//employee, fn:default-collation(), <span class="deltaxml-old">fn($e) </span><span class="deltaxml-new">-&gt;</span>{<span class="deltaxml-old"> </span>xs:decimal(<span class="deltaxml-old">$e/</span>salary)<span class="deltaxml-old"> </span>})</code>. </span></p></li></ul><p><span style="display: none;" class="delete_version">An <code>EQName</code> in a <code>KeywordArgument</code> is expanded to a QName value; if there is no prefix, then the name is in no namespace (otherwise the prefix is resolved in the usual way). The keywords used in a function call (after expansion to QNames) must be distinct [<a title="err:XPST0017" href="#ERRXPST0017">err:XPST0017</a>]; [<a title="err:XPST0017" href="#ERRXPST0017">err:XPST0017</a>].</span><span style="display: none;" class="add_version">An <code>EQName</code> in a <code>KeywordArgument</code> is expanded to a QName value; if there is no prefix, then the name is in no namespace (otherwise the prefix is resolved in the usual way). The keywords used in a function call (after expansion to QNames) must be distinct [<a title="err:XPST0141" href="#ERRXPST0141">err:XPST0141</a>]; [<a title="err:XPST0142" href="#ERRXPST0142">err:XPST0142</a>].</span><span class="modify_version">An <code>EQName</code> in a <code>KeywordArgument</code> is expanded to a QName value; if there is no prefix, then the name is in no namespace (otherwise the prefix is resolved in the usual way). The keywords used in a function call (after expansion to QNames) must be distinct [<a title="err:XPST0017" href="#ERRXPST0017"><span class="deltaxml-old">err:XPST0017</span></a><a title="err:XPST0141" href="#ERRXPST0141"><span class="deltaxml-new">err:XPST0141</span></a>]; [<a title="err:XPST0017" href="#ERRXPST0017"><span class="deltaxml-old">err:XPST0017</span></a><a title="err:XPST0142" href="#ERRXPST0142"><span class="deltaxml-new">err:XPST0142</span></a>].</span></p></div><div class="div4"><h5><a id="id-eval-static-function-call"></a><span class="deltaxml-old">4.6.1.2</span><span class="deltaxml-new">4.4.1.2</span> Evaluating Static Function Calls</h5><p><span style="display: none;" class="delete_version">This section applies to static function calls where none of the arguments is an <code>ArgumentPlaceholder</code>. For function calls involving placeholders, see <a href="#id-partial-function-application"><span class="delete_version"><b>4.6.2.3 Partial Function Application</b></span><span class="modify_version"><b>4.6.2.3 Partial Function Application</b></span></a>.</span><span style="display: none;" class="add_version">This section applies to static function calls where none of the arguments is an <code>ArgumentPlaceholder</code>. For function calls involving placeholders, see <a href="#id-partial-function-application"><span class="add_version"><b>4.4.2.2 Partial Function Application</b></span><span class="modify_version"><b>4.4.2.2 Partial Function Application</b></span></a>.</span><span class="modify_version">This section applies to static function calls where none of the arguments is an <code>ArgumentPlaceholder</code>. For function calls involving placeholders, see <a href="#id-partial-function-application"><span style="display: none;" class="delete_version"><b>4.6.2.3 Partial Function Application</b></span><span style="display: none;" class="add_version"><b>4.4.2.2 Partial Function Application</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.2.3</span><span class="deltaxml-new">4.4.2.2</span> Partial Function Application</b></span></a>.</span></p><p> When a static function call <var>FC</var> is evaluated with respect to a static context <var>SC</var> and a dynamic context <var>DC</var>, the result is obtained as follows: </p><ol class="enumar"><li><p> The <a title="function definition" class="termref" href="#dt-function-definition">function definition</a><var>FD</var> to be used is found in the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a> of <var>SC</var>. </p><p>The <b>required arity</b> is the total number of arguments in the function call, including both positional and keyword arguments.</p><p><span style="display: none;" class="delete_version"> There can be at most one <a title="function definition" class="termref" href="#dt-function-definition">function definition</a><var>FD</var> in the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a> component of <var>SC</var> whose function name matches the expanded QName in <var>FC</var> and whose <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> includes the arity of <var>FC</var>’s <code>ArgumentList</code>. </span><span style="display: none;" class="add_version"> There can be at most one <a title="function definition" class="termref" href="#dt-function-definition">function definition</a><var>FD</var> in the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a> component of <var>SC</var> whose function name matches the expanded QName in <var>FC</var> and whose <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> includes the arity of <var>FC</var>'s <code>ArgumentList</code>. </span><span class="modify_version"> There can be at most one <a title="function definition" class="termref" href="#dt-function-definition">function definition</a><var>FD</var> in the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a> component of <var>SC</var> whose function name matches the expanded QName in <var>FC</var> and whose <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> includes the arity of <var>FC</var><span class="deltaxml-old">’</span><span class="deltaxml-new">'</span>s <code>ArgumentList</code>. </span></p><p>If there is no such <a title="function definition" class="termref" href="#dt-function-definition">function definition</a>, a static error [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>] is raised.</p></li><li><p>Each parameter in the <a title="function definition" class="termref" href="#dt-function-definition">function definition</a><var>FD</var> is matched to an argument expression as follows:</p><ol class="enumla"><li><p>If there are <var>N</var> positional arguments in the function call, the corresponding argument expressions are matched pairwise to the first <var>N</var> parameters in the declaration. For this purpose the required parameters and optional parameters in <var>FD</var> are concatenated into a single list, in order.</p></li><li><p><span style="display: none;" class="delete_version">Any keyword arguments in <var>FC</var> are then matched to parameters (whether required or optional) in <var>FD</var> by comparing the keyword used in <var>FC</var> with the paramater name declared in <var>FD</var>. Each keyword must match the name of a declared parameter [<a title="err:XPST0017" href="#ERRXPST0017">err:XPST0017</a>], and this must be one that has not already been matched to a positional argument. [<a title="err:XPST0017" href="#ERRXPST0017">err:XPST0017</a>].</span><span style="display: none;" class="add_version">Any keyword arguments in <var>FC</var> are then matched to parameters (whether required or optional) in <var>FD</var> by comparing the keyword used in <var>FC</var> with the paramater name declared in <var>FD</var>. Each keyword must match the name of a declared parameter [<a title="err:XPST0142" href="#ERRXPST0142">err:XPST0142</a>], and this must be one that has not already been matched to a positional argument. [<a title="err:XPST0141" href="#ERRXPST0141">err:XPST0141</a>].</span><span class="modify_version">Any keyword arguments in <var>FC</var> are then matched to parameters (whether required or optional) in <var>FD</var> by comparing the keyword used in <var>FC</var> with the paramater name declared in <var>FD</var>. Each keyword must match the name of a declared parameter [<a title="err:XPST0017" href="#ERRXPST0017"><span class="deltaxml-old">err:XPST0017</span></a><a title="err:XPST0142" href="#ERRXPST0142"><span class="deltaxml-new">err:XPST0142</span></a>], and this must be one that has not already been matched to a positional argument. [<a title="err:XPST0017" href="#ERRXPST0017"><span class="deltaxml-old">err:XPST0017</span></a><a title="err:XPST0141" href="#ERRXPST0141"><span class="deltaxml-new">err:XPST0141</span></a>].</span></p></li><li><p><span style="display: none;" class="delete_version">If any required parameter has not been matched to any argument in <var>FC</var> by applying the above rules, a static error is reported [<a title="err:XPST0017" href="#ERRXPST0017">err:XPST0017</a>] </span><span style="display: none;" class="add_version">If any required parameter has not been matched to any argument in <var>FC</var> by applying the above rules, a static error is reported [<a title="err:XPST0141" href="#ERRXPST0141">err:XPST0141</a>] </span><span class="modify_version">If any required parameter has not been matched to any argument in <var>FC</var> by applying the above rules, a static error is reported [<a title="err:XPST0017" href="#ERRXPST0017"><span class="deltaxml-old">err:XPST0017</span></a><a title="err:XPST0141" href="#ERRXPST0141"><span class="deltaxml-new">err:XPST0141</span></a>] </span></p></li><li><p>If any optional parameter has not been matched to any argument in <var>FC</var> by applying the above rules, then the parameter is matched to the default value expression for that parameter in <var>FD</var>.</p></li></ol></li><li><p> Each argument expression established by the above rules is evaluated with respect to DC. The order of argument evaluation is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation dependent</a> and it is not required that an argument be evaluated if the function body can be evaluated without evaluating that argument.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>All argument expressions, including default value expressions, are evaluated in the dynamic context of the function call. It is therefore possible to use a default value expression such as <code>.</code>, or <code>/</code>, or <code>fn:current-dateTime()</code>, whose value depends on the dynamic context of the function call.</p></div><p>If the expression used for the default value of a parameter has no dependencies on the dynamic context, then an implementation <strong>may</strong> choose to reuse the same value on repeated function calls rather than re-evaluating it on each function call.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This is relevant, for example, if the expression constructs new nodes.</p></div></li><li><p><span style="display: none;" class="delete_version">The result of evaluating the argument expression is converted to the required type (the declared type associated with the corresponding parameter in the function declaration, defaulting to <code>item()*</code>) by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. <span>This applies both to explicitly supplied arguments, and to values obtained by evaluating default value expressions. In both cases a type error will be raised if the value (after coercion) does not match the required type.</span></span><span style="display: none;" class="add_version">The result of evaluating the argument expression is converted to the required type (the declared type associated with the corresponding parameter in the function declaration, defaulting to <code>item()*</code>) by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</span><span class="modify_version">The result of evaluating the argument expression is converted to the required type (the declared type associated with the corresponding parameter in the function declaration, defaulting to <code>item()*</code>) by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.<span class="deltaxml-old"> </span><span class="deltaxml-old">This applies both to explicitly supplied arguments, and to values obtained by evaluating default value expressions. In both cases a type error will be raised if the value (after coercion) does not match the required type.</span></span></p></li><li><p>The result of the function call is obtained as follows:</p><ul><li><p><span style="display: none;" class="delete_version"><var>FD</var>’s <span>body</span> is invoked in an implementation-dependent way. The processor makes the following information available to that invocation: </span><span style="display: none;" class="add_version"><var>FD</var>'s <span>body</span> is invoked in an implementation-dependent way. The processor makes the following information available to that invocation: </span><span class="modify_version"><var>FD</var><span class="deltaxml-old">’</span><span class="deltaxml-new">'</span>s <span>body</span> is invoked in an implementation-dependent way. The processor makes the following information available to that invocation: </span></p><ul><li><p>The converted argument values;</p></li><li><p>If the function is <a title="context dependent" class="termref" href="#dt-context-dependent">context dependent</a>, the static context <var>SC</var> and dynamic context <var>DC</var> of the function call. </p></li></ul></li><li><p>The result is converted to the required type (the declared return type in the function declaration, defaulting to <code>item()*</code>) by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p><p><span style="display: none;" class="delete_version">The result of applying the coercion rules is either an instance of <var>FD</var>’s return type or a dynamic error. This result is then the result of evaluating <var>FC</var>.</span><span style="display: none;" class="add_version">The result of applying the coercion rules is either an instance of <var>FD</var>'s return type or a dynamic error. This result is then the result of evaluating <var>FC</var>.</span><span class="modify_version">The result of applying the coercion rules is either an instance of <var>FD</var><span class="deltaxml-old">’</span><span class="deltaxml-new">'</span>s return type or a dynamic error. This result is then the result of evaluating <var>FC</var>.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>A host language may define alternative rules for processing the result, especially in the case of external functions implemented using a non-XDM type system.</p></div></li><li><p> Errors raised by <span class="deltaxml-old">system</span><span class="deltaxml-new">built-in</span> functions are defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>. </p></li><li class="xquery"><p> Errors raised by external functions are <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> (see <a href="#id-consistency-constraints"><b>2.3.5 Consistency Constraints</b></a>). </p></li></ul><div class="example"><div class="exampleHeader"><a id="d3e14240"></a><a id="d3e11799"></a>Example: A <span class="deltaxml-old">System</span><span class="deltaxml-new">Built-in</span> Function</div><p><span style="display: none;" class="delete_version">The following function call uses the function <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-base-uri">Section 2.5 fn:base-uri</a><sup><small>FO40</small></sup>. Use of <code>SC</code> and <code>DC</code> and errors raised by this function are all defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>.</span><span style="display: none;" class="add_version">The following function call uses the function <a href="https://www.w3.org/TR/xpath-functions-31/#func-base-uri">Section 2.5 fn:base-uri </a><sup><small>FO31</small></sup>. Use of <code>SC</code> and <code>DC</code> and errors raised by this function are all defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>.</span><span class="modify_version">The following function call uses the function <a href="https://www.w3.org/TR/xpath-functions-31/#func-base-uri">Section 2.5 fn:base-uri<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>. Use of <code>SC</code> and <code>DC</code> and errors raised by this function are all defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>.</span></p><div class="exampleInner"><pre><span class="deltaxml-old">base-uri()</span></pre><pre><span class="deltaxml-new">fn:base-uri()</span></pre></div></div></li></ol></div></div><div class="div3"><h4><a id="id-dynamic-functions"></a><span class="deltaxml-old">4.6.2</span><span class="deltaxml-new">4.4.2</span> Function Items</h4><p>A <a title="function item" class="termref" href="#dt-function-item">function item</a> is an XDM value that can be bound to a variable, or manipulated in various ways by XQuery 4.0 expressions. The most significant such expression is a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a>, which supplies values of arguments and evaluates the function to produce a result.</p><p>The syntax of dynamic function calls is defined in <a href="#id-dynamic-function-invocation"><span style="display: none;" class="delete_version"><b>4.6.2.1 Dynamic Function Calls</b></span><span style="display: none;" class="add_version"><b>4.5.2 Dynamic Function Calls</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.2.1</span><span class="deltaxml-new">4.5.2</span> Dynamic Function Calls</b></span></a>.</p><p>A number of constructs can be used to produce a <a title="function item" class="termref" href="#dt-function-item">function item</a>, notably:</p><ul><li><p><span style="display: none;" class="delete_version">A <b>named function reference</b> (see <a href="#id-named-function-ref"><span class="delete_version"><b>4.6.2.4 Named Function References</b></span><span class="modify_version"><b>4.6.2.4 Named Function References</b></span></a>) constructs a function item by reference to <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> in the static context. For example, <code>fn:node-name#1</code> returns a function item whose effect is to call the static <code>fn:node-name</code> function with one argument.</span><span style="display: none;" class="add_version">A <b>named function reference</b> (see <a href="#id-named-function-ref"><span class="add_version"><b>4.4.2.3 Named Function References</b></span><span class="modify_version"><b>4.4.2.3 Named Function References</b></span></a>) constructs a function item by reference to <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> in the static context: for example <code>fn:node-name#1</code> returns a function item whose effect is to call the static <code>fn:node-name</code> function with one argument.</span><span class="modify_version">A <b>named function reference</b> (see <a href="#id-named-function-ref"><span style="display: none;" class="delete_version"><b>4.6.2.4 Named Function References</b></span><span style="display: none;" class="add_version"><b>4.4.2.3 Named Function References</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.2.4</span><span class="deltaxml-new">4.4.2.3</span> Named Function References</b></span></a>) constructs a function item by reference to <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> in the static context<span class="deltaxml-old">. For example,</span><span class="deltaxml-new">: for example</span> <code>fn:node-name#1</code> returns a function item whose effect is to call the static <code>fn:node-name</code> function with one argument.</span></p></li><li><p><span style="display: none;" class="delete_version">An <b>inline function</b> (see <a href="#id-inline-func"><span class="delete_version"><b>4.6.2.5 Inline Function Expressions</b></span><span class="modify_version"><b>4.6.2.5 Inline Function Expressions</b></span></a> ) constructs a function item whose <span>body</span> is defined locally. For example, the construct <code>fn($x) { $x + 1 }</code> returns a function item whose effect is to increment the value of the supplied argument.</span><span style="display: none;" class="add_version">An <b>inline function</b> (see <a href="#id-inline-func"><span class="add_version"><b>4.4.2.4 Inline Function Expressions</b></span><span class="modify_version"><b>4.4.2.4 Inline Function Expressions</b></span></a>) constructs a function item whose <span>body</span> is defined locally. For example the construct <code>-&gt;($x){$x+1}</code> returns a function item whose effect is to increment the value of the supplied argument.</span><span class="modify_version">An <b>inline function</b> (see <a href="#id-inline-func"><span style="display: none;" class="delete_version"><b>4.6.2.5 Inline Function Expressions</b></span><span style="display: none;" class="add_version"><b>4.4.2.4 Inline Function Expressions</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.2.5</span><span class="deltaxml-new">4.4.2.4</span> Inline Function Expressions</b></span></a><span class="deltaxml-old"> </span>) constructs a function item whose <span>body</span> is defined locally. For example<span class="deltaxml-old">,</span> the construct <code><span class="deltaxml-old">fn</span><span class="deltaxml-new">-&gt;</span>($x)<span class="deltaxml-old"> </span>{<span class="deltaxml-old"> </span>$x<span class="deltaxml-old"> </span>+<span class="deltaxml-old"> </span>1<span class="deltaxml-old"> </span>}</code> returns a function item whose effect is to increment the value of the supplied argument.</span></p></li><li><p><span style="display: none;" class="delete_version">A <b>partial function application</b> (see <a href="#id-partial-function-application"><span class="delete_version"><b>4.6.2.3 Partial Function Application</b></span><span class="modify_version"><b>4.6.2.3 Partial Function Application</b></span></a>) derives one function item from another by supplying the values of some of its arguments. For example, <code>fn:ends-with(?, ".txt")</code> returns a function item with one argument that tests whether the supplied string ends with the substring <code>".txt"</code>.</span><span style="display: none;" class="add_version">A <b>partial function application</b> (see <a href="#id-partial-function-application"><span class="add_version"><b>4.4.2.2 Partial Function Application</b></span><span class="modify_version"><b>4.4.2.2 Partial Function Application</b></span></a>) derives one function item from another by supplying the values of some of its arguments. For example, <code>fn:ends-with(?, ".txt")</code> returns a function item with one argument that tests whether the supplied string ends with the substring <code>".txt"</code>.</span><span class="modify_version">A <b>partial function application</b> (see <a href="#id-partial-function-application"><span style="display: none;" class="delete_version"><b>4.6.2.3 Partial Function Application</b></span><span style="display: none;" class="add_version"><b>4.4.2.2 Partial Function Application</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.2.3</span><span class="deltaxml-new">4.4.2.2</span> Partial Function Application</b></span></a>) derives one function item from another by supplying the values of some of its arguments. For example, <code>fn:ends-with(?, ".txt")</code> returns a function item with one argument that tests whether the supplied string ends with the substring <code>".txt"</code>.</span></p></li><li><p>Maps and arrays are also function items. See <a href="#id-map-constructors"><span style="display: none;" class="delete_version"><b>4.14.1.1 Map Constructors</b></span><span style="display: none;" class="add_version"><b>4.13.1.1 Map Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.14.1.1</span><span class="deltaxml-new">4.13.1.1</span> Map Constructors</b></span></a> and <a href="#id-array-constructors"><span style="display: none;" class="delete_version"><b>4.14.2.1 Array Constructors</b></span><span style="display: none;" class="add_version"><b>4.13.2.1 Array Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.14.2.1</span><span class="deltaxml-new">4.13.2.1</span> Array Constructors</b></span></a>.</p></li><li><p>The <code>fn:function-lookup</code> function can be called to discover functions that are present in the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a>.</p></li><li><p>The <code>fn:load-xquery-module</code> function can be called to load functions dynamically from an external XQuery library module.</p></li><li><p><span style="display: none;" class="delete_version">Some system functions such as <code>fn:random-number-generator</code> and <code>fn:op</code> return a <a title="function item" class="termref" href="#dt-function-item">function item</a> as their result.</span><span style="display: none;" class="add_version">Some built-in functions such as <code>fn:random-number-generator</code> and <code>fn:op</code> return a <a title="function item" class="termref" href="#dt-function-item">function item</a> as their result.</span><span class="modify_version">Some <span class="deltaxml-old">system</span><span class="deltaxml-new">built-in</span> functions such as <code>fn:random-number-generator</code> and <code>fn:op</code> return a <a title="function item" class="termref" href="#dt-function-item">function item</a> as their result.</span></p></li></ul><p>These constructs are described in detail in the following sections, or in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>.</p><div class="div4"><h5><a id="id-dynamic-function-invocation"></a><span class="deltaxml-old">4.6.2.1 Dynamic Function Calls</span></h5><a id="d3e14344"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DynamicFunctionCall"></a><span class="deltaxml-old">[152]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-DynamicFunctionCall"><span class="deltaxml-old">DynamicFunctionCall</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-PostfixExpr"><span class="deltaxml-old">PostfixExpr</span></a><a href="#doc-xquery40-PositionalArgumentList"><span class="deltaxml-old">PositionalArgumentList</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PositionalArgumentList"></a><span class="deltaxml-old">[154]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-PositionalArgumentList"><span class="deltaxml-old">PositionalArgumentList</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"(" </span><a href="#doc-xquery40-PositionalArguments"><span class="deltaxml-old">PositionalArguments</span></a><span class="deltaxml-old">? ")"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PositionalArguments"></a><span class="deltaxml-old">[155]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-PositionalArguments"><span class="deltaxml-old">PositionalArguments</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-Argument"><span class="deltaxml-old">Argument</span></a><span class="deltaxml-old"> ("," </span><a href="#doc-xquery40-Argument"><span class="deltaxml-old">Argument</span></a><span class="deltaxml-old">)*</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e13092.doc-xquery40-Argument"></a><span class="deltaxml-old">[176]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">Argument</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-ExprSingle"><span class="deltaxml-old">ExprSingle</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-ArgumentPlaceholder"><span class="deltaxml-old">ArgumentPlaceholder</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e13093.doc-xquery40-ArgumentPlaceholder"></a><span class="deltaxml-old">[177]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">ArgumentPlaceholder</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"?"</span></code></td><td></td></tr></tbody></table><p><span class="deltaxml-old"> [</span><a id="dt-dynamic-function-invocation" title="dynamic function call"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">dynamic function call</span></b><span class="deltaxml-old"> consists of a base expression that returns the function and a parenthesized list of zero or more arguments (</span><a title="argument expression" class="termref" href="#dt-arg-expr"><span class="deltaxml-old">argument expressions</span></a><span class="deltaxml-old"> or ArgumentPlaceholders).] </span></p><p><span class="deltaxml-old"> A dynamic function call is evaluated as described in </span><a href="#id-eval-dynamic-function-call"><b><span class="deltaxml-old">4.6.2.2 Evaluating Dynamic Function Calls</span></b></a><span class="deltaxml-old">. </span></p><p><span class="deltaxml-old">The following are examples of some dynamic function calls:</span></p><ul><li><p><span class="deltaxml-old">This example calls the function contained in </span><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old">, passing the arguments 2 and 3: </span></p><div class="exampleInner"><pre><span class="deltaxml-old">$f(2, 3)</span></pre></div></li><li><p><span class="deltaxml-old">This example fetches the second item from sequence </span><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old">, treats it as a function and calls it, passing an </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> argument: </span></p><div class="exampleInner"><pre><span class="deltaxml-old">$f[2]("Hi there")</span></pre></div></li><li><p><span class="deltaxml-old">This example calls the function </span><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old"> passing no arguments, and filters the result with a positional predicate: </span></p><div class="exampleInner"><pre><span class="deltaxml-old">$f()[2]</span></pre></div></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Arguments in a dynamic function call are always supplied positionally.</span></p></div></div><div class="div4"><h5><a id="id-eval-dynamic-function-call"></a><span class="deltaxml-old">4.6.2.2</span><span class="deltaxml-new">4.4.2.1</span> Evaluating Dynamic Function Calls</h5><p><span style="display: none;" class="delete_version">This section applies to dynamic function calls whose arguments do not include an <code>ArgumentPlaceholder</code>. For function calls that include a placeholder, see <a href="#id-partial-function-application"><span class="delete_version"><b>4.6.2.3 Partial Function Application</b></span><span class="modify_version"><b>4.6.2.3 Partial Function Application</b></span></a>.</span><span style="display: none;" class="add_version">This section applies to dynamic function calls whose arguments do not include an <code>ArgumentPlaceholder</code>. For function calls that include a placeholder, see <a href="#id-partial-function-application"><span class="add_version"><b>4.4.2.2 Partial Function Application</b></span><span class="modify_version"><b>4.4.2.2 Partial Function Application</b></span></a>.</span><span class="modify_version">This section applies to dynamic function calls whose arguments do not include an <code>ArgumentPlaceholder</code>. For function calls that include a placeholder, see <a href="#id-partial-function-application"><span style="display: none;" class="delete_version"><b>4.6.2.3 Partial Function Application</b></span><span style="display: none;" class="add_version"><b>4.4.2.2 Partial Function Application</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.2.3</span><span class="deltaxml-new">4.4.2.2</span> Partial Function Application</b></span></a>.</span></p><p> [<a id="dt-dynamic-function-call" title="dynamic function call">Definition</a>: A <b>dynamic function call</b> is an expression that is evaluated by calling a <a title="function item" class="termref" href="#dt-function-item">function item</a>, which is typically obtained dynamically.] </p><p> When a dynamic function call <var>FC</var> is evaluated, the result is obtained as follows: </p><ol class="enumar"><li><p><span style="display: none;" class="delete_version"> The <a title="function item" class="termref" href="#dt-function-item">function item</a><var>FI</var> to be called is obtained by evaluating the base expression of the function call. If this yields a sequence consisting of a single function item whose arity matches the number of arguments in the <code>ArgumentList</code>, let <var>FI</var> denote that function item. Otherwise, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. </span><span style="display: none;" class="add_version"> The <a title="function item" class="termref" href="#dt-function-item">function item</a><var>F</var> to be called is obtained by evaluating the base expression of the function call. If this yields a sequence consisting of a single function item whose arity matches the number of arguments in the <code>ArgumentList</code>, let <var>F</var> denote that function item. Otherwise, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. </span><span class="modify_version"> The <a title="function item" class="termref" href="#dt-function-item">function item</a><var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var> to be called is obtained by evaluating the base expression of the function call. If this yields a sequence consisting of a single function item whose arity matches the number of arguments in the <code>ArgumentList</code>, let <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var> denote that function item. Otherwise, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Keyword arguments are not allowed in a dynamic function call.</p></div></li><li><p><a title="argument expression" class="termref" href="#dt-arg-expr">Argument expressions</a> are evaluated, producing <b>argument values</b>. The order of argument evaluation is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> and an argument need not be evaluated if the function body can be evaluated without evaluating that argument.</p></li><li><p><span style="display: none;" class="delete_version"> Each argument value is converted to the corresponding parameter type in <var>FI</var>’s signature by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, resulting in a <b>converted argument value</b></span><span style="display: none;" class="add_version"> Each argument value is converted to the corresponding parameter type in <var>F</var>'s signature by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, resulting in a <b>converted argument value</b> . </span><span class="modify_version"> Each argument value is converted to the corresponding parameter type in <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var><span class="deltaxml-old">’</span><span class="deltaxml-new">'</span>s signature by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, resulting in a <b>converted argument value</b><span class="deltaxml-new"> . </span></span></p></li><li><p><span style="display: none;" class="delete_version">If <var>FI</var> is a map, it is evaluated as described in <a href="#id-map-lookup"><span class="delete_version"><b>4.14.1.2 Map Lookup using Function Call Syntax</b></span><span class="modify_version"><b>4.14.1.2 Map Lookup using Function Call Syntax</b></span></a>.</span><span style="display: none;" class="add_version">If <var>F</var> is a map, it is evaluated as described in <a href="#id-map-lookup"><span class="add_version"><b>4.13.1.2 Map Lookup using Function Call Syntax</b></span><span class="modify_version"><b>4.13.1.2 Map Lookup using Function Call Syntax</b></span></a>.</span><span class="modify_version">If <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var> is a map, it is evaluated as described in <a href="#id-map-lookup"><span style="display: none;" class="delete_version"><b>4.14.1.2 Map Lookup using Function Call Syntax</b></span><span style="display: none;" class="add_version"><b>4.13.1.2 Map Lookup using Function Call Syntax</b></span><span class="modify_version"><b><span class="deltaxml-old">4.14.1.2</span><span class="deltaxml-new">4.13.1.2</span> Map Lookup using Function Call Syntax</b></span></a>.</span></p></li><li><p><span style="display: none;" class="delete_version">If <var>FI</var> is an array, it is evaluated as described in <a href="#id-array-lookup"><span class="delete_version"><b>4.14.2.2 Array Lookup using Function Call Syntax</b></span><span class="modify_version"><b>4.14.2.2 Array Lookup using Function Call Syntax</b></span></a>.</span><span style="display: none;" class="add_version">If <var>F</var> is an array, it is evaluated as described in <a href="#id-array-lookup"><span class="add_version"><b>4.13.2.2 Array Lookup using Function Call Syntax</b></span><span class="modify_version"><b>4.13.2.2 Array Lookup using Function Call Syntax</b></span></a>.</span><span class="modify_version">If <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var> is an array, it is evaluated as described in <a href="#id-array-lookup"><span style="display: none;" class="delete_version"><b>4.14.2.2 Array Lookup using Function Call Syntax</b></span><span style="display: none;" class="add_version"><b>4.13.2.2 Array Lookup using Function Call Syntax</b></span><span class="modify_version"><b><span class="deltaxml-old">4.14.2.2</span><span class="deltaxml-new">4.13.2.2</span> Array Lookup using Function Call Syntax</b></span></a>.</span></p></li><li><p><span style="display: none;" class="delete_version"> If <var>FI</var>’s <span>body</span> is an XQuery 4.0 expression (for example, if <var>FI</var> is <span class="xquery">a <a title="user-defined function" class="termref" href="#dt-udf">user-defined function</a> or</span> an <a title="anonymous function" class="termref" href="#dt-anonymous-function">anonymous function</a>, or a <a title="partially applied function" class="termref" href="#dt-partially-applied-function">partial application</a> of such a function): </span><span style="display: none;" class="add_version"> If <var>F</var>'s <span>body</span> is an XQuery 4.0 expression (for example, if <var>F</var> is <span class="xquery">a <a title="user-defined function" class="termref" href="#dt-udf">user-defined function</a> or</span> an <a title="anonymous function" class="termref" href="#dt-anonymous-function">anonymous function</a>, or a <a title="partially applied function" class="termref" href="#dt-partially-applied-function">partial application</a> of such a function): </span><span class="modify_version"> If <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var><span class="deltaxml-old">’</span><span class="deltaxml-new">'</span>s <span>body</span> is an XQuery 4.0 expression (for example, if <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var> is <span class="xquery">a <a title="user-defined function" class="termref" href="#dt-udf">user-defined function</a> or</span> an <a title="anonymous function" class="termref" href="#dt-anonymous-function">anonymous function</a>, or a <a title="partially applied function" class="termref" href="#dt-partially-applied-function">partial application</a> of such a function): </span></p><ol class="enumla"><li><p><span style="display: none;" class="delete_version"><var>FI</var>’s <span>body</span> is evaluated. The static context for this evaluation is the static context of the XQuery 4.0 expression. The dynamic context for this evaluation is obtained by taking the dynamic context of the <span class="xquery">module</span> that contains the <code>FunctionBody</code>, and making the following changes: </span><span style="display: none;" class="add_version"><var>F</var>'s <span>body</span> is evaluated. The static context for this evaluation is the static context of the XQuery 4.0 expression. The dynamic context for this evaluation is obtained by taking the dynamic context of the <span class="xquery">module</span> that contains the <code>FunctionBody</code>, and making the following changes: </span><span class="modify_version"><var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var><span class="deltaxml-old">’</span><span class="deltaxml-new">'</span>s <span>body</span> is evaluated. The static context for this evaluation is the static context of the XQuery 4.0 expression. The dynamic context for this evaluation is obtained by taking the dynamic context of the <span class="xquery">module</span> that contains the <code>FunctionBody</code>, and making the following changes: </span></p><ul><li><p><span style="display: none;" class="delete_version"> The <a title="focus" class="termref" href="#dt-focus">focus</a> (context value, context position, and context size) is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>. </span><span style="display: none;" class="add_version"> The <a title="focus" class="termref" href="#dt-focus">focus</a> (context item, context position, and context size) is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. </span><span class="modify_version"> The <a title="focus" class="termref" href="#dt-focus">focus</a> (context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>, context position, and context size) is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>. </span></p></li><li><p> In the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a> component of the dynamic context, each converted argument value is bound to the corresponding parameter name. </p><p><span>When this is done, the converted argument values retain their <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic types</a>, even where these are <a title="subtype" class="termref" href="#dt-subtype">subtypes</a> of the declared parameter types.</span> For example, a function with a parameter <code>$p</code> of type <code>xs:decimal</code> can be called with an argument of type <code>xs:integer</code>, which is derived from <code>xs:decimal</code>. During the processing of this function call, the value of <code>$p</code> inside the body of the function retains its <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> of <code>xs:integer</code>. </p></li><li><p><span style="display: none;" class="delete_version"><var>FI</var>’s nonlocal variable bindings are also added to the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a>. (Note that the names of the nonlocal variables are by definition disjoint from the parameter names, so there can be no conflict.) </span><span style="display: none;" class="add_version"> F's nonlocal variable bindings are also added to the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a>. (Note that the names of the nonlocal variables are by definition disjoint from the parameter names, so there can be no conflict.) </span><span class="modify_version"><span class="deltaxml-old">FI</span><span class="deltaxml-old">’s</span><span class="deltaxml-new"> F's</span> nonlocal variable bindings are also added to the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a>. (Note that the names of the nonlocal variables are by definition disjoint from the parameter names, so there can be no conflict.) </span></p></li></ul></li><li><p><span style="display: none;" class="delete_version"> The value returned by evaluating the function body is then converted to the declared return type of <var>FI</var> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. The result is then the result of evaluating <var>FC</var>. </span><span style="display: none;" class="add_version"> The value returned by evaluating the function body is then converted to the declared return type of <var>F</var> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. The result is then the result of evaluating <var>FC</var>. </span><span class="modify_version"> The value returned by evaluating the function body is then converted to the declared return type of <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. The result is then the result of evaluating <var>FC</var>. </span></p><p><span style="display: none;" class="delete_version"> As with argument values, the value returned by a function retains its <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a>, which may be a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the declared return type of <var>FI</var>. For example, a function that has a declared return type of <code>xs:decimal</code> may in fact return a value of dynamic type <code>xs:integer</code>. </span><span style="display: none;" class="add_version"> As with argument values, the value returned by a function retains its <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a>, which may be a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the declared return type of <var>F</var>. For example, a function that has a declared return type of <code>xs:decimal</code> may in fact return a value of dynamic type <code>xs:integer</code>. </span><span class="modify_version"> As with argument values, the value returned by a function retains its <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a>, which may be a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the declared return type of <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var>. For example, a function that has a declared return type of <code>xs:decimal</code> may in fact return a value of dynamic type <code>xs:integer</code>. </span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d3e14610"></a><a id="d3e12082"></a>Example: Derived Types and Nonlocal Variable Bindings</div><p><code>$incr</code> is a nonlocal variable that is available within the function because its variable binding has been added to the variable values of the function.. Even though the parameter and return type of this function are both <code>xs:decimal</code>, the more specific type <code>xs:integer</code> is preserved in both cases.</p><div class="exampleInner"><pre><span class="deltaxml-old">let $incr := 1 let $f := function($i as xs:decimal) as xs:decimal { $i + $incr } return $f(5)</span></pre><pre><span class="deltaxml-new">let $incr := 1, $f := function ($i as xs:decimal) as xs:decimal { $i + $incr } return $f(5) </span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d3e14622"></a><a id="d3e12094"></a>Example: Using the Context <span class="deltaxml-old">Value</span><span class="deltaxml-new">Item</span> in an Anonymous Function</div><p>The following example will raise a <a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-old">type error</span></a><span class="deltaxml-new">dynamic error</span> [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>]:</p><div class="exampleInner"><pre><span class="deltaxml-old">let $vat := function() { @vat + @price } return doc('wares.xml')/shop/article/$vat()</span></pre><pre><span class="deltaxml-new">let $vat := function() { @vat + @price } return shop/article/$vat()</span></pre></div><p>Instead, the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> can be used as an argument to the anonymous function:</p><div class="exampleInner"><pre><span class="deltaxml-old">let $vat := function($art) { $art/@vat + $art/@price } return doc('wares.xml')/shop/article/$vat(.)</span></pre><pre><span class="deltaxml-new">let $vat := function($art) { $art/@vat + $art/@price } return shop/article/$vat(.)</span></pre></div><p><span class="deltaxml-old">Alternatively</span><span class="deltaxml-new">Or</span>, the value can be referenced as a nonlocal variable binding:</p><div class="exampleInner"><pre><span class="deltaxml-old">let $ctx := doc('wares.xml')/shop/article let $vat := function() { for $a in $ctx return $a/@vat + $a/@price } return $vat()</span></pre><pre><span class="deltaxml-new">let $ctx := shop/article, $vat := function() { for $a in $ctx return $a/@vat + $a/@price } return $vat() </span></pre></div><p><span class="deltaxml-old">Finally, a </span><a title="focus function" class="termref" href="#dt-focus-function"><span class="deltaxml-old">focus function</span></a><span class="deltaxml-old"> can be used. This binds the value of the argument to the context value within the function body:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">let $vat := function { @vat + @price } return $vat(doc('wares.xml')/shop/article)</span></pre></div></div></li><li><p><span style="display: none;" class="delete_version"> If the implementation of <var>FI</var> is not an XQuery 4.0 expression (for example, <var>FI</var> is a <a class="termref" title="system function" href="#dt-system-function">system function</a><span class="xquery">or an <a title="external function" class="termref" href="#dt-external-function">external function</a>, </span> the <span>body</span> of the function is evaluated, and the result is converted to the declared return type, in the same way as for a static function call (see <a href="#id-function-calls"><span class="delete_version"><b>4.6.1.1 Static Function Call Syntax</b></span><span class="modify_version"><b>4.6.1.1 Static Function Call Syntax</b></span></a>).</span><span style="display: none;" class="add_version"> If <var>F</var>'s implementation is not an XQuery 4.0 expression (e.g., <var>F</var> is a <a class="termref" title="built-in function" href="#dt-built-in-function">built-in function</a><span class="xquery">or an <a title="external function" class="termref" href="#dt-external-function">external function</a>, </span> the <span>body</span> of the function is evaluated, and the result is converted to the declared return type, in the same way as for a static function call (see <a href="#id-function-calls"><span class="add_version"><b>4.4.1.1 Static Function Call Syntax</b></span><span class="modify_version"><b>4.4.1.1 Static Function Call Syntax</b></span></a>).</span><span class="modify_version"> If <var><span class="deltaxml-old">the</span><span class="deltaxml-new">F</span></var><span class="deltaxml-new">'s</span> implementation <span class="deltaxml-old">of </span><span class="deltaxml-old">FI</span><span class="deltaxml-old"> </span>is not an XQuery 4.0 expression (<span class="deltaxml-old">for example</span><span class="deltaxml-new">e.g.</span>, <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var> is a <a class="termref" title="built-in function" href="#dt-built-in-function"><span class="deltaxml-old">system</span><span class="deltaxml-new">built-in</span> function</a><span class="xquery">or an <a title="external function" class="termref" href="#dt-external-function">external function</a>, </span> the <span>body</span> of the function is evaluated, and the result is converted to the declared return type, in the same way as for a static function call (see <a href="#id-function-calls"><span style="display: none;" class="delete_version"><b>4.6.1.1 Static Function Call Syntax</b></span><span style="display: none;" class="add_version"><b>4.4.1.1 Static Function Call Syntax</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.1.1</span><span class="deltaxml-new">4.4.1.1</span> Static Function Call Syntax</b></span></a>).</span></p><p>Errors may be raised in the same way.</p></li></ol></div><div class="div4"><h5><a id="id-partial-function-application"></a><span class="deltaxml-old">4.6.2.3</span><span class="deltaxml-new">4.4.2.2</span> Partial Function Application</h5><p> [<a id="dt-partial-function-application" title="partial function application">Definition</a>: A static or <a title="dynamic function call" class="termref" href="#dt-dynamic-function-invocation">dynamic</a> function call is a <b>partial function application</b> if one or more arguments is an <a href="#doc-xquery40-ArgumentPlaceholder">ArgumentPlaceholder</a>.] </p><p>The rules for partial function application in static function calls and dynamic function calls have a great deal in common, but they are stated separately below for clarity.</p><p>In each case, the result of a partial function application is a <a title="function item" class="termref" href="#dt-function-item">function item</a>, whose arity is equal to the number of placeholders in the call.</p><p>More specifically, the result of the partial function application is a <a title="partially applied function" class="termref" href="#dt-partially-applied-function">partially applied function</a>. [<a id="dt-partially-applied-function" title="partially applied function">Definition</a>: A <b>partially applied function</b> is a function created by <a title="partial function application" class="termref" href="#dt-partial-function-application">partial function application</a>.] </p><p>For static function calls, the result is obtained as follows:</p><ol class="enumar"><li><p><span style="display: none;" class="delete_version">The <a title="function definition" class="termref" href="#dt-function-definition">function definition</a><var>FD</var> to be partially applied is determined in the same way as for a static function call without placeholders, as described in <a href="#id-function-calls"><span class="delete_version"><b>4.6.1.1 Static Function Call Syntax</b></span><span class="modify_version"><b>4.6.1.1 Static Function Call Syntax</b></span></a>. For this purpose an <code>ArgumentPlaceholder</code> contributes to the count of arguments.</span><span style="display: none;" class="add_version">The <a title="function definition" class="termref" href="#dt-function-definition">function definition</a><var>F</var> to be partially applied is determined in the same way as for a static function call without placeholders, as described in <a href="#id-function-calls"><span class="add_version"><b>4.4.1.1 Static Function Call Syntax</b></span><span class="modify_version"><b>4.4.1.1 Static Function Call Syntax</b></span></a>. For this purpose an <code>ArgumentPlaceholder</code> contributes to the count of arguments.</span><span class="modify_version">The <a title="function definition" class="termref" href="#dt-function-definition">function definition</a><var><span class="deltaxml-old">FD</span><span class="deltaxml-new">F</span></var> to be partially applied is determined in the same way as for a static function call without placeholders, as described in <a href="#id-function-calls"><span style="display: none;" class="delete_version"><b>4.6.1.1 Static Function Call Syntax</b></span><span style="display: none;" class="add_version"><b>4.4.1.1 Static Function Call Syntax</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.1.1</span><span class="deltaxml-new">4.4.1.1</span> Static Function Call Syntax</b></span></a>. For this purpose an <code>ArgumentPlaceholder</code> contributes to the count of arguments.</span></p></li><li><p><span style="display: none;" class="delete_version">The parameters of <var>FD</var> are classified into three categories:</span><span style="display: none;" class="add_version">The parameters of <var>F</var> are classified into three categories:</span><span class="modify_version">The parameters of <var><span class="deltaxml-old">FD</span><span class="deltaxml-new">F</span></var> are classified into three categories:</span></p><ul><li><p>Parameters that map to a placeholder, referred to as <b>placeholder parameters</b>.</p></li><li><p>Parameters for which an explicit value is given in the function call (either positionally or by keyword), referred to as <b>explicitly supplied parameters</b>.</p></li><li><p>Parameters (which are necessarily optional parameters) for which no corresponding argument is supplied, either as a placeholder or with an explicit value. These are referred to as <b>defaulted parameters</b>.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p><span class="deltaxml-new">A partial function application need not have any supplied parameters.</span></p><p><span style="display: none;" class="delete_version">A partial function application need not have any explicitly supplied parameters. For example, the partial function application <code>fn:string(?)</code> is allowed; it has exactly the same effect as the named function reference <code>fn:string#1</code>. </span><span style="display: none;" class="add_version">For example, the partial function application <code>fn:string(?)</code> is allowed; it has exactly the same effect as the named function reference <code>fn:string#1</code>. </span><span class="modify_version"><span class="deltaxml-old">A partial function application need not have any explicitly supplied parameters. </span>For example, the partial function application <code>fn:string(?)</code> is allowed; it has exactly the same effect as the named function reference <code>fn:string#1</code>. </span></p></div></li><li><p>Explicitly supplied parameters and defaulted parameters are evaluated and converted to the required type using the rules for a static function call.<span class="deltaxml-old"> This may result in an error being raised.</span></p><p><span class="deltaxml-old">A type error is raised if any of the explicitly supplied or defaulted parameters, after applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-old">coercion rules</span></a><span class="deltaxml-old">, does not match the required type of the corresponding parameter.</span></p><p><span class="deltaxml-old">In addition, a dynamic error </span><strong><span class="deltaxml-old">may</span></strong><span class="deltaxml-old"> be raised if any of the explicitly supplied or defaulted parameters does not match other constraints on the value of that parameter (for example, if the value supplied for a parameter expecting a regular expression is not a valid regular expression); or if the processor is able to establish that evaluation of the resulting function will fail for any other reason (for example, if an error is raised while evaluating a subexpression in the function body that depends only on explicitly supplied and defaulted parameters).</span></p><p><span class="deltaxml-old">In all cases the error code is the same as for a static function call supplying the same invalid value(s).</span></p><p><span class="deltaxml-old">In the particular case where all the supplied arguments are placeholders, the error behavior </span><strong><span class="deltaxml-old">should</span></strong><span class="deltaxml-old"> be the same as for an equivalent </span><a title="named function reference" class="termref" href="#dt-named-function-ref"><span class="deltaxml-old">named function reference</span></a><span class="deltaxml-old">: for example, </span><code><span class="deltaxml-old">fn:id#1</span></code><span class="deltaxml-old"> fails if there is no context node, and </span><code><span class="deltaxml-old">fn:id(?)</span></code><strong><span class="deltaxml-old">should</span></strong><span class="deltaxml-old"> fail likewise.</span></p></li><li><p><span style="display: none;" class="delete_version"> The result is a <a title="partially applied function" class="termref" href="#dt-partially-applied-function">partially applied function</a> having the following properties (which are defined in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items">Section 2.9.4 Function Items</a><sup><small>DM40</small></sup>): </span><span style="display: none;" class="add_version"> The result is a <a title="partially applied function" class="termref" href="#dt-partially-applied-function">partially applied function</a> having the following properties (which are defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items">Section 2.8.1 Functions </a><sup><small>DM31</small></sup>): </span><span class="modify_version"> The result is a <a title="partially applied function" class="termref" href="#dt-partially-applied-function">partially applied function</a> having the following properties (which are defined in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items"><span class="deltaxml-old">Section 2.9.4 Function Items</span></a><a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items"><span class="deltaxml-new">Section 2.8.1 Functions </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>): </span></p><ul><li><p><b><span class="deltaxml-old">name</span></b><span class="deltaxml-old">: The name of </span><var><span class="deltaxml-old">FD</span></var><span class="deltaxml-old"> if all parameters map to placeholders, that is, if the partial function application is equivalent to the corresponding </span><a title="named function reference" class="termref" href="#dt-named-function-ref"><span class="deltaxml-old">named function reference</span></a><span class="deltaxml-old">. Otherwise, the name is absent. </span></p><p><b><span class="deltaxml-new">name</span></b><span class="deltaxml-new">: Absent. </span></p></li><li class="delete_version" style="display: none;"><p><b>identity</b>: A new function identity distinct from the identity of any other function item.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>See also <a href="#id-function-identity"><b>4.6.2.7 Function Identity</b></a>.</p></div></li><li class="modify_version"><p><b><span class="deltaxml-old">identity</span></b><span class="deltaxml-old">: A new function identity distinct from the identity of any other function item.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">See also </span><a href="#id-function-identity"><b><span class="deltaxml-old">4.6.2.7 Function Identity</span></b></a><span class="deltaxml-old">.</span></p></div></li><li><p><span style="display: none;" class="delete_version"><b>arity</b>: The number of placeholders in the function call.</span><span style="display: none;" class="add_version"><b>arity</b>: the number of placeholders in the function call.</span><span class="modify_version"><b>arity</b>: <span class="deltaxml-old">The</span><span class="deltaxml-new">the</span> number of placeholders in the function call.</span></p></li><li><p><span style="display: none;" class="delete_version"><b>parameter names</b>: The names of the parameters of <var>FD</var> that have been identified as placeholder parameters, retaining the order in which the placeholders appear in the function call. </span><span style="display: none;" class="add_version"><b>parameter names</b>: The names of the parameters of <var>F</var> that have been identified as placeholder parameters, retaining the order in which the placeholders appear in the function call. </span><span class="modify_version"><b>parameter names</b>: The names of the parameters of <var><span class="deltaxml-old">FD</span><span class="deltaxml-new">F</span></var> that have been identified as placeholder parameters, retaining the order in which the placeholders appear in the function call. </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">A partial function application can be used to change the order of parameters, for example <code>fn:contains(substring:=?, value:=?)</code> returns a function item that is equivalent to <code>fn:contains#2</code>, but with the order of arguments reversed.</span><span style="display: none;" class="add_version">Partial function application can be used to change the order of parameters, for example <code>fn:contains(substring:=?, value:=?)</code> returns a function item that is equivalent to <code>fn:contains#2</code>, but with the order of arguments reversed.</span><span class="modify_version"><span class="deltaxml-old">A partial</span><span class="deltaxml-new">Partial</span> function application can be used to change the order of parameters, for example <code>fn:contains(substring:=?, value:=?)</code> returns a function item that is equivalent to <code>fn:contains#2</code>, but with the order of arguments reversed.</span></p></div></li><li><p><span style="display: none;" class="delete_version"><b>signature</b>: The parameters in the returned function are the parameters of <var>FD</var> that have been identified as placeholder parameters, retaining the order in which the placeholders appear in the function call. The result type of the returned function is the same as the result type of <var>FD</var>.</span><span style="display: none;" class="add_version"><b>signature</b>: the parameters in the returned function are the parameters of <var>F</var> that have been identified as placeholder parameters, retaining the order in which the placeholders appear in the function call. The result type of the returned function is the same as the result type of <var>F</var>.</span><span class="modify_version"><b>signature</b>: <span class="deltaxml-old">The</span><span class="deltaxml-new">the</span> parameters in the returned function are the parameters of <var><span class="deltaxml-old">FD</span><span class="deltaxml-new">F</span></var> that have been identified as placeholder parameters, retaining the order in which the placeholders appear in the function call. The result type of the returned function is the same as the result type of <var><span class="deltaxml-old">FD</span><span class="deltaxml-new">F</span></var>.</span></p><p>An implementation which can determine a more specific signature (for example, through use of type analysis) is permitted to do so. </p></li><li><p><span style="display: none;" class="delete_version"><b>body</b>: The body of <var>FD</var>.</span><span style="display: none;" class="add_version"><b>body</b>: The body of <var>F</var>.</span><span class="modify_version"><b>body</b>: The body of <var><span class="deltaxml-old">FD</span><span class="deltaxml-new">F</span></var>.</span></p></li><li><p><span style="display: none;" class="delete_version"><b>captured context</b>: The static and dynamic context of the function call, augmented, for each explicitly supplied parameter and each defaulted parameter, with a binding of the converted argument value to the corresponding parameter name. </span><span style="display: none;" class="add_version"><b>captured context</b>: the static and dynamic context of the function call, augmented, for each explicitly supplied parameter and each defaulted parameter, with a binding of the converted argument value to the corresponding parameter name. </span><span class="modify_version"><b>captured context</b>: <span class="deltaxml-old">The</span><span class="deltaxml-new">the</span> static and dynamic context of the function call, augmented, for each explicitly supplied parameter and each defaulted parameter, with a binding of the converted argument value to the corresponding parameter name. </span></p></li></ul><div class="example"><div class="exampleHeader"><a id="d3e14835"></a><a id="d3e12265"></a>Example: Partial Application of a <span class="deltaxml-old">System</span><span class="deltaxml-new">Built-In</span> Function</div><p>The following partial function application creates a function item that computes the sum of squares of a sequence.</p><div class="exampleInner"><pre><span class="deltaxml-old">let $sum-of-squares := fold-right(?, 0, function($a, $b) { $a*$a + $b }) return $sum-of-squares(1 to 3)</span></pre><pre><span class="deltaxml-new">let $sum-of-squares := fn:fold-right(?, 0, function($a, $b) { $a*$a + $b }) return $sum-of-squares(1 to 3)</span></pre></div><p><span style="display: none;" class="delete_version"><code>$sum-of-squares</code> is an anonymous function. It has one parameter, named <code>$seq</code>, which is taken from the corresponding parameter in <code>fn:fold-right</code> (the other two parameters are fixed). The implementation is the implementation of <code>fn:fold-right</code>, which is a context-independent system function. The nonlocal bindings contain the fixed bindings for the second and third parameters of <code>fn:fold-right</code>.</span><span style="display: none;" class="add_version"><code>$sum-of-squares</code> is an anonymous function. It has one parameter, named <code>$seq</code>, which is taken from the corresponding parameter in <code>fn:fold-right</code> (the other two parameters are fixed). The implementation is the implementation of <code>fn:fold-right</code>, which is a built-in context-independent function. The nonlocal bindings contain the fixed bindings for the second and third parameters of <code>fn:fold-right</code>.</span><span class="modify_version"><code>$sum-of-squares</code> is an anonymous function. It has one parameter, named <code>$seq</code>, which is taken from the corresponding parameter in <code>fn:fold-right</code> (the other two parameters are fixed). The implementation is the implementation of <code>fn:fold-right</code>, which is a <span class="deltaxml-new">built-in </span>context-independent <span class="deltaxml-old">system </span>function. The nonlocal bindings contain the fixed bindings for the second and third parameters of <code>fn:fold-right</code>.</span></p></div></li></ol><p>For dynamic function calls, the result is obtained as follows:</p><ol class="enumar"><li><p><span style="display: none;" class="delete_version">The <a title="function item" class="termref" href="#dt-function-item">function item</a><var>FI</var> to be partially applied is determined in the same way as for a dynamic function call without placeholders, as described in <a href="#id-dynamic-function-invocation"><span class="delete_version"><b>4.6.2.1 Dynamic Function Calls</b></span><span class="modify_version"><b>4.6.2.1 Dynamic Function Calls</b></span></a>. For this purpose an <code>ArgumentPlaceholder</code> contributes to the count of arguments.</span><span style="display: none;" class="add_version">The <a title="function item" class="termref" href="#dt-function-item">function item</a><var>F</var> to be partially applied is determined in the same way as for a dynamic function call without placeholders, as described in <a href="#id-dynamic-function-invocation"><span class="add_version"><b>4.5.2 Dynamic Function Calls</b></span><span class="modify_version"><b>4.5.2 Dynamic Function Calls</b></span></a>. For this purpose an <code>ArgumentPlaceholder</code> contributes to the count of arguments.</span><span class="modify_version">The <a title="function item" class="termref" href="#dt-function-item">function item</a><var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var> to be partially applied is determined in the same way as for a dynamic function call without placeholders, as described in <a href="#id-dynamic-function-invocation"><span style="display: none;" class="delete_version"><b>4.6.2.1 Dynamic Function Calls</b></span><span style="display: none;" class="add_version"><b>4.5.2 Dynamic Function Calls</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.2.1</span><span class="deltaxml-new">4.5.2</span> Dynamic Function Calls</b></span></a>. For this purpose an <code>ArgumentPlaceholder</code> contributes to the count of arguments.</span></p></li><li><p><span style="display: none;" class="delete_version">The parameters of <var>FI</var> are classified into two categories:</span><span style="display: none;" class="add_version">The parameters of <var>F</var> are classified into two categories:</span><span class="modify_version">The parameters of <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var> are classified into two categories:</span></p><ul><li><p>Parameters that map to a placeholder, referred to as <b>placeholder parameters</b>.</p></li><li><p>Parameters for which an explicit value is given in the function call, referred to as <b>supplied parameters</b>.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p><span class="deltaxml-new">A partial function application need not have any supplied parameters.</span></p><p><span style="display: none;" class="delete_version">A partial function application need not have any explicitly supplied parameters. For example, if <code>$f</code> is a function with arity 2, then the partial function application <code>$f(?, ?)</code> returns a function that has exactly the same effect as <code>$f</code>. </span><span style="display: none;" class="add_version">For example, if <code>$f</code> is a function with arity 2, then the partial function application <code>$f(?, ?)</code> returns a function that has exactly the same effect as <code>$f</code>. </span><span class="modify_version"><span class="deltaxml-old">A partial function application need not have any explicitly supplied parameters. </span>For example, if <code>$f</code> is a function with arity 2, then the partial function application <code>$f(?, ?)</code> returns a function that has exactly the same effect as <code>$f</code>. </span></p></div></li><li><p>Arguments corresponding to supplied parameters are evaluated and converted to the required type of the parameter, using the rules for dynamic function calls.</p><p><span class="deltaxml-old">A type error is raised if any of the supplied parameters, after applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-old">coercion rules</span></a><span class="deltaxml-old">, does not match the required type.</span></p><p><span class="deltaxml-old">In addition, a dynamic error </span><strong><span class="deltaxml-old">may</span></strong><span class="deltaxml-old"> be raised if any of the supplied parameters does not match other constraints on the value of that parameter (for example, if the value supplied for a parameter expecting a regular expression is not a valid regular expression); or if the processor is able to establish that evaluation of the resulting function will fail for any other reason (for example, if an error is raised while evaluating a subexpression in the function body that depends only on explicitly supplied parameters).</span></p><p><span class="deltaxml-old">In both cases the error code is the same as for a dynamic function call supplying the same invalid value.</span></p></li><li><p><span style="display: none;" class="delete_version"> The result of the partial function application is a <a title="partially applied function" class="termref" href="#dt-partially-applied-function">partially applied function</a> with the following properties (which are defined in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items">Section 2.9.4 Function Items</a><sup><small>DM40</small></sup>): </span><span style="display: none;" class="add_version"> The result of the partial function application is a <a title="partially applied function" class="termref" href="#dt-partially-applied-function">partially applied function</a> with the following properties (which are defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items">Section 2.8.1 Functions </a><sup><small>DM31</small></sup>): </span><span class="modify_version"> The result of the partial function application is a <a title="partially applied function" class="termref" href="#dt-partially-applied-function">partially applied function</a> with the following properties (which are defined in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items"><span class="deltaxml-old">Section 2.9.4 Function Items</span></a><a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items"><span class="deltaxml-new">Section 2.8.1 Functions </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>): </span></p><ul><li><p><b>name</b>: Absent. </p></li><li><p><span style="display: none;" class="delete_version"><b>arity</b>: The number of placeholders in the function call.</span><span style="display: none;" class="add_version"><b>arity</b>: the number of placeholders in the function call.</span><span class="modify_version"><b>arity</b>: <span class="deltaxml-old">The</span><span class="deltaxml-new">the</span> number of placeholders in the function call.</span></p></li><li><p><span style="display: none;" class="delete_version"><b>parameter names</b>: The names of parameters in <var>FI</var> that have been identified as placeholder parameters, in order. </span><span style="display: none;" class="add_version"><b>parameter names</b>: The names of parameters in <var>F</var> that have been identified as placeholder parameters, in order. </span><span class="modify_version"><b>parameter names</b>: The names of parameters in <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var> that have been identified as placeholder parameters, in order. </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>In a dynamic partial function application, argument keywords are not available, so it is not possible to change the order of parameters.</p></div></li><li><p><span style="display: none;" class="delete_version"><b>signature</b>: The signature of <var>FI</var>, removing the types of supplied parameters. An implementation which can determine a more specific signature (for example, through use of type analysis) is permitted to do so. </span><span style="display: none;" class="add_version"><b>signature</b>: The signature of <var>F</var>, removing the types of supplied parameters. An implementation which can determine a more specific signature (for example, through use of type analysis) is permitted to do so. </span><span class="modify_version"><b>signature</b>: The signature of <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var>, removing the types of supplied parameters. An implementation which can determine a more specific signature (for example, through use of type analysis) is permitted to do so. </span></p></li><li><p><span style="display: none;" class="delete_version"><b>body</b>: The body of <var>FI</var>. </span><span style="display: none;" class="add_version"><b>body</b>: The body of <var>F</var>. </span><span class="modify_version"><b>body</b>: The body of <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var>. </span></p></li><li><p><span style="display: none;" class="delete_version"><b>captured context</b>: the captured context of <var>FI</var>, augmented, for each supplied parameter, with a binding of the converted argument value to the corresponding parameter name. </span><span style="display: none;" class="add_version"><b>captured context</b>: the captured context of <var>F</var>, augmented, for each supplied parameter, with a binding of the converted argument value to the corresponding parameter name. </span><span class="modify_version"><b>captured context</b>: the captured context of <var><span class="deltaxml-old">FI</span><span class="deltaxml-new">F</span></var>, augmented, for each supplied parameter, with a binding of the converted argument value to the corresponding parameter name. </span></p></li></ul><div class="example"><div class="exampleHeader"><a id="d3e14951"></a><a id="d3e12372"></a>Example: Partial Application of an Anonymous Function</div><p>In the following example, <code>$f</code> is an anonymous function, and <code>$paf</code> is a partially applied function created from <code>$f</code>.</p><div class="exampleInner"><pre><span class="deltaxml-old">let $f := function($seq, $delim) { fold-left($seq, "", concat(?, $delim, ?)) } let $paf := $f(?, ".") return $paf(1 to 5)</span></pre><pre><span class="deltaxml-new">let $f := function ($seq, $delim) { fn:fold-left($seq, "", fn:concat(?, $delim, ?)) }, $paf := $f(?, ".") return $paf(1 to 5) </span></pre></div><p><code>$paf</code> is also an anonymous function. It has one parameter, named <code>$delim</code>, which is taken from the corresponding parameter in <code>$f</code> (the other parameter is fixed). The implementation of <code>$paf</code> is the implementation of <code>$f</code>, which is <code>fn:fold-left($seq, "", fn:concat(?, $delim, ?))</code>. This implementation is associated with the <code>SC</code> and <code>DC</code> of the original expression in <code>$f</code>. The nonlocal bindings associate the value <code>"."</code> with the parameter <code>$delim</code>.</p></div></li></ol><p><span style="display: none;" class="delete_version">Partial function application never returns a map or an array. If <code>$f</code> is a map or an array, then <code>$f(?)</code> is a partial function application that returns a function, but the function it returns is neither a map nor an array.</span><span style="display: none;" class="add_version">Partial function application never returns a map or an array. If <code>$F</code> is a map or an array, then <code>$F(?)</code> is a partial function application that returns a function, but the function it returns is not a map nor an array.</span><span class="modify_version">Partial function application never returns a map or an array. If <code>$<span class="deltaxml-old">f</span><span class="deltaxml-new">F</span></code> is a map or an array, then <code>$<span class="deltaxml-old">f</span><span class="deltaxml-new">F</span>(?)</code> is a partial function application that returns a function, but the function it returns is <span class="deltaxml-old">neither</span><span class="deltaxml-new">not</span> a map nor an array.</span></p><div class="example"><div class="exampleHeader"><a id="d3e14994"></a><a id="d3e12415"></a>Example: Partial Application of a Map</div><p>The following partial function application converts a map to an equivalent function that is not a map.</p><div class="exampleInner"><pre>let $a := map {"A": 1, "B": 2}(?) return $a("A")</pre></div></div></div><div class="div4"><h5><a id="id-named-function-ref"></a><span class="deltaxml-old">4.6.2.4</span><span class="deltaxml-new">4.4.2.3</span> Named Function References</h5><a id="d3e15002"></a><a id="d3e12423"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NamedFunctionRef"></a>[<span class="deltaxml-old">206</span><span class="deltaxml-new">193</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NamedFunctionRef">NamedFunctionRef</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a> "#" <a href="#doc-xquery40-IntegerLiteral">IntegerLiteral</a></code></td><td><i>/* <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e13713.doc-xquery40-EQName"></a><a id="noid_d4e11383.doc-xquery40-EQName"></a>[<span class="deltaxml-old">266</span><span class="deltaxml-new">252</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EQName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-QName">QName</a> | <a href="#doc-xquery40-URIQualifiedName">URIQualifiedName</a></code></td><td></td></tr></tbody></table><p> [<a id="dt-named-function-ref" title="named function reference">Definition</a>: A <b>named function reference</b> is an expression (written <code>name#arity</code>) which evaluates to a <a title="function item" class="termref" href="#dt-function-item">function item</a>, <span>the details of the function item being based on the properties of a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a></span>.] </p><p>The name and arity of the required function are known statically.</p><p>If the EQName is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, it is expanded using the <a title="default function namespace" class="termref" href="#dt-default-function-namespace">default function namespace</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>.</p><p>The expanded QName and arity must correspond to a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> present in the <a title="static context" class="termref" href="#dt-static-context">static context</a>. <span>More specifically, for a named function reference <code>F#N</code>, there must be a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a> whose name matches <var>F</var>, and whose <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> includes <var>N</var></span>. Call this <a title="function definition" class="termref" href="#dt-function-definition">function definition</a><var>FD</var>.</p><p><span style="display: none;" class="delete_version">If <var>FD</var> is <a title="context dependent" class="termref" href="#dt-context-dependent">context dependent</a> for the given arity, then the returned function item has a captured context comprising the static and dynamic context of the named function reference.</span><span style="display: none;" class="add_version">If the function is <a title="context dependent" class="termref" href="#dt-context-dependent">context dependent</a>, then the returned function has a captured context comprising the static and dynamic context of the named function reference.</span><span class="modify_version">If <span class="deltaxml-old">FD</span><span class="deltaxml-new">the</span> <span class="deltaxml-new">function </span>is <a title="context dependent" class="termref" href="#dt-context-dependent">context dependent</a><span class="deltaxml-old"> for the given arity</span>, then the returned function <span class="deltaxml-old">item </span>has a captured context comprising the static and dynamic context of the named function reference.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice, it is <span class="deltaxml-new">only </span>necessary to retain <span class="deltaxml-old">only </span>those parts of the static and dynamic context that can affect the outcome. These means it is unnecessary to retain parts of the context that no <a title="system function" class="termref" href="#dt-system-function">system function</a> depends on (for example, local variables), or parts that are invariant within an execution scope (for example, the implicit timezone).</p></div><div class="example"><div class="exampleHeader"><a id="d3e15096"></a><a id="d3e12515"></a>Example: A Context-Dependent Named Function Reference</div><p>Consider:</p><div class="exampleInner"><pre><span class="deltaxml-old">let $f := &lt;foo/&gt;/fn:name#0 return &lt;bar/&gt;/$f()</span></pre><pre><span class="deltaxml-new">let $f := &lt;foo/&gt;/fn:name#0 return &lt;bar&gt;/$f()</span></pre></div><p><span style="display: none;" class="delete_version">The function <code>fn:name()</code>, with no arguments, returns the name of the context node. The function item delivered by evaluating the expression <code>fn:name#0</code> returns the name of the element that was the context node at the point where the function reference was evaluated (that is, the <code>&lt;foo&gt;</code> element). This expression therefore returns <code>"foo"</code>, not <code>"bar"</code>.</span><span style="display: none;" class="add_version">The function <code>fn:name()</code>, with no arguments, returns the name of the context node. The function item delivered by evaluating the expression <code>fn:name#0</code> returns the name of the element that was the context node at the point where the function reference was evaluated (that is, the <code>&lt;foo&gt;</code> element). This expression therefore returns "foo", not "bar".</span><span class="modify_version">The function <code>fn:name()</code>, with no arguments, returns the name of the context node. The function item delivered by evaluating the expression <code>fn:name#0</code> returns the name of the element that was the context node at the point where the function reference was evaluated (that is, the <code>&lt;foo&gt;</code> element). This expression therefore returns "foo", not "bar".</span></p></div><p><span class="deltaxml-old">An error is raised if the identified function depends on components of the static or dynamic context that are not present, or that have unsuitable values. For example [</span><a href="#ERRXPDY0002" title="err:XPDY0002"><span class="deltaxml-old">err:XPDY0002</span></a><span class="deltaxml-old">] is raised for the expression </span><code><span class="deltaxml-old">fn:name#0</span></code><span class="deltaxml-old"> if the context item is absent, and [</span><a href="https://www.w3.org/TR/xpath-functions/#ERRFODC0001" title="err:FODC0001"><span class="deltaxml-old">err:FODC0001</span></a><span class="deltaxml-old">]</span><sup><small><span class="deltaxml-old">FO</span></small></sup><span class="deltaxml-old"> is raised for the call </span><code><span class="deltaxml-old">fn:id#1</span></code><span class="deltaxml-old"> if the context item is not a node in a tree that is rooted at a document node. The error that is raised is the same as the error that would be raised by the corresponding function if called with the same static and dynamic context.</span></p><p>If the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and arity in a named function reference do not match the name and <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> of a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the static context, a static error is raised [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>].</p><p> The value of a <code>NamedFunctionRef</code> is a <a title="function item" class="termref" href="#dt-function-item">function item</a><var>FI</var> obtained from <var>FD</var> as follows: </p><ul><li><p><span style="display: none;" class="delete_version"><b>name</b>: The name of <var>FD</var>.</span><span style="display: none;" class="add_version">The name of <var>FI</var> is the name of <var>FD</var>.</span><span class="modify_version"><span class="deltaxml-new">The </span>name<span class="deltaxml-new"> of </span><var><span class="deltaxml-new">FI</span></var><span class="deltaxml-old">: The</span><span class="deltaxml-new"> is the</span> name of <var>FD</var>.</span></p></li><li class="delete_version" style="display: none;"><p><b>identity</b>:</p><ul><li><p>If <var>FD</var> is <a title="context dependent" class="termref" href="#dt-context-dependent">context dependent</a> for the given arity, then a new function identity distinct from the identity of any other function item.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In the general case, a function reference to a context-dependent function will produce different results every time it is evaluated, because the resulting function item has a <b>captured context</b> (see <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items">Section 2.9.4 Function Items</a><sup><small>DM40</small></sup>) that includes the dynamic context of the particular evaluation. Optimizers, however, are allowed to detect cases where the captured context happens to be the same, or where any variations are immaterial, and where it is therefore safe to return the same function item each time. This might be the case, for example, where the only context dependency of a function is on the default collation, and the default collation for both evaluations is known to be the same.</p></div></li><li><p>Otherwise, a function identity that is the same as that produced by the evaluation of any other named function reference with the same function name and arity.</p><p>This rule applies even across different <a href="https://qt4cg.org/specifications/xpath-functions-40/#execution-scope">execution scopes</a><sup><small>FO40</small></sup>: for example if a parameter to a call to <code>fn:transform</code> is set to the result of the expression <code>fn:abs#1</code>, then the function item passed as the parameter value will be identical to that obtained by evaluating the expression <code>fn:abs#1</code> within the target XSLT stylesheet.</p><p>This rule also applies when the target function definition is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-nondeterministic">nondeterministic</a><sup><small>FO40</small></sup>. For example all evaluations of the named function reference <code>map:keys#2</code> return identical function items, even though two evaluations of <code>map:keys</code> with the same arguments may produce different results.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>See also <a href="#id-function-identity"><b>4.6.2.7 Function Identity</b></a>.</p></div></li><li class="modify_version"><p><b><span class="deltaxml-old">identity</span></b><span class="deltaxml-old">:</span></p><ul><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">FD</span></var><span class="deltaxml-old"> is </span><a title="context dependent" class="termref" href="#dt-context-dependent"><span class="deltaxml-old">context dependent</span></a><span class="deltaxml-old"> for the given arity, then a new function identity distinct from the identity of any other function item.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">In the general case, a function reference to a context-dependent function will produce different results every time it is evaluated, because the resulting function item has a </span><b><span class="deltaxml-old">captured context</span></b><span class="deltaxml-old"> (see </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items"><span class="deltaxml-old">Section 2.9.4 Function Items</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">) that includes the dynamic context of the particular evaluation. Optimizers, however, are allowed to detect cases where the captured context happens to be the same, or where any variations are immaterial, and where it is therefore safe to return the same function item each time. This might be the case, for example, where the only context dependency of a function is on the default collation, and the default collation for both evaluations is known to be the same.</span></p></div></li><li><p><span class="deltaxml-old">Otherwise, a function identity that is the same as that produced by the evaluation of any other named function reference with the same function name and arity.</span></p><p><span class="deltaxml-old">This rule applies even across different </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#execution-scope"><span class="deltaxml-old">execution scopes</span></a><sup><small><span class="deltaxml-old">FO40</span></small></sup><span class="deltaxml-old">: for example if a parameter to a call to </span><code><span class="deltaxml-old">fn:transform</span></code><span class="deltaxml-old"> is set to the result of the expression </span><code><span class="deltaxml-old">fn:abs#1</span></code><span class="deltaxml-old">, then the function item passed as the parameter value will be identical to that obtained by evaluating the expression </span><code><span class="deltaxml-old">fn:abs#1</span></code><span class="deltaxml-old"> within the target XSLT stylesheet.</span></p><p><span class="deltaxml-old">This rule also applies when the target function definition is </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-nondeterministic"><span class="deltaxml-old">nondeterministic</span></a><sup><small><span class="deltaxml-old">FO40</span></small></sup><span class="deltaxml-old">. For example all evaluations of the named function reference </span><code><span class="deltaxml-old">map:keys#2</span></code><span class="deltaxml-old"> return identical function items, even though two evaluations of </span><code><span class="deltaxml-old">map:keys</span></code><span class="deltaxml-old"> with the same arguments may produce different results.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">See also </span><a href="#id-function-identity"><b><span class="deltaxml-old">4.6.2.7 Function Identity</span></b></a><span class="deltaxml-old">.</span></p></div></li><li class="delete_version" style="display: none;"><p><b>arity</b>: As specified in the named function reference.</p></li><li class="modify_version"><p><b><span class="deltaxml-old">arity</span></b><span class="deltaxml-old">: As specified in the named function reference.</span></p></li><li><p><span style="display: none;" class="delete_version"><b>parameter names</b>: The first <var>A</var> parameter names of <var>FD</var>, where <var>A</var> is the required arity.</span><span style="display: none;" class="add_version">The parameter names of <var>FI</var> are the first <var>A</var> parameter names of <var>FD</var>, where <var>A</var> is the required arity.</span><span class="modify_version"><span class="deltaxml-new">The </span>parameter names<span class="deltaxml-new"> of </span><var><span class="deltaxml-new">FI</span></var><span class="deltaxml-old">: The</span><span class="deltaxml-new"> are the</span> first <var>A</var> parameter names of <var>FD</var>, where <var>A</var> is the required arity.</span></p></li><li><p><span style="display: none;" class="delete_version"><b>signature</b>: Formed from the required types of the first <var>A</var> parameters of <var>FD</var>, and the function result type of <var>FD</var>.</span><span style="display: none;" class="add_version">The signature of <var>FI</var> is formed from the required types of the first <var>A</var> parameters of <var>FD</var>, and the function result type of <var>FD</var>.</span><span class="modify_version"><span class="deltaxml-new">The </span>signature<span class="deltaxml-new"> of </span><var><span class="deltaxml-new">FI</span></var><span class="deltaxml-old">: Formed</span><span class="deltaxml-new"> is formed</span> from the required types of the first <var>A</var> parameters of <var>FD</var>, and the function result type of <var>FD</var>.</span></p></li><li><p><b><span class="deltaxml-old">body</span></b><span class="deltaxml-old">: The body of </span><var><span class="deltaxml-old">FD</span></var><span class="deltaxml-old">.</span></p><p><span class="deltaxml-new">The implementation of </span><var><span class="deltaxml-new">FI</span></var><span class="deltaxml-new"> is the implementation of </span><var><span class="deltaxml-new">FD</span></var><span class="deltaxml-new">.</span></p></li><li><p><span style="display: none;" class="delete_version"><b>captured context</b>: Comprises the static and dynamic context of the named function reference, augmented with bindings of the names of parameters of <var>FD</var> beyond the <var>A</var>’th parameter, to their respective default values.</span><span style="display: none;" class="add_version">The captured context of <var>FI</var> comprises the static and dynamic context of the named function reference, augmented with bindings of the names of parameters of <var>FD</var> beyond the <var>A</var>'th parameter, to their respective default values.</span><span class="modify_version"><span class="deltaxml-new">The </span>captured context<span class="deltaxml-new"> of </span><var><span class="deltaxml-new">FI</span></var><span class="deltaxml-old">: Comprises</span><span class="deltaxml-new"> comprises</span> the static and dynamic context of the named function reference, augmented with bindings of the names of parameters of <var>FD</var> beyond the <var>A</var><span class="deltaxml-old">’</span><span class="deltaxml-new">'</span>th parameter, to their respective default values.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice<span class="deltaxml-old">,</span> it is <span class="deltaxml-new">only </span>necessary to retain <span class="deltaxml-old">only </span>the parts of the context that the function actually depends on (if any).</p></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">Consider the system function <code>fn:format-date</code>, which has an arity range of 2 to 5. The named function reference <code>fn:format-date#3</code> returns a function item whose three parameters correspond to the first three parameters of <code>fn:format-date</code>; the remaining two arguments will take their default values. To obtain an arity-3 function that binds to arguments 1, 2, and 5 of <code>fn:format-date</code>, use the partial function application <code>format-date(?, ?, place:=?)</code>.</span><span style="display: none;" class="add_version">Consider the built-in function <code>fn:format-date</code> which has an arity range of 2 to 5. The named function reference <code>fn:format-date#3</code> returns a function item whose three parameters correspond to the first three parameters of <code>fn:format-date</code>; the remaining two arguments will take their default values. To obtain an arity-3 function that binds to arguments 1, 2, and 5 of <code>fn:format-date</code>, use the partial function application <code>format-date(?, ?, place:?)</code>.</span><span class="modify_version">Consider the <span class="deltaxml-old">system</span><span class="deltaxml-new">built-in</span> function <code>fn:format-date</code><span class="deltaxml-old">,</span> which has an arity range of 2 to 5. The named function reference <code>fn:format-date#3</code> returns a function item whose three parameters correspond to the first three parameters of <code>fn:format-date</code>; the remaining two arguments will take their default values. To obtain an arity-3 function that binds to arguments 1, 2, and 5 of <code>fn:format-date</code>, use the partial function application <code>format-date(?, ?, place:<span class="deltaxml-old">=</span>?)</code>.</span></p></div><p>The following are examples of named function references: </p><ul><li><p><code>fn:abs#1</code> references the <code>fn:abs</code> function which takes a single argument.</p></li><li><p><code>fn:concat#5</code> references the <code>fn:concat</code> function which takes 5 arguments.</p></li><li><p><code>local:myfunc#2</code> references a function named <code>local:myfunc</code> which takes 2 arguments.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>Function items, as values in the data model, have a fixed arity, and a dynamic function call always supplies the arguments positionally. Although the base function referred to may be variadic, the result of evaluating the function reference is a function that has fixed arity. In effect, the result of evaluating <code>my:func#3</code> is the same as the result of evaluating the inline function expression <code>function($x, $y, $z){my:func($x, $y, $z)}</code>, except that the returned function has a name (it retains the name <code>my:func</code>).</p></div></div><div class="div4"><h5><a id="id-inline-func"></a><span class="deltaxml-old">4.6.2.5</span><span class="deltaxml-new">4.4.2.4</span> Inline Function Expressions</h5><a id="d3e15306"></a><a id="d3e12658"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-InlineFunctionExpr"></a>[<span class="deltaxml-old">207</span><span class="deltaxml-new">194</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-InlineFunctionExpr">InlineFunctionExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-Annotation">Annotation</a>* ("function" | "fn") <a href="#doc-xquery40-FunctionSignature">FunctionSignature</a>? <a href="#doc-xquery40-FunctionBody">FunctionBody</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-Annotation">Annotation</a>* (("function" <a href="#doc-xquery40-FunctionSignature">FunctionSignature</a>) | ("-&gt;" <a href="#doc-xquery40-FunctionSignature">FunctionSignature</a>?)) <a href="#doc-xquery40-FunctionBody">FunctionBody</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-Annotation">Annotation</a>* (<span class="deltaxml-new">(</span>"function" <a href="#doc-xquery40-FunctionSignature"><span class="deltaxml-new">FunctionSignature</span></a><span class="deltaxml-new">) </span>| <span class="deltaxml-old">"fn")</span><span class="deltaxml-new">("-&gt;"</span> <a href="#doc-xquery40-FunctionSignature">FunctionSignature</a>?<span class="deltaxml-new">))</span> <a href="#doc-xquery40-FunctionBody">FunctionBody</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e13994.doc-xquery40-Annotation"></a><a id="noid_d4e11595.doc-xquery40-Annotation"></a>[27]&nbsp;&nbsp;&nbsp;</td><td><code>Annotation</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-AnnotationValue">AnnotationValue</a> ("," <a href="#doc-xquery40-AnnotationValue">AnnotationValue</a>)* ")")?</code></span><span style="display: none;" class="add_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-Literal">Literal</a> ("," <a href="#doc-xquery40-Literal">Literal</a>)* ")")?</code></span><span class="modify_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a><a href="#doc-xquery40-Literal"><span class="deltaxml-new">Literal</span></a> ("," <a href="#doc-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a><a href="#doc-xquery40-Literal"><span class="deltaxml-new">Literal</span></a>)* ")")?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e13995.doc-xquery40-AnnotationValue"></a><span class="deltaxml-old">[28]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">AnnotationValue</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a><span class="deltaxml-old"> | ("-"? </span><a href="#doc-xquery40-NumericLiteral"><span class="deltaxml-old">NumericLiteral</span></a><span class="deltaxml-old">) | ("true" "(" ")") | ("false" "(" ")")</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionSignature"></a>[<span class="deltaxml-old">35</span><span class="deltaxml-new">34</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-FunctionSignature">FunctionSignature</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" <a href="#doc-xquery40-ParamList">ParamList</a>? ")" <a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ParamList"></a>[<span class="deltaxml-old">38</span><span class="deltaxml-new">37</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ParamList">ParamList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Param">Param</a> ("," <a href="#doc-xquery40-Param">Param</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Param"></a>[<span class="deltaxml-old">39</span><span class="deltaxml-new">38</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Param">Param</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#doc-xquery40-EQName">EQName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>?</code></td><td></td></tr></tbody></table><p> [<a id="dt-inline-func" title="inline function expression">Definition</a>: An <b>inline function expression</b><span>, when evaluated,</span> creates an <a title="anonymous function" class="termref" href="#dt-anonymous-function">anonymous function</a> defined directly in the inline function expression.] An inline function expression specifies the names and SequenceTypes of the parameters to the function, the SequenceType of the result, and the body of the function.</p><p><span class="deltaxml-old">An </span><a title="inline function expression" class="termref" href="#dt-inline-func"><span class="deltaxml-old">inline function expression</span></a><span class="deltaxml-old"> whose </span><a href="#doc-xquery40-FunctionSignature"><span class="deltaxml-old">FunctionSignature</span></a><span class="deltaxml-old"> is omitted is known as a </span><a title="focus function" class="termref" href="#dt-focus-function"><span class="deltaxml-old">focus function</span></a><span class="deltaxml-old">. Focus functions are described in </span><a href="#id-focus-functions"><b><span class="deltaxml-old">4.6.2.6 Focus Functions</span></b></a><span class="deltaxml-old">.</span></p><p> [<a id="dt-anonymous-function" title="anonymous function">Definition</a>: An <b>anonymous function</b> is a <a title="function item" class="termref" href="#dt-function-item">function item</a> with no name. Anonymous functions may be created, for example, by evaluating an inline function expression or by partial function application.] </p><p><span class="deltaxml-old">The keywords </span><code><span class="deltaxml-old">function</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">fn</span></code><span class="deltaxml-old"> are synonymous.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">A more concise notation is introduced for simple functions in XQuery 4.0 because it can improve the readability of code by reducing visual clutter. For example, a sort operation previously written as </span><code><span class="deltaxml-new">sort(//employee, (), function($emp as element(employee)) as xs:string { $emp/@dateOfBirth })</span></code><span class="deltaxml-new"> can now be written </span><code><span class="deltaxml-new">sort(//employee, (), -&gt;{@dateOfBirth})</span></code><span class="deltaxml-new">.</span></p><p><span class="deltaxml-new">The use of the notation </span><code><span class="deltaxml-new">-&gt;{expr}</span></code><span class="deltaxml-new"> mirrors the use of </span><code><span class="deltaxml-new">-&gt;</span></code><span class="deltaxml-new"> as an </span><a title="arrow operator" class="termref" href="#dt-arrow-operator"><span class="deltaxml-new">arrow operator</span></a><span class="deltaxml-new">.</span></p></div><p>The <span class="deltaxml-new">full inline function </span>syntax allows the names and types of the function argument to be declared, along with the type of the result:</p><div class="exampleInner"><pre>function($x as xs:integer, $y as xs:integer) as xs:integer {$x + $y}</pre></div><p><span class="deltaxml-old">The types can be omitted</span><span><span class="deltaxml-old">, and the keyword can be abbreviated</span></span><span class="deltaxml-old">:</span></p><p><span class="deltaxml-new">The types can be omitted:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">function($x, $y) {$x + $y}</span></pre></div><p><span class="deltaxml-new">For brevity, the keyword </span><code><span class="deltaxml-new">function</span></code><span class="deltaxml-new"> can be replaced by the symbol </span><code><span class="deltaxml-new">-&gt;</span></code><span class="deltaxml-new">:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">fn($x, $y) {$x + $y}</span></pre><pre><span class="deltaxml-new">-&gt;($x, $y) {$x + $y}</span></pre></div><p><span class="deltaxml-new">This avoids visual clutter when a function is used as an argument to another function:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">fn:for-each-pair($A, $B, -&gt;($a, $b) {$a + $b})</span></pre></div><p><span class="deltaxml-new">The common case where a function accepts a single argument of type </span><code><span class="deltaxml-new">item()</span></code><span class="deltaxml-new"> can be further abbreviated to </span><code><span class="deltaxml-new">-&gt;{EXPR}</span></code><span class="deltaxml-new">. This is equivalent to the expanded syntax </span><code><span class="deltaxml-new">function($x as item()} as item()* {$x -&gt; {EXPR}}</span></code><span class="deltaxml-new">, where </span><code><span class="deltaxml-new">x</span></code><span class="deltaxml-new"> is a system-allocated name that does not conflict with any user-defined variables. That is, it defines an anonymous arity-one function, accepting any single item as its argument value, and returns the result of evaluating the supplied expression with that item as the </span><a title="singleton focus" class="termref" href="#dt-singleton-focus"><span class="deltaxml-new">singleton focus</span></a><span class="deltaxml-new">. For example, the following function call returns the sequence </span><code><span class="deltaxml-new">(2, 3, 4, 5, 6)</span></code><span class="deltaxml-new">.</span></p><div class="exampleInner"><pre><span class="deltaxml-new">fn:for-each(1 to 5, -&gt;{.+1})</span></pre></div><p><span style="display: none;" class="delete_version">A zero-arity function can be written as, for example, <code>fn(){current-date()}</code>.</span><span style="display: none;" class="add_version">A zero-arity function can be written as, for example, <code>-&gt;(){current-date()}</code>.</span><span class="modify_version">A zero-arity function can be written as, for example, <code><span class="deltaxml-old">fn</span><span class="deltaxml-new">-&gt;</span>(){current-date()}</code>.</span></p><p> If a function parameter is declared using a name but no type, its default type is <code>item()*</code>. If the result type is omitted, its default result type is <code>item()*</code>. </p><p> The parameters of an inline function expression are considered to be variables whose scope is the function body. It is a static error [<a href="#ERRXQST0039" title="err:XQST0039">err:XQST0039</a>] for an inline function expression to have more than one parameter with the same name. </p><p class="xquery">An inline function expression may have annotations. XQuery 4.0 does not define annotations that apply to inline function expressions, in particular it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0125" title="err:XQST0125">err:XQST0125</a>] if an inline function expression is annotated as <code>%public</code> or <code>%private</code>. An implementation can define annotations, in its own namespace, to support functionality beyond the scope of this specification.</p><p><span style="display: none;" class="delete_version"> The static context for the function body is inherited from the location of the inline function expression, with the exception of the static type of the context value which is initially <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>. </span><span style="display: none;" class="add_version"> The static context for the function body is inherited from the location of the inline function expression, with the exception of the static type of the context item which is initially <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. </span><span class="modify_version"> The static context for the function body is inherited from the location of the inline function expression, with the exception of the static type of the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> which is initially <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>. </span></p><p> The variables in scope for the function body include all variables representing the function parameters, as well as all variables that are in scope for the inline function expression.</p><div class="note"><p class="prefix"><b>Note:</b></p><p> Function parameter names can mask variables that would otherwise be in scope for the function body. </p></div><p><span style="display: none;" class="delete_version">The result of an inline function expression is a single function <span>item</span> with the following properties (as defined in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items">Section 2.9.4 Function Items</a><sup><small>DM40</small></sup>):</span><span style="display: none;" class="add_version">The result of an inline function expression is a single function with the following properties (as defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items">Section 2.8.1 Functions </a><sup><small>DM31</small></sup>):</span><span class="modify_version">The result of an inline function expression is a single function <span class="deltaxml-old">item</span><span class="deltaxml-old"> </span>with the following properties (as defined in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items"><span class="deltaxml-old">Section 2.9.4 Function Items</span></a><a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items"><span class="deltaxml-new">Section 2.8.1 Functions </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>):</span></p><ul><li><p><span style="display: none;" class="delete_version"><b>name</b>: Absent. </span><span style="display: none;" class="add_version"><b>name</b>: An absent name. Absent. </span><span class="modify_version"><b>name</b>: <span class="deltaxml-new">An absent name. </span>Absent. </span></p></li><li class="delete_version" style="display: none;"><p><b>identity</b>: A new function identity distinct from the identity of any other function item.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>See also <a href="#id-function-identity"><b>4.6.2.7 Function Identity</b></a>.</p></div></li><li class="modify_version"><p><b><span class="deltaxml-old">identity</span></b><span class="deltaxml-old">: A new function identity distinct from the identity of any other function item.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">See also </span><a href="#id-function-identity"><b><span class="deltaxml-old">4.6.2.7 Function Identity</span></b></a><span class="deltaxml-old">.</span></p></div></li><li><p><span style="display: none;" class="delete_version"><b>parameter names</b>: The parameter names in the <code>InlineFunctionExpr</code>’s <code>ParamList</code>. </span><span style="display: none;" class="add_version"><b>parameter names</b>: The parameter names in the <code>InlineFunctionExpr</code>'s <code>ParamList</code>. </span><span class="modify_version"><b>parameter names</b>: The parameter names in the <code>InlineFunctionExpr</code><span class="deltaxml-old">’</span><span class="deltaxml-new">'</span>s <code>ParamList</code>. </span></p></li><li><p><span style="display: none;" class="delete_version"><b>signature</b>: A <code>FunctionTest</code> constructed from the <span class="xquery"><code>Annotation</code>s and</span><code>SequenceType</code>s in the <code>InlineFunctionExpr</code>. An implementation which can determine a more specific signature (for example, through use of type analysis of the function’s body) is permitted to do so. </span><span style="display: none;" class="add_version"><b>signature</b>: A <code>FunctionTest</code> constructed from the <span class="xquery"><code>Annotation</code>s and</span><code>SequenceType</code>s in the <code>InlineFunctionExpr</code>. An implementation which can determine a more specific signature (for example, through use of type analysis of the function's body) is permitted to do so. </span><span class="modify_version"><b>signature</b>: A <code>FunctionTest</code> constructed from the <span class="xquery"><code>Annotation</code>s and</span><code>SequenceType</code>s in the <code>InlineFunctionExpr</code>. An implementation which can determine a more specific signature (for example, through use of type analysis of the <span class="deltaxml-old">function’s</span><span class="deltaxml-new">function's</span> body) is permitted to do so. </span></p></li><li><p><span style="display: none;" class="delete_version"><b>body</b>: The <code>InlineFunctionExpr</code>’s <code>FunctionBody</code>. </span><span style="display: none;" class="add_version"><b>implementation</b>: The <code>InlineFunctionExpr</code>'s <code>FunctionBody</code>. </span><span class="modify_version"><b><span class="deltaxml-old">body</span><span class="deltaxml-new">implementation</span></b>: The <code>InlineFunctionExpr</code><span class="deltaxml-old">’</span><span class="deltaxml-new">'</span>s <code>FunctionBody</code>. </span></p></li><li><p><span style="display: none;" class="delete_version"><b>captured context</b>: the static context is the static context of the inline function expression, with the exception of the static context value type which is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>. The dynamic context has an absent <a title="focus" class="termref" href="#dt-focus">focus</a>, and a set of variable bindings comprising the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a> component of the dynamic context of the <code>InlineFunctionExpr</code>. </span><span style="display: none;" class="add_version"><b>captured context</b>: the static context is the static context of the inline function expression, with the exception of the static context item type which is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. The dynamic context has an absent <a title="focus" class="termref" href="#dt-focus">focus</a>, and a set of variable bindings comprising the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a> component of the dynamic context of the <code>InlineFunctionExpr</code>. </span><span class="modify_version"><b>captured context</b>: the static context is the static context of the inline function expression, with the exception of the static context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> type which is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>. The dynamic context has an absent <a title="focus" class="termref" href="#dt-focus">focus</a>, and a set of variable bindings comprising the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a> component of the dynamic context of the <code>InlineFunctionExpr</code>. </span></p></li></ul><p>The following are examples of some inline function expressions:</p><ul><li><p>This example creates a function that takes no arguments and returns a sequence of the first 6 primes: </p><div class="exampleInner"><pre>function() as xs:integer+ { 2, 3, 5, 7, 11, 13 }</pre></div></li><li><p><span style="display: none;" class="delete_version">This example creates a function that takes two <code>xs:double</code> arguments and returns their product: </span><span style="display: none;" class="add_version">This example creates a function that takes two xs:double arguments and returns their product: </span><span class="modify_version">This example creates a function that takes two xs:double arguments and returns their product: </span></p><div class="exampleInner"><pre><span class="deltaxml-old">fn($a as xs:double, $b as xs:double) as xs:double { $a * $b }</span></pre><pre><span class="deltaxml-new">function($a as xs:double, $b as xs:double) as xs:double { $a * $b }</span></pre></div></li><li><p>This example creates and invokes a function that captures the value of a local variable in its scope: </p><div class="exampleInner"><pre>let $incrementors := for $x in 1 to 10 return function($y) as xs:integer { $x + $y } return $incrementors[2](4)</pre></div><p>The result of this expression is <code>6</code></p></li><li class="add_version" style="display: none;"><p>This example creates a function that prepends "$" to a supplied value: </p><div class="exampleInner"><pre>-&gt;{"$" || .}</pre></div><p>It is equivalent to the function <code>concat("$", ?)</code>.</p></li><li class="modify_version"><p><span class="deltaxml-new">This example creates a function that prepends "$" to a supplied value: </span></p><div class="exampleInner"><pre><span class="deltaxml-new">-&gt;{"$" || .}</span></pre></div><p><span class="deltaxml-new">It is equivalent to the function </span><code><span class="deltaxml-new">concat("$", ?)</span></code><span class="deltaxml-new">.</span></p></li><li class="add_version" style="display: none;"><p>This example creates a function that returns the <code>name</code> attribute of a supplied element node: </p><div class="exampleInner"><pre>-&gt;{@name}</pre></div><p>It is equivalent to the function <code>function($x as item()) as item()* {$x ! @name}</code>.</p></li><li class="modify_version"><p><span class="deltaxml-new">This example creates a function that returns the </span><code><span class="deltaxml-new">name</span></code><span class="deltaxml-new"> attribute of a supplied element node: </span></p><div class="exampleInner"><pre><span class="deltaxml-new">-&gt;{@name}</span></pre></div><p><span class="deltaxml-new">It is equivalent to the function </span><code><span class="deltaxml-new">function($x as item()) as item()* {$x ! @name}</span></code><span class="deltaxml-new">.</span></p></li></ul></div><div class="div4"><h5><a id="id-focus-functions"></a><span class="deltaxml-old">4.6.2.6 Focus Functions</span></h5><p><span class="deltaxml-old"> [</span><a id="dt-focus-function" title="focus function"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">focus function</span></b><span class="deltaxml-old"> is an inline function expression in which the function signature is implicit: the function takes a single argument of type </span><code><span class="deltaxml-old">item()*</span></code><span class="deltaxml-old"> (that is, any value), and binds this to the context value when evaluating the function body, which returns a result of type </span><code><span class="deltaxml-old">item()*</span></code><span class="deltaxml-old">.] </span></p><p><span class="deltaxml-old">Here are some examples of focus functions:</span></p><ul><li><p><code><span class="deltaxml-old">fn{@age}</span></code><span class="deltaxml-old"> - a function that expects a node as its argument, and returns the </span><code><span class="deltaxml-old">@age</span></code><span class="deltaxml-old"> attribute of that node.</span></p></li><li><p><code><span class="deltaxml-old">fn{.+1}</span></code><span class="deltaxml-old"> - a function that expects a number as its argument, and returns that number plus one.</span></p></li><li><p><code><span class="deltaxml-old">function{`${.}`}</span></code><span class="deltaxml-old"> - a function that expects a string as its argument, and prepends a </span><code><span class="deltaxml-old">"$"</span></code><span class="deltaxml-old"> character.</span></p></li><li><p><code><span class="deltaxml-old">function{head(.)+foot(.)}</span></code><span class="deltaxml-old"> - a function that expects a sequence of numbers as its argument, and returns the sum of the first and last items in the sequence.</span></p></li></ul><p><span class="deltaxml-old">Focus functions are often useful as arguments to simple higher-order functions such as </span><code><span class="deltaxml-old">fn:sort</span></code><span class="deltaxml-old">. For example, to sort employees by salary, write </span><code><span class="deltaxml-old">sort(//employee, (), fn { +@salary })</span></code><span class="deltaxml-old">. (The unary plus has the effect of converting the attribute’s value to a number, for numeric sorting).</span></p><p><span class="deltaxml-old">Focus functions can also be useful on the right-hand side of the </span><a title="sequence arrow operator" class="termref" href="#dt-sequence-arrow-operator"><span class="deltaxml-old">sequence arrow operator</span></a><span class="deltaxml-old"> and </span><a title="mapping arrow operator" class="termref" href="#dt-mapping-arrow-operator"><span class="deltaxml-old">mapping arrow operator</span></a><span class="deltaxml-old">. For example, </span><code><span class="deltaxml-old">$s =&gt; tokenize() =!&gt; fn { `"{.}"` }()</span></code><span class="deltaxml-old"> first tokenizes the string </span><code><span class="deltaxml-old">$s</span></code><span class="deltaxml-old">, then wraps each token in double quotation marks.</span></p><p><span class="deltaxml-old">The expression </span><code><span class="deltaxml-old">function{EXPR}</span></code><span class="deltaxml-old"> (or </span><code><span class="deltaxml-old">fn{EXPR}</span></code><span class="deltaxml-old">) is a syntactic shorthand for the expression </span><code><span class="deltaxml-old">function($Z as item()*) as item()* {$Z!(EXPR)}</span></code><span class="deltaxml-old">, where </span><code><span class="deltaxml-old">$Z</span></code><span class="deltaxml-old"> is a variable name that is otherwise unused. Note that the function body (</span><code><span class="deltaxml-old">EXPR</span></code><span class="deltaxml-old">) is evaluated with a </span><a title="fixed focus" class="termref" href="#dt-fixed-focus"><span class="deltaxml-old">fixed focus</span></a><span class="deltaxml-old">: the context position and context size will always be 1 (one).</span></p><table class="ednote" caption="Editorial note"><tbody><tr><td style="text-align: left; vertical-align:top; width: 50%;"><b><span class="deltaxml-old">Editorial note</span></b></td><td style="text-align: right; vertical-align:top; width: 50%;"><span class="deltaxml-old">2023-09-14</span></td></tr><tr style="text-align: left; vertical-align: top;"><td colspan="2"><span class="deltaxml-old">TODO: The above no longer works. We don't currently have any construct (other than this one) that sets the context value to something other than a singleton.</span></td></tr></tbody></table></div><div class="div4"><h5><a id="id-function-identity"></a><span class="deltaxml-old">4.6.2.7 Function Identity</span></h5><p><span class="deltaxml-old">It is sometimes useful to be able to establish whether two variables refer to the same function or to different functions. For this purpose, every function item has an identity. Functions with the same identity are indistinguishable in every way; in particular, any function call with identical arguments will produce an identical result.</span></p><p><span class="deltaxml-old">In general, evaluation of an expression that returns a function item other than one that was present in its operands delivers a function item whose identity is unique, and thus distinct from any other function item. There are two exceptions to this rule:</span></p><ul><li><p><span class="deltaxml-old">Evaluating a function reference such as </span><code><span class="deltaxml-old">count#1</span></code><span class="deltaxml-old"> returns the same function every time. Specifically, if the function name identifies a </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-old">function definition</span></a><span class="deltaxml-old"> that is not </span><a title="context dependent" class="termref" href="#dt-context-dependent"><span class="deltaxml-old">context dependent</span></a><span class="deltaxml-old"> (which is the most usual case), then all function references using this function name and arity return the same function. For more details see </span><a href="#id-named-function-ref"><b><span class="deltaxml-old">4.6.2.4 Named Function References</span></b></a><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">An optimizer is permitted to rewrite expressions in such a way that repeated evaluation is avoided if it can be established that the result will be the same each time, and this may be done without consideration of function identity. For example, if the expression </span><code><span class="deltaxml-old">contains(?, "e")</span></code><span class="deltaxml-old"> appears within the body of a </span><code><span class="deltaxml-old">for</span></code><span class="deltaxml-old"> expression, or if the same expression is written repeatedly in a query, then an optimizer may decide to evaluate it once only, and thus return the same function item each time.</span></p><p><span class="deltaxml-old">Similarly, optimizers are allowed to replace any expression with an equivalent expression; for example, </span><code><span class="deltaxml-old">count(?)</span></code><span class="deltaxml-old"> may be rewritten as </span><code><span class="deltaxml-old">count#1</span></code><span class="deltaxml-old">.</span></p></li></ul></div></div><div class="div3"><h4><a id="id-coercion-rules"></a><span class="deltaxml-new">4.4.3 Coercion Rules</span></h4><p><span class="deltaxml-new"> [</span><a id="dt-coercion-rules" title="coercion rules"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: The </span><b><span class="deltaxml-new">coercion rules</span></b><span class="deltaxml-new"> are rules used to convert a supplied value to a required type, for example when converting an argument of a function call to the declared type of the function parameter. ] The required type is expressed as a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new">sequence type</span></a><span class="deltaxml-new">. The effect of the coercion rules may be to accept the value as supplied, to convert it to a value that matches the required type, or to reject it with a type error.</span></p><p><span class="deltaxml-new">This section defines how the coercion rules operate; the situations in which the rules apply are defined elsewhere, by reference to this section.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">In previous versions of this specification, the coercion rules were referred to as the </span><em><span class="deltaxml-new">function conversion</span></em><span class="deltaxml-new"> rules. The terminology has changed because the rules are not exclusively associated with functions or function calling.</span></p></div><p><span class="deltaxml-new">The coercion rules are applied to a supplied value </span><var><span class="deltaxml-new">V</span></var><span class="deltaxml-new"> and a required </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new">sequence type</span></a><var><span class="deltaxml-new">T</span></var><span class="deltaxml-new"> as follows:</span></p><ul><li><p><span class="deltaxml-new">If </span><var><span class="deltaxml-new">T</span></var><span class="deltaxml-new"> is </span><span><span class="deltaxml-new">a </span><code><span class="deltaxml-new">SequenceType</span></code><span class="deltaxml-new"> whose </span><code><span class="deltaxml-new">ItemType</span></code><span class="deltaxml-new"> is a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new">generalized atomic type</span></a><span class="deltaxml-new"> other than an enumeration type,</span></span><span class="deltaxml-new"> (possibly with an occurrence indicator </span><code><span class="deltaxml-new">*</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">+</span></code><span class="deltaxml-new">, or </span><code><span class="deltaxml-new">?</span></code><span class="deltaxml-new">), then the following conversions are applied, </span><span><span class="deltaxml-new">in order</span></span><span class="deltaxml-new">:</span></p><p><span class="deltaxml-new">TODO: coercion for enumeration types needs further work.</span></p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new">Atomization</span></a><span class="deltaxml-new"> is applied to the given value, resulting in a sequence of atomic values.</span></p></li><li><p><span class="deltaxml-new">Each item in the atomic sequence that is of type </span><code><span class="deltaxml-new">xs:untypedAtomic</span></code><span class="deltaxml-new"> is cast to the expected atomic type. </span><span><span class="deltaxml-new">If the expected atomic type is an </span><a title="EnumerationType" class="termref" href="#dt-EnumerationType"><span class="deltaxml-new">EnumerationType</span></a><span class="deltaxml-new">, the value is cast to </span><code><span class="deltaxml-new">xs:string</span></code></span><span class="deltaxml-new">. If the item is of type </span><code><span class="deltaxml-new">xs:untypedAtomic</span></code><span class="deltaxml-new"> and the expected type is </span><a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive"><span class="deltaxml-new">namespace-sensitive</span></a><span class="deltaxml-new">, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new">type error</span></a><span class="deltaxml-new"> [</span><a href="#ERRXPTY0117" title="err:XPTY0117"><span class="deltaxml-new">err:XPTY0117</span></a><span class="deltaxml-new">] is raised.</span></p></li><li><p><span class="deltaxml-new">For each </span><a title="numeric" class="termref" href="#dt-numeric"><span class="deltaxml-new">numeric</span></a><span class="deltaxml-new"> item in the atomic sequence that can be </span><a title="type promotion" class="termref" href="#dt-type-promotion"><span class="deltaxml-new">promoted</span></a><span class="deltaxml-new"> to the expected atomic type using numeric promotion as described in </span><a href="#promotion"><b><span class="deltaxml-new">B.1 Type Promotion</span></b></a><span class="deltaxml-new">, the promotion is done.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">Numeric promotion is performed only when the required type is </span><code><span class="deltaxml-new">xs:double</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">xs:float</span></code><span class="deltaxml-new"> (perhaps with an occurrence indicator). It is not performed when the required type is derived from </span><code><span class="deltaxml-new">xs:double</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">xs:float</span></code><span class="deltaxml-new">.</span></p></div></li><li><p><span class="deltaxml-new">For each item of type </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new"> in the atomic sequence that can be </span><a title="type promotion" class="termref" href="#dt-type-promotion"><span class="deltaxml-new">promoted</span></a><span class="deltaxml-new"> to the expected atomic type using URI promotion as described in </span><a href="#promotion"><b><span class="deltaxml-new">B.1 Type Promotion</span></b></a><span class="deltaxml-new">, the promotion is done.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">Promotion of </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new"> values is performed only when the required type is </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> (perhaps with an occurrence indicator). It is not performed when the required type is derived from </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new">.</span></p></div></li><li><p><span class="deltaxml-new">If </span><var><span class="deltaxml-new">T</span></var><span class="deltaxml-new"> is a sequence type whose item type is an atomic type </span><var><span class="deltaxml-new">D</span></var><span class="deltaxml-new">, where </span><var><span class="deltaxml-new">D</span></var><span class="deltaxml-new"> is derived from some primitive type </span><var><span class="deltaxml-new">P</span></var><span class="deltaxml-new">, then any atomic value </span><var><span class="deltaxml-new">A</span></var><span class="deltaxml-new"> in the atomic sequence is </span><b><span class="deltaxml-new">relabeled</span></b><span class="deltaxml-new"> as an instance of </span><var><span class="deltaxml-new">D</span></var><span class="deltaxml-new"> if it satisfies all the following conditions: </span></p><ol class="enumla"><li><p><var><span class="deltaxml-new">A</span></var><span class="deltaxml-new"> is an instance of </span><var><span class="deltaxml-new">P</span></var><span class="deltaxml-new">.</span></p></li><li><p><var><span class="deltaxml-new">A</span></var><span class="deltaxml-new"> is not an instance of </span><var><span class="deltaxml-new">D</span></var><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">The </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-datum"><span class="deltaxml-new">datum</span></a><sup><small><span class="deltaxml-new">DM40</span></small></sup><span class="deltaxml-new"> of </span><var><span class="deltaxml-new">A</span></var><span class="deltaxml-new"> is within the value space of </span><var><span class="deltaxml-new">D</span></var><span class="deltaxml-new">.</span></p></li></ol><p><span class="deltaxml-new">Relabeling an atomic value changes the </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new">type annotation</span></a><span class="deltaxml-new"> but not the </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-datum"><span class="deltaxml-new">datum</span></a><sup><small><span class="deltaxml-new">DM40</span></small></sup><span class="deltaxml-new">. For example, the </span><code><span class="deltaxml-new">xs:integer</span></code><span class="deltaxml-new"> value 3 can be relabeled as an instance of </span><code><span class="deltaxml-new">xs:unsignedByte</span></code><span class="deltaxml-new">, because the datum is within the value space of </span><code><span class="deltaxml-new">xs:unsignedByte</span></code><span class="deltaxml-new">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">Relabeling is not the same as casting. For example, the </span><code><span class="deltaxml-new">xs:decimal</span></code><span class="deltaxml-new"> value 10.1 can be cast to </span><code><span class="deltaxml-new">xs:integer</span></code><span class="deltaxml-new">, but it cannot be relabeled as </span><code><span class="deltaxml-new">xs:integer</span></code><span class="deltaxml-new">, because its datum not within the value space of </span><code><span class="deltaxml-new">xs:integer</span></code><span class="deltaxml-new">.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">The effect of this rule is that if, for example, a function parameter is declared with an expected type of </span><code><span class="deltaxml-new">xs:positiveInteger</span></code><span class="deltaxml-new">, then a call that supplies the literal value 3 will succeed, whereas a call that supplies -3 will fail.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">This differs from previous versions of this specification, where both these calls would fail.</span></p><p><span class="deltaxml-new">This change allows the arguments of existing functions to be defined with a more precise type. For example, the </span><code><span class="deltaxml-new">$position</span></code><span class="deltaxml-new"> argument of </span><code><span class="deltaxml-new">array:get</span></code><span class="deltaxml-new"> can be defined as </span><code><span class="deltaxml-new">xs:positiveInteger</span></code><span class="deltaxml-new"> rather than </span><code><span class="deltaxml-new">xs:integer</span></code><span class="deltaxml-new">. To enable this to be done without breaking backwards compatibility in respect of error behavior, built-in functions in many cases define custom error codes to be raised where relabeling of argument values fails.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">Numeric promotion and </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new"> promotion occur only when </span><var><span class="deltaxml-new">T</span></var><span class="deltaxml-new"> is a primitive type (</span><code><span class="deltaxml-new">xs:double</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">xs:float</span></code><span class="deltaxml-new">, or </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new">). Relabeling occurs only when </span><var><span class="deltaxml-new">T</span></var><span class="deltaxml-new"> is a derived type. Promotion and relabeling are therefore never combined.</span></p></div></li></ol></li><li><p><span class="deltaxml-new">If </span><var><span class="deltaxml-new">T</span></var><span class="deltaxml-new"> is a </span><a href="#doc-xquery40-RecordTest"><span class="deltaxml-new">RecordTest</span></a><span class="deltaxml-new"> (possibly with an occurrence indicator </span><code><span class="deltaxml-new">*</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">+</span></code><span class="deltaxml-new">, or </span><code><span class="deltaxml-new">?</span></code><span class="deltaxml-new">), then </span><var><span class="deltaxml-new">V</span></var><span class="deltaxml-new"> must be a map or sequence of maps, and the values of any entries in these maps whose keys correspond to field declarations in the </span><code><span class="deltaxml-new">RecordTest</span></code><span class="deltaxml-new"> are converted to the required type defined by that field declaration, by applying these rules recursively (but with XPath 1.0 compatibility mode treated as false).</span></p><p><span class="deltaxml-new">For example, if the required type is </span><code><span class="deltaxml-new">record(longitude as xs:double, latitude as xs:double)</span></code><span class="deltaxml-new"> and the supplied value is </span><code><span class="deltaxml-new">map{"longitude": 0, "latitude":53.2}</span></code><span class="deltaxml-new">, then the map is converted to </span><code><span class="deltaxml-new">map{"longitude": 0.0e0, "latitude": 53.2e0}</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">If the expected type is a </span><a href="#doc-xquery40-TypedFunctionTest"><span class="deltaxml-new">TypedFunctionTest</span></a><span class="deltaxml-new"> (possibly with an occurrence indicator </span><code><span class="deltaxml-new">*</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">+</span></code><span class="deltaxml-new">, or </span><code><span class="deltaxml-new">?</span></code><span class="deltaxml-new">), </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new">function coercion</span></a><span class="deltaxml-new"> is applied to each function in the given value.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">Maps and arrays are functions, so function coercion applies to them as well.</span></p></div></li><li><p><span class="deltaxml-new"> If, after the above conversions, the resulting value does not match the expected type </span><var><span class="deltaxml-new">T</span></var><span class="deltaxml-new"> according to the rules for </span><a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching"><span class="deltaxml-new">SequenceType Matching</span></a><span class="deltaxml-new">, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new">type error</span></a><span class="deltaxml-new"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new">err:XPTY0004</span></a><span class="deltaxml-new">].</span></p></li></ul></div><div class="div3"><h4><a id="id-function-coercion"></a><span class="deltaxml-new">4.4.4 Function Coercion</span></h4><p><span class="deltaxml-new"> Function coercion is a transformation applied to </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new">function items</span></a><span class="deltaxml-new"> during application of the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new">coercion rules</span></a><span class="deltaxml-new">. [</span><a id="dt-function-coercion" title="function coercion"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: </span><b><span class="deltaxml-new">Function coercion</span></b><span class="deltaxml-new"> wraps a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new">function item</span></a><span class="deltaxml-new"> in a new function whose signature is the same as the expected type. This effectively delays the checking of the argument and return types until the function is called.] </span></p><p><span class="deltaxml-new">Given a function </span><var><span class="deltaxml-new">F</span></var><span class="deltaxml-new">, and an expected function type, </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new">function coercion</span></a><span class="deltaxml-new"> proceeds as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new">If </span><var><span class="deltaxml-new">F</span></var><span class="deltaxml-new"> has higher arity than the expected type, a type error is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new">err:XPTY0004</span></a><span class="deltaxml-new">] </span></p></li><li><p><span class="deltaxml-new">If </span><var><span class="deltaxml-new">F</span></var><span class="deltaxml-new"> has lower arity than the expected type, then </span><var><span class="deltaxml-new">F</span></var><span class="deltaxml-new"> is wrapped in a new function that declares and ignores the additional argument; the following steps are then applied to this new function.</span></p><p><span class="deltaxml-new">For example, if the expected type is </span><code><span class="deltaxml-new">function(node(), xs:boolean) as xs:string</span></code><span class="deltaxml-new">, and the supplied function is </span><code><span class="deltaxml-new">fn:name#1</span></code><span class="deltaxml-new">, then the supplied function is effectively replaced by </span><code><span class="deltaxml-new">function($n as node(), $b as xs:boolean) as xs:string {fn:name($n)}</span></code></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">This mechanism makes it easier to design versatile and extensible higher-order functions. For example, in previous versions of this specification, the second argument of the </span><code><span class="deltaxml-new">fn:filter</span></code><span class="deltaxml-new"> function expected an argument of type </span><code><span class="deltaxml-new">function (item()) as xs:boolean</span></code><span class="deltaxml-new">. This has now been extended to </span><code><span class="deltaxml-new">function (item(), xs:integer) as xs:boolean</span></code><span class="deltaxml-new">, but existing code continues to work, because callback functions that are not interested in the value of the second argument simply ignore it. </span></p><p><span class="deltaxml-new">TODO: this change to fn:filter has not yet been made.</span></p></div></li><li><p><span class="deltaxml-new">Function coercion then returns a new </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new">function item</span></a><span class="deltaxml-new"> with the following properties (as defined in </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#function-items"><span class="deltaxml-new">Section 2.8.1 Functions </span></a><sup><small><span class="deltaxml-new">DM31</span></small></sup><span class="deltaxml-new">): </span></p><ul><li><p><b><span class="deltaxml-new">name</span></b><span class="deltaxml-new">: The name of </span><var><span class="deltaxml-new">F</span></var><span><span class="deltaxml-new">(if not absent)</span></span><span class="deltaxml-new">. </span></p></li><li><p><b><span class="deltaxml-new">parameter names</span></b><span class="deltaxml-new">: The parameter names of </span><var><span class="deltaxml-new">F</span></var><span class="deltaxml-new">. </span></p></li><li><p><b><span class="deltaxml-new">signature</span></b><span class="deltaxml-new">: </span><code><span class="deltaxml-new">Annotations</span></code><span class="deltaxml-new"> is set to the annotations of </span><var><span class="deltaxml-new">F</span></var><span class="deltaxml-new">. </span><code><span class="deltaxml-new">TypedFunctionTest</span></code><span class="deltaxml-new"> is set to the expected type. </span></p></li><li><p><b><span class="deltaxml-new">implementation</span></b><span class="deltaxml-new">: In effect, a </span><code><span class="deltaxml-new">FunctionBody</span></code><span class="deltaxml-new"> that calls </span><var><span class="deltaxml-new">F</span></var><span class="deltaxml-new">, passing it the parameters of this new function, in order. </span></p></li><li><p><b><span class="deltaxml-new">nonlocal variable bindings</span></b><span class="deltaxml-new">: An empty mapping. </span></p></li></ul></li></ol><p><span class="deltaxml-new"> If the result of invoking the new function would necessarily result in a type error, that error may be raised during </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new">function coercion</span></a><span class="deltaxml-new">. It is implementation dependent whether this happens or not. </span></p><p><span class="deltaxml-new"> These rules have the following consequences: </span></p><ul><li><p><span class="deltaxml-new"> SequenceType matching of the function's arguments and result are delayed until that function is called. </span></p></li><li><p><span class="deltaxml-new"> The </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new">coercion rules</span></a><span class="deltaxml-new"> rules applied to the function's arguments and result are defined by the SequenceType it has most recently been coerced to. Additional coercion rules could apply when the wrapped function is called. </span></p></li><li><p><span class="deltaxml-new"> If an implementation has static type information about a function, that can be used to type check the function's argument and return types during static analysis. </span></p></li></ul><p class="xquery"><span class="deltaxml-new"> For instance, consider the following query: </span></p><div class="exampleInner"><pre><span class="deltaxml-new">declare function local:filter($s as item()*, $p as function(xs:string) as xs:boolean) as item()* { $s[$p(.)] }; let $f := function($a) { starts-with($a, "E") } return local:filter(("Ethel", "Enid", "Gertrude"), $f) </span></pre></div><p class="xquery"><span class="deltaxml-new"> The function </span><code><span class="deltaxml-new">$f</span></code><span class="deltaxml-new"> has a static type of </span><code><span class="deltaxml-new">function(item()*) as item()*</span></code><span class="deltaxml-new">. When the </span><code><span class="deltaxml-new">local:filter()</span></code><span class="deltaxml-new"> function is called, the following occurs to the function: </span></p><ol class="enumar"><li><p><span class="deltaxml-new"> The </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new">coercion rules</span></a><span class="deltaxml-new"> result in applying </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new">function coercion</span></a><span class="deltaxml-new"> to </span><code><span class="deltaxml-new">$f</span></code><span class="deltaxml-new">, wrapping $f in a new function (</span><code><span class="deltaxml-new">$p</span></code><span class="deltaxml-new">) with the signature </span><code><span class="deltaxml-new">function(xs:string) as xs:boolean</span></code><span class="deltaxml-new">. </span></p></li><li><p><code><span class="deltaxml-new">$p</span></code><span class="deltaxml-new"> is matched against the SequenceType of </span><code><span class="deltaxml-new">function(xs:string) as xs:boolean</span></code><span class="deltaxml-new">, and succeeds. </span></p></li><li><p><span class="deltaxml-new"> When </span><code><span class="deltaxml-new">$p</span></code><span class="deltaxml-new"> is called inside the predicate, </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new">coercion</span></a><span class="deltaxml-new"> and SequenceType matching rules are applied to the context item argument, resulting in an </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> value or a type error. </span></p></li><li><p><code><span class="deltaxml-new">$f</span></code><span class="deltaxml-new"> is called with the </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new">, which returns an </span><code><span class="deltaxml-new">xs:boolean</span></code><span class="deltaxml-new">. </span></p></li><li><p><code><span class="deltaxml-new">$p</span></code><span class="deltaxml-new"> applies </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new">coercion rules</span></a><span class="deltaxml-new"> to the result sequence from </span><code><span class="deltaxml-new">$f</span></code><span class="deltaxml-new">, which already matches its declared return type of </span><code><span class="deltaxml-new">xs:boolean</span></code><span class="deltaxml-new">. </span></p></li><li><p><span class="deltaxml-new"> The </span><code><span class="deltaxml-new">xs:boolean</span></code><span class="deltaxml-new"> is returned as the result of </span><code><span class="deltaxml-new">$p</span></code><span class="deltaxml-new">. </span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new"> Although the semantics of </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new">function coercion</span></a><span class="deltaxml-new"> are specified in terms of wrapping the functions, static typing will often be able to reduce the number of places where this is actually necessary. </span></p></div><p><span class="deltaxml-new">Since maps and arrays are also functions in XQuery 4.0, </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new">function coercion</span></a><span class="deltaxml-new"> applies to them as well. For instance, consider the following expression: </span></p><div class="exampleInner"><pre><span class="deltaxml-new">let $m := map { "Monday" : true(), "Wednesday" : true(), "Friday" : true(), "Saturday" : false(), "Sunday" : false() }, $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday") return fn:filter($days,$m) </span></pre></div><p><span class="deltaxml-new"> The map </span><code><span class="deltaxml-new">$m</span></code><span class="deltaxml-new"> has a function signature of </span><code><span class="deltaxml-new">function(xs:anyAtomicType) as item()*</span></code><span class="deltaxml-new">. When the </span><code><span class="deltaxml-new">fn:filter()</span></code><span class="deltaxml-new"> function is called, the following occurs to the map: </span></p><ol class="enumar"><li><p><span class="deltaxml-new">The map </span><code><span class="deltaxml-new">$m</span></code><span class="deltaxml-new"> is treated as </span><code><span class="deltaxml-new">function ($f)</span></code><span class="deltaxml-new">, equivalent to </span><code><span class="deltaxml-new">map:get($m,?)</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">The </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new">coercion rules</span></a><span class="deltaxml-new"> result in applying </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new">function coercion</span></a><span class="deltaxml-new"> to </span><code><span class="deltaxml-new">$f</span></code><span class="deltaxml-new">, wrapping </span><code><span class="deltaxml-new">$f</span></code><span class="deltaxml-new"> in a new function (</span><code><span class="deltaxml-new">$p</span></code><span class="deltaxml-new">) with the signature </span><code><span class="deltaxml-new">function(item()) as xs:boolean</span></code><span class="deltaxml-new">.</span></p></li><li><p><code><span class="deltaxml-new">$p</span></code><span class="deltaxml-new"> is matched against the SequenceType </span><code><span class="deltaxml-new">function(item()) as xs:boolean</span></code><span class="deltaxml-new">, and succeeds.</span></p></li><li><p><span class="deltaxml-new">When </span><code><span class="deltaxml-new">$p</span></code><span class="deltaxml-new"> is called by </span><code><span class="deltaxml-new">fn:filter()</span></code><span class="deltaxml-new">, </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new">coercion</span></a><span class="deltaxml-new"> and SequenceType matching rules are applied to the argument, resulting in an </span><code><span class="deltaxml-new">item()</span></code><span class="deltaxml-new"> value (</span><code><span class="deltaxml-new">$a</span></code><span class="deltaxml-new">) or a type error.</span></p></li><li><p><code><span class="deltaxml-new">$f</span></code><span class="deltaxml-new"> is called with </span><code><span class="deltaxml-new">$a</span></code><span class="deltaxml-new">, which returns an </span><code><span class="deltaxml-new">xs:boolean</span></code><span class="deltaxml-new"> or the empty sequence.</span></p></li><li><p><code><span class="deltaxml-new">$p</span></code><span class="deltaxml-new"> applies </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new">coercion rule</span></a><span class="deltaxml-new"> and SequenceType matching to the result sequence from </span><code><span class="deltaxml-new">$f</span></code><span class="deltaxml-new">. When the result is an </span><code><span class="deltaxml-new">xs:boolean</span></code><span class="deltaxml-new"> the SequenceType matching succeeds. When it is an empty sequence (such as when </span><code><span class="deltaxml-new">$m</span></code><span class="deltaxml-new"> does not contain a key for </span><code><span class="deltaxml-new">"Tuesday"</span></code><span class="deltaxml-new">), SequenceType matching results in a type error [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new">err:XPTY0004</span></a><span class="deltaxml-new">], since the expected type is </span><code><span class="deltaxml-new">xs:boolean</span></code><span class="deltaxml-new"> and the actual type is an empty sequence.</span></p></li></ol><p><span class="deltaxml-new">Consider the following expression: </span></p><div class="exampleInner"><pre><span class="deltaxml-new">let $m := map { "Monday" : true(), "Tuesday" : false(), "Wednesday" : true(), "Thursday" : false(), "Friday" : true(), "Saturday" : false(), "Sunday" : false() } let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday") return fn:filter($days,$m) </span></pre></div><p><span class="deltaxml-new">The result of the expression is the sequence </span><code><span class="deltaxml-new">("Monday", "Wednesday", "Friday")</span></code></p></div></div><div class="div2"><h3><a id="id-postfix-expression"></a><span class="deltaxml-new">4.5 Postfix Expressions</span></h3><a id="d3e13540"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PostfixExpr"></a><span class="deltaxml-new">[141]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-PostfixExpr"><span class="deltaxml-new">PostfixExpr</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-PrimaryExpr"><span class="deltaxml-new">PrimaryExpr</span></a><span class="deltaxml-new"> (</span><a href="#doc-xquery40-Predicate"><span class="deltaxml-new">Predicate</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-PositionalArgumentList"><span class="deltaxml-new">PositionalArgumentList</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-Lookup"><span class="deltaxml-new">Lookup</span></a><span class="deltaxml-new">)*</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12423.doc-xquery40-Predicate"></a><span class="deltaxml-new">[148]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">Predicate</span></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">"[" </span><a href="#doc-xquery40-Expr"><span class="deltaxml-new">Expr</span></a><span class="deltaxml-new"> "]"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12424.doc-xquery40-PositionalArgumentList"></a><span class="deltaxml-new">[143]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">PositionalArgumentList</span></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">"(" </span><a href="#doc-xquery40-PositionalArguments"><span class="deltaxml-new">PositionalArguments</span></a><span class="deltaxml-new">? ")"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12425.doc-xquery40-PositionalArguments"></a><span class="deltaxml-new">[144]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">PositionalArguments</span></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-Argument"><span class="deltaxml-new">Argument</span></a><span class="deltaxml-new"> ("," </span><a href="#doc-xquery40-Argument"><span class="deltaxml-new">Argument</span></a><span class="deltaxml-new">)*</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12426.doc-xquery40-Argument"></a><span class="deltaxml-new">[163]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">Argument</span></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-ExprSingle"><span class="deltaxml-new">ExprSingle</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-ArgumentPlaceholder"><span class="deltaxml-new">ArgumentPlaceholder</span></a></code></td><td></td></tr></tbody></table><p><span class="deltaxml-new"> [</span><a id="dt-filter-expression" title="filter expression"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: An expression followed by a predicate (that is, </span><code><span class="deltaxml-new">E1[E2]</span></code><span class="deltaxml-new">) is referred to as a </span><b><span class="deltaxml-new">filter expression</span></b><span class="deltaxml-new">: its effect is to return those items from the value of </span><code><span class="deltaxml-new">E1</span></code><span class="deltaxml-new"> that satisfy the predicate in E2.] Filter expressions are described in </span><a href="#id-filter-expression"><b><span class="deltaxml-new">4.5.1 Filter Expressions</span></b></a></p><p><span class="deltaxml-new">An expression (other than a raw EQName) followed by an argument list in parentheses (that is, </span><code><span class="deltaxml-new">E1(E2, E3, ...)</span></code><span class="deltaxml-new">) is referred to as a </span><a title="dynamic function call" class="termref" href="#dt-dynamic-function-invocation"><span class="deltaxml-new">dynamic function call</span></a><span class="deltaxml-new">. Its effect is to evaluate </span><code><span class="deltaxml-new">E1</span></code><span class="deltaxml-new"> to obtain a function, and then call that function, with </span><code><span class="deltaxml-new">E2</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">E3</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">...</span></code><span class="deltaxml-new"> as arguments. Dynamic function calls are described in </span><a href="#id-dynamic-function-invocation"><b><span class="deltaxml-new">4.5.2 Dynamic Function Calls</span></b></a><span class="deltaxml-new">.</span></p><div class="div3"><h4><a id="id-filter-expression"></a><span class="deltaxml-new">4.5.1 Filter Expressions</span></h4><a id="d3e13625"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12462.doc-xquery40-PostfixExpr"></a><span class="deltaxml-new">[141]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">PostfixExpr</span></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-PrimaryExpr"><span class="deltaxml-new">PrimaryExpr</span></a><span class="deltaxml-new"> (</span><a href="#doc-xquery40-Predicate"><span class="deltaxml-new">Predicate</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-PositionalArgumentList"><span class="deltaxml-new">PositionalArgumentList</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-Lookup"><span class="deltaxml-new">Lookup</span></a><span class="deltaxml-new">)*</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Predicate"></a><span class="deltaxml-new">[148]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-Predicate"><span class="deltaxml-new">Predicate</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">"[" </span><a href="#doc-xquery40-Expr"><span class="deltaxml-new">Expr</span></a><span class="deltaxml-new"> "]"</span></code></td><td></td></tr></tbody></table><p><span class="deltaxml-new">A filter expression consists of a base expression followed by a predicate, which is an expression written in square brackets. The result of the filter expression consists of the items returned by the base expression, filtered by applying the predicate to each item in turn. The ordering of the items returned by a filter expression is the same as their order in the result of the primary expression.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">Where the expression before the square brackets is a </span><a href="#doc-xquery40-ReverseStep"><span class="deltaxml-new">ReverseStep</span></a><span class="deltaxml-new"> or </span><a href="#doc-xquery40-ForwardStep"><span class="deltaxml-new">ForwardStep</span></a><span class="deltaxml-new">, the expression is technically not a filter expression but an </span><a href="#doc-xquery40-AxisStep"><span class="deltaxml-new">AxisStep</span></a><span class="deltaxml-new">. There are minor differences in the semantics: see </span><a href="#id-predicate"><b><span class="deltaxml-new">4.6.3 Predicates within Steps</span></b></a></p></div><p><span class="deltaxml-new">Here are some examples of filter expressions:</span></p><ul><li><p><span class="deltaxml-new">Given a sequence of products in a variable, return only those products whose price is greater than 100.</span></p><div class="exampleInner"><pre><span class="deltaxml-new">$products[price gt 100]</span></pre></div></li><li><p><span class="deltaxml-new">List all the integers from 1 to 100 that are divisible by 5. (See </span><a href="#construct_seq"><b><span class="deltaxml-new">4.7.1 Sequence Concatenation</span></b></a><span class="deltaxml-new"> for an explanation of the </span><code><span class="deltaxml-new">to</span></code><span class="deltaxml-new"> operator.)</span></p><div class="exampleInner"><pre><span class="deltaxml-new">(1 to 100)[. mod 5 eq 0]</span></pre></div></li><li><p><span class="deltaxml-new">The result of the following expression is the integer 25:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">(21 to 29)[5]</span></pre></div></li><li><p><span class="deltaxml-new">The following example returns the fifth through ninth items in the sequence bound to variable </span><code><span class="deltaxml-new">$orders</span></code><span class="deltaxml-new">.</span></p><div class="exampleInner"><pre><span class="deltaxml-new">$orders[fn:position() = (5 to 9)]</span></pre></div></li><li><p><span class="deltaxml-new">The following example illustrates the use of a filter expression as a </span><a title="step" class="termref" href="#dt-step"><span class="deltaxml-new">step</span></a><span class="deltaxml-new"> in a </span><a title="path expression" class="termref" href="#dt-path-expression"><span class="deltaxml-new">path expression</span></a><span class="deltaxml-new">. It returns the last chapter or appendix within the book bound to variable </span><code><span class="deltaxml-new">$book</span></code><span class="deltaxml-new">:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">$book/(chapter | appendix)[fn:last()]</span></pre></div></li></ul><p><span class="deltaxml-new">For each item in the input sequence, the predicate expression is evaluated using an </span><b><span class="deltaxml-new">inner focus</span></b><span class="deltaxml-new">, defined as follows: The context item is the item currently being tested against the predicate. The context size is the number of items in the input sequence. The context position is the position of the context item within the input sequence. </span></p><p><span class="deltaxml-new">For each item in the input sequence, the result of the predicate expression is coerced to an </span><code><span class="deltaxml-new">xs:boolean</span></code><span class="deltaxml-new"> value, called the </span><b><span class="deltaxml-new">predicate truth value</span></b><span class="deltaxml-new">, as described below. Those items for which the predicate truth value is </span><code><span class="deltaxml-new">true</span></code><span class="deltaxml-new"> are retained, and those for which the predicate truth value is </span><code><span class="deltaxml-new">false</span></code><span class="deltaxml-new"> are discarded.</span></p><p><span class="deltaxml-new">The predicate truth value is derived by applying the following rules, in order:</span></p><ol class="enumar"><li><p><span class="deltaxml-new">If the value of the predicate expression is a </span><a title="singleton" class="termref" href="#dt-singleton"><span class="deltaxml-new">singleton</span></a><span class="deltaxml-new"> atomic value of a </span><a title="numeric" class="termref" href="#dt-numeric"><span class="deltaxml-new">numeric</span></a><span class="deltaxml-new"> type or derived from a </span><a title="numeric" class="termref" href="#dt-numeric"><span class="deltaxml-new">numeric</span></a><span class="deltaxml-new"> type, the predicate truth value is </span><code><span class="deltaxml-new">true</span></code><span class="deltaxml-new"> if the value of the predicate expression is equal (by the </span><code><span class="deltaxml-new">eq</span></code><span class="deltaxml-new"> operator) to the </span><b><span class="deltaxml-new">context position</span></b><span class="deltaxml-new">, and is </span><code><span class="deltaxml-new">false</span></code><span class="deltaxml-new"> otherwise. [</span><a id="dt-numeric-predicate" title="numeric predicate"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: A predicate whose predicate expression returns a numeric type is called a </span><b><span class="deltaxml-new">numeric predicate</span></b><span class="deltaxml-new">.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">In a region of a query where </span><a title="ordering mode" class="termref" href="#dt-ordering-mode"><span class="deltaxml-new">ordering mode</span></a><span class="deltaxml-new"> is </span><code><span class="deltaxml-new">unordered</span></code><span class="deltaxml-new">, the result of a numeric predicate is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new">implementation-dependent</span></a><span class="deltaxml-new"> , as explained in </span><a href="#id-unordered-expressions"><b><span class="deltaxml-new">4.15 Ordered and Unordered Expressions</span></b></a><span class="deltaxml-new">.</span></p></div></li><li><p><span class="deltaxml-new">Otherwise, the predicate truth value is the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new">effective boolean value</span></a><span class="deltaxml-new"> of the predicate expression.</span></p></li></ol></div><div class="div3"><h4><a id="id-dynamic-function-invocation"></a><span class="deltaxml-new">4.5.2 Dynamic Function Calls</span></h4><a id="d3e13767"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12583.doc-xquery40-PostfixExpr"></a><span class="deltaxml-new">[141]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">PostfixExpr</span></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-PrimaryExpr"><span class="deltaxml-new">PrimaryExpr</span></a><span class="deltaxml-new"> (</span><a href="#doc-xquery40-Predicate"><span class="deltaxml-new">Predicate</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-PositionalArgumentList"><span class="deltaxml-new">PositionalArgumentList</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-Lookup"><span class="deltaxml-new">Lookup</span></a><span class="deltaxml-new">)*</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ArgumentList"></a><span class="deltaxml-new">[142]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-ArgumentList"><span class="deltaxml-new">ArgumentList</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">"(" ((</span><a href="#doc-xquery40-PositionalArguments"><span class="deltaxml-new">PositionalArguments</span></a><span class="deltaxml-new"> ("," </span><a href="#doc-xquery40-KeywordArguments"><span class="deltaxml-new">KeywordArguments</span></a><span class="deltaxml-new">)?) | </span><a href="#doc-xquery40-KeywordArguments"><span class="deltaxml-new">KeywordArguments</span></a><span class="deltaxml-new">)? ")"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PositionalArguments"></a><span class="deltaxml-new">[144]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-PositionalArguments"><span class="deltaxml-new">PositionalArguments</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-Argument"><span class="deltaxml-new">Argument</span></a><span class="deltaxml-new"> ("," </span><a href="#doc-xquery40-Argument"><span class="deltaxml-new">Argument</span></a><span class="deltaxml-new">)*</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12586.doc-xquery40-Argument"></a><span class="deltaxml-new">[163]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">Argument</span></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-ExprSingle"><span class="deltaxml-new">ExprSingle</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-ArgumentPlaceholder"><span class="deltaxml-new">ArgumentPlaceholder</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e12587.doc-xquery40-ArgumentPlaceholder"></a><span class="deltaxml-new">[164]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">ArgumentPlaceholder</span></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">"?"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-KeywordArguments"></a><span class="deltaxml-new">[145]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-KeywordArguments"><span class="deltaxml-new">KeywordArguments</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-KeywordArgument"><span class="deltaxml-new">KeywordArgument</span></a><span class="deltaxml-new"> ("," </span><a href="#doc-xquery40-KeywordArgument"><span class="deltaxml-new">KeywordArgument</span></a><span class="deltaxml-new">)*</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-KeywordArgument"></a><span class="deltaxml-new">[146]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-KeywordArgument"><span class="deltaxml-new">KeywordArgument</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-EQName"><span class="deltaxml-new">EQName</span></a><span class="deltaxml-new"> ":=" </span><a href="#doc-xquery40-Argument"><span class="deltaxml-new">Argument</span></a></code></td><td></td></tr></tbody></table><p><span class="deltaxml-new"> [</span><a id="dt-dynamic-function-invocation" title="dynamic function call"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: A </span><b><span class="deltaxml-new">dynamic function call</span></b><span class="deltaxml-new"> consists of a base expression that returns the function and a parenthesized list of zero or more arguments (</span><a title="argument expression" class="termref" href="#dt-arg-expr"><span class="deltaxml-new">argument expressions</span></a><span class="deltaxml-new"> or ArgumentPlaceholders).] </span></p><p><span class="deltaxml-new"> A dynamic function call is evaluated as described in </span><a href="#id-eval-dynamic-function-call"><b><span class="deltaxml-new">4.4.2.1 Evaluating Dynamic Function Calls</span></b></a><span class="deltaxml-new">. </span></p><p><span class="deltaxml-new">The following are examples of some dynamic function calls:</span></p><ul><li><p><span class="deltaxml-new">This example calls the function contained in $f, passing the arguments 2 and 3: </span></p><div class="exampleInner"><pre><span class="deltaxml-new">$f(2, 3)</span></pre></div></li><li><p><span class="deltaxml-new">This example fetches the second item from sequence $f, treats it as a function and calls it, passing an </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> argument: </span></p><div class="exampleInner"><pre><span class="deltaxml-new">$f[2]("Hi there")</span></pre></div></li><li><p><span class="deltaxml-new">This example calls the function </span><code><span class="deltaxml-new">$f</span></code><span class="deltaxml-new"> passing no arguments, and filters the result with a positional predicate: </span></p><div class="exampleInner"><pre><span class="deltaxml-new">$f()[2]</span></pre></div></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">Arguments in a dynamic function call are always supplied positionally.</span></p></div></div></div><div class="div2"><h3><a id="id-path-expressions"></a><span class="deltaxml-old">4.7</span><span class="deltaxml-new">4.6</span> Path Expressions</h3><a id="d3e15659"></a><a id="d3e13883"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PathExpr"></a>[<span class="deltaxml-old">135</span><span class="deltaxml-new">126</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-PathExpr">PathExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("/" <a href="#doc-xquery40-RelativePathExpr">RelativePathExpr</a>?)<br>| ("//" <a href="#doc-xquery40-RelativePathExpr">RelativePathExpr</a>)<br>| <a href="#doc-xquery40-RelativePathExpr">RelativePathExpr</a></code></td><td><i>/* <a href="#parse-note-leading-lone-slash">xgc: leading-lone-slash</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e14287.doc-xquery40-RelativePathExpr"></a><a id="noid_d4e12635.doc-xquery40-RelativePathExpr"></a>[<span class="deltaxml-old">136</span><span class="deltaxml-new">127</span>]&nbsp;&nbsp;&nbsp;</td><td><code>RelativePathExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-StepExpr">StepExpr</a> (("/" | "//") <a href="#doc-xquery40-StepExpr">StepExpr</a>)*</code></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version"> [<a id="dt-path-expression" title="path expression">Definition</a>: A path expression consists of a series of one or more <a title="step" class="termref" href="#dt-step">steps</a>, separated by <code>/</code> or <code>//</code>, and optionally beginning with <code>/</code> or <code>//</code>. A <b>path expression</b> is typically used to locate nodes within trees. ] </span><span style="display: none;" class="add_version"> [<a id="dt-path-expression" title="path expression">Definition</a>: A <b>path expression</b> can be used to locate nodes within trees. A path expression consists of a series of one or more <a title="step" class="termref" href="#dt-step">steps</a>, separated by "<code>/</code>" or "<code>//</code>", and optionally beginning with "<code>/</code>" or "<code>//</code>".] An initial "<code>/</code>" or "<code>//</code>" is an abbreviation for one or more initial steps that are implicitly added to the beginning of the path expression, as described below.</span><span class="modify_version"> [<a id="dt-path-expression" title="path expression">Definition</a>: A <b>path expression</b> <span class="deltaxml-new">can be used to locate nodes within trees. A path expression </span>consists of a series of one or more <a title="step" class="termref" href="#dt-step">steps</a>, separated by <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> or <span class="deltaxml-new">"</span><code>//</code><span class="deltaxml-new">"</span>, and optionally beginning with <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> or <span class="deltaxml-new">"</span><code>//</code><span class="deltaxml-old">. A</span><span class="deltaxml-new">".] An</span> <span class="deltaxml-old">path expression</span><span class="deltaxml-new">initial "</span><code><span class="deltaxml-new">/</span></code><span class="deltaxml-old"> </span><span class="deltaxml-new">" or "</span><code><span class="deltaxml-new">//</span></code><span class="deltaxml-old">is typically used to locate nodes within trees. ] </span><span class="deltaxml-new">" is an abbreviation for one or more initial steps that are implicitly added to the beginning of the path expression, as described below.</span></span></p><p><span class="deltaxml-old">Absolute path expressions (those starting with an initial </span><code><span class="deltaxml-old">/</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">//</span></code><span class="deltaxml-old">), start their selection from the root node of a tree; relative path expressions (those without a leading </span><code><span class="deltaxml-old">/</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">//</span></code><span class="deltaxml-old">) start from the </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-old">context value</span></a><span class="deltaxml-old">.</span></p><p>A path expression consisting of a single step is evaluated as described in <a href="#id-steps"><span style="display: none;" class="delete_version"><b>4.7.4 Steps</b></span><span style="display: none;" class="add_version"><b>4.6.2 Steps</b></span><span class="modify_version"><b><span class="deltaxml-old">4.7.4</span><span class="deltaxml-new">4.6.2</span> Steps</b></span></a>.</p><p><span class="deltaxml-new">A "</span><code><span class="deltaxml-new">/</span></code><span class="deltaxml-new">" at the beginning of a path expression is an abbreviation for the initial step </span><code><span class="deltaxml-new">(fn:root(self::node()) treat as document-node())/</span></code><span class="deltaxml-new"> (however, if the "</span><code><span class="deltaxml-new">/</span></code><span class="deltaxml-new">" is the entire path expression, the trailing "</span><code><span class="deltaxml-new">/</span></code><span class="deltaxml-new">" is omitted from the expansion.) The effect of this initial step is to begin the path at the root node of the tree that contains the context node. If the context item is not a node, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new">type error</span></a><span class="deltaxml-new"> is raised [</span><a href="#ERRXPTY0020" title="err:XPTY0020"><span class="deltaxml-new">err:XPTY0020</span></a><span class="deltaxml-new">]. At evaluation time, if the root node of the context node is not a document node, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new">dynamic error</span></a><span class="deltaxml-new"> is raised [</span><a href="#ERRXPDY0050" title="err:XPDY0050"><span class="deltaxml-new">err:XPDY0050</span></a><span class="deltaxml-new">].</span></p><p><span class="deltaxml-new">A "</span><code><span class="deltaxml-new">//</span></code><span class="deltaxml-new">" at the beginning of a path expression is an abbreviation for the initial steps </span><code><span class="deltaxml-new">(fn:root(self::node()) treat as document-node())/descendant-or-self::node()/</span></code><span class="deltaxml-new"> (however, "</span><code><span class="deltaxml-new">//</span></code><span class="deltaxml-new">" by itself is not a valid path expression [</span><a href="#ERRXPST0003" title="err:XPST0003"><span class="deltaxml-new">err:XPST0003</span></a><span class="deltaxml-new">].) The effect of these initial steps is to establish an initial node sequence that contains the root of the tree in which the context node is found, plus all nodes descended from this root. This node sequence is used as the input to subsequent steps in the path expression. If the context item is not a node, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new">type error</span></a><span class="deltaxml-new"> is raised [</span><a href="#ERRXPTY0020" title="err:XPTY0020"><span class="deltaxml-new">err:XPTY0020</span></a><span class="deltaxml-new">]. At evaluation time, if the root node of the context node is not a document node, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new">dynamic error</span></a><span class="deltaxml-new"> is raised [</span><a href="#ERRXPDY0050" title="err:XPDY0050"><span class="deltaxml-new">err:XPDY0050</span></a><span class="deltaxml-new">].</span></p><div class="note"><h4><a id="id-absolute-path-expressions"></a><span class="deltaxml-old">4.7.1 Absolute Path Expressions</span></h4><p><span class="deltaxml-old">A path expression consisting of </span><code><span class="deltaxml-old">/</span></code><span class="deltaxml-old"> on its own is treated as an abbreviation for </span><code><span class="deltaxml-old">/.</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">An expression of the form </span><code><span class="deltaxml-old">/PP</span></code><span class="deltaxml-old"> (that is, a path expression with a leading </span><code><span class="deltaxml-old">/</span></code><span class="deltaxml-old">) is treated as an abbreviation for the expression </span><code><span class="deltaxml-old">self::node()/(fn:root(.) treat as document-node())/PP</span></code><span class="deltaxml-old">. The effect of this expansion is that for every item </span><var><span class="deltaxml-old">J</span></var><span class="deltaxml-old"> in the context value </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old">:</span></p><ol class="enumar"><li><p><span class="deltaxml-old">A </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-old">type error</span></a><span class="deltaxml-old"> occurs if </span><var><span class="deltaxml-old">J</span></var><span class="deltaxml-old"> is not a node [</span><a href="#ERRXPTY0020" title="err:XPTY0020"><span class="deltaxml-old">err:XPTY0020</span></a><span class="deltaxml-old">].</span></p></li><li><p><span class="deltaxml-old">The root node </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> of the tree containing </span><var><span class="deltaxml-old">J</span></var><span class="deltaxml-old"> is selected.</span></p></li><li><p><span class="deltaxml-old">A </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-old">dynamic error</span></a><span class="deltaxml-old"> occurs if </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> is not a document node [</span><a href="#ERRXPDY0050" title="err:XPDY0050"><span class="deltaxml-old">err:XPDY0050</span></a><span class="deltaxml-old">].</span></p></li><li><p><span class="deltaxml-old">The expression that follows the leading </span><code><span class="deltaxml-old">/</span></code><span class="deltaxml-old"> is evaluated with </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> as the context value.</span></p></li></ol><p><span class="deltaxml-old">The results of these multiple evaluations are then combined into a single sequence; if the result is a set of nodes, the nodes are delivered in document order with duplicates eliminated.</span></p><p><span class="deltaxml-old">An expression of the form </span><code><span class="deltaxml-old">//PP</span></code><span class="deltaxml-old"> (that is, a path expression with a leading </span><code><span class="deltaxml-old">//</span></code><span class="deltaxml-old">) is treated as an abbreviation for the expression </span><code><span class="deltaxml-old">self::node()/(fn:root(.) treat as document-node())/descendant-or-self:node()/PP</span></code><span class="deltaxml-old">. The effect of this expansion is that for every item </span><var><span class="deltaxml-old">J</span></var><span class="deltaxml-old"> in the context value </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old">:</span></p><ol class="enumar"><li><p><span class="deltaxml-old">A </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-old">type error</span></a><span class="deltaxml-old"> occurs if </span><var><span class="deltaxml-old">J</span></var><span class="deltaxml-old"> is not a node [</span><a href="#ERRXPTY0020" title="err:XPTY0020"><span class="deltaxml-old">err:XPTY0020</span></a><span class="deltaxml-old">].</span></p></li><li><p><span class="deltaxml-old">The root node </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> of the tree containing </span><var><span class="deltaxml-old">J</span></var><span class="deltaxml-old"> is selected.</span></p></li><li><p><span class="deltaxml-old">A </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-old">dynamic error</span></a><span class="deltaxml-old"> occurs if </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> is not a document node [</span><a href="#ERRXPDY0050" title="err:XPDY0050"><span class="deltaxml-old">err:XPDY0050</span></a><span class="deltaxml-old">].</span></p></li><li><p><span class="deltaxml-old">The descendants of </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> are selected, along with </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> itself.</span></p></li><li><p><span class="deltaxml-old">For every node </span><var><span class="deltaxml-old">D</span></var><span class="deltaxml-old"> in this set of nodes, the expression that follows the leading </span><code><span class="deltaxml-old">//</span></code><span class="deltaxml-old"> is evaluated with </span><var><span class="deltaxml-old">D</span></var><span class="deltaxml-old"> as the context value.</span></p></li></ol><p><span class="deltaxml-old">The results of these multiple evaluations are then combined into a single sequence; if the result is a set of nodes, the nodes are delivered in document order with duplicates eliminated.</span></p><p><span class="deltaxml-old">If the context value is not a node, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-old">type error</span></a><span class="deltaxml-old"> is raised [</span><a href="#ERRXPTY0020" title="err:XPTY0020"><span class="deltaxml-old">err:XPTY0020</span></a><span class="deltaxml-old">]. At evaluation time, if the root node of the context node is not a document node, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-old">dynamic error</span></a><span class="deltaxml-old"> is raised [</span><a href="#ERRXPDY0050" title="err:XPDY0050"><span class="deltaxml-old">err:XPDY0050</span></a><span class="deltaxml-old">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The descendants of a node do not include attribute nodes.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">A </span><code><span class="deltaxml-old">//</span></code><span class="deltaxml-old"> on its own is not allowed by the grammar.</span></p></div><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">The descendants of a node do not include attribute nodes.</span></p></div><p><span class="deltaxml-new"> A path expression that starts with "</span><code><span class="deltaxml-new">/</span></code><span class="deltaxml-new">" or "</span><code><span class="deltaxml-new">//</span></code><span class="deltaxml-new">" selects nodes starting from the root of the tree containing the context item; it is often referred to as an absolute path expression. </span></p><div class="div3"><h4><a id="id-relative-path-expressions"></a><span class="deltaxml-old">4.7.2</span><span class="deltaxml-new">4.6.1</span> Relative Path Expressions</h4><a id="d3e15863"></a><a id="d3e13996"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RelativePathExpr"></a>[<span class="deltaxml-old">136</span><span class="deltaxml-new">127</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-RelativePathExpr">RelativePathExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-StepExpr">StepExpr</a> (("/" | "//") <a href="#doc-xquery40-StepExpr">StepExpr</a>)*</code></td><td></td></tr></tbody></table><p> A relative path expression is a path expression that selects nodes within a tree by following a series of steps starting at the <span class="deltaxml-old">nodes in the context value (which</span><span class="deltaxml-new">context node (which, unlike an absolute path expression,</span> may be any <span class="deltaxml-old">kind of node, not necessarily the root of the</span><span class="deltaxml-new">node in a</span> tree). </p><p><span style="display: none;" class="delete_version"> Each non-initial occurrence of <code>//</code> in a path expression is expanded as described in <a href="#abbrev"><span class="delete_version"><b>4.7.7 Abbreviated Syntax</b></span><span class="modify_version"><b>4.7.7 Abbreviated Syntax</b></span></a>, leaving a sequence of steps separated by <code>/</code>. This sequence of steps is then evaluated from left to right. So a path such as <code>E1/E2/E3/E4</code> is evaluated as <code>((E1/E2)/E3)/E4</code>. The semantics of a path expression are thus defined by the semantics of the binary <code>/</code> operator, which is defined in <a href="#id-path-operator"><span class="delete_version"><b>4.7.3 Path operator (/)</b></span><span class="modify_version"><b>4.7.3 Path operator (/)</b></span></a>. </span><span style="display: none;" class="add_version"> Each non-initial occurrence of "<code>//</code>" in a path expression is expanded as described in <a href="#abbrev"><span class="add_version"><b>4.6.5 Abbreviated Syntax</b></span><span class="modify_version"><b>4.6.5 Abbreviated Syntax</b></span></a>, leaving a sequence of steps separated by "<code>/</code>". This sequence of steps is then evaluated from left to right. So a path such as <code>E1/E2/E3/E4</code> is evaluated as <code>((E1/E2)/E3)/E4</code>. The semantics of a path expression are thus defined by the semantics of the binary "<code>/</code>" operator, which is defined in <a href="#id-path-operator"><span class="add_version"><b>4.6.1.1 Path operator (/)</b></span><span class="modify_version"><b>4.6.1.1 Path operator (/)</b></span></a>. </span><span class="modify_version"> Each non-initial occurrence of <span class="deltaxml-new">"</span><code>//</code><span class="deltaxml-new">"</span> in a path expression is expanded as described in <a href="#abbrev"><span style="display: none;" class="delete_version"><b>4.7.7 Abbreviated Syntax</b></span><span style="display: none;" class="add_version"><b>4.6.5 Abbreviated Syntax</b></span><span class="modify_version"><b><span class="deltaxml-old">4.7.7</span><span class="deltaxml-new">4.6.5</span> Abbreviated Syntax</b></span></a>, leaving a sequence of steps separated by <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span>. This sequence of steps is then evaluated from left to right. So a path such as <code>E1/E2/E3/E4</code> is evaluated as <code>((E1/E2)/E3)/E4</code>. The semantics of a path expression are thus defined by the semantics of the binary <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> operator, which is defined in <a href="#id-path-operator"><span style="display: none;" class="delete_version"><b>4.7.3 Path operator (/)</b></span><span style="display: none;" class="add_version"><b>4.6.1.1 Path operator (/)</b></span><span class="modify_version"><b><span class="deltaxml-old">4.7.3</span><span class="deltaxml-new">4.6.1.1</span> Path operator (/)</b></span></a>. </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version"> Although the semantics describe the evaluation of a path with more than two steps as proceeding from left to right, the <code>/</code> operator is in most cases associative, so evaluation from right to left usually delivers the same result. The cases where <code>/</code> is not associative arise when the functions <code>fn:position()</code> and <code>fn:last()</code> are used: <code>A/B/position()</code> delivers a sequence of integers from 1 to the size of <code>(A/B)</code>, whereas <code>A/(B/position())</code> restarts the counting at each <code>B</code> element. </span><span style="display: none;" class="add_version"> Although the semantics describe the evaluation of a path with more than two steps as proceeding from left to right, the "<code>/</code>" operator is in most cases associative, so evaluation from right to left usually delivers the same result. The cases where "<code>/</code>" is not associative arise when the functions <code>fn:position()</code> and <code>fn:last()</code> are used: <code>A/B/position()</code> delivers a sequence of integers from 1 to the size of <code>(A/B)</code>, whereas <code>A/(B/position())</code> restarts the counting at each <code>B</code> element. </span><span class="modify_version"> Although the semantics describe the evaluation of a path with more than two steps as proceeding from left to right, the <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> operator is in most cases associative, so evaluation from right to left usually delivers the same result. The cases where <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> is not associative arise when the functions <code>fn:position()</code> and <code>fn:last()</code> are used: <code>A/B/position()</code> delivers a sequence of integers from 1 to the size of <code>(A/B)</code>, whereas <code>A/(B/position())</code> restarts the counting at each <code>B</code> element. </span></p></div><p>The following example illustrates the use of relative path expressions.<span class="deltaxml-old"> In each case it is assumed that the context value is a single node, referred to as the context node.</span></p><div class="example"><ul><li><p><code>child::div1/child::para</code></p><p>Selects the <code>para</code> element children of the <code>div1</code> element children of the context node; that is, the <code>para</code> element grandchildren of the context node that have <code>div1</code> parents.</p></li></ul></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Since each step in a path provides context nodes for the following step, in effect, only the last step in a path is allowed to return a sequence of non-nodes.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p id="Chg-slash-note"><span style="display: none;" class="delete_version">The <code>/</code> character can be used either as a complete path expression or as the beginning of a longer path expression such as <code>/*</code>. Also, <code>*</code> is both the multiply operator and a wildcard in path expressions. This can cause parsing difficulties when <code>/</code> appears on the left-hand side of <code>*</code>. This is resolved using the <a href="#parse-note-leading-lone-slash">leading-lone-slash </a> constraint. For example, <code>/*</code> and <code>/ *</code> are valid path expressions containing wildcards, but <code>/*5</code> and <code>/ * 5</code> raise syntax errors. Parentheses must be used when <code>/</code> is used on the left-hand side of an operator, as in <code>(/) * 5</code>. Similarly, <code>4 + / * 5</code> raises a syntax error, but <code>4 + (/) * 5</code> is a valid expression. The expression <code>4 + /</code> is also valid, because <code>/</code> does not occur on the left-hand side of the operator.</span><span style="display: none;" class="add_version">The "<code>/</code>" character can be used either as a complete path expression or as the beginning of a longer path expression such as "<code>/*</code>". Also, "<code>*</code>" is both the multiply operator and a wildcard in path expressions. This can cause parsing difficulties when "<code>/</code>" appears on the left-hand side of "<code>*</code>". This is resolved using the <a href="#parse-note-leading-lone-slash">leading-lone-slash </a> constraint. For example, "<code>/*</code>" and "<code>/ *</code>" are valid path expressions containing wildcards, but "<code>/*5</code>" and "<code>/ * 5</code>" raise syntax errors. Parentheses must be used when "<code>/</code>" is used on the left-hand side of an operator, as in "<code>(/) * 5</code>". Similarly, "<code>4 + / * 5</code>" raises a syntax error, but "<code>4 + (/) * 5</code>" is a valid expression. The expression "<code>4 + /</code>" is also valid, because <code>/</code> does not occur on the left-hand side of the operator.</span><span class="modify_version">The <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> character can be used either as a complete path expression or as the beginning of a longer path expression such as <span class="deltaxml-new">"</span><code>/*</code><span class="deltaxml-new">"</span>. Also, <span class="deltaxml-new">"</span><code>*</code><span class="deltaxml-new">"</span> is both the multiply operator and a wildcard in path expressions. This can cause parsing difficulties when <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> appears on the left-hand side of <span class="deltaxml-new">"</span><code>*</code><span class="deltaxml-new">"</span>. This is resolved using the <a href="#parse-note-leading-lone-slash">leading-lone-slash </a> constraint. For example, <span class="deltaxml-new">"</span><code>/*</code><span class="deltaxml-new">"</span> and <span class="deltaxml-new">"</span><code>/ *</code><span class="deltaxml-new">"</span> are valid path expressions containing wildcards, but <span class="deltaxml-new">"</span><code>/*5</code><span class="deltaxml-new">"</span> and <span class="deltaxml-new">"</span><code>/ * 5</code><span class="deltaxml-new">"</span> raise syntax errors. Parentheses must be used when <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> is used on the left-hand side of an operator, as in <span class="deltaxml-new">"</span><code>(/) * 5</code><span class="deltaxml-new">"</span>. Similarly, <span class="deltaxml-new">"</span><code>4 + / * 5</code><span class="deltaxml-new">"</span> raises a syntax error, but <span class="deltaxml-new">"</span><code>4 + (/) * 5</code><span class="deltaxml-new">"</span> is a valid expression. The expression <span class="deltaxml-new">"</span><code>4 + /</code><span class="deltaxml-new">"</span> is also valid, because <code>/</code> does not occur on the left-hand side of the operator.</span></p><p><span style="display: none;" class="delete_version">Similarly, in the expression <code>/ union /*</code>, <code>union</code> is interpreted as an element name rather than an operator. For it to be parsed as an operator, the expression should be written <code>(/) union /*</code>.</span><span style="display: none;" class="add_version">Similarly, in the expression <code>/ union /*</code>, "union" is interpreted as an element name rather than an operator. For it to be parsed as an operator, the expression should be written <code>(/) union /*</code>.</span><span class="modify_version">Similarly, in the expression <code>/ union /*</code>, <span class="deltaxml-new">"</span>union<span class="deltaxml-new">"</span> is interpreted as an element name rather than an operator. For it to be parsed as an operator, the expression should be written <code>(/) union /*</code>.</span></p></div><div class="div4"><h5><a id="id-path-operator"></a><span class="deltaxml-new">4.6.1.1 Path operator (</span><code><span class="deltaxml-new">/</span></code><span class="deltaxml-new">)</span></h5><p><span class="deltaxml-new">The path operator "/" is used to build expressions for locating nodes within trees. Its left-hand side expression must return a sequence of nodes. The operator returns either a sequence of nodes, in which case it additionally performs document ordering and duplicate elimination, or a sequence of non-nodes.</span></p><p><span class="deltaxml-new">Each operation </span><code><span class="deltaxml-new">E1/E2</span></code><span class="deltaxml-new"> is evaluated as follows: Expression </span><code><span class="deltaxml-new">E1</span></code><span class="deltaxml-new"> is evaluated, and if the result is not a (possibly empty) sequence </span><code><span class="deltaxml-new">S</span></code><span class="deltaxml-new"> of nodes, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new">type error</span></a><span class="deltaxml-new"> is raised [</span><a href="#ERRXPTY0019" title="err:XPTY0019"><span class="deltaxml-new">err:XPTY0019</span></a><span class="deltaxml-new">]. Each node in </span><code><span class="deltaxml-new">S</span></code><span class="deltaxml-new"> then serves in turn to provide an inner focus (the node as the context item, its position in </span><code><span class="deltaxml-new">S</span></code><span class="deltaxml-new"> as the context position, the length of </span><code><span class="deltaxml-new">S</span></code><span class="deltaxml-new"> as the context size) for an evaluation of </span><code><span class="deltaxml-new">E2</span></code><span class="deltaxml-new">, as described in </span><a href="#eval_context"><b><span class="deltaxml-new">2.2.2 Dynamic Context</span></b></a><span class="deltaxml-new">. The sequences resulting from all the evaluations of </span><code><span class="deltaxml-new">E2</span></code><span class="deltaxml-new"> are combined as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new">If every evaluation of </span><code><span class="deltaxml-new">E2</span></code><span class="deltaxml-new"> returns a (possibly empty) sequence of nodes, these sequences are combined, and duplicate nodes are eliminated based on node identity. </span><span class="xquery"><span class="deltaxml-new">If ordering mode is ordered, the resulting node sequence is returned in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new">document order</span></a><span class="deltaxml-new">; otherwise it is returned in </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new">implementation-dependent</span></a><span class="deltaxml-new"> order.</span></span></p></li><li><p><span class="deltaxml-new">If every evaluation of </span><code><span class="deltaxml-new">E2</span></code><span class="deltaxml-new"> returns a (possibly empty) sequence of non-nodes, these sequences are concatenated and returned. </span><span class="xquery"><span class="deltaxml-new">If </span><a title="ordering mode" class="termref" href="#dt-ordering-mode"><span class="deltaxml-new">ordering mode</span></a><span class="deltaxml-new"> is </span><code><span class="deltaxml-new">ordered</span></code><span class="deltaxml-new">, the</span></span><span class="deltaxml-new"> returned sequence preserves the orderings within and among the subsequences generated by the evaluations of </span><code><span class="deltaxml-new">E2</span></code><span class="xquery"><span class="deltaxml-new">; otherwise the order of the returned sequence is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new">implementation-dependent</span></a><span class="deltaxml-new">.</span></span></p></li><li><p><span class="deltaxml-new">If the multiple evaluations of </span><code><span class="deltaxml-new">E2</span></code><span class="deltaxml-new"> return at least one node and at least one non-node, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new">type error</span></a><span class="deltaxml-new"> is raised [</span><a href="#ERRXPTY0018" title="err:XPTY0018"><span class="deltaxml-new">err:XPTY0018</span></a><span class="deltaxml-new">].</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">The semantics of the path operator can also be defined using the simple map operator as follows (forming the union with an empty sequence </span><code><span class="deltaxml-new">($R | ())</span></code><span class="deltaxml-new"> has the effect of eliminating duplicates and sorting nodes into document order):</span></p><div class="exampleInner"><pre><span class="deltaxml-new">E1/E2 ::= let $R := E1!E2 return if (every $r in $R satisfies $r instance of node()) then ($R|()) else if (every $r in $R satisfies not($r instance of node())) then $R else error()</span></pre></div></div></div></div><div class="div3"><h4><a id="id-path-operator"></a><span class="deltaxml-old">4.7.3 Path operator (</span><code><span class="deltaxml-old">/</span></code><span class="deltaxml-old">)</span></h4><p><span class="deltaxml-old">The path operator </span><code><span class="deltaxml-old">/</span></code><span class="deltaxml-old"> is primarily used for locating nodes within trees. Its left-hand operand must return a sequence of nodes. The result of the operator is either a sequence of nodes (in document order, with no duplicates), or a sequence of non-nodes.</span></p><p><span class="deltaxml-old">The operation </span><code><span class="deltaxml-old">E1/E2</span></code><span class="deltaxml-old"> is evaluated as follows: Expression </span><code><span class="deltaxml-old">E1</span></code><span class="deltaxml-old"> is evaluated, and if the result is not a (possibly empty) sequence </span><code><span class="deltaxml-old">S</span></code><span class="deltaxml-old"> of nodes, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-old">type error</span></a><span class="deltaxml-old"> is raised [</span><a href="#ERRXPTY0019" title="err:XPTY0019"><span class="deltaxml-old">err:XPTY0019</span></a><span class="deltaxml-old">]. Each node in </span><code><span class="deltaxml-old">S</span></code><span class="deltaxml-old"> then serves in turn to provide an inner focus (the node as the context value, its position in </span><code><span class="deltaxml-old">S</span></code><span class="deltaxml-old"> as the context position, the length of </span><code><span class="deltaxml-old">S</span></code><span class="deltaxml-old"> as the context size) for an evaluation of </span><code><span class="deltaxml-old">E2</span></code><span class="deltaxml-old">, as described in </span><a href="#eval_context"><b><span class="deltaxml-old">2.2.2 Dynamic Context</span></b></a><span class="deltaxml-old">. The sequences resulting from all the evaluations of </span><code><span class="deltaxml-old">E2</span></code><span class="deltaxml-old"> are combined as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-old">If every evaluation of </span><code><span class="deltaxml-old">E2</span></code><span class="deltaxml-old"> returns a (possibly empty) sequence of nodes, these sequences are combined, and duplicate nodes are eliminated based on node identity. </span><span class="xquery"><span class="deltaxml-old">If ordering mode is ordered, the resulting node sequence is returned in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-old">document order</span></a><span class="deltaxml-old">; otherwise it is returned in </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-old">implementation-dependent</span></a><span class="deltaxml-old"> order.</span></span></p></li><li><p><span class="deltaxml-old">If every evaluation of </span><code><span class="deltaxml-old">E2</span></code><span class="deltaxml-old"> returns a (possibly empty) sequence of non-nodes, these sequences are concatenated and returned. </span><span class="xquery"><span class="deltaxml-old">If </span><a title="ordering mode" class="termref" href="#dt-ordering-mode"><span class="deltaxml-old">ordering mode</span></a><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">ordered</span></code><span class="deltaxml-old">, the</span></span><span class="deltaxml-old"> returned sequence preserves the orderings within and among the subsequences generated by the evaluations of </span><code><span class="deltaxml-old">E2</span></code><span class="xquery"><span class="deltaxml-old">; otherwise the order of the returned sequence is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-old">implementation-dependent</span></a><span class="deltaxml-old">.</span></span></p></li><li><p><span class="deltaxml-old">If the multiple evaluations of </span><code><span class="deltaxml-old">E2</span></code><span class="deltaxml-old"> return at least one node and at least one non-node, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-old">type error</span></a><span class="deltaxml-old"> is raised [</span><a href="#ERRXPTY0018" title="err:XPTY0018"><span class="deltaxml-old">err:XPTY0018</span></a><span class="deltaxml-old">].</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The semantics of the path operator can also be defined using the simple map operator (</span><code><span class="deltaxml-old">!</span></code><span class="deltaxml-old">) as follows (forming the union with an empty sequence </span><code><span class="deltaxml-old">($R | ())</span></code><span class="deltaxml-old"> has the effect of eliminating duplicates and sorting nodes into document order):</span></p><div class="exampleInner"><pre><span class="deltaxml-old">E1/E2 ::= let $R := E1!E2 return if (every $r in $R satisfies $r instance of node()) then ($R|()) else if (every $r in $R satisfies not($r instance of node())) then $R else error()</span></pre></div><p><span class="deltaxml-old">For a table comparing the step operator to the map operator, see </span><a href="#id-map-operator"><b><span class="deltaxml-old">4.23 Simple map operator (!)</span></b></a><span class="deltaxml-old">.</span></p></div></div><div class="div3"><h4><a id="id-steps"></a><span class="deltaxml-old">4.7.4</span><span class="deltaxml-new">4.6.2</span> Steps</h4><a id="d3e16084"></a><a id="d3e14206"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StepExpr"></a>[<span class="deltaxml-old">137</span><span class="deltaxml-new">128</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-StepExpr">StepExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PostfixExpr">PostfixExpr</a> | <a href="#doc-xquery40-AxisStep">AxisStep</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e14673.doc-xquery40-AxisStep"></a><a id="noid_d4e12919.doc-xquery40-AxisStep"></a>[<span class="deltaxml-old">138</span><span class="deltaxml-new">129</span>]&nbsp;&nbsp;&nbsp;</td><td><code>AxisStep</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#doc-xquery40-ReverseStep">ReverseStep</a> | <a href="#doc-xquery40-ForwardStep">ForwardStep</a>) <a href="#doc-xquery40-PredicateList">PredicateList</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForwardStep"></a>[<span class="deltaxml-old">139</span><span class="deltaxml-new">130</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ForwardStep">ForwardStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#doc-xquery40-ForwardAxis">ForwardAxis</a><a href="#doc-xquery40-NodeTest">NodeTest</a>) | <a href="#doc-xquery40-AbbrevForwardStep">AbbrevForwardStep</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ReverseStep"></a>[<span class="deltaxml-old">142</span><span class="deltaxml-new">133</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ReverseStep">ReverseStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#doc-xquery40-ReverseAxis">ReverseAxis</a><a href="#doc-xquery40-NodeTest">NodeTest</a>) | <a href="#doc-xquery40-AbbrevReverseStep">AbbrevReverseStep</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e14676.doc-xquery40-PredicateList"></a><a id="noid_d4e12922.doc-xquery40-PredicateList"></a>[<span class="deltaxml-old">158</span><span class="deltaxml-new">147</span>]&nbsp;&nbsp;&nbsp;</td><td><code>PredicateList</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Predicate">Predicate</a>*</code></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version"> [<a id="dt-step" title="step">Definition</a>: A <b>step</b> is a part of a <a title="path expression" class="termref" href="#dt-path-expression">path expression</a> that generates a sequence of items and then filters the sequence by zero or more <a title="" class="termref" href="#dt-predicate">predicates</a>. The value of the step consists of those items that satisfy the predicates, working from left to right. A step may be either an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a> or a postfix expression.] Postfix expressions are described in <a href="#id-postfix-expression"><span class="delete_version"><b>4.4 Postfix Expressions</b></span><span class="modify_version"><b>4.4 Postfix Expressions</b></span></a>.</span><span style="display: none;" class="add_version"> [<a id="dt-step" title="step">Definition</a>: A <b>step</b> is a part of a <a title="path expression" class="termref" href="#dt-path-expression">path expression</a> that generates a sequence of items and then filters the sequence by zero or more <a title="" class="termref" href="#dt-predicate">predicates</a>. The value of the step consists of those items that satisfy the predicates, working from left to right. A step may be either an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a> or a postfix expression.] Postfix expressions are described in <a href="#id-postfix-expression"><span class="add_version"><b>4.5 Postfix Expressions</b></span><span class="modify_version"><b>4.5 Postfix Expressions</b></span></a>.</span><span class="modify_version"> [<a id="dt-step" title="step">Definition</a>: A <b>step</b> is a part of a <a title="path expression" class="termref" href="#dt-path-expression">path expression</a> that generates a sequence of items and then filters the sequence by zero or more <a title="" class="termref" href="#dt-predicate">predicates</a>. The value of the step consists of those items that satisfy the predicates, working from left to right. A step may be either an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a> or a postfix expression.] Postfix expressions are described in <a href="#id-postfix-expression"><span style="display: none;" class="delete_version"><b>4.4 Postfix Expressions</b></span><span style="display: none;" class="add_version"><b>4.5 Postfix Expressions</b></span><span class="modify_version"><b><span class="deltaxml-old">4.4</span><span class="deltaxml-new">4.5</span> Postfix Expressions</b></span></a>.</span></p><p><span style="display: none;" class="delete_version"> [<a id="dt-axis-step" title="axis step">Definition</a>: An <b>axis step</b> returns a sequence of nodes that are reachable from a starting node via a specified axis. Such a step has two parts: an <b>axis</b>, which defines the "direction of movement" for the step, and a <a title="node test" class="termref" href="#dt-node-test">node test</a>, which selects nodes based on their kind, name, and/or <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> .] </span><span style="display: none;" class="add_version"> [<a id="dt-axis-step" title="axis step">Definition</a>: An <b>axis step</b> returns a sequence of nodes that are reachable from the context node via a specified axis. Such a step has two parts: an <b>axis</b>, which defines the "direction of movement" for the step, and a <a title="node test" class="termref" href="#dt-node-test">node test</a>, which selects nodes based on their kind, name, and/or <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>.] If the context item is a node, an axis step returns a sequence of zero or more nodes; otherwise, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0020" title="err:XPTY0020">err:XPTY0020</a>]. <span class="xquery">If <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the resulting node sequence is returned in <a title="document order" class="termref" href="#dt-document-order">document order</a>; otherwise it is returned in <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order.</span> An axis step may be either a <b>forward step</b> or a <b>reverse step</b>, followed by zero or more <a title="" class="termref" href="#dt-predicate">predicates</a>.</span><span class="modify_version"> [<a id="dt-axis-step" title="axis step">Definition</a>: An <b>axis step</b> returns a sequence of nodes that are reachable from <span class="deltaxml-old">a starting</span><span class="deltaxml-new">the context</span> node via a specified axis. Such a step has two parts: an <b>axis</b>, which defines the "direction of movement" for the step, and a <a title="node test" class="termref" href="#dt-node-test">node test</a>, which selects nodes based on their kind, name, and/or <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><span class="deltaxml-old"> </span>.] <span class="deltaxml-new">If the context item is a node, an axis step returns a sequence of zero or more nodes; otherwise, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new">type error</span></a><span class="deltaxml-new"> is raised [</span><a href="#ERRXPTY0020" title="err:XPTY0020"><span class="deltaxml-new">err:XPTY0020</span></a><span class="deltaxml-new">]. </span><span class="xquery"><span class="deltaxml-new">If </span><a title="ordering mode" class="termref" href="#dt-ordering-mode"><span class="deltaxml-new">ordering mode</span></a><span class="deltaxml-new"> is </span><code><span class="deltaxml-new">ordered</span></code><span class="deltaxml-new">, the resulting node sequence is returned in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new">document order</span></a><span class="deltaxml-new">; otherwise it is returned in </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new">implementation-dependent</span></a><span class="deltaxml-new"> order.</span></span><span class="deltaxml-new"> An axis step may be either a </span><b><span class="deltaxml-new">forward step</span></b><span class="deltaxml-new"> or a </span><b><span class="deltaxml-new">reverse step</span></b><span class="deltaxml-new">, followed by zero or more </span><a title="" class="termref" href="#dt-predicate"><span class="deltaxml-new">predicates</span></a><span class="deltaxml-new">.</span></span></p><p><span class="deltaxml-old">If the context value is a sequence of zero or more nodes, an axis step returns a sequence of zero or more nodes; otherwise, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-old">type error</span></a><span class="deltaxml-old"> is raised [</span><a href="#ERRXPTY0020" title="err:XPTY0020"><span class="deltaxml-old">err:XPTY0020</span></a><span class="deltaxml-old">].</span></p><p><span class="deltaxml-old">The step expression </span><code><span class="deltaxml-old">S</span></code><span class="deltaxml-old"> is equivalent to </span><code><span class="deltaxml-old">./S</span></code><span class="deltaxml-old">. Thus, if the context value is a sequence containing multiple nodes, the semantics of a step expression are equivalent to a path expression in which the step is always applied to a single node. The following description therefore explains the semantics for the case where the context value is a single node, called the context node.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The equivalence of a step </span><code><span class="deltaxml-old">S</span></code><span class="deltaxml-old"> to the path expression </span><code><span class="deltaxml-old">./S</span></code><span class="deltaxml-old"> means that </span><span class="xquery"><span class="deltaxml-old">if </span><a title="ordering mode" class="termref" href="#dt-ordering-mode"><span class="deltaxml-old">ordering mode</span></a><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">ordered</span></code><span class="deltaxml-old">, the resulting node sequence is returned in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-old">document order</span></a><span class="deltaxml-old">; otherwise it is returned in </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-old">implementation-dependent</span></a><span class="deltaxml-old"> order.</span></span></p></div><p><span class="deltaxml-old">An axis step may be either a </span><b><span class="deltaxml-old">forward step</span></b><span class="deltaxml-old"> or a </span><b><span class="deltaxml-old">reverse step</span></b><span class="deltaxml-old">, followed by zero or more </span><a title="" class="termref" href="#dt-predicate"><span class="deltaxml-old">predicates</span></a><span class="deltaxml-old">.</span></p><p><span style="display: none;" class="delete_version">In the <b>abbreviated syntax</b> for a step, the axis can be omitted and other shorthand notations can be used as described in <a href="#abbrev"><span class="delete_version"><b>4.7.7 Abbreviated Syntax</b></span><span class="modify_version"><b>4.7.7 Abbreviated Syntax</b></span></a>.</span><span style="display: none;" class="add_version">In the <b>abbreviated syntax</b> for a step, the axis can be omitted and other shorthand notations can be used as described in <a href="#abbrev"><span class="add_version"><b>4.6.5 Abbreviated Syntax</b></span><span class="modify_version"><b>4.6.5 Abbreviated Syntax</b></span></a>.</span><span class="modify_version">In the <b>abbreviated syntax</b> for a step, the axis can be omitted and other shorthand notations can be used as described in <a href="#abbrev"><span style="display: none;" class="delete_version"><b>4.7.7 Abbreviated Syntax</b></span><span style="display: none;" class="add_version"><b>4.6.5 Abbreviated Syntax</b></span><span class="modify_version"><b><span class="deltaxml-old">4.7.7</span><span class="deltaxml-new">4.6.5</span> Abbreviated Syntax</b></span></a>.</span></p><p><span style="display: none;" class="delete_version">The unabbreviated syntax for an axis step consists of the axis name and node test separated by a double colon. The result of the step consists of the nodes reachable from the starting node via the specified axis that have the node kind, name, and/or <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> specified by the node test. For example, the step <code>child::para</code> selects the <code>para</code> element children of the context node: <code>child</code> is the name of the axis, and <code>para</code> is the name of the element nodes to be selected on this axis. The available axes are described in <a href="#axes"><span class="delete_version"><b>4.7.4.1 Axes</b></span><span class="modify_version"><b>4.7.4.1 Axes</b></span></a>. The available node tests are described in <a href="#node-tests"><span class="delete_version"><b>4.7.4.2 Node Tests</b></span><span class="modify_version"><b>4.7.4.2 Node Tests</b></span></a>. Examples of steps are provided in <a href="#unabbrev"><span class="delete_version"><b>4.7.6 Unabbreviated Syntax</b></span><span class="modify_version"><b>4.7.6 Unabbreviated Syntax</b></span></a> and <a href="#abbrev"><span class="delete_version"><b>4.7.7 Abbreviated Syntax</b></span><span class="modify_version"><b>4.7.7 Abbreviated Syntax</b></span></a>.</span><span style="display: none;" class="add_version">The unabbreviated syntax for an axis step consists of the axis name and node test separated by a double colon. The result of the step consists of the nodes reachable from the context node via the specified axis that have the node kind, name, and/or <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> specified by the node test. For example, the step <code>child::para</code> selects the <code>para</code> element children of the context node: <code>child</code> is the name of the axis, and <code>para</code> is the name of the element nodes to be selected on this axis. The available axes are described in <a href="#axes"><span class="add_version"><b>4.6.2.1 Axes</b></span><span class="modify_version"><b>4.6.2.1 Axes</b></span></a>. The available node tests are described in <a href="#node-tests"><span class="add_version"><b>4.6.2.2 Node Tests</b></span><span class="modify_version"><b>4.6.2.2 Node Tests</b></span></a>. Examples of steps are provided in <a href="#unabbrev"><span class="add_version"><b>4.6.4 Unabbreviated Syntax</b></span><span class="modify_version"><b>4.6.4 Unabbreviated Syntax</b></span></a> and <a href="#abbrev"><span class="add_version"><b>4.6.5 Abbreviated Syntax</b></span><span class="modify_version"><b>4.6.5 Abbreviated Syntax</b></span></a>.</span><span class="modify_version">The unabbreviated syntax for an axis step consists of the axis name and node test separated by a double colon. The result of the step consists of the nodes reachable from the <span class="deltaxml-old">starting</span><span class="deltaxml-new">context</span> node via the specified axis that have the node kind, name, and/or <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> specified by the node test. For example, the step <code>child::para</code> selects the <code>para</code> element children of the context node: <code>child</code> is the name of the axis, and <code>para</code> is the name of the element nodes to be selected on this axis. The available axes are described in <a href="#axes"><span style="display: none;" class="delete_version"><b>4.7.4.1 Axes</b></span><span style="display: none;" class="add_version"><b>4.6.2.1 Axes</b></span><span class="modify_version"><b><span class="deltaxml-old">4.7.4.1</span><span class="deltaxml-new">4.6.2.1</span> Axes</b></span></a>. The available node tests are described in <a href="#node-tests"><span style="display: none;" class="delete_version"><b>4.7.4.2 Node Tests</b></span><span style="display: none;" class="add_version"><b>4.6.2.2 Node Tests</b></span><span class="modify_version"><b><span class="deltaxml-old">4.7.4.2</span><span class="deltaxml-new">4.6.2.2</span> Node Tests</b></span></a>. Examples of steps are provided in <a href="#unabbrev"><span style="display: none;" class="delete_version"><b>4.7.6 Unabbreviated Syntax</b></span><span style="display: none;" class="add_version"><b>4.6.4 Unabbreviated Syntax</b></span><span class="modify_version"><b><span class="deltaxml-old">4.7.6</span><span class="deltaxml-new">4.6.4</span> Unabbreviated Syntax</b></span></a> and <a href="#abbrev"><span style="display: none;" class="delete_version"><b>4.7.7 Abbreviated Syntax</b></span><span style="display: none;" class="add_version"><b>4.6.5 Abbreviated Syntax</b></span><span class="modify_version"><b><span class="deltaxml-old">4.7.7</span><span class="deltaxml-new">4.6.5</span> Abbreviated Syntax</b></span></a>.</span></p><div class="div4"><h5><a id="axes"></a><span class="deltaxml-old">4.7.4.1</span><span class="deltaxml-new">4.6.2.1</span> Axes</h5><a id="d3e16249"></a><a id="d3e14355"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForwardAxis"></a>[<span class="deltaxml-old">140</span><span class="deltaxml-new">131</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ForwardAxis">ForwardAxis</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("child" "::")<br>| ("descendant" "::")<br>| ("attribute" "::")<br>| ("self" "::")<br>| ("descendant-or-self" "::")<br>| ("following-sibling" "::")<br>| ("following" "::")</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ReverseAxis"></a>[<span class="deltaxml-old">143</span><span class="deltaxml-new">134</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ReverseAxis">ReverseAxis</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("parent" "::")<br>| ("ancestor" "::")<br>| ("preceding-sibling" "::")<br>| ("preceding" "::")<br>| ("ancestor-or-self" "::")</code></td><td></td></tr></tbody></table><p class="xquery">XQuery supports the following axes:</p><ul><li><p><span style="display: none;" class="delete_version">The <code>child</code> axis contains the children of the context node, which are the nodes returned by the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dm-children">Section 4.3 children Accessor</a><sup><small>DM40</small></sup>. </span><span style="display: none;" class="add_version">The <code>child</code> axis contains the children of the context node, which are the nodes returned by the <a href="https://www.w3.org/TR/xpath-datamodel-31/#dm-children">Section 5.3 children Accessor </a><sup><small>DM31</small></sup>. </span><span class="modify_version">The <code>child</code> axis contains the children of the context node, which are the nodes returned by the <a href="https://www.w3.org/TR/xpath-datamodel-31/#dm-children">Section <span class="deltaxml-old">4.3</span><span class="deltaxml-new">5.3</span> children Accessor<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>. </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Only document nodes and element nodes have children. If the context node is any other kind of node, or if the context node is an empty document or element node, then the child axis is an empty sequence. The children of a document node or element node may be element, processing instruction, comment, or text nodes. Attribute and document nodes can never appear as children.</p></div></li><li><p><span style="display: none;" class="delete_version">The <code>descendant</code> axis is defined as the transitive closure of the child axis; it contains the descendants of the context node (the children, the children of the children, and so on).</span><span style="display: none;" class="add_version">the <code>descendant</code> axis is defined as the transitive closure of the child axis; it contains the descendants of the context node (the children, the children of the children, and so on)</span><span class="modify_version"><span class="deltaxml-old">The</span><span class="deltaxml-new">the</span> <code>descendant</code> axis is defined as the transitive closure of the child axis; it contains the descendants of the context node (the children, the children of the children, and so on)<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version">The <code>parent</code> axis contains the sequence returned by the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dm-parent">Section 4.11 parent Accessor</a><sup><small>DM40</small></sup>, which returns the parent of the context node, or an empty sequence if the context node has no parent.</span><span style="display: none;" class="add_version">the <code>parent</code> axis contains the sequence returned by the <a href="https://www.w3.org/TR/xpath-datamodel-31/#dm-parent">Section 5.11 parent Accessor </a><sup><small>DM31</small></sup>, which returns the parent of the context node, or an empty sequence if the context node has no parent</span><span class="modify_version"><span class="deltaxml-old">The</span><span class="deltaxml-new">the</span> <code>parent</code> axis contains the sequence returned by the <a href="https://www.w3.org/TR/xpath-datamodel-31/#dm-parent">Section <span class="deltaxml-old">4.11</span><span class="deltaxml-new">5.11</span> parent Accessor<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>, which returns the parent of the context node, or an empty sequence if the context node has no parent<span class="deltaxml-old">.</span></span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>An attribute node may have an element node as its parent, even though the attribute node is not a child of the element node.</p></div></li><li><p><span style="display: none;" class="delete_version">The <code>ancestor</code> axis is defined as the transitive closure of the parent axis; it contains the ancestors of the context node (the parent, the parent of the parent, and so on).</span><span style="display: none;" class="add_version">the <code>ancestor</code> axis is defined as the transitive closure of the parent axis; it contains the ancestors of the context node (the parent, the parent of the parent, and so on)</span><span class="modify_version"><span class="deltaxml-old">The</span><span class="deltaxml-new">the</span> <code>ancestor</code> axis is defined as the transitive closure of the parent axis; it contains the ancestors of the context node (the parent, the parent of the parent, and so on)<span class="deltaxml-old">.</span></span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The ancestor axis includes the root node of the tree in which the context node is found, unless the context node is the root node.</p></div></li><li><p><span style="display: none;" class="delete_version">the <code>following-sibling</code> axis contains the context node’s following siblings, those children of the context node’s parent that occur after the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a>; if the context node is an attribute node, the <code>following-sibling</code> axis is empty.</span><span style="display: none;" class="add_version">the <code>following-sibling</code> axis contains the context node's following siblings, those children of the context node's parent that occur after the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a>; if the context node is an attribute node, the <code>following-sibling</code> axis is empty</span><span class="modify_version">the <code>following-sibling</code> axis contains the context <span class="deltaxml-old">node’s</span><span class="deltaxml-new">node's</span> following siblings, those children of the context <span class="deltaxml-old">node’s</span><span class="deltaxml-new">node's</span> parent that occur after the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a>; if the context node is an attribute node, the <code>following-sibling</code> axis is empty<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version">the <code>preceding-sibling</code> axis contains the context node’s preceding siblings, those children of the context node’s parent that occur before the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a>; if the context node is an attribute node, the <code>preceding-sibling</code> axis is empty.</span><span style="display: none;" class="add_version">the <code>preceding-sibling</code> axis contains the context node's preceding siblings, those children of the context node's parent that occur before the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a>; if the context node is an attribute node, the <code>preceding-sibling</code> axis is empty</span><span class="modify_version">the <code>preceding-sibling</code> axis contains the context <span class="deltaxml-old">node’s</span><span class="deltaxml-new">node's</span> preceding siblings, those children of the context <span class="deltaxml-old">node’s</span><span class="deltaxml-new">node's</span> parent that occur before the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a>; if the context node is an attribute node, the <code>preceding-sibling</code> axis is empty<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version">The <code>following</code> axis contains all nodes that are descendants of the root of the tree in which the context node is found, are not descendants of the context node, and occur after the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a>. </span><span style="display: none;" class="add_version">the <code>following</code> axis contains all nodes that are descendants of the root of the tree in which the context node is found, are not descendants of the context node, and occur after the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a></span><span class="modify_version"><span class="deltaxml-old">The</span><span class="deltaxml-new">the</span> <code>following</code> axis contains all nodes that are descendants of the root of the tree in which the context node is found, are not descendants of the context node, and occur after the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a><span class="deltaxml-old">. </span></span></p></li><li><p><span style="display: none;" class="delete_version">The <code>preceding</code> axis contains all nodes that are descendants of the root of the tree in which the context node is found, are not ancestors of the context node, and occur before the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a>. </span><span style="display: none;" class="add_version">the <code>preceding</code> axis contains all nodes that are descendants of the root of the tree in which the context node is found, are not ancestors of the context node, and occur before the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a></span><span class="modify_version"><span class="deltaxml-old">The</span><span class="deltaxml-new">the</span> <code>preceding</code> axis contains all nodes that are descendants of the root of the tree in which the context node is found, are not ancestors of the context node, and occur before the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a><span class="deltaxml-old">. </span></span></p></li><li><p><span style="display: none;" class="delete_version">The <code>attribute</code> axis contains the attributes of the context node, which are the nodes returned by the <span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dm-attributes">Section 4.1 attributes Accessor</a><sup><small>DM40</small></sup></span>; the axis will be empty unless the context node is an element.</span><span style="display: none;" class="add_version">the <code>attribute</code> axis contains the attributes of the context node, which are the nodes returned by the <span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dm-attributes">Section 5.1 attributes Accessor </a><sup><small>DM31</small></sup></span>; the axis will be empty unless the context node is an element</span><span class="modify_version"><span class="deltaxml-old">The</span><span class="deltaxml-new">the</span> <code>attribute</code> axis contains the attributes of the context node, which are the nodes returned by the <span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dm-attributes">Section <span class="deltaxml-old">4.1</span><span class="deltaxml-new">5.1</span> attributes Accessor<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup></span>; the axis will be empty unless the context node is an element<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version">The <code>self</code> axis contains just the context node itself.</span><span style="display: none;" class="add_version">the <code>self</code> axis contains just the context node itself</span><span class="modify_version"><span class="deltaxml-old">The</span><span class="deltaxml-new">the</span> <code>self</code> axis contains just the context node itself<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version">The <code>descendant-or-self</code> axis contains the context node and the descendants of the context node.</span><span style="display: none;" class="add_version">the <code>descendant-or-self</code> axis contains the context node and the descendants of the context node</span><span class="modify_version"><span class="deltaxml-old">The</span><span class="deltaxml-new">the</span> <code>descendant-or-self</code> axis contains the context node and the descendants of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version">The <code>ancestor-or-self</code> axis contains the context node and the ancestors of the context node; thus, the ancestor-or-self axis will always include the root node.</span><span style="display: none;" class="add_version">the <code>ancestor-or-self</code> axis contains the context node and the ancestors of the context node; thus, the ancestor-or-self axis will always include the root node</span><span class="modify_version"><span class="deltaxml-old">The</span><span class="deltaxml-new">the</span> <code>ancestor-or-self</code> axis contains the context node and the ancestors of the context node; thus, the ancestor-or-self axis will always include the root node<span class="deltaxml-old">.</span></span></p></li></ul><p>Axes can be categorized as <b>forward axes</b> and <b>reverse axes</b>. An axis that only ever contains the context node or nodes that are after the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a> is a forward axis. An axis that only ever contains the context node or nodes that are before the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a> is a reverse axis.</p><p>The <code>parent</code>, <code>ancestor</code>, <code>ancestor-or-self</code>, <code>preceding</code>, and <code>preceding-sibling</code> axes are reverse axes; all other axes are forward axes. The <code>ancestor</code>, <code>descendant</code>, <code>following</code>, <code>preceding</code> and <code>self</code> axes partition a document (ignoring attribute nodes): they do not overlap and together they contain all the nodes in the document.</p><p> [<a id="dt-principal-node-kind" title="principal node kind">Definition</a>: Every axis has a <b>principal node kind</b>. If an axis can contain elements, then the principal node kind is element; otherwise, it is the kind of nodes that the axis can contain.] Thus:</p><ul><li><p>For the attribute axis, the principal node kind is attribute.</p></li><li><p>For all other axes, the principal node kind is element.</p></li></ul></div><div class="div4"><h5><a id="node-tests"></a><span class="deltaxml-old">4.7.4.2</span><span class="deltaxml-new">4.6.2.2</span> Node Tests</h5><p> [<a id="dt-node-test" title="node test">Definition</a>: A <b>node test</b> is a condition on the name, kind (element, attribute, text, document, comment, or processing instruction), and/or <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of a node. A node test determines which nodes contained by an axis are selected by a <a title="step" class="termref" href="#dt-step">step</a>.] </p><a id="d3e16440"></a><a id="d3e14545"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeTest"></a>[<span class="deltaxml-old">145</span><span class="deltaxml-new">136</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NodeTest">NodeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-UnionNodeTest">UnionNodeTest</a> | <a href="#doc-xquery40-SimpleNodeTest">SimpleNodeTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-UnionNodeTest"></a>[<span class="deltaxml-old">146</span><span class="deltaxml-new">137</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-UnionNodeTest">UnionNodeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" <a href="#doc-xquery40-SimpleNodeTest">SimpleNodeTest</a> ("|" <a href="#doc-xquery40-SimpleNodeTest">SimpleNodeTest</a>)* ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SimpleNodeTest"></a>[<span class="deltaxml-old">147</span><span class="deltaxml-new">138</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SimpleNodeTest">SimpleNodeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-KindTest">KindTest</a> | <a href="#doc-xquery40-NameTest">NameTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NameTest"></a>[<span class="deltaxml-old">148</span><span class="deltaxml-new">139</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NameTest">NameTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a> | <a href="#doc-xquery40-Wildcard">Wildcard</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Wildcard"></a>[<span class="deltaxml-old">149</span><span class="deltaxml-new">140</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Wildcard">Wildcard</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"*"<br>| (<a href="#prod-xquery40-NCName">NCName</a> ":*")<br>| ("*:" <a href="#prod-xquery40-NCName">NCName</a>)<br>| (<a href="#doc-xquery40-BracedURILiteral">BracedURILiteral</a> "*")</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e14955.doc-xquery40-EQName"></a><a id="noid_d4e13184.doc-xquery40-EQName"></a>[<span class="deltaxml-old">266</span><span class="deltaxml-new">252</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EQName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-QName">QName</a> | <a href="#doc-xquery40-URIQualifiedName">URIQualifiedName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e14956.doc-xquery40-KindTest"></a><a id="noid_d4e13185.doc-xquery40-KindTest"></a>[<span class="deltaxml-old">230</span><span class="deltaxml-new">217</span>]&nbsp;&nbsp;&nbsp;</td><td><code>KindTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DocumentTest">DocumentTest</a><br>| <a href="#doc-xquery40-ElementTest">ElementTest</a><br>| <a href="#doc-xquery40-AttributeTest">AttributeTest</a><br>| <a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a><br>| <a href="#doc-xquery40-SchemaAttributeTest">SchemaAttributeTest</a><br>| <a href="#doc-xquery40-PITest">PITest</a><br>| <a href="#doc-xquery40-CommentTest">CommentTest</a><br>| <a href="#doc-xquery40-TextTest">TextTest</a><br>| <a href="#doc-xquery40-NamespaceNodeTest">NamespaceNodeTest</a><br>| <a href="#doc-xquery40-AnyKindTest">AnyKindTest</a></code></td><td></td></tr></tbody></table><p>A <a href="#doc-xquery40-UnionNodeTest">UnionNodeTest</a> matches a node <var>N</var> if at least one of the constituent <a href="#doc-xquery40-SimpleNodeTest">SimpleNodeTest</a>s matches <var>N</var>.</p><p>For example, <code>(div1|div2|div3)</code> matches a node named <code>div1</code>, <code>div2</code>, or <code>div3</code></p><p> [<a id="dt-name-test" title="name test">Definition</a>: A node test that consists only of an EQName or a Wildcard is called a <b>name test</b>.] A name test that consists of an EQName matches a node <var>N</var> if and only if the <b>kind</b> of node <var>N</var> is the <a title="principal node kind" class="termref" href="#dt-principal-node-kind">principal node kind</a> for the step axis and the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the node is equal (as defined by the <code>eq</code> operator) to the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> specified by the name test. For example, <code>child::para</code> selects the <code>para</code> element children of the context node; if the context node has no <code>para</code> children, it selects an empty set of nodes. <code>attribute::abc:href</code> selects the attribute of the context node with the QName <code>abc:href</code>; if the context node has no such attribute, it selects an empty set of nodes.</p><p><span style="display: none;" class="delete_version">If the EQName is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, it is resolved into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> in the expression context. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>] if the QName has a prefix that does not correspond to any statically known namespace. An unprefixed QName, when used as a name test on an axis whose <a title="principal node kind" class="termref" href="#dt-principal-node-kind">principal node kind</a> is <code>element</code>, is interpreted as follows:</span><span style="display: none;" class="add_version">If the EQName is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, it is resolved into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> in the expression context. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>] if the QName has a prefix that does not correspond to any statically known namespace. An unprefixed QName, when used as a name test on an axis whose <a title="principal node kind" class="termref" href="#dt-principal-node-kind">principal node kind</a> is element, has the namespace URI of the <a title="default element namespace" class="termref" href="#dt-def-element-ns">default element namespace</a> in the expression context; otherwise, it has no namespace URI. </span><span class="modify_version">If the EQName is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, it is resolved into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> in the expression context. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>] if the QName has a prefix that does not correspond to any statically known namespace. An unprefixed QName, when used as a name test on an axis whose <a title="principal node kind" class="termref" href="#dt-principal-node-kind">principal node kind</a> is element, <span class="deltaxml-old">is interpreted as follows</span><span class="deltaxml-new">has the namespace URI of the </span><a title="default element namespace" class="termref" href="#dt-def-element-ns"><span class="deltaxml-new">default element namespace</span></a><span class="deltaxml-old">:</span><span class="deltaxml-new"> in the expression context; otherwise, it has no namespace URI. </span></span></p><ul><li><p><span class="deltaxml-old">If the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old"> is a namespace URI, then the name is interpreted as having that namespace URI.</span></p></li><li><p><span class="deltaxml-old">If the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old"> is absent, then the name is interpreted as being in no namespace.</span></p></li></ul><p>A name test is not satisfied by an element node whose name does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the name test, even if it is in a <a title="substitution group" class="termref" href="#dt-substitution-group">substitution group</a> whose head is the named element.</p><p>A node test <code>*</code> is true for any node of the <a title="principal node kind" class="termref" href="#dt-principal-node-kind">principal node kind</a> of the step axis. For example, <code>child::*</code> will select all element children of the context node, and <code>attribute::*</code> will select all attributes of the context node.</p><p>A node test can have the form <code>NCName:*</code>. In this case, the prefix is expanded in the same way as with a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>. If the prefix is not found in the statically known namespaces, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>]. The node test is true for any node of the <a title="principal node kind" class="termref" href="#dt-principal-node-kind">principal node kind</a> of the step axis whose <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> has the namespace URI to which the prefix is bound, regardless of the local part of the name.</p><p><span style="display: none;" class="delete_version">A node test can contain a <a href="#doc-xquery40-BracedURILiteral">BracedURILiteral</a>, for example <code>Q{http://example.com/msg}*</code>. Such a node test is true for any node of the principal node kind of the step axis whose expanded QName has the namespace URI specified in the <a href="#doc-xquery40-BracedURILiteral">BracedURILiteral</a>, regardless of the local part of the name.</span><span style="display: none;" class="add_version">A node test can contain a BracedURILiteral, e.g. <code>Q{http://example.com/msg}*</code> Such a node test is true for any node of the principal node kind of the step axis whose expanded QName has the namespace URI specified in the BracedURILiteral, regardless of the local part of the name.</span><span class="modify_version">A node test can contain a <a href="#doc-xquery40-BracedURILiteral"><span class="deltaxml-old">BracedURILiteral</span></a><span class="deltaxml-old">, for example</span><span class="deltaxml-new">BracedURILiteral, e.g.</span> <code>Q{http://example.com/msg}*</code><span class="deltaxml-old">.</span> Such a node test is true for any node of the principal node kind of the step axis whose expanded QName has the namespace URI specified in the <a href="#doc-xquery40-BracedURILiteral"><span class="deltaxml-old">BracedURILiteral</span></a><span class="deltaxml-new">BracedURILiteral</span>, regardless of the local part of the name.</span></p><p>A node test can also have the form <code>*:NCName</code>. In this case, the node test is true for any node of the <a title="principal node kind" class="termref" href="#dt-principal-node-kind">principal node kind</a> of the step axis whose local name matches the given NCName, regardless of its namespace or lack of a namespace.</p><p> [<a id="dt-kind-test" title="kind test">Definition</a>: An alternative form of a node test called a <b>kind test</b> can select nodes based on their kind, name, and <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>.] The syntax and semantics of a kind test are described in <a href="#id-sequencetype-syntax"><b>3.4 Sequence Types</b></a> and <a href="#id-sequencetype-matching"><b>3.5 Sequence Type Matching</b></a>. When a kind test is used in a <a title="node test" class="termref" href="#dt-node-test">node test</a>, only those nodes on the designated axis that match the kind test are selected. Shown below are several examples of kind tests that might be used in path expressions:</p><ul><li><p><code>node()</code> matches any node.</p></li><li><p><code>text()</code> matches any text node.</p></li><li><p><code>comment()</code> matches any comment node.</p></li><li><p><code>namespace-node()</code> matches any namespace node.</p></li><li><p><code>element()</code> matches any element node.</p></li><li><p><code>schema-element(person)</code> matches any element node whose name is <code>person</code> (or is in the <a title="substitution group" class="termref" href="#dt-substitution-group">substitution group</a> headed by <code>person</code>), and whose type annotation is the same as (or is derived from) the declared type of the <code>person</code> element in the <a title="in-scope element declarations" class="termref" href="#dt-is-elems">in-scope element declarations</a>.</p></li><li><p><code>element(person)</code> matches any element node whose name is <code>person</code>, regardless of its type annotation.</p></li><li class="delete_version" style="display: none;"><p><code>element(doctor|nurse)</code> matches any element node whose name is <code>doctor</code> or <code>nurse</code>, regardless of its type annotation.</p></li><li class="modify_version"><p><code><span class="deltaxml-old">element(doctor|nurse)</span></code><span class="deltaxml-old"> matches any element node whose name is </span><code><span class="deltaxml-old">doctor</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">nurse</span></code><span class="deltaxml-old">, regardless of its type annotation.</span></p></li><li><p><code>element(person, surgeon)</code> matches any non-nilled element node whose name is <code>person</code>, and whose type annotation is <code>surgeon</code> or is derived from <code>surgeon</code>.</p></li><li class="delete_version" style="display: none;"><p><code>element(doctor|nurse, medical-staff)</code> matches any non-nilled element node whose name is <code>doctor</code> or <code>nurse</code>, and whose type annotation is <code>medical-staff</code> or is derived from <code>medical-staff</code>.</p></li><li class="modify_version"><p><code><span class="deltaxml-old">element(doctor|nurse, medical-staff)</span></code><span class="deltaxml-old"> matches any non-nilled element node whose name is </span><code><span class="deltaxml-old">doctor</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">nurse</span></code><span class="deltaxml-old">, and whose type annotation is </span><code><span class="deltaxml-old">medical-staff</span></code><span class="deltaxml-old"> or is derived from </span><code><span class="deltaxml-old">medical-staff</span></code><span class="deltaxml-old">.</span></p></li><li><p><code>element(*, surgeon)</code> matches any non-nilled element node whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</p></li><li><p><code>attribute()</code> matches any attribute node.</p></li><li><p><code>attribute(price)</code> matches any attribute whose name is <code>price</code>, regardless of its type annotation.</p></li><li><p><code>attribute(*, xs:decimal)</code> matches any attribute whose type annotation is <code>xs:decimal</code> (or is derived from <code>xs:decimal</code>), regardless of its name.</p></li><li><p><code>document-node()</code> matches any document node.</p></li><li><p><code>document-node(element(book))</code> matches any document node whose content consists of a single element node that satisfies the <a title="kind test" class="termref" href="#dt-kind-test">kind test</a><code>element(book)</code>, interleaved with zero or more comments and processing instructions.</p></li></ul></div><div class="div4"><h5><a id="implausible-axis-steps"></a><span class="deltaxml-old">4.7.4.3 Implausible Axis Steps</span></h5><p><span class="deltaxml-old">Certain axis steps, given an inferred type for the context value, are classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-old">implausible</span></a><span class="deltaxml-old">. During the static analysis phase, a processor </span><strong><span class="deltaxml-old">may</span></strong><span class="deltaxml-old"> (subject to the rules in </span><a href="#id-implausible-expressions"><b><span class="deltaxml-old">2.4.6 Implausible Expressions</span></b></a><span class="deltaxml-old">) report a static error when such axis steps are encountered: [</span><a href="#ERRXPTY0144" title="err:XPTY0144"><span class="deltaxml-old">err:XPTY0144</span></a><span class="deltaxml-old">].</span></p><p><span class="deltaxml-old">More specifically, an axis step is classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-old">implausible</span></a><span class="deltaxml-old"> if any of the following conditions applies:</span></p><ol class="enumar"><li><p><span class="deltaxml-old">The inferred item type of the context value is a node kind for which the specified axis is always empty: for example, the inferred item type of the context value is </span><code><span class="deltaxml-old">attribute()</span></code><span class="deltaxml-old"> and the axis is </span><code><span class="deltaxml-old">child</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The node test exclusively selects node kinds that cannot appear on the specified axis: for example, the axis is </span><code><span class="deltaxml-old">child</span></code><span class="deltaxml-old"> and the node test is </span><code><span class="deltaxml-old">document-node()</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">In a schema-aware environment, when using the </span><code><span class="deltaxml-old">child</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">descendant</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">descendant-or-self</span></code><span class="deltaxml-old">, or </span><code><span class="deltaxml-old">attribute</span></code><span class="deltaxml-old"> axes, the inferred item type of the context value has a content type that does not allow any node matching the node test to be present on the relevant axis. For example, if the inferred item type of the context value is </span><code><span class="deltaxml-old">schema-element(list)</span></code><span class="deltaxml-old"> and the relevant element declaration (taking into account substitution group membership and wildcards) only allows </span><code><span class="deltaxml-old">item</span></code><span class="deltaxml-old"> children, the axis step </span><code><span class="deltaxml-old">child::li</span></code><span class="deltaxml-old"> will never select anything and is therefore classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-old">implausible</span></a><span class="deltaxml-old">.</span></p></li></ol><p><span class="deltaxml-old">Examples of implausible axis steps include the following:</span></p><ul><li><p><code><span class="deltaxml-old">@code/text()</span></code><span class="deltaxml-old">: attributes cannot have text node children.</span></p></li><li><p><code><span class="deltaxml-old">/@code</span></code><span class="deltaxml-old">: document nodes cannot have attributes.</span></p></li><li><p><code><span class="deltaxml-old">ancestor::text()</span></code><span class="deltaxml-old">: the ancestor axis never returns text nodes.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Processors may choose not to classify the expression </span><code><span class="deltaxml-old">/..</span></code><span class="deltaxml-old"> as implausible, since XSLT 1.0 users were sometimes advised to use this construct as an explicit way of denoting the empty sequence.</span></p></div></div></div><div class="div3"><h4><a id="id-predicate"></a><span class="deltaxml-old">4.7.5</span><span class="deltaxml-new">4.6.3</span> Predicates within Steps</h4><a id="d3e16971"></a><a id="d3e14963"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AxisStep"></a>[<span class="deltaxml-old">138</span><span class="deltaxml-new">129</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AxisStep">AxisStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#doc-xquery40-ReverseStep">ReverseStep</a> | <a href="#doc-xquery40-ForwardStep">ForwardStep</a>) <a href="#doc-xquery40-PredicateList">PredicateList</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PredicateList"></a>[<span class="deltaxml-old">158</span><span class="deltaxml-new">147</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-PredicateList">PredicateList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Predicate">Predicate</a>*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e15360.doc-xquery40-Predicate"></a><a id="noid_d4e13476.doc-xquery40-Predicate"></a>[<span class="deltaxml-old">159</span><span class="deltaxml-new">148</span>]&nbsp;&nbsp;&nbsp;</td><td><code>Predicate</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"[" <a href="#doc-xquery40-Expr">Expr</a> "]"</code></td><td></td></tr></tbody></table><p id="dt-predicate">A predicate within a Step has similar syntax and semantics to a predicate within a <a class="termref" title="" href="#id-filter-expression">filter expression</a>. The only difference is in the way the context position is set for evaluation of the predicate.</p><p>For the purpose of evaluating the context position within a predicate, the input sequence is considered to be sorted as follows: into document order if the predicate is in a forward-axis step, into reverse document order if the predicate is in a reverse-axis step, or in its original order if the predicate is not in a step.</p><p>Here are some examples of <a title="axis step" class="termref" href="#dt-axis-step">axis steps</a> that contain predicates:</p><ul><li><p>This example selects the second <code>chapter</code> element that is a child of the context node:</p><div class="exampleInner"><pre>child::chapter[2]</pre></div></li><li><p>This example selects all the descendants of the context node that are elements named <code>"toy"</code> and whose <code>color</code> attribute has the value <code>"red"</code>:</p><div class="exampleInner"><pre>descendant::toy[attribute::color = "red"]</pre></div></li><li><p>This example selects all the <code>employee</code> children of the context node that have both a <code>secretary</code> child element and an <code>assistant</code> child element:</p><div class="exampleInner"><pre>child::employee[secretary][assistant]</pre></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>When using <a title="" class="termref" href="#dt-predicate">predicates</a> with a sequence of nodes selected using a <b>reverse axis</b>, the context positions for such a sequence are assigned in <a title="reverse document order" class="termref" href="#dt-reverse-document-order">reverse document order</a>. For example, <code>preceding::foo[1]</code> returns the first qualifying <code>foo</code> element in <a title="reverse document order" class="termref" href="#dt-reverse-document-order">reverse document order</a>, because the predicate is part of an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a> using a reverse axis. By contrast, <code>(preceding::foo)[1]</code> returns the first qualifying <code>foo</code> element in <a title="document order" class="termref" href="#dt-document-order">document order</a>, because the parentheses cause <code>(preceding::foo)</code> to be parsed as a <a title="primary expression" class="termref" href="#dt-primary-expression">primary expression</a> in which context positions are assigned in document order. Similarly, <code>ancestor::*[1]</code> returns the nearest ancestor element, because the <code>ancestor</code> axis is a reverse axis, whereas <code>(ancestor::*)[1]</code> returns the root element (first ancestor in document order).</p><p>The fact that a reverse-axis step assigns context positions in reverse document order for the purpose of evaluating predicates does not alter the fact that the final result of the step <span class="xquery">(when in ordered mode) </span> is always in document order.</p><p>The expression <code>ancestor::(div1|div2)[1]</code> does not have the same meaning as <code>(ancestor::div1|ancestor::div2)[1]</code>. In the first expression, the predicate <code>[1]</code> is within a step that uses a reverse axis, so nodes are counted in reverse document order. In the second expression, the predicate applies to the result of a union expression, so nodes are counted in document order.</p></div><p><span class="deltaxml-old">When the context value for evaluation of a step includes multiple nodes, the step is evaluated separately for each of those nodes, and the results are combined. This means, for example, that if the context value contains three </span><code><span class="deltaxml-old">list</span></code><span class="deltaxml-old"> nodes, and each of those nodes has multiple </span><code><span class="deltaxml-old">item</span></code><span class="deltaxml-old"> children, then the step </span><code><span class="deltaxml-old">item[1]</span></code><span class="deltaxml-old"> will deliver a sequence of three </span><code><span class="deltaxml-old">item</span></code><span class="deltaxml-old"> elements, namely the first </span><code><span class="deltaxml-old">item</span></code><span class="deltaxml-old"> from each </span><code><span class="deltaxml-old">list</span></code><span class="deltaxml-old">.</span></p></div><div class="div3"><h4><a id="unabbrev"></a><span class="deltaxml-old">4.7.6</span><span class="deltaxml-new">4.6.4</span> Unabbreviated Syntax</h4><p><span style="display: none;" class="delete_version">This section provides a number of examples of path expressions in which the axis is explicitly specified in each <a title="step" class="termref" href="#dt-step">step</a>. The syntax used in these examples is called the <b>unabbreviated syntax</b>. In many common cases, it is possible to write path expressions more concisely using an <b>abbreviated syntax</b>, as explained in <a href="#abbrev"><span class="delete_version"><b>4.7.7 Abbreviated Syntax</b></span><span class="modify_version"><b>4.7.7 Abbreviated Syntax</b></span></a>.</span><span style="display: none;" class="add_version">This section provides a number of examples of path expressions in which the axis is explicitly specified in each <a title="step" class="termref" href="#dt-step">step</a>. The syntax used in these examples is called the <b>unabbreviated syntax</b>. In many common cases, it is possible to write path expressions more concisely using an <b>abbreviated syntax</b>, as explained in <a href="#abbrev"><span class="add_version"><b>4.6.5 Abbreviated Syntax</b></span><span class="modify_version"><b>4.6.5 Abbreviated Syntax</b></span></a>.</span><span class="modify_version">This section provides a number of examples of path expressions in which the axis is explicitly specified in each <a title="step" class="termref" href="#dt-step">step</a>. The syntax used in these examples is called the <b>unabbreviated syntax</b>. In many common cases, it is possible to write path expressions more concisely using an <b>abbreviated syntax</b>, as explained in <a href="#abbrev"><span style="display: none;" class="delete_version"><b>4.7.7 Abbreviated Syntax</b></span><span style="display: none;" class="add_version"><b>4.6.5 Abbreviated Syntax</b></span><span class="modify_version"><b><span class="deltaxml-old">4.7.7</span><span class="deltaxml-new">4.6.5</span> Abbreviated Syntax</b></span></a>.</span></p><p><span class="deltaxml-old">These examples assume that the context value is a single node, referred to as the context node.</span></p><ul><li><p><span style="display: none;" class="delete_version"><code>child::para</code> selects the <code>para</code> element children of the context node.</span><span style="display: none;" class="add_version"><code>child::para</code> selects the <code>para</code> element children of the context node</span><span class="modify_version"><code>child::para</code> selects the <code>para</code> element children of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::(para|bullet)</code> selects the <code>para</code> and <code>bullet</code> element children of the context node.</span><span style="display: none;" class="add_version"><code>child::(para|bullet)</code> selects the <code>para</code> and <code>bullet</code> element children of the context node</span><span class="modify_version"><code>child::(para|bullet)</code> selects the <code>para</code> and <code>bullet</code> element children of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::*</code> selects all element children of the context node.</span><span style="display: none;" class="add_version"><code>child::*</code> selects all element children of the context node</span><span class="modify_version"><code>child::*</code> selects all element children of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::text()</code> selects all text node children of the context node.</span><span style="display: none;" class="add_version"><code>child::text()</code> selects all text node children of the context node</span><span class="modify_version"><code>child::text()</code> selects all text node children of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::(text()|comment())</code> selects all text node and comment node children of the context node.</span><span style="display: none;" class="add_version"><code>child::(text()|comment())</code> selects all text node and comment node children of the context node</span><span class="modify_version"><code>child::(text()|comment())</code> selects all text node and comment node children of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><code>child::node()</code> selects all the children of the context node. Note that no attribute nodes are returned, because attributes are not children.</p></li><li><p><span style="display: none;" class="delete_version"><code>attribute::name</code> selects the <code>name</code> attribute of the context node.</span><span style="display: none;" class="add_version"><code>attribute::name</code> selects the <code>name</code> attribute of the context node</span><span class="modify_version"><code>attribute::name</code> selects the <code>name</code> attribute of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>attribute::*</code> selects all the attributes of the context node.</span><span style="display: none;" class="add_version"><code>attribute::*</code> selects all the attributes of the context node</span><span class="modify_version"><code>attribute::*</code> selects all the attributes of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><code>parent::node()</code> selects the parent of the context node. If the context node is an attribute node, this expression returns the element node (if any) to which the attribute node is attached.</p></li><li><p><span style="display: none;" class="delete_version"><code>descendant::para</code> selects the <code>para</code> element descendants of the context node.</span><span style="display: none;" class="add_version"><code>descendant::para</code> selects the <code>para</code> element descendants of the context node</span><span class="modify_version"><code>descendant::para</code> selects the <code>para</code> element descendants of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>ancestor::div</code> selects all <code>div</code> ancestors of the context node.</span><span style="display: none;" class="add_version"><code>ancestor::div</code> selects all <code>div</code> ancestors of the context node</span><span class="modify_version"><code>ancestor::div</code> selects all <code>div</code> ancestors of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>ancestor-or-self::div</code> selects the <code>div</code> ancestors of the context node and, if the context node is a <code>div</code> element, the context node as well.</span><span style="display: none;" class="add_version"><code>ancestor-or-self::div</code> selects the <code>div</code> ancestors of the context node and, if the context node is a <code>div</code> element, the context node as well</span><span class="modify_version"><code>ancestor-or-self::div</code> selects the <code>div</code> ancestors of the context node and, if the context node is a <code>div</code> element, the context node as well<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>descendant-or-self::para</code> selects the <code>para</code> element descendants of the context node and, if the context node is a <code>para</code> element, the context node as well.</span><span style="display: none;" class="add_version"><code>descendant-or-self::para</code> selects the <code>para</code> element descendants of the context node and, if the context node is a <code>para</code> element, the context node as well</span><span class="modify_version"><code>descendant-or-self::para</code> selects the <code>para</code> element descendants of the context node and, if the context node is a <code>para</code> element, the context node as well<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns an empty sequence.</span><span style="display: none;" class="add_version"><code>self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns an empty sequence</span><span class="modify_version"><code>self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns an empty sequence<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>self::(chapter|appendix)</code> selects the context node if it is a <code>chapter</code> or <code>appendix</code> element, and otherwise returns an empty sequence.</span><span style="display: none;" class="add_version"><code>self::(chapter|appendix)</code> selects the context node if it is a <code>chapter</code> or <code>appendix</code> element, and otherwise returns an empty sequence</span><span class="modify_version"><code>self::(chapter|appendix)</code> selects the context node if it is a <code>chapter</code> or <code>appendix</code> element, and otherwise returns an empty sequence<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::chapter/descendant::para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node.</span><span style="display: none;" class="add_version"><code>child::chapter/descendant::para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node</span><span class="modify_version"><code>child::chapter/descendant::para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::*/child::para</code> selects all <code>para</code> grandchildren of the context node.</span><span style="display: none;" class="add_version"><code>child::*/child::para</code> selects all <code>para</code> grandchildren of the context node</span><span class="modify_version"><code>child::*/child::para</code> selects all <code>para</code> grandchildren of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>/</code> selects the root of the tree that contains the context node, but raises a dynamic error if this root is not a document node.</span><span style="display: none;" class="add_version"><code>/</code> selects the root of the tree that contains the context node, but raises a dynamic error if this root is not a document node</span><span class="modify_version"><code>/</code> selects the root of the tree that contains the context node, but raises a dynamic error if this root is not a document node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>/descendant::para</code> selects all the <code>para</code> elements in the same document as the context node.</span><span style="display: none;" class="add_version"><code>/descendant::para</code> selects all the <code>para</code> elements in the same document as the context node</span><span class="modify_version"><code>/descendant::para</code> selects all the <code>para</code> elements in the same document as the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>/descendant::list/child::member</code> selects all the <code>member</code> elements that have a <code>list</code> parent and that are in the same document as the context node.</span><span style="display: none;" class="add_version"><code>/descendant::list/child::member</code> selects all the <code>member</code> elements that have a <code>list</code> parent and that are in the same document as the context node</span><span class="modify_version"><code>/descendant::list/child::member</code> selects all the <code>member</code> elements that have a <code>list</code> parent and that are in the same document as the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::para[position() = 1]</code> selects the first <code>para</code> child of the context node.</span><span style="display: none;" class="add_version"><code>child::para[fn:position() = 1]</code> selects the first <code>para</code> child of the context node</span><span class="modify_version"><code>child::para[<span class="deltaxml-old">position</span><span class="deltaxml-new">fn:position</span>() = 1]</code> selects the first <code>para</code> child of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::para[position() = last()]</code> selects the last <code>para</code> child of the context node.</span><span style="display: none;" class="add_version"><code>child::para[fn:position() = fn:last()]</code> selects the last <code>para</code> child of the context node</span><span class="modify_version"><code>child::para[<span class="deltaxml-old">position</span><span class="deltaxml-new">fn:position</span>() = <span class="deltaxml-old">last</span><span class="deltaxml-new">fn:last</span>()]</code> selects the last <code>para</code> child of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::para[position() = last()-1]</code> selects the last but one <code>para</code> child of the context node.</span><span style="display: none;" class="add_version"><code>child::para[fn:position() = fn:last()-1]</code> selects the last but one <code>para</code> child of the context node</span><span class="modify_version"><code>child::para[<span class="deltaxml-old">position</span><span class="deltaxml-new">fn:position</span>() = <span class="deltaxml-old">last</span><span class="deltaxml-new">fn:last</span>()-1]</code> selects the last but one <code>para</code> child of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::para[position() &gt; 1]</code> selects all the <code>para</code> children of the context node other than the first <code>para</code> child of the context node.</span><span style="display: none;" class="add_version"><code>child::para[fn:position() &gt; 1]</code> selects all the <code>para</code> children of the context node other than the first <code>para</code> child of the context node</span><span class="modify_version"><code>child::para[<span class="deltaxml-old">position</span><span class="deltaxml-new">fn:position</span>() &gt; 1]</code> selects all the <code>para</code> children of the context node other than the first <code>para</code> child of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>following-sibling::chapter[position() = 1]</code> selects the next <code>chapter</code> sibling of the context node.</span><span style="display: none;" class="add_version"><code>following-sibling::chapter[fn:position() = 1]</code> selects the next <code>chapter</code> sibling of the context node</span><span class="modify_version"><code>following-sibling::chapter[<span class="deltaxml-old">position</span><span class="deltaxml-new">fn:position</span>() = 1]</code> selects the next <code>chapter</code> sibling of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>following-sibling::(chapter|appendix)[position() = 1]</code> selects the next sibling of the context node that is either a <code>chapter</code> or an <code>appendix</code>.</span><span style="display: none;" class="add_version"><code>following-sibling::(chapter|appendix)[fn:position() = 1]</code> selects the next sibling of the context node that is either a <code>chapter</code> or an <code>appendix</code></span><span class="modify_version"><code>following-sibling::(chapter|appendix)[<span class="deltaxml-old">position</span><span class="deltaxml-new">fn:position</span>() = 1]</code> selects the next sibling of the context node that is either a <code>chapter</code> or an <code>appendix</code><span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>preceding-sibling::chapter[position() = 1]</code> selects the previous <code>chapter</code> sibling of the context node.</span><span style="display: none;" class="add_version"><code>preceding-sibling::chapter[fn:position() = 1]</code> selects the previous <code>chapter</code> sibling of the context node</span><span class="modify_version"><code>preceding-sibling::chapter[<span class="deltaxml-old">position</span><span class="deltaxml-new">fn:position</span>() = 1]</code> selects the previous <code>chapter</code> sibling of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>/descendant::figure[position() = 42]</code> selects the forty-second <code>figure</code> element in the document containing the context node.</span><span style="display: none;" class="add_version"><code>/descendant::figure[fn:position() = 42]</code> selects the forty-second <code>figure</code> element in the document containing the context node</span><span class="modify_version"><code>/descendant::figure[<span class="deltaxml-old">position</span><span class="deltaxml-new">fn:position</span>() = 42]</code> selects the forty-second <code>figure</code> element in the document containing the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>/child::book/child::chapter[position() = 5]/child::section[position() = 2]</code> selects the second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node.</span><span style="display: none;" class="add_version"><code>/child::book/child::chapter[fn:position() = 5]/child::section[fn:position() = 2]</code> selects the second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node</span><span class="modify_version"><code>/child::book/child::chapter[<span class="deltaxml-old">position</span><span class="deltaxml-new">fn:position</span>() = 5]/child::section[<span class="deltaxml-old">position</span><span class="deltaxml-new">fn:position</span>() = 2]</code> selects the second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::para[attribute::type eq "warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code>. </span><span style="display: none;" class="add_version"><code>child::para[attribute::type eq "warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code></span><span class="modify_version"><code>child::para[attribute::type eq "warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code><span class="deltaxml-old">. </span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::para[attribute::type eq 'warning'][position() = 5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code>. </span><span style="display: none;" class="add_version"><code>child::para[attribute::type eq 'warning'][fn:position() = 5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code></span><span class="modify_version"><code>child::para[attribute::type eq 'warning'][<span class="deltaxml-old">position</span><span class="deltaxml-new">fn:position</span>() = 5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code><span class="deltaxml-old">. </span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::para[position() = 5][attribute::type eq "warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code>. </span><span style="display: none;" class="add_version"><code>child::para[fn:position() = 5][attribute::type eq "warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code></span><span class="modify_version"><code>child::para[<span class="deltaxml-old">position</span><span class="deltaxml-new">fn:position</span>() = 5][attribute::type eq "warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code><span class="deltaxml-old">. </span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::chapter[child::title = 'Introduction']</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children whose <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> is equal to the string <code>Introduction</code>. </span><span style="display: none;" class="add_version"><code>child::chapter[child::title = 'Introduction']</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children whose <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> is equal to the string <code>Introduction</code></span><span class="modify_version"><code>child::chapter[child::title = 'Introduction']</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children whose <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> is equal to the string <code>Introduction</code><span class="deltaxml-old">. </span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::chapter[child::title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children.</span><span style="display: none;" class="add_version"><code>child::chapter[child::title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children</span><span class="modify_version"><code>child::chapter[child::title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::*[self::chapter or self::appendix]</code> selects the <code>chapter</code> and <code>appendix</code> children of the context node.</span><span style="display: none;" class="add_version"><code>child::*[self::chapter or self::appendix]</code> selects the <code>chapter</code> and <code>appendix</code> children of the context node</span><span class="modify_version"><code>child::*[self::chapter or self::appendix]</code> selects the <code>chapter</code> and <code>appendix</code> children of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>child::*[self::(chapter|appendix)][position() = last()]</code> selects the last <code>chapter</code> or <code>appendix</code> child of the context node.</span><span style="display: none;" class="add_version"><code>child::*[self::(chapter|appendix)][fn:position() = fn:last()]</code> selects the last <code>chapter</code> or <code>appendix</code> child of the context node</span><span class="modify_version"><code>child::*[self::(chapter|appendix)][<span class="deltaxml-old">position</span><span class="deltaxml-new">fn:position</span>() = <span class="deltaxml-old">last</span><span class="deltaxml-new">fn:last</span>()]</code> selects the last <code>chapter</code> or <code>appendix</code> child of the context node<span class="deltaxml-old">.</span></span></p></li></ul></div><div class="div3"><h4><a id="abbrev"></a><span class="deltaxml-old">4.7.7</span><span class="deltaxml-new">4.6.5</span> Abbreviated Syntax</h4><a id="d3e17455"></a><a id="d3e15431"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AbbrevForwardStep"></a>[<span class="deltaxml-old">141</span><span class="deltaxml-new">132</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AbbrevForwardStep">AbbrevForwardStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("@" <a href="#doc-xquery40-NodeTest">NodeTest</a>) | <a href="#doc-xquery40-SimpleNodeTest">SimpleNodeTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AbbrevReverseStep"></a>[<span class="deltaxml-old">144</span><span class="deltaxml-new">135</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AbbrevReverseStep">AbbrevReverseStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>".."</code></td><td></td></tr></tbody></table><p>The abbreviated syntax permits the following abbreviations:</p><ol class="enumar"><li><p>The attribute axis <code>attribute::</code> can be abbreviated by <code>@</code>. For example, a path expression <code>para[@type="warning"]</code> is short for <code>child::para[attribute::type="warning"]</code> and so selects <code>para</code> children with a <code>type</code> attribute with value equal to <code>warning</code>.</p></li><li><p>If the axis name is omitted from an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a>, the default axis is <code>child</code>, with two exceptions: (1) if the <a href="#doc-xquery40-NodeTest">NodeTest</a> in an axis step contains an <a href="#doc-xquery40-AttributeTest">AttributeTest</a> or <a href="#doc-xquery40-SchemaAttributeTest">SchemaAttributeTest</a> then the default axis is <code>attribute</code>; (2) if the <a href="#doc-xquery40-NodeTest">NodeTest</a> in an axis step is a <a href="#doc-xquery40-NamespaceNodeTest">NamespaceNodeTest</a><span class="xquery">then a static error is raised [<a href="#ERRXQST0134" title="err:XQST0134">err:XQST0134</a>].</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p> The namespace axis is deprecated as of XPath 2.0, but <span class="deltaxml-old">is </span>required in some languages that use XPath, including XSLT.</p></div><p> For example, the path expression <code>section/para</code> is an abbreviation for <code>child::section/child::para</code>, and the path expression <code>section/@id</code> is an abbreviation for <code>child::section/attribute::id</code>. Similarly, <code>section/attribute(id)</code> is an abbreviation for <code>child::section/attribute::attribute(id)</code>. Note that the latter expression contains both an axis specification and a <a title="node test" class="termref" href="#dt-node-test">node test</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An abbreviated axis step that omits the axis name must use a <a href="#doc-xquery40-SimpleNodeTest">SimpleNodeTest</a> rather than a <a href="#doc-xquery40-UnionNodeTest">UnionNodeTest</a>. This means that a construct such as <code>(ul|ol)</code> is treated as an abbreviation for <code>(child::ul|child::ol)</code> rather than <code>child::(ul|ol)</code>. Since the two constructs have exactly the same semantics, this is not actually a restriction.</p></div></li><li><p> Each non-initial occurrence of <code>//</code> is effectively replaced by <code>/descendant-or-self::node()/</code> during processing of a path expression. For example, <code>div1//para</code> is short for <code>child::div1/descendant-or-self::node()/child::para</code> and so will select all <code>para</code> descendants of <code>div1</code> children.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The path expression <code>//para[1]</code> does <em>not</em> mean the same as the path expression <code>/descendant::para[1]</code>. The latter selects the first descendant <code>para</code> element; the former selects all descendant <code>para</code> elements that are the first <code>para</code> children of their respective parents.</p></div></li><li><p>A step consisting of <code>..</code> is short for <code>parent::node()</code>. For example, <code>../title</code> is short for <code>parent::node()/child::title</code> and so will select the <code>title</code> children of the parent of the context node.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">The expression <code>.</code>, known as a <b>context value reference</b>, is a <a title="primary expression" class="termref" href="#dt-primary-expression">primary expression</a>, and is described in <a href="#id-context-value-references"><b>4.3.3 Context Value References</b></a>.</span><span style="display: none;" class="add_version">The expression <code>.</code>, known as a <b>context item expression</b>, is a <a title="primary expression" class="termref" href="#dt-primary-expression">primary expression</a>, and is described in <a href="#id-context-item-expression"><b>4.3.4 Context Item Expression</b></a>.</span><span class="modify_version">The expression <code>.</code>, known as a <b>context <span class="deltaxml-old">value reference</span><span class="deltaxml-new">item expression</span></b>, is a <a title="primary expression" class="termref" href="#dt-primary-expression">primary expression</a>, and is described in <a href="#id-context-value-references"><b><span class="deltaxml-old">4.3.3 Context Value References</span></b></a><a href="#id-context-item-expression"><b><span class="deltaxml-new">4.3.4 Context Item Expression</span></b></a>.</span></p></div></li></ol><p>Here are some examples of path expressions that use the abbreviated syntax<span class="deltaxml-old">. These examples assume that the context value is a single node, referred to as the context node</span>:</p><ul><li><p><span style="display: none;" class="delete_version"><code>para</code> selects the <code>para</code> element children of the context node.</span><span style="display: none;" class="add_version"><code>para</code> selects the <code>para</code> element children of the context node</span><span class="modify_version"><code>para</code> selects the <code>para</code> element children of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>*</code> selects all element children of the context node.</span><span style="display: none;" class="add_version"><code>*</code> selects all element children of the context node</span><span class="modify_version"><code>*</code> selects all element children of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>text()</code> selects all text node children of the context node.</span><span style="display: none;" class="add_version"><code>text()</code> selects all text node children of the context node</span><span class="modify_version"><code>text()</code> selects all text node children of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>@name</code> selects the <code>name</code> attribute of the context node.</span><span style="display: none;" class="add_version"><code>@name</code> selects the <code>name</code> attribute of the context node</span><span class="modify_version"><code>@name</code> selects the <code>name</code> attribute of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>@(id|name)</code> selects the <code>id</code> and <code>name</code> attributes of the context node.</span><span style="display: none;" class="add_version"><code>@(id|name)</code> selects the <code>id</code> and <code>name</code> attributes of the context node</span><span class="modify_version"><code>@(id|name)</code> selects the <code>id</code> and <code>name</code> attributes of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>@*</code> selects all the attributes of the context node.</span><span style="display: none;" class="add_version"><code>@*</code> selects all the attributes of the context node</span><span class="modify_version"><code>@*</code> selects all the attributes of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>para[1]</code> selects the first <code>para</code> child of the context node.</span><span style="display: none;" class="add_version"><code>para[1]</code> selects the first <code>para</code> child of the context node</span><span class="modify_version"><code>para[1]</code> selects the first <code>para</code> child of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>para[last()]</code> selects the last <code>para</code> child of the context node.</span><span style="display: none;" class="add_version"><code>para[fn:last()]</code> selects the last <code>para</code> child of the context node</span><span class="modify_version"><code>para[<span class="deltaxml-old">last</span><span class="deltaxml-new">fn:last</span>()]</code> selects the last <code>para</code> child of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>*/para</code> selects all <code>para</code> grandchildren of the context node.</span><span style="display: none;" class="add_version"><code>*/para</code> selects all <code>para</code> grandchildren of the context node</span><span class="modify_version"><code>*/para</code> selects all <code>para</code> grandchildren of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>/book/chapter[5]/section[2]</code> selects the second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node.</span><span style="display: none;" class="add_version"><code>/book/chapter[5]/section[2]</code> selects the second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node</span><span class="modify_version"><code>/book/chapter[5]/section[2]</code> selects the second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>chapter//para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node.</span><span style="display: none;" class="add_version"><code>chapter//para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node</span><span class="modify_version"><code>chapter//para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>//para</code> selects all the <code>para</code> descendants of the root document node and thus selects all <code>para</code> elements in the same document as the context node.</span><span style="display: none;" class="add_version"><code>//para</code> selects all the <code>para</code> descendants of the root document node and thus selects all <code>para</code> elements in the same document as the context node</span><span class="modify_version"><code>//para</code> selects all the <code>para</code> descendants of the root document node and thus selects all <code>para</code> elements in the same document as the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>//@version</code> selects all the <code>version</code> attribute nodes that are in the same document as the context node.</span><span style="display: none;" class="add_version"><code>//@version</code> selects all the <code>version</code> attribute nodes that are in the same document as the context node</span><span class="modify_version"><code>//@version</code> selects all the <code>version</code> attribute nodes that are in the same document as the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>//list/member</code> selects all the <code>member</code> elements in the same document as the context node that have a <code>list</code> parent.</span><span style="display: none;" class="add_version"><code>//list/member</code> selects all the <code>member</code> elements in the same document as the context node that have a <code>list</code> parent</span><span class="modify_version"><code>//list/member</code> selects all the <code>member</code> elements in the same document as the context node that have a <code>list</code> parent<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>.//para</code> selects the <code>para</code> element descendants of the context node.</span><span style="display: none;" class="add_version"><code>.//para</code> selects the <code>para</code> element descendants of the context node</span><span class="modify_version"><code>.//para</code> selects the <code>para</code> element descendants of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>..</code> selects the parent of the context node.</span><span style="display: none;" class="add_version"><code>..</code> selects the parent of the context node</span><span class="modify_version"><code>..</code> selects the parent of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>../@lang</code> selects the <code>lang</code> attribute of the parent of the context node.</span><span style="display: none;" class="add_version"><code>../@lang</code> selects the <code>lang</code> attribute of the parent of the context node</span><span class="modify_version"><code>../@lang</code> selects the <code>lang</code> attribute of the parent of the context node<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>para[@type="warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code>. </span><span style="display: none;" class="add_version"><code>para[@type="warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code></span><span class="modify_version"><code>para[@type="warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code><span class="deltaxml-old">. </span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>para[@type="warning"][5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code>. </span><span style="display: none;" class="add_version"><code>para[@type="warning"][5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code></span><span class="modify_version"><code>para[@type="warning"][5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code><span class="deltaxml-old">. </span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>para[5][@type="warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code>. </span><span style="display: none;" class="add_version"><code>para[5][@type="warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code></span><span class="modify_version"><code>para[5][@type="warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code><span class="deltaxml-old">. </span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>chapter[title="Introduction"]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children whose <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> is equal to the string <code>Introduction</code>. </span><span style="display: none;" class="add_version"><code>chapter[title="Introduction"]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children whose <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> is equal to the string <code>Introduction</code></span><span class="modify_version"><code>chapter[title="Introduction"]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children whose <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> is equal to the string <code>Introduction</code><span class="deltaxml-old">. </span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>chapter[title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children.</span><span style="display: none;" class="add_version"><code>chapter[title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children</span><span class="modify_version"><code>chapter[title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children<span class="deltaxml-old">.</span></span></p></li><li><p><span style="display: none;" class="delete_version"><code>employee[@secretary and @assistant]</code> selects all the <code>employee</code> children of the context node that have both a <code>secretary</code> attribute and an <code>assistant</code> attribute.</span><span style="display: none;" class="add_version"><code>employee[@secretary and @assistant]</code> selects all the <code>employee</code> children of the context node that have both a <code>secretary</code> attribute and an <code>assistant</code> attribute</span><span class="modify_version"><code>employee[@secretary and @assistant]</code> selects all the <code>employee</code> children of the context node that have both a <code>secretary</code> attribute and an <code>assistant</code> attribute<span class="deltaxml-old">.</span></span></p></li><li><p><code>book/(chapter|appendix)/section</code> selects every <code>section</code> element that has a parent that is either a <code>chapter</code> or an <code>appendix</code> element, that in turn is a child of a <code>book</code> element that is a child of the context node.</p></li><li><p>If <code>E</code> is any expression that returns a sequence of nodes, then the expression <code>E/.</code> returns the same nodes in <a title="document order" class="termref" href="#dt-document-order">document order</a>, with duplicates eliminated based on node identity.</p></li></ul></div></div><div class="div2"><h3><a id="id-sequence-expressions"></a><span class="deltaxml-old">4.8</span><span class="deltaxml-new">4.7</span> Sequence Expressions</h3><p>XQuery 4.0 supports operators to construct, filter, and combine <a title="sequence" class="termref" href="#dt-sequence">sequences</a> of <a title="item" class="termref" href="#dt-item">items</a>. Sequences are never nested—for example, combining the values <code>1</code>, <code>(2, 3)</code>, and <code>( )</code> into a single sequence results in the sequence <code>(1, 2, 3)</code>.</p><div class="div3"><h4><a id="construct_seq"></a><span class="deltaxml-old">4.8.1</span><span class="deltaxml-new">4.7.1</span> Sequence Concatenation</h4><a id="d3e17890"></a><a id="d3e15866"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e16242.doc-xquery40-Expr"></a><a id="noid_d4e14342.doc-xquery40-Expr"></a>[<span class="deltaxml-old">45</span><span class="deltaxml-new">44</span>]&nbsp;&nbsp;&nbsp;</td><td><code>Expr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ExprSingle">ExprSingle</a> ("," <a href="#doc-xquery40-ExprSingle">ExprSingle</a>)*</code></td><td></td></tr></tbody></table><p> [<a id="dt-comma-operator" title="comma operator">Definition</a>: One way to construct a sequence is by using the <b>comma operator</b>, which evaluates each of its operands and concatenates the resulting sequences, in order, into a single result sequence.] Empty parentheses can be used to denote an empty sequence.</p><p>A sequence may contain duplicate <a title="item" class="termref" href="#dt-item">items</a>, but a sequence is never an item in another sequence. When a new sequence is created by concatenating two or more input sequences, the new sequence contains all the items of the input sequences and its length is the sum of the lengths of the input sequences.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In places where the grammar calls for <a href="#doc-xquery40-ExprSingle">ExprSingle</a>, such as the arguments of a function call, any expression that contains a top-level comma operator must be enclosed in parentheses.</p></div><p>Here are some examples of expressions that construct sequences: </p><ul><li><p>The result of this expression is a sequence of five integers:</p><div class="exampleInner"><pre>(10, 1, 2, 3, 4)</pre></div></li><li><p>This expression combines four sequences of length one, two, zero, and two, respectively, into a single sequence of length five. The result of this expression is the sequence <code>10, 1, 2, 3, 4</code>.</p><div class="exampleInner"><pre>(10, (1, 2), (), (3, 4))</pre></div></li><li><p>The result of this expression is a sequence containing all <code>salary</code> children of the context node followed by all <code>bonus</code> children.</p><div class="exampleInner"><pre>(salary, bonus)</pre></div></li><li><p>Assuming that <code>$price</code> is bound to the value <code>10.50</code>, the result of this expression is the sequence <code>10.50, 10.50</code>.</p><div class="exampleInner"><pre>($price, $price)</pre></div></li></ul></div><div class="div3"><h4><a id="id-range-expressions"></a><span class="deltaxml-old">4.8.2</span><span class="deltaxml-new">4.7.2</span> Range Expressions</h4><a id="d3e17955"></a><a id="d3e15931"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RangeExpr"></a>[<span class="deltaxml-old">110</span><span class="deltaxml-new">102</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-RangeExpr">RangeExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AdditiveExpr">AdditiveExpr</a> ( "to" <a href="#doc-xquery40-AdditiveExpr">AdditiveExpr</a> )?</code></td><td></td></tr></tbody></table><p>A <b>RangeExpression</b> can be used to construct a sequence of integers. Each of the operands is converted as though it was an argument of a function with the expected parameter type <code>xs:integer?</code>. If either operand is an empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is an empty sequence. If the two operands convert to the same integer, the result of the range expression is that integer. Otherwise, the result is a sequence containing the two integer operands and every integer between the two operands, in increasing order. </p><p>The following examples illustrate the semantics:</p><ul><li><p><code>1 to 4</code> returns the sequence <code>1, 2, 3, 4</code></p></li><li><p><code>10 to 10</code> returns the singleton sequence <code>10</code></p></li><li><p><code>10 to 1</code> returns the empty sequence</p></li><li><p><code>-13 to -10</code> returns the sequence <code>-13, -12, -11, -10</code></p></li></ul><p>More formally, a <b>RangeExpression</b> is evaluated as follows:</p><ol class="enumar"><li><p>Each of the operands of the <code>to</code> operator is converted as though it was an argument of a function with the expected parameter type <code>xs:integer?</code>.</p></li><li><p>If either operand is an empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is an empty sequence.</p></li><li><p>If the two operands convert to the same integer, the result of the range expression is that integer.</p></li><li><p>Otherwise, the result is a sequence containing the two integer operands and every integer between the two operands, in increasing order.</p></li></ol><p>The following examples illustrate the use of <code>RangeExpressions</code> .</p><div class="example"><p>This example uses a range expression as one operand in constructing a sequence. It evaluates to the sequence <code>10, 1, 2, 3, 4</code>.</p><div class="exampleInner"><pre>(10, 1 to 4)</pre></div><p>This example selects the first four items from an input sequence:</p><div class="exampleInner"><pre>$input[position() = 1 to 4]</pre></div><p><span style="display: none;" class="delete_version">This example returns the sequence <code>(0, 0.1, 0.2, 0.3, 0.5)</code>:</span><span style="display: none;" class="add_version">This example returns the sequence (0, 0.1, 0.2, 0.3, 0.5):</span><span class="modify_version">This example returns the sequence (0, 0.1, 0.2, 0.3, 0.5):</span></p><div class="exampleInner"><pre>$x = (1 to 5)!.*0.1</pre></div><p>This example constructs a sequence of length one containing the single integer 10.</p><div class="exampleInner"><pre>10 to 10</pre></div><p>The result of this example is a sequence of length zero.</p><div class="exampleInner"><pre>15 to 10</pre></div><p>This example uses the <code>fn:reverse</code> function to construct a sequence of six integers in decreasing order. It evaluates to the sequence 15, 14, 13, 12, 11, 10.</p><div class="exampleInner"><pre><span class="deltaxml-old">reverse(10 to 15)</span></pre><pre><span class="deltaxml-new">fn:reverse(10 to 15)</span></pre></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">To construct a sequence of integers based on steps other than 1, use the </span><code><span class="deltaxml-old">fn:slice</span></code><span class="deltaxml-old"> function, as defined in </span><a href="https://www.w3.org/TR/xpath-functions-31/#general-seq-funcs"><span class="deltaxml-old">Section 14.1 General functions and operators on sequences </span></a><sup><small><span class="deltaxml-old">FO31</span></small></sup><span class="deltaxml-old">.</span></p></div></div><div class="div3"><h4><a id="combining_seq"></a><span class="deltaxml-old">4.8.3</span><span class="deltaxml-new">4.7.3</span> Combining Node Sequences</h4><a id="d3e18069"></a><a id="d3e16035"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-UnionExpr"></a>[<span class="deltaxml-old">113</span><span class="deltaxml-new">106</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-UnionExpr">UnionExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union" | "|") <a href="#doc-xquery40-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-IntersectExceptExpr"></a>[<span class="deltaxml-old">114</span><span class="deltaxml-new">107</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-IntersectExceptExpr">IntersectExceptExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-InstanceofExpr">InstanceofExpr</a> ( ("intersect" | "except") <a href="#doc-xquery40-InstanceofExpr">InstanceofExpr</a> )*</code></td><td></td></tr></tbody></table><p>XQuery 4.0 provides the following operators for combining sequences of nodes:</p><ul><li><p>The <code>union</code> and <code>|</code> operators are equivalent. They take two node sequences as operands and return a sequence containing all the nodes that occur in either of the operands.</p></li><li><p>The <code>intersect</code> operator takes two node sequences as operands and returns a sequence containing all the nodes that occur in both operands.</p></li><li><p>The <code>except</code> operator takes two node sequences as operands and returns a sequence containing all the nodes that occur in the first operand but not in the second operand.</p></li></ul><p> All these operators eliminate duplicate nodes from their result sequences based on node identity. <span class="xquery">If <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the resulting sequence is returned in <a title="document order" class="termref" href="#dt-document-order">document order</a>; otherwise it is returned in <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order.</span></p><p>If an operand of <code>union</code>, <code>intersect</code>, or <code>except</code> contains an item that is not a node, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><p> If an IntersectExceptExpr contains more than two InstanceofExprs, they are grouped from left to right. With a UnionExpr, it makes no difference how operands are grouped, the results are the same. </p><div class="example"><p>Here are some examples of expressions that combine sequences. Assume the existence of three element nodes that we will refer to by symbolic names A, B, and C. <span class="xquery">Assume that <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>.</span> Assume that the variables <code>$seq1</code>, <code>$seq2</code> and <code>$seq3</code> are bound to the following sequences of these nodes:</p><ul><li><p><code>$seq1</code> is bound to (A, B)</p></li><li><p><code>$seq2</code> is bound to (A, B)</p></li><li><p><code>$seq3</code> is bound to (B, C)</p></li></ul><p>Then: </p><ul><li><p><code>$seq1 union $seq2</code> evaluates to the sequence (A, B). </p></li><li><p><code>$seq2 union $seq3</code> evaluates to the sequence (A, B, C). </p></li><li><p><code>$seq1 intersect $seq2</code> evaluates to the sequence (A, B). </p></li><li><p><code>$seq2 intersect $seq3</code> evaluates to the sequence containing B only.</p></li><li><p><code>$seq1 except $seq2</code> evaluates to the empty sequence.</p></li><li><p><code>$seq2 except $seq3</code> evaluates to the sequence containing A only.</p></li></ul></div><p><span style="display: none;" class="delete_version">In addition to the sequence operators described here, see <a href="https://qt4cg.org/specifications/xpath-functions-40/#sequence-functions">Section 14 Functions and operators on sequences</a><sup><small>FO40</small></sup> for functions defined on sequences. </span><span style="display: none;" class="add_version">In addition to the sequence operators described here, see <a href="https://www.w3.org/TR/xpath-functions-31/#sequence-functions">Section 14 Functions and operators on sequences </a><sup><small>FO31</small></sup> for functions defined on sequences. </span><span class="modify_version">In addition to the sequence operators described here, see <a href="https://www.w3.org/TR/xpath-functions-31/#sequence-functions">Section 14 Functions and operators on sequences<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup> for functions defined on sequences. </span></p></div></div><div class="div2"><h3><a id="id-arithmetic"></a><span class="deltaxml-old">4.9</span><span class="deltaxml-new">4.8</span> Arithmetic Expressions</h3><p>XQuery 4.0 provides arithmetic operators for addition, subtraction, multiplication, division, and modulus, in their usual binary and unary forms.</p><a id="d3e18218"></a><a id="d3e16184"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AdditiveExpr"></a>[<span class="deltaxml-old">111</span><span class="deltaxml-new">103</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AdditiveExpr">AdditiveExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" | "-") <a href="#doc-xquery40-MultiplicativeExpr">MultiplicativeExpr</a> )*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-MultiplicativeExpr"></a>[<span class="deltaxml-old">112</span><span class="deltaxml-new">104</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-MultiplicativeExpr">MultiplicativeExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-UnionExpr">UnionExpr</a> ( ("*" | "×" | "div" | "÷" | "idiv" | "mod") <a href="#doc-xquery40-UnionExpr">UnionExpr</a> )*</code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-OtherwiseExpr">OtherwiseExpr</a> ( ("*" | "div" | "idiv" | "mod") <a href="#doc-xquery40-OtherwiseExpr">OtherwiseExpr</a> )*</code></span><span class="modify_version"><code><a href="#doc-xquery40-UnionExpr"><span class="deltaxml-old">UnionExpr</span></a><a href="#doc-xquery40-OtherwiseExpr"><span class="deltaxml-new">OtherwiseExpr</span></a> ( ("*" | "<span class="deltaxml-old">×" | "</span>div" | "<span class="deltaxml-old">÷" | "</span>idiv" | "mod") <a href="#doc-xquery40-UnionExpr"><span class="deltaxml-old">UnionExpr</span></a><a href="#doc-xquery40-OtherwiseExpr"><span class="deltaxml-new">OtherwiseExpr</span></a> )*</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-UnaryExpr"></a>[<span class="deltaxml-old">120</span><span class="deltaxml-new">113</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-UnaryExpr">UnaryExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("-" | "+")* <a href="#doc-xquery40-ValueExpr">ValueExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ValueExpr"></a>[<span class="deltaxml-old">121</span><span class="deltaxml-new">114</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ValueExpr">ValueExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ValidateExpr">ValidateExpr</a> | <a href="#doc-xquery40-ExtensionExpr">ExtensionExpr</a> | <a href="#doc-xquery40-SimpleMapExpr">SimpleMapExpr</a></code></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version">A subtraction operator must be preceded by whitespace if it could otherwise be interpreted as part of the previous token. For example, <code>a-b</code> will be interpreted as a name, but <code>a - b</code> and <code>a -b</code> will be interpreted as arithmetic expressions. (See <a href="#whitespace-rules"><span class="delete_version"><b>A.3.5 Whitespace Rules</b></span><span class="modify_version"><b>A.3.5 Whitespace Rules</b></span></a> for further details on whitespace handling.)</span><span style="display: none;" class="add_version">A subtraction operator must be preceded by whitespace if it could otherwise be interpreted as part of the previous token. For example, <code>a-b</code> will be interpreted as a name, but <code>a - b</code> and <code>a -b</code> will be interpreted as arithmetic expressions. (See <a href="#whitespace-rules"><span class="add_version"><b>A.2.4 Whitespace Rules</b></span><span class="modify_version"><b>A.2.4 Whitespace Rules</b></span></a> for further details on whitespace handling.)</span><span class="modify_version">A subtraction operator must be preceded by whitespace if it could otherwise be interpreted as part of the previous token. For example, <code>a-b</code> will be interpreted as a name, but <code>a - b</code> and <code>a -b</code> will be interpreted as arithmetic expressions. (See <a href="#whitespace-rules"><span style="display: none;" class="delete_version"><b>A.3.5 Whitespace Rules</b></span><span style="display: none;" class="add_version"><b>A.2.4 Whitespace Rules</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">3.5</span><span class="deltaxml-new">2.4</span> Whitespace Rules</b></span></a> for further details on whitespace handling.)</span></p><p><span class="deltaxml-old">The arithmetic operator symbols </span><code><span class="deltaxml-old">*</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">×</span></code><span class="deltaxml-old"> (xD7) are interchangeable, and denote multiplication.</span></p><p><span class="deltaxml-old">The arithmetic operator symbols </span><code><span class="deltaxml-old">div</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">÷</span></code><span class="deltaxml-old"> (xF7) are interchangeable, and denote division.</span></p><p><span style="display: none;" class="delete_version"> If an <code>AdditiveExpr</code> contains more than two <code>MultiplicativeExprs</code>, they are grouped from left to right. So, for instance, </span><span style="display: none;" class="add_version"> If an AdditiveExpr contains more than two MultiplicativeExprs, they are grouped from left to right. So, for instance, </span><span class="modify_version"> If an AdditiveExpr contains more than two MultiplicativeExprs, they are grouped from left to right. So, for instance, </span></p><div class="exampleInner"><pre>A - B + C - D</pre></div><p> is equivalent to </p><div class="exampleInner"><pre>((A - B) + C) - D</pre></div><p><span style="display: none;" class="delete_version"> Similarly, the operands of a <code>MultiplicativeExpr</code> are grouped from left to right. </span><span style="display: none;" class="add_version"> Similarly, the operands of a MultiplicativeExpr are grouped from left to right. </span><span class="modify_version"> Similarly, the operands of a MultiplicativeExpr are grouped from left to right. </span></p><p>The first step in evaluating an arithmetic expression is to evaluate its operands. The order in which the operands are evaluated is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p><span class="xquery">Each</span> operand is evaluated by applying the following steps, in order:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the operand. The result of this operation is called the <b>atomized operand</b>.</p></li><li><p>If the atomized operand is an empty sequence, the result of the arithmetic expression is an empty sequence, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</p></li><li><p> If the atomized operand is a sequence of length greater than one, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p><span style="display: none;" class="delete_version">If the atomized operand is of type <code>xs:untypedAtomic</code>, it is cast to <code>xs:double</code>. If the cast fails, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised. [<a title="err:FORG0001" href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0001">err:FORG0001</a>]<sup><small>FO40</small></sup></span><span style="display: none;" class="add_version">If the atomized operand is of type <code>xs:untypedAtomic</code>, it is cast to <code>xs:double</code>. If the cast fails, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised. [<a title="err:FORG0001" href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0001">err:FORG0001</a>]<sup><small>FO31</small></sup></span><span class="modify_version">If the atomized operand is of type <code>xs:untypedAtomic</code>, it is cast to <code>xs:double</code>. If the cast fails, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised. [<a title="err:FORG0001" href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0001">err:FORG0001</a>]<sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup></span></p></li></ol><p>After evaluation of the operands, if the types of the operands are a valid combination for the given arithmetic operator, the operator is applied to the operands, resulting in an atomic value or a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> (for example, an error might result from dividing by zero<span class="deltaxml-old">)</span>.<span class="deltaxml-new">)</span> The combinations of atomic types that are accepted by the various arithmetic operators, and their respective result types, are listed in <a href="#mapping"><b>B.2 Operator Mapping</b></a> together with the <a title="operator function" class="termref" href="#dt-operator-function">operator functions</a> that define the semantics of the operator for each type combination, including the dynamic errors that can be raised by the operator. The definitions of the operator functions are found in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>.</p><p>If the types of the operands, after evaluation, are not a valid combination for the given operator, according to the rules in <a href="#mapping"><b>B.2 Operator Mapping</b></a>, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><p><span class="deltaxml-old">XQuery 4.0 provides three division operators:</span></p><ul><li><p><span class="deltaxml-old">The </span><code><span class="deltaxml-old">div</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">÷</span></code><span class="deltaxml-old"> operators are synonyms, and implement numeric division as well as division of duration values; the semantics are defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-numeric-divide"><span class="deltaxml-old">Section 4.2.4 op:numeric-divide</span></a><sup><small><span class="deltaxml-old">FO40</span></small></sup></p></li><li><p><span class="deltaxml-old">The </span><code><span class="deltaxml-old">idiv</span></code><span class="deltaxml-old"> operator implements integer division; the semantics are defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-numeric-integer-divide"><span class="deltaxml-old">Section 4.2.5 op:numeric-integer-divide</span></a><sup><small><span class="deltaxml-old">FO40</span></small></sup></p></li></ul><p><span class="deltaxml-new">XQuery 4.0 supports two division operators named </span><code><span class="deltaxml-new">div</span></code><span class="deltaxml-new"> and </span><code><span class="deltaxml-new">idiv</span></code><span class="deltaxml-new">. Each of these operators accepts two operands of any </span><a title="numeric" class="termref" href="#dt-numeric"><span class="deltaxml-new">numeric</span></a><span class="deltaxml-new"> type. The semantics of </span><code><span class="deltaxml-new">div</span></code><span class="deltaxml-new"> are defined in </span><a href="https://www.w3.org/TR/xpath-functions-31/#func-numeric-integer-divide"><span class="deltaxml-new">Section 4.2.5 op:numeric-integer-divide </span></a><sup><small><span class="deltaxml-new">FO31</span></small></sup><span class="deltaxml-new">. The semantics of </span><code><span class="deltaxml-new">idiv</span></code><span class="deltaxml-new"> are defined in </span><a href="https://www.w3.org/TR/xpath-functions-31/#func-numeric-divide"><span class="deltaxml-new">Section 4.2.4 op:numeric-divide </span></a><sup><small><span class="deltaxml-new">FO31</span></small></sup><span class="deltaxml-new">. </span></p><p>Here are some examples of arithmetic expressions:</p><ul><li><p>The first expression below returns the <code>xs:decimal</code> value <code>-1.5</code>, and the second expression returns the <code>xs:integer</code> value <code>-1</code>:</p><div class="exampleInner"><pre>-3 div 2 -3 idiv 2</pre></div></li><li><p>Subtraction of two date values results in a value of type <code>xs:dayTimeDuration</code>:</p><div class="exampleInner"><pre>$emp/hiredate - $emp/birthdate</pre></div></li><li><p>This example illustrates the difference between a subtraction operator and a hyphen:</p><div class="exampleInner"><pre>$unit-price - $unit-discount</pre></div></li><li><p><span style="display: none;" class="delete_version">Unary operators have higher precedence than binary operators (other than <code>!</code>, <code>/</code>, and <code>[]</code>), subject of course to the use of parentheses. Therefore, the following two examples have different meanings:</span><span style="display: none;" class="add_version">Unary operators have higher precedence than binary operators (other than "<code>!</code>", "<code>/</code>", and "<code>[]</code>"), subject of course to the use of parentheses. Therefore, the following two examples have different meanings:</span><span class="modify_version">Unary operators have higher precedence than binary operators (other than <span class="deltaxml-new">"</span><code>!</code><span class="deltaxml-new">"</span>, <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span>, and <span class="deltaxml-new">"</span><code>[]</code><span class="deltaxml-new">"</span>), subject of course to the use of parentheses. Therefore, the following two examples have different meanings:</span></p><div class="exampleInner"><pre>-$bellcost + $whistlecost -($bellcost + $whistlecost)</pre></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p id="note-consecutive-unary-ops">Multiple consecutive unary arithmetic operators are permitted.</p></div></div><div class="div2"><h3><a id="id-string-expr"></a><span class="deltaxml-old">4.10</span><span class="deltaxml-new">4.9</span> String Expressions</h3><p>This section describes several ways of constructing strings.</p><div class="div3"><h4><a id="id-string-concat-expr"></a><span class="deltaxml-old">4.10.1</span><span class="deltaxml-new">4.9.1</span> String Concatenation Expressions</h4><a id="d3e18427"></a><a id="d3e16375"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringConcatExpr"></a>[<span class="deltaxml-old">109</span><span class="deltaxml-new">101</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-StringConcatExpr">StringConcatExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-RangeExpr">RangeExpr</a> ( "||" <a href="#doc-xquery40-RangeExpr">RangeExpr</a> )*</code></td><td></td></tr></tbody></table><p>String concatenation expressions allow the string representations of values to be concatenated. In XQuery 4.0, <code>$a || $b</code> is equivalent to <code>fn:concat($a, $b)</code>. The following expression evaluates to the string <code>concatenate</code>:</p><div class="exampleInner"><pre><span class="deltaxml-old">() || "con" || ("cat", "enate")</span></pre><pre><span class="deltaxml-new">"con" || "cat" || "enate"</span></pre></div></div><div class="div3"><h4><a id="id-string-templates"></a><span class="deltaxml-old">4.10.2</span><span class="deltaxml-new">4.9.2</span> String Templates</h4><a id="d3e18451"></a><a id="d3e16399"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringTemplate"></a>[<span class="deltaxml-old">215</span><span class="deltaxml-new">202</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-StringTemplate">StringTemplate</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"`" (<a href="#doc-xquery40-StringTemplateFixedPart">StringTemplateFixedPart</a> | <a href="#doc-xquery40-StringTemplateVariablePart">StringTemplateVariablePart</a>)* "`"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringTemplateFixedPart"></a>[<span class="deltaxml-old">216</span><span class="deltaxml-new">203</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-StringTemplateFixedPart">StringTemplateFixedPart</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>((<a href="#prod-xquery40-Char">Char</a> - ('{' | '}' | '`')) | "{{" | "}}" | "``")*</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringTemplateVariablePart"></a>[<span class="deltaxml-old">217</span><span class="deltaxml-new">204</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-StringTemplateVariablePart">StringTemplateVariablePart</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e16725.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e14797.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p>String templates provide an alternative way of constructing strings. For example, the expression <code>`Pi is {round(math:pi(), 4)}`</code> returns the string <code>"Pi is 3.1416"</code>.</p><p>A string template starts and ends with a grave accent (x60), popularly known as a back-tick. Between the back-ticks is a string consisting of an sequence of fixed parts and variable parts:</p><ul><li><p>A variable part consists of an optional XPath expression enclosed in curly brackets (<code>{}</code>): more specifically, a string conforming to the XPath production <code>Expr?</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An expression within a variable part may contain an unescaped curly bracket within a <a href="#doc-xquery40-StringLiteral">StringLiteral</a> or within a comment.</p><p>Currently no XPath expression starts with an opening curly bracket, so the use of <code>{{</code> creates no ambiguity. If an enclosed expression ends with a closing curly bracket, no whitespace is required between this and the closing delimiter.</p><p>The fact that the expression is optional means that the string contained between the curly brackets may be zero-length, may comprise whitespace only, or may contain XPath comments. The effective value in this case is a zero-length string, which is equivalent to omitting the variable part entirely, together with its curly-bracket delimiters. </p></div></li><li><p>A fixed part may contain any characters, except that:</p><ul><li><p>a left curly bracket <strong>must</strong> be written as <code>{{</code></p></li><li><p>a right curly bracket <strong>must</strong> be written as <code>}}</code>.</p></li><li><p>a back-tick <strong>must</strong> be written as <code>``</code>.</p></li></ul></li></ul><p> The result of evaluating a string template is the string obtained by concatenating the expansions of the fixed and variable parts:</p><ul><li><p>The expansion of a fixed part is obtained by replacing any double curly brackets (<code>{{</code> or <code>}}</code>) by the corresponding single curly bracket, and replacing doubled back-ticks (<code>``</code>) by a single back-tick.</p></li><li><p>The expansion of a variable part containing an expression is as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the enclosed expression, converting it to a sequence of atomic values.</p></li><li><p>If the result of atomization is an empty sequence, the result is the zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair.</p></li></ol></li><li><p>The expansion of an empty variable part (one that contains no expression) is a zero-length string.</p></li></ul><p>For example:</p><div class="exampleInner"><pre>let $greeting := "Hello", $planet := "Mars" return `{$greeting}, {$planet}!`</pre></div><p>returns <code>"Hello, Mars!"</code>.</p><p>The expression:</p><div class="exampleInner"><pre>let $longMonths := (1, 3, 5, 7, 8, 10, 12) return `The months with 31 days are: {$longMonths}.`</pre></div><p>returns <code>"The months with 31 days are: 1 3 5 7 8 10 12."</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The rules for processing an enclosed expression are identical to the rules for attributes in XQuery direct element constructors. These rules differ slightly from the rules in XSLT attribute value templates, where adjacent text nodes are concatenated with no separator, prior to atomization.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>A string template containing no variable parts is effectively just another way of writing a string literal: <code>"Goethe"</code>, <code>'Goethe'</code>, and <code>`Goethe`</code> are interchangeable. This means that back-ticks can sometimes be a useful way of delimiting a string that contains both single and double quotes: <code>`He said: "I didn't."`</code>.</p><p>It is sometimes useful to use string templates in conjunction with the <code>fn:char</code> function to build strings containing special characters, for example <code>`Chapter{fn:char("nbsp")}{$chapNr}`</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>String literals containing an ampersand behave differently between XPath and XQuery: in XPath (unless first expanded by an XML parser) the string literal <code>"Bacon &amp; Eggs"</code> represents a string containing an ampersand, while in XQuery it is an error, because an ampersand is taken as introducing a character reference. This difference does not arise for string templates, since neither XPath nor XQuery recognizes entity or character references in a string template. This means that back-tick delimited strings (such as <code>`Bacon &amp; Eggs`</code>) may be useful in contexts where an XPath expression is required to have the same effect whether it is evaluated using an XPath or an XQuery processor.</p></div><p><span style="display: none;" class="delete_version">In XQuery, the token <code>``[</code> is recognized as the start of a <a title="string constructor" class="termref" href="#dt-string-constructor">string constructor</a>, under the “longest token” rule (see <a href="#lexical-structure"><span class="delete_version"><b>A.3 Lexical structure</b></span><span class="modify_version"><b>A.3 Lexical structure</b></span></a>). This means that the construct <code>``[1]</code> is not recognized as a <a href="#doc-xquery40-StringTemplate">StringTemplate</a> followed by a predicate. In the unlikely event that an empty <a href="#doc-xquery40-StringTemplate">StringTemplate</a> followed by a predicate is wanted, whitespace or parentheses can be used to avoid the tokenization problem.</span><span style="display: none;" class="add_version">In XQuery, the token <code>``[</code> is recognized as the start of a <a title="string constructor" class="termref" href="#dt-string-constructor">string constructor</a>, under the "longest token" rule (see <a href="#lexical-structure"><span class="add_version"><b>A.2 Lexical structure</b></span><span class="modify_version"><b>A.2 Lexical structure</b></span></a>). This means that the construct <code>``[1]</code> is not recognized as a <a href="#doc-xquery40-StringTemplate">StringTemplate</a> followed by a predicate. In the unlikely event that an empty <a href="#doc-xquery40-StringTemplate">StringTemplate</a> followed by a predicate is wanted, whitespace or parentheses can be used to avoid the tokenization problem.</span><span class="modify_version">In XQuery, the token <code>``[</code> is recognized as the start of a <a title="string constructor" class="termref" href="#dt-string-constructor">string constructor</a>, under the <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>longest token<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> rule (see <a href="#lexical-structure"><span style="display: none;" class="delete_version"><b>A.3 Lexical structure</b></span><span style="display: none;" class="add_version"><b>A.2 Lexical structure</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">3</span><span class="deltaxml-new">2</span> Lexical structure</b></span></a>). This means that the construct <code>``[1]</code> is not recognized as a <a href="#doc-xquery40-StringTemplate">StringTemplate</a> followed by a predicate. In the unlikely event that an empty <a href="#doc-xquery40-StringTemplate">StringTemplate</a> followed by a predicate is wanted, whitespace or parentheses can be used to avoid the tokenization problem.</span></p></div><div class="div3"><h4><a id="id-string-constructors"></a><span class="deltaxml-old">4.10.3</span><span class="deltaxml-new">4.9.3</span> String Constructors</h4><p> [<a id="dt-string-constructor" title="string constructor">Definition</a>: A <b>String Constructor</b> creates a string from literal text and interpolated expressions. ] </p><p>The syntax of a string constructor is convenient for generating JSON, JavaScript, CSS, SPARQL, XQuery, XPath, or other languages that use curly brackets, quotation marks, or other strings that are delimiters in XQuery 4.0.</p><a id="d3e18643"></a><a id="d3e16591"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringConstructor"></a>[<span class="deltaxml-old">218</span><span class="deltaxml-new">205</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-StringConstructor">StringConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"``[" <a href="#doc-xquery40-StringConstructorContent">StringConstructorContent</a> "]``"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringConstructorContent"></a>[<span class="deltaxml-old">219</span><span class="deltaxml-new">206</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-StringConstructorContent">StringConstructorContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-StringConstructorChars">StringConstructorChars</a> (<a href="#doc-xquery40-StringInterpolation">StringInterpolation</a><a href="#doc-xquery40-StringConstructorChars">StringConstructorChars</a>)*</code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-StringConstructorChars">StringConstructorChars</a> (<a href="#doc-xquery40-StringConstructorInterpolation">StringConstructorInterpolation</a><a href="#doc-xquery40-StringConstructorChars">StringConstructorChars</a>)*</code></span><span class="modify_version"><code><a href="#doc-xquery40-StringConstructorChars">StringConstructorChars</a> (<a href="#doc-xquery40-StringInterpolation"><span class="deltaxml-old">StringInterpolation</span></a><a href="#doc-xquery40-StringConstructorInterpolation"><span class="deltaxml-new">StringConstructorInterpolation</span></a><a href="#doc-xquery40-StringConstructorChars">StringConstructorChars</a>)*</code></span></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringConstructorChars"></a>[<span class="deltaxml-old">220</span><span class="deltaxml-new">207</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-StringConstructorChars">StringConstructorChars</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a>* - (Char* ('`{' | ']``') Char*))</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringInterpolation"></a><a id="doc-xquery40-StringConstructorInterpolation"></a>[<span class="deltaxml-old">221</span><span class="deltaxml-new">208</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-StringInterpolation">StringInterpolation</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-StringConstructorInterpolation">StringConstructorInterpolation</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-StringInterpolation"><span class="deltaxml-old">StringInterpolation</span></a><a href="#prod-xquery40-StringConstructorInterpolation"><span class="deltaxml-new">StringConstructorInterpolation</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"`{" <a href="#doc-xquery40-Expr">Expr</a>? "}`"</code></td><td><span style="display: none;" class="delete_version"><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></span><span style="display: none;" class="add_version"></span><span class="modify_version"><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></span></td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p>String templates (see <a href="#id-string-templates"><span style="display: none;" class="delete_version"><b>4.10.2 String Templates</b></span><span style="display: none;" class="add_version"><b>4.9.2 String Templates</b></span><span class="modify_version"><b><span class="deltaxml-old">4.10.2</span><span class="deltaxml-new">4.9.2</span> String Templates</b></span></a>) and string constructors have overlapping functionality. String constructors were introduced in XQuery 3.1, and are not available in XPath; string templates are new in XQuery 4.0 and XPath 4.0. String constructors were designed specifically for convenience when generating code in languages that use curly braces, but with experience, they have been found to be somewhat unwieldy for simpler applications; this motivated the introduction of a simpler syntax in 4.0.</p></div><p><span style="display: none;" class="delete_version">In a <a href="#doc-xquery40-StringConstructor">string constructor</a>, adjacent <a href="#doc-xquery40-StringConstructorChars">string constructor characters</a> are treated as literal text. Line endings are processed as elsewhere in XQuery; no other processing is performed on this text. To evaluate a string constructor, each sequence of adjacent string constructor characters is converted to a string containing the same characters, and each <a href="#doc-xquery40-StringInterpolation">string constructor interpolation</a><code>$i</code> is evaluated, then converted to a string using the expression <code>string-join($i, ' ')</code>. A string constructor interpolation that does not contain an expression (<code>`{ }`</code>) is ignored. The strings created from string constructor characters and the strings created from string constructor interpolations are then concatenated, in order.</span><span style="display: none;" class="add_version">In a <a href="#doc-xquery40-StringConstructor">string constructor</a>, adjacent <a href="#doc-xquery40-StringConstructorChars">string constructor characters</a> are treated as literal text. Line endings are processed as elsewhere in XQuery; no other processing is performed on this text. To evaluate a string constructor, each sequence of adjacent string constructor characters is converted to a string containing the same characters, and each <a href="#doc-xquery40-StringConstructorInterpolation">string constructor interpolation</a><code>$i</code> is evaluated, then converted to a string using the expression <code>string-join($i, ' ')</code>. A string constructor interpolation that does not contain an expression (<code>`{ }`</code>) is ignored. The strings created from string constructor characters and the strings created from string constructor interpolations are then concatenated, in order.</span><span class="modify_version">In a <a href="#doc-xquery40-StringConstructor">string constructor</a>, adjacent <a href="#doc-xquery40-StringConstructorChars">string constructor characters</a> are treated as literal text. Line endings are processed as elsewhere in XQuery; no other processing is performed on this text. To evaluate a string constructor, each sequence of adjacent string constructor characters is converted to a string containing the same characters, and each <a href="#doc-xquery40-StringConstructorInterpolation">string constructor interpolation</a><code>$i</code> is evaluated, then converted to a string using the expression <code>string-join($i, ' ')</code>. A string constructor interpolation that does not contain an expression (<code>`{ }`</code>) is ignored. The strings created from string constructor characters and the strings created from string constructor interpolations are then concatenated, in order.</span></p><p>For instance, the following expression:</p><div class="exampleInner"><pre><span class="deltaxml-old">for $s in ("one", "two", "red", "blue") return ``[`{$s}` fish]``</span></pre><pre><span class="deltaxml-new">for $s in ("one", "two", "red", "blue") return ``[`{$s}` fish]`` </span></pre></div><p>evaluates to the sequence <code>("one fish", "two fish", "red fish", "blue fish")</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Character entities are not expanded in string constructor content. Thus, <code>``[&amp;lt;]``</code> evaluates to the string <code>"&amp;lt;"</code>, not the string <code>"&lt;"</code>.</p></div><p>Interpolations can contain string constructors. For instance, consider the following expression:</p><div class="exampleInner"><pre>``[`{ $i, ``[literal text]``, $j, ``[more literal text]`` }`]``</pre></div><p>Assuming the values <code>$i := 1</code> and <code>$j := 2</code>, this evaluates to the string <code>"1 literal text 2 more literal text"</code>.</p><p>The following examples are based on an example taken from the documentation of <a href="#Moustache">[Moustache]</a>, a JavaScript template library. Each function takes a map, containing values like these:</p><div class="exampleInner"><pre>map { "name": "Chris", "value": 10000, "taxed_value": 10000 - (10000 * 0.4), "in_ca": true }</pre></div><p>This function creates a simple string.</p><div class="exampleInner"><pre>declare function local:prize-message($a) as xs:string { ``[Hello `{$a?name}` You have just won `{$a?value}` dollars! `{ if ($a?in_ca) then ``[Well, `{$a?taxed_value}` dollars, after taxes.]`` else "" }`]`` };</pre></div><p>This is the output of the above function :</p><div class="exampleInner"><pre>Hello Chris You have just won 10000 dollars! Well, 6000 dollars, after taxes.</pre></div><p>This function creates a similar string in HTML syntax.</p><div class="exampleInner"><pre>declare function local:prize-message($a) as xs:string { ``[&lt;div&gt; &lt;h1&gt;Hello `{$a?name}`&lt;/h1&gt; &lt;p&gt;You have just won `{$a?value}` dollars!&lt;/p&gt; `{ if ($a?in_ca) then ``[ &lt;p&gt;Well, `{$a?taxed_value}` dollars, after taxes.&lt;/p&gt; ]`` else "" }` &lt;/div&gt;]`` };</pre></div><p>This is the output of the above function :</p><div class="exampleInner"><pre>&lt;div&gt; &lt;h1&gt;Hello Chris&lt;/h1&gt; &lt;p&gt;You have just won 10000 dollars!&lt;/p&gt; &lt;p&gt;Well, 6000 dollars, after taxes.&lt;/p&gt; &lt;/div&gt;</pre></div><p>This function creates a similar string in JSON syntax.</p><div class="exampleInner"><pre>declare function local:prize-message($a) as xs:string { ``[{ "name" : `{ $a?name }` "value" : `{ $a?value }` `{ if ($a?in_ca) then ``[, "taxed_value" : `{ $a?taxed_value }`]`` else "" }` }]`` };</pre></div><p>This is the output of the above function :</p><div class="exampleInner"><pre>{ "name" : "Chris", "value" : 10000, "taxed_value" : 6000 }</pre></div></div></div><div class="div2"><h3><a id="id-comparisons"></a><span class="deltaxml-old">4.11</span><span class="deltaxml-new">4.10</span> Comparison Expressions</h3><p>Comparison expressions allow two values to be compared. XQuery 4.0 provides three kinds of comparison expressions, called value comparisons, general comparisons, and node comparisons.</p><a id="d3e18779"></a><a id="d3e16722"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComparisonExpr"></a>[<span class="deltaxml-old">107</span><span class="deltaxml-new">100</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ComparisonExpr">ComparisonExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-OtherwiseExpr">OtherwiseExpr</a> ( (<a href="#doc-xquery40-ValueComp">ValueComp</a><br>| <a href="#doc-xquery40-GeneralComp">GeneralComp</a><br>| <a href="#doc-xquery40-NodeComp">NodeComp</a>) <a href="#doc-xquery40-OtherwiseExpr">OtherwiseExpr</a> )?</code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-StringConcatExpr">StringConcatExpr</a> ( (<a href="#doc-xquery40-ValueComp">ValueComp</a><br>| <a href="#doc-xquery40-GeneralComp">GeneralComp</a><br>| <a href="#doc-xquery40-NodeComp">NodeComp</a>) <a href="#doc-xquery40-StringConcatExpr">StringConcatExpr</a> )?</code></span><span class="modify_version"><code><a href="#doc-xquery40-OtherwiseExpr"><span class="deltaxml-old">OtherwiseExpr</span></a><a href="#doc-xquery40-StringConcatExpr"><span class="deltaxml-new">StringConcatExpr</span></a> ( (<a href="#doc-xquery40-ValueComp">ValueComp</a><br>| <a href="#doc-xquery40-GeneralComp">GeneralComp</a><br>| <a href="#doc-xquery40-NodeComp">NodeComp</a>) <a href="#doc-xquery40-OtherwiseExpr"><span class="deltaxml-old">OtherwiseExpr</span></a><a href="#doc-xquery40-StringConcatExpr"><span class="deltaxml-new">StringConcatExpr</span></a> )?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ValueComp"></a>[<span class="deltaxml-old">127</span><span class="deltaxml-new">118</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ValueComp">ValueComp</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GeneralComp"></a>[<span class="deltaxml-old">126</span><span class="deltaxml-new">117</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-GeneralComp">GeneralComp</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;="</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeComp"></a>[<span class="deltaxml-old">128</span><span class="deltaxml-new">119</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NodeComp">NodeComp</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td><td></td></tr></tbody></table><p><span class="deltaxml-old">For a summary of the differences between different ways of comparing atomic values in XQuery 4.0, see </span><a href="#id-atomic-comparisons"><b><span class="deltaxml-old">I Atomic Comparisons: An Overview</span></b></a><span class="deltaxml-old">.</span></p><div class="div3"><h4><a id="id-value-comparisons"></a><span class="deltaxml-old">4.11.1</span><span class="deltaxml-new">4.10.1</span> Value Comparisons</h4><p>The value comparison operators are <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code>. Value comparisons are used for comparing single values.</p><p>The first step in evaluating a value comparison is to evaluate its operands. The order in which the operands are evaluated is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. Each operand is evaluated by applying the following steps, in order:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to each operand. The result of this operation is called the <b>atomized operand</b>.</p></li><li><p>If an atomized operand is an empty sequence, the result of the value comparison is an empty sequence, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</p></li><li><p> If an atomized operand is a sequence of length greater than one, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If an atomized operand is of type <code>xs:untypedAtomic</code>, it is cast to <code>xs:string</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The purpose of this rule is to make value comparisons transitive. Users should be aware that the general comparison operators have a different rule for casting of <code>xs:untypedAtomic</code> operands. Users should also be aware that transitivity of value comparisons may be compromised by loss of precision during type conversion (for example, two <code>xs:integer</code> values that differ slightly may both be considered equal to the same <code>xs:float</code> value because <code>xs:float</code> has less precision than <code>xs:integer</code>).</p></div></li><li><p>If the two operands are instances of different primitive types (meaning the 19 primitive types defined in <a href="https://www.w3.org/TR/xmlschema-2/#built-in-primitive-datatypes">Section 3.2 Primitive datatypes</a><sup><small>XS2</small></sup>), then: </p><ol class="enumla"><li><p>If each operand is an instance of one of the types <code>xs:string</code> or <code>xs:anyURI</code>, then both operands are cast to type <code>xs:string</code>.</p></li><li><p>If each operand is an instance of one of the types <code>xs:decimal</code> or <code>xs:float</code>, then both operands are cast to type <code>xs:float</code>.</p></li><li><p>If each operand is an instance of one of the types <code>xs:decimal</code>, <code>xs:float</code>, or <code>xs:double</code>, then both operands are cast to type <code>xs:double</code>.</p></li><li><p>Otherwise, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The primitive type of an <code>xs:integer</code> value for this purpose is <code>xs:decimal</code>.</p></div></li></ol></li><li><p>Finally, if the types of the operands are a valid combination for the given operator, the operator is applied to the operands.</p></li></ol><p>The combinations of atomic types that are accepted by the various value comparison operators, and their respective result types, are listed in <a href="#mapping"><b>B.2 Operator Mapping</b></a> together with the <a title="operator function" class="termref" href="#dt-operator-function">operator functions</a> that define the semantics of the operator for each type combination. The definitions of the operator functions are found in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>.</p><p>Informally, if both atomized operands consist of exactly one atomic value, then the result of the comparison is <code>true</code> if the value of the first operand is (equal, not equal, less than, less than or equal, greater than, greater than or equal) to the value of the second operand; otherwise the result of the comparison is <code>false</code>.</p><p>If the types of the operands, after evaluation, are not a valid combination for the given operator, according to the rules in <a href="#mapping"><b>B.2 Operator Mapping</b></a>, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><p>Here are some examples of value comparisons:</p><ul><li><p>The following comparison atomizes the node(s) that are returned by the expression <code>$book/author</code>. The comparison is true only if the result of atomization is the value "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>. If the result of atomization is an empty sequence, the result of the comparison is an empty sequence. If the result of atomization is a sequence containing more than one value, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><div class="exampleInner"><pre>$book1/author eq "Kennedy"</pre></div></li><li><p>The following comparison is <code>true</code> because atomization converts an array to its member sequence:</p><div class="exampleInner"><pre>[ "Kennedy" ] eq "Kennedy"</pre></div></li><li><p>The following <a title="path expression" class="termref" href="#dt-path-expression">path expression</a> contains a predicate that selects products whose weight is greater than 100. For any product that does not have a <code>weight</code> subelement, the value of the predicate is the empty sequence, and the product is not selected. This example assumes that <code>weight</code> is a validated element with a numeric type.</p><div class="exampleInner"><pre>//product[weight gt 100]</pre></div></li><li class="xquery"><p>The following comparisons are true because, in each case, the two constructed nodes have the same value after atomization, even though they have different identities and/or names:</p><div class="exampleInner"><pre>&lt;a&gt;5&lt;/a&gt; eq &lt;a&gt;5&lt;/a&gt;</pre></div><div class="exampleInner"><pre>&lt;a&gt;5&lt;/a&gt; eq &lt;b&gt;5&lt;/b&gt;</pre></div></li><li><p>The following comparison is true if <code>my:hatsize</code> and <code>my:shoesize</code> are both user-defined types that are derived by restriction from a primitive <a title="numeric" class="termref" href="#dt-numeric">numeric</a> type:</p><div class="exampleInner"><pre>my:hatsize(5) eq my:shoesize(5)</pre></div></li><li><p>The following comparison is true. The <code>eq</code> operator compares two QNames by performing codepoint-comparisons of their namespace URIs and their local names, ignoring their namespace prefixes.</p><div class="exampleInner"><pre><span class="deltaxml-old">QName("http://example.com/ns1", "this:color") eq QName("http://example.com/ns1", "that:color")</span></pre><pre><span class="deltaxml-new">fn:QName("http://example.com/ns1", "this:color") eq fn:QName("http://example.com/ns1", "that:color")</span></pre></div></li></ul></div><div class="div3"><h4><a id="id-general-comparisons"></a><span class="deltaxml-old">4.11.2</span><span class="deltaxml-new">4.10.2</span> General Comparisons</h4><p>The general comparison operators are <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>. General comparisons are existentially quantified comparisons that may be applied to operand sequences of any length. The result of a general comparison that does not raise an error is always <code>true</code> or <code>false</code>.</p><p><span class="xquery">A</span> general comparison is evaluated by applying the following rules, in order:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to each operand. After atomization, each operand is a sequence of atomic values.</p></li><li><p><span style="display: none;" class="delete_version">The result of the comparison is <code>true</code> if and only if there is a pair of atomic values, one in the first operand sequence and the other in the second operand sequence, that have the required <b>magnitude relationship</b>. Otherwise the result of the comparison is <code>false</code> or an error. The <b>magnitude relationship</b> between two atomic values is determined by applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised. [<a title="err:FORG0001" href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0001">err:FORG0001</a>]<sup><small>FO40</small></sup></span><span style="display: none;" class="add_version">The result of the comparison is <code>true</code> if and only if there is a pair of atomic values, one in the first operand sequence and the other in the second operand sequence, that have the required <b>magnitude relationship</b>. Otherwise the result of the comparison is <code>false</code> or an error. The <b>magnitude relationship</b> between two atomic values is determined by applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised. [<a title="err:FORG0001" href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0001">err:FORG0001</a>]<sup><small>FO31</small></sup></span><span class="modify_version">The result of the comparison is <code>true</code> if and only if there is a pair of atomic values, one in the first operand sequence and the other in the second operand sequence, that have the required <b>magnitude relationship</b>. Otherwise the result of the comparison is <code>false</code> or an error. The <b>magnitude relationship</b> between two atomic values is determined by applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised. [<a title="err:FORG0001" href="https://www.w3.org/TR/xpath-functions-31/#ERRFORG0001">err:FORG0001</a>]<sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup></span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The purpose of these rules is to preserve compatibility with XPath 1.0, in which (for example) <code>x &lt; 17</code> is a numeric comparison if <code>x</code> is an untyped value. Users should be aware that the value comparison operators have different rules for casting of <code>xs:untypedAtomic</code> operands.</p></div><ol class="enumla"><li><p>If both atomic values are instances of <code>xs:untypedAtomic</code>, then the values are cast to the type <code>xs:string</code>. </p></li><li><p><span style="display: none;" class="delete_version">If exactly one of the atomic values is an instance of <code>xs:untypedAtomic</code>, it is cast to a type depending on the other value’s dynamic type T according to the following rules, in which V denotes the value to be cast: </span><span style="display: none;" class="add_version">If exactly one of the atomic values is an instance of <code>xs:untypedAtomic</code>, it is cast to a type depending on the other value's dynamic type T according to the following rules, in which V denotes the value to be cast: </span><span class="modify_version">If exactly one of the atomic values is an instance of <code>xs:untypedAtomic</code>, it is cast to a type depending on the other <span class="deltaxml-old">value’s</span><span class="deltaxml-new">value's</span> dynamic type T according to the following rules, in which V denotes the value to be cast: </span></p><ol class="enumlr"><li><p>If T is a numeric type or is derived from a numeric type, then V is cast to <code>xs:double</code>.</p></li><li><p>If T is <code>xs:dayTimeDuration</code> or is derived from <code>xs:dayTimeDuration</code>, then V is cast to <code>xs:dayTimeDuration</code>.</p></li><li><p>If T is <code>xs:yearMonthDuration</code> or is derived from <code>xs:yearMonthDuration</code>, then V is cast to <code>xs:yearMonthDuration</code>.</p></li><li><p>In all other cases, V is cast to the primitive base type of T.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p> The special treatment of the duration types is required to avoid errors that may arise when comparing the primitive type <code>xs:duration</code> with any duration type. </p></div></li><li><p>After performing the conversions described above, the atomic values are compared using one of the value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or <code>ge</code>, depending on whether the general comparison operator was <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>. The values have the required <b>magnitude relationship</b> if and only if the result of this value comparison is <code>true</code>.</p></li></ol></li></ol><p>When evaluating a general comparison in which either operand is a sequence of items, an implementation may return <code>true</code> as soon as it finds an item in the first operand and an item in the second operand that have the required <b>magnitude relationship</b>. Similarly, a general comparison may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> as soon as it encounters an error in evaluating either operand, or in comparing a pair of items from the two operands. As a result of these rules, the result of a general comparison is not deterministic in the presence of errors.</p><p>Here are some examples of general comparisons:</p><ul><li><p>The following comparison is true if the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> of any <code>author</code> subelement of <code>$book1</code> is "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>:</p><div class="exampleInner"><pre>$book1/author = "Kennedy"</pre></div></li><li><p>The following comparison is <code>true</code> because atomization converts an array to its member sequence:</p><div class="exampleInner"><pre>[ "Obama", "Nixon", "Kennedy" ] = "Kennedy"</pre></div></li><li><p>The following example contains three general comparisons. The value of the first two comparisons is <code>true</code>, and the value of the third comparison is <code>false</code>. This example illustrates the fact that general comparisons are not transitive.</p><div class="exampleInner"><pre>(1, 2) = (2, 3) (2, 3) = (3, 4) (1, 2) = (3, 4)</pre></div></li><li><p>The following example contains two general comparisons, both of which are <code>true</code>. This example illustrates the fact that the <code>=</code> and <code>!=</code> operators are not inverses of each other.</p><div class="exampleInner"><pre>(1, 2) = (2, 3) (1, 2) != (2, 3)</pre></div></li><li><p><span style="display: none;" class="delete_version">Suppose that <code>$a</code>, <code>$b</code>, and <code>$c</code> are bound to element nodes with type annotation <code>xs:untypedAtomic</code>, with <a title="string value" class="termref" href="#dt-string-value">string values</a><code>"1"</code>, <code>"2"</code>, and <code>"2.0"</code> respectively. Then <code>($a, $b) = ($c, 3.0)</code> returns <code>false</code>, because <code>$b</code> and <code>$c</code> are compared as strings. However, <code>($a, $b) = ($c, 2.0)</code> returns <code>true</code>, because <code>$b</code> and <code>2.0</code> are compared as numbers.</span><span style="display: none;" class="add_version">Suppose that <code>$a</code>, <code>$b</code>, and <code>$c</code> are bound to element nodes with type annotation <code>xs:untypedAtomic</code>, with <a title="string value" class="termref" href="#dt-string-value">string values</a> "<code>1</code>", "<code>2</code>", and "<code>2.0</code>" respectively. Then <code>($a, $b) = ($c, 3.0)</code> returns <code>false</code>, because <code>$b</code> and <code>$c</code> are compared as strings. However, <code>($a, $b) = ($c, 2.0)</code> returns <code>true</code>, because <code>$b</code> and <code>2.0</code> are compared as numbers.</span><span class="modify_version">Suppose that <code>$a</code>, <code>$b</code>, and <code>$c</code> are bound to element nodes with type annotation <code>xs:untypedAtomic</code>, with <a title="string value" class="termref" href="#dt-string-value">string values</a><span class="deltaxml-new"> </span>"<code>1<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>, "<code>2<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>, and "<code>2.0<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span> respectively. Then <code>($a, $b) = ($c, 3.0)</code> returns <code>false</code>, because <code>$b</code> and <code>$c</code> are compared as strings. However, <code>($a, $b) = ($c, 2.0)</code> returns <code>true</code>, because <code>$b</code> and <code>2.0</code> are compared as numbers.</span></p></li></ul></div><div class="div3"><h4><a id="id-node-comparisons"></a><span class="deltaxml-old">4.11.3</span><span class="deltaxml-new">4.10.3</span> Node Comparisons</h4><p>Node comparisons are used to compare two nodes, by their identity or by their <a title="document order" class="termref" href="#dt-document-order">document order</a>. The result of a node comparison is defined by the following rules:</p><ol class="enumar"><li><p>The operands of a node comparison are evaluated in <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order.</p></li><li><p>If either operand is an empty sequence, the result of the comparison is an empty sequence, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</p></li><li><p> Each operand must be either a single node or an empty sequence; otherwise a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p><span style="display: none;" class="delete_version">A comparison with the <code>is</code> operator is <code>true</code> if the two operand nodes are the same node; otherwise it is <code>false</code>. See <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a> for the definition of node identity.</span><span style="display: none;" class="add_version">A comparison with the <code>is</code> operator is <code>true</code> if the two operand nodes are the same node; otherwise it is <code>false</code>. See <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a> for the definition of node identity.</span><span class="modify_version">A comparison with the <code>is</code> operator is <code>true</code> if the two operand nodes are the same node; otherwise it is <code>false</code>. See <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a> for the definition of node identity.</span></p></li><li><p>A comparison with the <code>&lt;&lt;</code> operator returns <code>true</code> if the left operand node precedes the right operand node in <a title="document order" class="termref" href="#dt-document-order">document order</a>; otherwise it returns <code>false</code>.</p></li><li><p>A comparison with the <code>&gt;&gt;</code> operator returns <code>true</code> if the left operand node follows the right operand node in <a title="document order" class="termref" href="#dt-document-order">document order</a>; otherwise it returns <code>false</code>.</p></li></ol><p>Here are some examples of node comparisons:</p><ul><li><p>The following comparison is true only if the left and right sides each evaluate to exactly the same single node:</p><div class="exampleInner"><pre>/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]</pre></div></li><li class="xquery"><p>The following comparison is false because each constructed node has its own identity:</p><div class="exampleInner"><pre>&lt;a&gt;5&lt;/a&gt; is &lt;a&gt;5&lt;/a&gt;</pre></div></li><li><p>The following comparison is true only if the node identified by the left side occurs before the node identified by the right side in document order:</p><div class="exampleInner"><pre>/transactions/purchase[parcel="28-451"] &lt;&lt; /transactions/sale[parcel="33-870"]</pre></div></li></ul></div></div><div class="div2"><h3><a id="id-logical-expressions"></a><span class="deltaxml-old">4.12</span><span class="deltaxml-new">4.11</span> Logical Expressions</h3><p>A <b>logical expression</b> is either an <b>and-expression</b> or an <b>or-expression</b>. If a logical expression does not raise an error, its value is always one of the boolean values <code>true</code> or <code>false</code>.</p><a id="d3e19338"></a><a id="d3e17277"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-OrExpr"></a>[<span class="deltaxml-old">105</span><span class="deltaxml-new">98</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-OrExpr">OrExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AndExpr">AndExpr</a> ( "or" <a href="#doc-xquery40-AndExpr">AndExpr</a> )*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AndExpr"></a>[<span class="deltaxml-old">106</span><span class="deltaxml-new">99</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AndExpr">AndExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ComparisonExpr">ComparisonExpr</a> ( "and" <a href="#doc-xquery40-ComparisonExpr">ComparisonExpr</a> )*</code></td><td></td></tr></tbody></table><p>The first step in evaluating a logical expression is to find the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of each of its operands (see <a href="#id-ebv"><b>2.5.3 Effective Boolean Value</b></a>).</p><p>The value of an and-expression is determined by the effective boolean values (<span class="deltaxml-old">EBVs</span><span class="deltaxml-new">EBV's</span>) of its operands, as shown in the following table:</p><table style="width:80%" class="medium"><tbody><tr><th>AND:</th><th>EBV<sub>2</sub> = <code>true</code></th><th>EBV<sub>2</sub> = <code>false</code></th><th>error in EBV<sub>2</sub></th></tr><tr><th>EBV<sub>1</sub> = <code>true</code></th><td><code>true</code></td><td><code>false</code></td><td>error</td></tr><tr><th>EBV<sub>1</sub> = <code>false</code></th><td><code>false</code></td><td><code>false</code></td><td><span class="xquery">either <code>false</code> or error</span></td></tr><tr><th>error in EBV<sub>1</sub></th><td>error</td><td><span class="xquery">either <code>false</code> or error</span></td><td>error</td></tr></tbody></table><p>The value of an or-expression is determined by the effective boolean values (<span class="deltaxml-old">EBVs</span><span class="deltaxml-new">EBV's</span>) of its operands, as shown in the following table:</p><table style="width:80%" class="medium"><tbody><tr><th>OR:</th><th>EBV<sub>2</sub> = <code>true</code></th><th>EBV<sub>2</sub> = <code>false</code></th><th>error in EBV<sub>2</sub></th></tr><tr><th>EBV<sub>1</sub> = <code>true</code></th><td><code>true</code></td><td><code>true</code></td><td><span class="xquery">either <code>true</code> or error</span></td></tr><tr><th>EBV<sub>1</sub> = <code>false</code></th><td><code>true</code></td><td><code>false</code></td><td>error</td></tr><tr><th>error in EBV<sub>1</sub></th><td><span class="xquery">either <code>true</code> or error</span></td><td>error</td><td>error</td></tr></tbody></table><p><span class="xquery">The order in which the operands of a logical expression are evaluated is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. The tables above are defined in such a way that</span> an or-expression can return <code>true</code> if the first expression evaluated is true, and it can raise an error if evaluation of the first expression raises an error. Similarly, an and-expression can return <code>false</code> if the first expression evaluated is false, and it can raise an error if evaluation of the first expression raises an error. As a result of these rules, a logical expression is not deterministic in the presence of errors, as illustrated in the examples below.</p><p>Here are some examples of logical expressions:</p><ul><li><p>The following expressions return <code>true</code>:</p><div class="exampleInner"><pre>1 eq 1 and 2 eq 2</pre></div><div class="exampleInner"><pre>1 eq 1 or 2 eq 3</pre></div></li><li><p>The following expression may return either <code>false</code> or raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> :</p><div class="exampleInner"><pre>1 eq 2 and 3 idiv 0 = 1</pre></div></li><li><p>The following expression may return either <code>true</code> or raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> :</p><div class="exampleInner"><pre>1 eq 1 or 3 idiv 0 = 1</pre></div></li><li><p>The following expression must raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>:</p><div class="exampleInner"><pre>1 eq 1 and 3 idiv 0 = 1</pre></div></li></ul><p>In addition to and- and or-expressions, XQuery 4.0 provides a function named <code>fn:not</code> that takes a general sequence as parameter and returns a boolean value. The <code>fn:not</code> function is defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>. The <code>fn:not</code> function reduces its parameter to an <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a>. It then returns <code>true</code> if the effective boolean value of its parameter is <code>false</code>, and <code>false</code> if the effective boolean value of its parameter is <code>true</code>. If an error is encountered in finding the effective boolean value of its operand, <code>fn:not</code> raises the same error.</p></div><div class="div2"><h3><a id="id-constructors"></a><span class="deltaxml-old">4.13</span><span class="deltaxml-new">4.12</span> Node Constructors</h3><p>XQuery provides node constructors that can create XML nodes within a query.</p><a id="d3e19601"></a><a id="d3e17540"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor"></a>[<span class="deltaxml-old">178</span><span class="deltaxml-new">165</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NodeConstructor">NodeConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DirectConstructor">DirectConstructor</a><br>| <a href="#doc-xquery40-ComputedConstructor">ComputedConstructor</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DirectConstructor"></a>[<span class="deltaxml-old">179</span><span class="deltaxml-new">166</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DirectConstructor">DirectConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DirElemConstructor">DirElemConstructor</a><br>| <a href="#doc-xquery40-DirCommentConstructor">DirCommentConstructor</a><br>| <a href="#doc-xquery40-DirPIConstructor">DirPIConstructor</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DirElemConstructor"></a>[<span class="deltaxml-old">180</span><span class="deltaxml-new">167</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DirElemConstructor">DirElemConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"&lt;" <a href="#doc-xquery40-QName">QName</a><a href="#doc-xquery40-DirAttributeList">DirAttributeList</a> ("/&gt;" | ("&gt;" <a href="#doc-xquery40-DirElemContent">DirElemContent</a>* "&lt;/" <a href="#doc-xquery40-QName">QName</a><a href="#prod-xquery40-S">S</a>? "&gt;"))</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DirElemContent"></a>[<span class="deltaxml-old">185</span><span class="deltaxml-new">172</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DirElemContent">DirElemContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DirectConstructor">DirectConstructor</a><br>| <a href="#doc-xquery40-CDataSection">CDataSection</a><br>| <a href="#doc-xquery40-CommonContent">CommonContent</a><br>| <a href="#doc-xquery40-ElementContentChar">ElementContentChar</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ElementContentChar"></a>[<span class="deltaxml-old">280</span><span class="deltaxml-new">264</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ElementContentChar">ElementContentChar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a> - [{}&lt;&amp;])</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CommonContent"></a>[<span class="deltaxml-old">186</span><span class="deltaxml-new">173</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CommonContent">CommonContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-PredefinedEntityRef">PredefinedEntityRef</a> | <a href="#doc-xquery40-CharRef">CharRef</a> | "{{" | "}}" | <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-PredefinedEntityRef">PredefinedEntityRef</a> | <a href="#prod-xquery40-CharRef">CharRef</a> | "{{" | "}}" | <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-PredefinedEntityRef">PredefinedEntityRef</a> | <a href="#prod-xquery40-CharRef">CharRef</a> | "{{" | "}}" | <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CDataSection"></a>[<span class="deltaxml-old">191</span><span class="deltaxml-new">178</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CDataSection">CDataSection</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"&lt;![CDATA[" <a href="#doc-xquery40-CDataSectionContents">CDataSectionContents</a> "]]&gt;"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CDataSectionContents"></a>[<span class="deltaxml-old">192</span><span class="deltaxml-new">179</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CDataSectionContents">CDataSectionContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a>* - (Char* ']]&gt;' Char*))</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DirAttributeList"></a>[<span class="deltaxml-old">181</span><span class="deltaxml-new">168</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DirAttributeList">DirAttributeList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-S">S</a> (<a href="#doc-xquery40-QName">QName</a><a href="#prod-xquery40-S">S</a>? "=" <a href="#prod-xquery40-S">S</a>? <a href="#doc-xquery40-DirAttributeValue">DirAttributeValue</a>)?)*</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DirAttributeValue"></a>[<span class="deltaxml-old">182</span><span class="deltaxml-new">169</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DirAttributeValue">DirAttributeValue</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>('"' (<a href="#doc-xquery40-EscapeQuot">EscapeQuot</a> | <a href="#doc-xquery40-QuotAttrValueContent">QuotAttrValueContent</a>)* '"')<br>| ("'" (<a href="#doc-xquery40-EscapeApos">EscapeApos</a> | <a href="#doc-xquery40-AposAttrValueContent">AposAttrValueContent</a>)* "'")</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QuotAttrValueContent"></a>[<span class="deltaxml-old">183</span><span class="deltaxml-new">170</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-QuotAttrValueContent">QuotAttrValueContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-QuotAttrContentChar">QuotAttrContentChar</a><br>| <a href="#doc-xquery40-CommonContent">CommonContent</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AposAttrValueContent"></a>[<span class="deltaxml-old">184</span><span class="deltaxml-new">171</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AposAttrValueContent">AposAttrValueContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AposAttrContentChar">AposAttrContentChar</a><br>| <a href="#doc-xquery40-CommonContent">CommonContent</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QuotAttrContentChar"></a>[<span class="deltaxml-old">281</span><span class="deltaxml-new">265</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-QuotAttrContentChar">QuotAttrContentChar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a> - ["{}&lt;&amp;])</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AposAttrContentChar"></a>[<span class="deltaxml-old">282</span><span class="deltaxml-new">266</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AposAttrContentChar">AposAttrContentChar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a> - ['{}&lt;&amp;])</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e17748.doc-xquery40-EscapeQuot"></a><a id="noid_d4e15816.doc-xquery40-EscapeQuot"></a>[<span class="deltaxml-old">278</span><span class="deltaxml-new">262</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EscapeQuot</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>'""'</code></td><td><span style="display: none;" class="delete_version"><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></span><span style="display: none;" class="add_version"></span><span class="modify_version"><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></span></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e17749.doc-xquery40-EscapeApos"></a><a id="noid_d4e15817.doc-xquery40-EscapeApos"></a>[<span class="deltaxml-old">279</span><span class="deltaxml-new">263</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EscapeApos</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"''"</code></td><td><span style="display: none;" class="delete_version"><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></span><span style="display: none;" class="add_version"></span><span class="modify_version"><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></span></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e17750.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e15818.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p>Constructors are provided for element, attribute, document, text, comment, and processing instruction nodes. Two kinds of constructors are provided: <b>direct constructors</b>, which use an XML-like notation that can incorporate enclosed expressions, and <b>computed constructors</b>, which use a notation based on enclosed expressions. </p><p>The rest of this section contains a conceptual description of the semantics of various kinds of constructor expressions. An XQuery implementation is free to use any implementation technique that produces the same result as the processing steps described here.</p><div class="div3"><h4><a id="id-element-constructor"></a><span class="deltaxml-old">4.13.1</span><span class="deltaxml-new">4.12.1</span> Direct Element Constructors</h4><p>An <b>element constructor</b> creates an element node. [<a id="dt-direct-elem-const" title="direct element constructor">Definition</a>: A <b>direct element constructor</b> is a form of element constructor in which the name of the constructed element is a constant.] Direct element constructors are based on standard XML notation. For example, the following expression is a direct element constructor that creates a <code>book</code> element containing an attribute and some nested elements:</p><div class="exampleInner"><pre>&lt;book isbn="isbn-0060229357"&gt; &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt; &lt;author&gt; &lt;first&gt;Crockett&lt;/first&gt; &lt;last&gt;Johnson&lt;/last&gt; &lt;/author&gt; &lt;/book&gt;</pre></div><p><span style="display: none;" class="delete_version">If the element name in a direct element constructor has a namespace prefix, the namespace prefix is resolved to a namespace URI using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>. If the element name has no namespace prefix, <span>the namespace binding for the zero-length prefix in the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> is used; if there is no such binding, the element name will be in no namespace</span>.</span><span style="display: none;" class="add_version">If the element name in a direct element constructor has a namespace prefix, the namespace prefix is resolved to a namespace URI using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>. If the element name has no namespace prefix, it is implicitly qualified by the <span>namespace bound to the zero-length prefix in the statically known namespaces</span>: if there is no such binding, then the expanded name of the element will be in no namespace.</span><span class="modify_version">If the element name in a direct element constructor has a namespace prefix, the namespace prefix is resolved to a namespace URI using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>. If the element name has no namespace prefix, <span class="deltaxml-old">the</span><span class="deltaxml-new">it is implicitly qualified by the</span> <span>namespace <span class="deltaxml-old">binding for</span><span class="deltaxml-new">bound to</span> the zero-length prefix in the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-old">statically known namespaces</span></a><span class="deltaxml-old"> is used</span><span class="deltaxml-new">statically known namespaces</span></span><span class="deltaxml-old">;</span><span class="deltaxml-new">:</span> if there is no such binding, <span class="deltaxml-new">then </span>the <span class="deltaxml-old">element name</span><span class="deltaxml-new">expanded name of the element</span> will be in no namespace.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">The statically known namespaces may be affected by <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> found inside the element constructor.</span><span style="display: none;" class="add_version">Both the statically known namespaces and the <span>default element namespace</span> may be affected by <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> found inside the element constructor.</span><span class="modify_version"><span class="deltaxml-old">The</span><span class="deltaxml-new">Both the</span> statically known namespaces <span class="deltaxml-new">and the </span><span><span class="deltaxml-new">default element namespace</span></span><span class="deltaxml-new"> </span>may be affected by <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> found inside the element constructor.</span></p></div><p><span style="display: none;" class="delete_version">The namespace prefix of the element name is retained after expansion of the <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, as described in <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>. The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> becomes the <code>node-name</code> property of the constructed element node.</span><span style="display: none;" class="add_version">The namespace prefix of the element name is retained after expansion of the <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, as described in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>. The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> becomes the <code>node-name</code> property of the constructed element node.</span><span class="modify_version">The namespace prefix of the element name is retained after expansion of the <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, as described in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a>. The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> becomes the <code>node-name</code> property of the constructed element node.</span></p><p>In a direct element constructor, the name used in the end tag must exactly match the name used in the corresponding start tag, including its prefix or absence of a prefix [<a href="#ERRXQST0118" title="err:XQST0118">err:XQST0118</a>].</p><p>In a direct element constructor, curly braces { } delimit <a title="enclosed expression" class="termref" href="#dt-enclosed-expression">enclosed expressions</a>, distinguishing them from literal text. Enclosed expressions are evaluated and replaced by their value, as illustrated by the following example:</p><div class="exampleInner"><pre>&lt;example&gt; &lt;p&gt; Here is a query. &lt;/p&gt; &lt;eg&gt; $b/title &lt;/eg&gt; &lt;p&gt; Here is the result of the query. &lt;/p&gt; &lt;eg&gt;{ $b/title }&lt;/eg&gt; &lt;/example&gt;</pre></div><p>The above query might generate the following result (whitespace has been added for readability to this result and other result examples in this document):</p><div class="exampleInner"><pre>&lt;example&gt; &lt;p&gt; Here is a query. &lt;/p&gt; &lt;eg&gt; $b/title &lt;/eg&gt; &lt;p&gt; Here is the result of the query. &lt;/p&gt; &lt;eg&gt;&lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;&lt;/eg&gt; &lt;/example&gt;</pre></div><p><span style="display: none;" class="delete_version">Since XQuery uses curly braces to denote enclosed expressions, some convention is needed to denote a curly brace used as an ordinary character. For this purpose, a pair of identical curly brace characters within the content of an element or attribute are interpreted by XQuery as a single curly brace character (that is, the pair <code>"{{"</code> represents the character <code>{</code> and the pair <code>"}}"</code> represents the character <code>}</code>.) Alternatively, the <a title="character reference" class="termref" href="#dt-character-reference">character references</a><code>&amp;#x7b;</code> and <code>&amp;#x7d;</code> can be used to denote curly brace characters. A single left curly brace (<code>{</code>) is interpreted as the beginning delimiter for an enclosed expression. A single right curly brace (<code>}</code>) without a matching left curly brace is treated as a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXPST0003" title="err:XPST0003">err:XPST0003</a>].</span><span style="display: none;" class="add_version">Since XQuery uses curly braces to denote enclosed expressions, some convention is needed to denote a curly brace used as an ordinary character. For this purpose, a pair of identical curly brace characters within the content of an element or attribute are interpreted by XQuery as a single curly brace character (that is, the pair "<code>{{</code>" represents the character "<code>{</code>" and the pair "<code>}}</code>" represents the character "<code>}</code>".) Alternatively, the <a title="character reference" class="termref" href="#dt-character-reference">character references</a><code>&amp;#x7b;</code> and <code>&amp;#x7d;</code> can be used to denote curly brace characters. A single left curly brace ("<code>{</code>") is interpreted as the beginning delimiter for an enclosed expression. A single right curly brace ("<code>}</code>") without a matching left curly brace is treated as a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXPST0003" title="err:XPST0003">err:XPST0003</a>].</span><span class="modify_version">Since XQuery uses curly braces to denote enclosed expressions, some convention is needed to denote a curly brace used as an ordinary character. For this purpose, a pair of identical curly brace characters within the content of an element or attribute are interpreted by XQuery as a single curly brace character (that is, the pair "<code>{{<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span> represents the character <span class="deltaxml-new">"</span><code>{</code><span class="deltaxml-new">"</span> and the pair "<code>}}<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span> represents the character <span class="deltaxml-new">"</span><code>}</code><span class="deltaxml-new">"</span>.) Alternatively, the <a title="character reference" class="termref" href="#dt-character-reference">character references</a><code>&amp;#x7b;</code> and <code>&amp;#x7d;</code> can be used to denote curly brace characters. A single left curly brace (<span class="deltaxml-new">"</span><code>{</code><span class="deltaxml-new">"</span>) is interpreted as the beginning delimiter for an enclosed expression. A single right curly brace (<span class="deltaxml-new">"</span><code>}</code><span class="deltaxml-new">"</span>) without a matching left curly brace is treated as a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXPST0003" title="err:XPST0003">err:XPST0003</a>].</span></p><p>The result of an element constructor is a new element node, with its own node identity. All the attribute and descendant nodes of the new element node are also new nodes with their own identities, even if they are copies of existing nodes.</p><div class="div4"><h5><a id="id-attributes"></a><span class="deltaxml-old">4.13.1.1</span><span class="deltaxml-new">4.12.1.1</span> Attributes</h5><p>The start tag of a direct element constructor may contain one or more attributes. As in XML, each attribute is specified by a name and a value. In a direct element constructor, the name of each attribute is specified by a constant <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, and the value of the attribute is specified by a string of characters enclosed in single or double quotes. As in the main content of the element constructor, an attribute value may contain <a title="enclosed expression" class="termref" href="#dt-enclosed-expression">enclosed expressions</a>, which are evaluated and replaced by their value during processing of the element constructor.</p><p>Each attribute in a direct element constructor creates a new attribute node, with its own node identity, whose parent is the constructed element node. However, note that <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> (see <a href="#id-namespaces"><span style="display: none;" class="delete_version"><b>4.13.1.2 Namespace Declaration Attributes</b></span><span style="display: none;" class="add_version"><b>4.12.1.2 Namespace Declaration Attributes</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1.2</span><span class="deltaxml-new">4.12.1.2</span> Namespace Declaration Attributes</b></span></a>) do not create attribute nodes.</p><p><span style="display: none;" class="delete_version">If an attribute name has a namespace prefix, the prefix is resolved to a namespace URI using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>. If the attribute name has no namespace prefix, the attribute is in no namespace. Note that the statically known namespaces used in resolving an attribute name may be affected by <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> that are found inside the same element constructor. The namespace prefix of the attribute name is retained after expansion of the <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, as described in <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>. The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> becomes the <code>node-name</code> property of the constructed attribute node.</span><span style="display: none;" class="add_version">If an attribute name has a namespace prefix, the prefix is resolved to a namespace URI using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>. If the attribute name has no namespace prefix, the attribute is in no namespace. Note that the statically known namespaces used in resolving an attribute name may be affected by <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> that are found inside the same element constructor. The namespace prefix of the attribute name is retained after expansion of the <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, as described in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>. The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> becomes the <code>node-name</code> property of the constructed attribute node.</span><span class="modify_version">If an attribute name has a namespace prefix, the prefix is resolved to a namespace URI using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>. If the attribute name has no namespace prefix, the attribute is in no namespace. Note that the statically known namespaces used in resolving an attribute name may be affected by <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> that are found inside the same element constructor. The namespace prefix of the attribute name is retained after expansion of the <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, as described in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a>. The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> becomes the <code>node-name</code> property of the constructed attribute node.</span></p><p>If the attributes in a direct element constructor do not have distinct <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> as their respective <code>node-name</code> properties, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0040" title="err:XQST0040">err:XQST0040</a>].</p><p>Conceptually, an attribute (other than a namespace declaration attribute) in a direct element constructor is processed by the following steps:</p><ol class="enumar"><li><p>Each consecutive sequence of literal characters in the attribute content is processed as a string literal containing those characters, with the following exceptions:</p><ol class="enumla"><li><p>Each occurrence of two consecutive <code>{</code> characters is replaced by a single <code>{</code> character. </p></li><li><p>Each occurrence of two consecutive <code>}</code> characters is replaced by a single <code>}</code> character. </p></li><li><p>Each occurrence of <a href="#doc-xquery40-EscapeQuot">EscapeQuot</a> is replaced by a single <code>"</code> character. </p></li><li><p>Each occurrence of <a href="#doc-xquery40-EscapeApos">EscapeApos</a> is replaced by a single <code>'</code> character. </p></li></ol><p>Attribute value normalization is then applied to normalize whitespace and expand <a title="character reference" class="termref" href="#dt-character-reference">character references</a> and <a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference">predefined entity references</a>. The rules for attribute value normalization are the rules from Section 3.3.3 of [XML 1.0] or Section 3.3.3 of [XML 1.1] (it is implementation-defined which version is used). The rules are applied as though the type of the attribute were CDATA (leading and trailing whitespace characters are not stripped.) </p></li><li><p>Each enclosed expression is converted to a string as follows:</p><ol class="enumla"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the enclosed expression, converting it to a sequence of atomic values.</p></li><li><p>If the result of atomization is an empty sequence, the result is the zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair.</p></li></ol></li><li><p>Adjacent strings resulting from the above steps are concatenated with no intervening blanks. The resulting string becomes the <code>string-value</code> property of the attribute node. The attribute node is given a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of <code>xs:untypedAtomic</code> (this type annotation may change if the parent element is validated). The <code>typed-value</code> property of the attribute node is the same as its <code>string-value</code>, as an instance of <code>xs:untypedAtomic</code>.</p></li><li><p>The <code>parent</code> property of the attribute node is set to the element node constructed by the direct element constructor that contains this attribute.</p></li><li><p>If the attribute name is <code>xml:id</code>, then <code>xml:id</code> processing is performed as defined in <a href="#XMLID">[XML ID]</a>. This ensures that the attribute has the type <code>xs:ID</code> and that its value is properly normalized. If an error is encountered during <code>xml:id</code> processing, an implementation may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0091" title="err:XQDY0091">err:XQDY0091</a>].</p></li><li><p>If the attribute name is <code>xml:id</code>, the <code>is-id</code> property of the resulting attribute node is set to <code>true</code>; otherwise the <code>is-id</code> property is set to <code>false</code>. The <code>is-idrefs</code> property of the attribute node is unconditionally set to <code>false</code>.</p></li></ol><ul><li><p>Example:</p><div class="exampleInner"><pre>&lt;shoe size="7"/&gt;</pre></div><p><span style="display: none;" class="delete_version">The string value of the <code>size</code> attribute is <code>"7"</code>.</span><span style="display: none;" class="add_version">The string value of the <code>size</code> attribute is "<code>7</code>".</span><span class="modify_version">The string value of the <code>size</code> attribute is "<code>7<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;shoe size="{7}"/&gt;</pre></div><p><span style="display: none;" class="delete_version">The string value of the <code>size</code> attribute is <code>"7"</code>.</span><span style="display: none;" class="add_version">The string value of the <code>size</code> attribute is "<code>7</code>".</span><span class="modify_version">The string value of the <code>size</code> attribute is "<code>7<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;shoe size="{()}"/&gt;</pre></div><p>The string value of the <code>size</code> attribute is the zero-length string.</p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;chapter ref="[{1, 5 to 7, 9}]"/&gt;</pre></div><p><span style="display: none;" class="delete_version">The string value of the <code>ref</code> attribute is <code>"[1 5 6 7 9]"</code>.</span><span style="display: none;" class="add_version">The string value of the <code>ref</code> attribute is "<code>[1 5 6 7 9]</code>".</span><span class="modify_version">The string value of the <code>ref</code> attribute is "<code>[1 5 6 7 9]<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;shoe size="As big as {$hat/@size}"/&gt;</pre></div><p><span style="display: none;" class="delete_version">The string value of the <code>size</code> attribute is the string <code>"As big as "</code>, concatenated with the string value of the node denoted by the expression <code>$hat/@size</code>.</span><span style="display: none;" class="add_version">The string value of the <code>size</code> attribute is the string "<code>As big as </code>", concatenated with the string value of the node denoted by the expression <code>$hat/@size</code>.</span><span class="modify_version">The string value of the <code>size</code> attribute is the string "<code>As big as <span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>, concatenated with the string value of the node denoted by the expression <code>$hat/@size</code>.</span></p></li></ul></div><div class="div4"><h5><a id="id-namespaces"></a><span class="deltaxml-old">4.13.1.2</span><span class="deltaxml-new">4.12.1.2</span> Namespace Declaration Attributes</h5><p>The names of a constructed element and its attributes may be <a title="lexical QName" class="termref" href="#dt-qname">lexical QNames</a> that include <b>namespace prefixes</b>. Namespace prefixes can be bound to namespaces in the <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> or by <b>namespace declaration attributes</b>. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a namespace prefix that has not been bound to a namespace [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>].</p><p> [<a id="dt-namespace-decl-attr" title="namespace declaration attribute">Definition</a>: A <b>namespace declaration attribute</b> is used inside a direct element constructor. Its purpose is to bind a namespace prefix <span>(including the zero-length prefix)</span> for the constructed element node, including its attributes.] Syntactically, a namespace declaration attribute has the form of an attribute with namespace prefix <code>xmlns</code>, or with name <code>xmlns</code> and no namespace prefix. All the namespace declaration attributes of a given element must have distinct names [<a href="#ERRXQST0071" title="err:XQST0071">err:XQST0071</a>]. Each namespace declaration attribute is processed as follows:</p><ul><li><p>The value of the namespace declaration attribute (a <a href="#doc-xquery40-DirAttributeValue">DirAttributeValue</a>) is processed as follows. If the <a href="#doc-xquery40-DirAttributeValue">DirAttributeValue</a> contains an <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a>, a static error is raised [<a href="#ERRXQST0022" title="err:XQST0022">err:XQST0022</a>]. Otherwise, it is processed as described in rule 1 of <a href="#id-attributes"><span style="display: none;" class="delete_version"><b>4.13.1.1 Attributes</b></span><span style="display: none;" class="add_version"><b>4.12.1.1 Attributes</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1.1</span><span class="deltaxml-new">4.12.1.1</span> Attributes</b></span></a>. An implementation may raise a static error<span class="deltaxml-new"> </span>[<a href="#ERRXQST0046" title="err:XQST0046">err:XQST0046</a>] if the resulting value is of nonzero length and is neither an absolute URI nor a relative URI. The resulting value is used as the namespace URI in the following rules. </p></li><li><p>If the prefix of the attribute name is <code>xmlns</code>, then the local part of the attribute name is interpreted as a namespace prefix. This prefix and the namespace URI are added to the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> of the constructor expression (overriding any existing binding of the given prefix), and are also added as a namespace binding to the <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> of the constructed element. If the namespace URI is a zero-length string and the implementation supports <a href="#XMLNAMES11">[XML Names 1.1]</a>, any existing namespace binding for the given prefix is removed from the <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> of the constructed element and from the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> of the constructor expression. If the namespace URI is a zero-length string and the implementation does not support <a href="#XMLNAMES11">[XML Names 1.1]</a>, a static error is raised [<a href="#ERRXQST0085" title="err:XQST0085">err:XQST0085</a>]. It is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether an implementation supports <a href="#XMLNAMES">[XML Names]</a> or <a href="#XMLNAMES11">[XML Names 1.1]</a>. </p></li><li><p><span class="deltaxml-old">If the name of the namespace declaration attribute is </span><code><span class="deltaxml-old">xmlns</span></code><span class="deltaxml-old"> with no prefix, then:</span></p><ul><li><p><span class="deltaxml-old">If the namespace URI is a zero-length string, then:</span></p><ul><li><p><span class="deltaxml-old">Any no-prefix namespace binding is removed from the </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-old">in-scope namespaces</span></a><span class="deltaxml-old"> of the constructed element and from the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-old">statically known namespaces</span></a><span class="deltaxml-old"> of the constructor expression.</span></p></li><li><p><span class="deltaxml-old">Unless the query prolog contains a default namespace declaration or import schema declaration defining the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old"> as being </span><code><span class="deltaxml-old">fixed</span></code><span class="deltaxml-old">, the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old"> in the static context of the element constructor is set to </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-old">absent</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">.</span></p></li></ul></li><li><p><span class="deltaxml-old">Otherwise (when the namespace URI is not a zero-length string): </span></p><ul><li><p><span class="deltaxml-old">The namespace URI is added (with no prefix) to the </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-old">in-scope namespaces</span></a><span class="deltaxml-old"> of the constructed element (overriding any existing binding of the zero-length prefix), and to the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-old">statically known namespaces</span></a><span class="deltaxml-old"> of the constructor expression.</span></p></li><li><p><span class="deltaxml-old">Unless the query prolog contains a default namespace declaration or import schema declaration defining the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old"> as being </span><code><span class="deltaxml-old">fixed</span></code><span class="deltaxml-old">, the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old"> in the static context of the constructor expression is set to the specified namespace URI.</span></p></li></ul></li></ul><p><span class="deltaxml-new">If the name of the namespace declaration attribute is </span><code><span class="deltaxml-new">xmlns</span></code><span class="deltaxml-new"> with no prefix, then a binding of the zero-length prefix to the namespace URI is added to the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new">statically known namespaces</span></a><span class="deltaxml-new"> of the constructor expression (overriding any existing binding of the zero-length prefix), and is also added (with no prefix) to the </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new">in-scope namespaces</span></a><span class="deltaxml-new"> of the constructed element (overriding any existing namespace binding with no prefix). If the namespace URI is a zero-length string then any no-prefix namespace binding is removed from the </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new">in-scope namespaces</span></a><span class="deltaxml-new"> of the constructed element. </span></p><p><span class="deltaxml-new">For backwards compatibility reasons, if the query prolog does not contain an explicit default type namespace declaration, then the </span><a title="default element namespace" class="termref" href="#dt-def-element-ns"><span class="deltaxml-new">default element namespace</span></a><span class="deltaxml-new"> and </span><a title="default type namespace" class="termref" href="#dt-def-type-ns"><span class="deltaxml-new">default type namespace</span></a><span class="deltaxml-new"> of the constructor expression are set to </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent"><span class="deltaxml-new">absent</span></a><sup><small><span class="deltaxml-new">DM31</span></small></sup><span class="deltaxml-new">. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">In earlier versions of XQuery, given the expression </span><code><span class="deltaxml-new">&lt;output xmlns=""&gt;{$x/input}&lt;/output&gt;</span></code><span class="deltaxml-new">, both the unprefixed names </span><code><span class="deltaxml-new">output</span></code><span class="deltaxml-new"> and </span><code><span class="deltaxml-new">input</span></code><span class="deltaxml-new"> were interpreted as no-namespace names. Furthermore, the </span><code><span class="deltaxml-new">xmlns=""</span></code><span class="deltaxml-new"> declaration would affect the interpretation of any unprefixed type names (though in practice, unprefixed type names were rarely used.) This behavior is retained in XQuery 4.0 for compatibility reasons. However, the behavior can be changed by adding a declaration such as </span><code><span class="deltaxml-new">declare default type namespace "http://www.w3.org/2001/XMLSchema"</span></code><span class="deltaxml-new"> to the query prolog. If a default type namespace is declared, then the attribute </span><code><span class="deltaxml-new">xmlns=""</span></code><span class="deltaxml-new"> only affects the </span><code><span class="deltaxml-new">output</span></code><span class="deltaxml-new"> namespace, not the </span><code><span class="deltaxml-new">input</span></code><span class="deltaxml-new"> namespace; it also has no effect on unprefixed type names. </span></p><p><span class="deltaxml-new">The same applies to a default namespace declaration such as </span><code><span class="deltaxml-new">xmlns="http://www.w3.org/1999/xhtml/</span></code><span class="deltaxml-new">. If a default type namespace is declared, the default namespace declaration only affects names used in element constructors, it no longer affects the interpretation of names in path expressions. This removes a usability problem that otherwise arises when the input is no-namespace XML and the output is XHTML.</span></p></div></li><li><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>] if a namespace declaration attribute attempts to do any of the following: </p><ul><li><p>Bind the prefix <code>xml</code> to some namespace URI other than <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Bind a prefix other than <code>xml</code> to the namespace URI <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Bind the prefix <code>xmlns</code> to any namespace URI. </p></li><li><p>Bind a prefix to the namespace URI <code>http://www.w3.org/2000/xmlns/</code>. </p></li></ul></li></ul><p> A namespace declaration attribute does not cause an attribute node to be created. </p><p>The following examples illustrate namespace declaration attributes:</p><ul><li><p><span style="display: none;" class="delete_version">In this element constructor, a namespace declaration attribute is used to set the default namespace to <code>http://example.org/animals</code>:</span><span style="display: none;" class="add_version">In this element constructor, a namespace declaration attribute is used to set the <span><a title="default element namespace" class="termref" href="#dt-def-element-ns">default element namespace</a> and <a title="default type namespace" class="termref" href="#dt-def-type-ns">default type namespace</a></span> to <code>http://example.org/animals</code>:</span><span class="modify_version">In this element constructor, a namespace declaration attribute is used to set the <span class="deltaxml-old">default</span><span><a title="default element namespace" class="termref" href="#dt-def-element-ns"><span class="deltaxml-new">default element namespace</span></a> <span class="deltaxml-old">namespace</span><span class="deltaxml-new">and</span> <a title="default type namespace" class="termref" href="#dt-def-type-ns"><span class="deltaxml-new">default type namespace</span></a></span><span class="deltaxml-new"> </span>to <code>http://example.org/animals</code>:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">&lt;cat xmlns="http://example.org/animals"&gt; &lt;breed&gt;{variety/@name}&lt;/breed&gt; &lt;/cat&gt;</span></pre><pre><span class="deltaxml-new">&lt;cat xmlns = "http://example.org/animals"&gt; &lt;breed&gt;Persian&lt;/breed&gt; &lt;/cat&gt;</span></pre></div><p><span class="deltaxml-old">More specifically:</span></p><ul><li><p><span class="deltaxml-old">The expanded name of the constructed element will be </span><code><span class="deltaxml-old">Q{http://example.org/animals}cat</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The constructed element will have a namespace binding that associates the empty prefix with the namespace URI </span><code><span class="deltaxml-old">http://example.org/animals</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The static context for evaluation of any expressions within the element constructor will include a binding of the empty prefix to the namespace URI </span><code><span class="deltaxml-old">http://example.org/animals</span></code><span class="deltaxml-old">. This ensures that the nested </span><code><span class="deltaxml-old">breed</span></code><span class="deltaxml-old"> element will also be in the namespace </span><code><span class="deltaxml-old">http://example.org/animals</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old"> within the element constructor will be </span><code><span class="deltaxml-old">http://example.org/animals</span></code><span class="deltaxml-old">, which means that the element name </span><code><span class="deltaxml-old">variety</span></code><span class="deltaxml-old"> is also interpreted as being in this namespace. This effect may be unwanted, since the document containing the context node may well use a different default namespace. In XQuery 4.0 this effect can be prevented by declaring, in the query prolog, that the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">fixed</span></code><span class="deltaxml-old">. Alternatively the path expression can be written </span><code><span class="deltaxml-old">Q{}variety/@name</span></code><span class="deltaxml-old"> to make it explicit that </span><code><span class="deltaxml-old">variety</span></code><span class="deltaxml-old"> refers to a no-namespace element.</span></p></li></ul></li><li><p>In this element constructor, namespace declaration attributes are used to bind the namespace prefixes <code>metric</code> and <code>english</code>:</p><div class="exampleInner"><pre>&lt;box xmlns:metric = "http://example.org/metric/units" xmlns:english = "http://example.org/english/units"&gt; &lt;height&gt; &lt;metric:meters&gt;3&lt;/metric:meters&gt; &lt;/height&gt; &lt;width&gt; &lt;english:feet&gt;6&lt;/english:feet&gt; &lt;/width&gt; &lt;depth&gt; &lt;english:inches&gt;18&lt;/english:inches&gt; &lt;/depth&gt; &lt;/box&gt;</pre></div></li></ul></div><div class="div4"><h5><a id="id-content"></a><span class="deltaxml-old">4.13.1.3</span><span class="deltaxml-new">4.12.1.3</span> Content</h5><p>The part of a direct element constructor between the start tag and the end tag is called the <b>content</b> of the element constructor. This content may consist of text characters (parsed as <a href="#doc-xquery40-ElementContentChar">ElementContentChar</a>), nested direct constructors, <a href="#doc-xquery40-CDataSection">CDataSections</a>, character and <a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference">predefined entity references</a>, and <a title="enclosed expression" class="termref" href="#dt-enclosed-expression">enclosed expressions</a>. In general, the value of an enclosed expression may be any sequence of nodes and/or atomic values. Enclosed expressions can be used in the content of an element constructor to compute both the content and the attributes of the constructed node.</p><p>Conceptually, the content of an element constructor is processed as follows:</p><ol class="enumar"><li><p>The content is evaluated to produce a sequence of nodes called the <b>content sequence</b>, as follows:</p><ol class="enumla"><li><p><span style="display: none;" class="delete_version">If the <a title="boundary-space policy" class="termref" href="#dt-boundary-space-policy">boundary-space policy</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> is <code>strip</code>, <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> is identified and deleted (see <a href="#id-whitespace"><span class="delete_version"><b>4.13.1.4 Boundary Whitespace</b></span><span class="modify_version"><b>4.13.1.4 Boundary Whitespace</b></span></a> for the definition of boundary whitespace.)</span><span style="display: none;" class="add_version">If the <a title="boundary-space policy" class="termref" href="#dt-boundary-space-policy">boundary-space policy</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> is <code>strip</code>, <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> is identified and deleted (see <a href="#id-whitespace"><span class="add_version"><b>4.12.1.4 Boundary Whitespace</b></span><span class="modify_version"><b>4.12.1.4 Boundary Whitespace</b></span></a> for the definition of boundary whitespace.)</span><span class="modify_version">If the <a title="boundary-space policy" class="termref" href="#dt-boundary-space-policy">boundary-space policy</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> is <code>strip</code>, <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> is identified and deleted (see <a href="#id-whitespace"><span style="display: none;" class="delete_version"><b>4.13.1.4 Boundary Whitespace</b></span><span style="display: none;" class="add_version"><b>4.12.1.4 Boundary Whitespace</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1.4</span><span class="deltaxml-new">4.12.1.4</span> Boundary Whitespace</b></span></a> for the definition of boundary whitespace.)</span></p></li><li><p><a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference">Predefined entity references</a> and <a title="character reference" class="termref" href="#dt-character-reference">character references</a> are expanded into their referenced strings, as described in <a href="#id-literals"><b>4.3.1 Literals</b></a>. Characters inside a <a href="#doc-xquery40-CDataSection">CDataSection</a>, including special characters such as <code>&lt;</code> and <code>&amp;</code>, are treated as literal characters rather than as markup characters (except for the sequence <code>]]&gt;</code>, which terminates the CDataSection).</p></li><li><p>Each consecutive sequence of literal characters evaluates to a single text node containing the characters.</p></li><li><p>Each nested direct constructor is evaluated according to the rules in <a href="#id-element-constructor"><span style="display: none;" class="delete_version"><b>4.13.1 Direct Element Constructors</b></span><span style="display: none;" class="add_version"><b>4.12.1 Direct Element Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1</span><span class="deltaxml-new">4.12.1</span> Direct Element Constructors</b></span></a> or <a href="#id-otherConstructors"><span style="display: none;" class="delete_version"><b>4.13.2 Other Direct Constructors</b></span><span style="display: none;" class="add_version"><b>4.12.2 Other Direct Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.2</span><span class="deltaxml-new">4.12.2</span> Other Direct Constructors</b></span></a>, resulting in a new element, comment, or processing instruction node. Then:</p><ol class="enumlr"><li><p>The <code>parent</code> property of the resulting node is then set to the newly constructed element node.</p></li><li><p>The <code>base-uri</code> property of the resulting node, and of each of its descendants, is set to be the same as that of its new parent, unless it (the child node) has an <code>xml:base</code> attribute, in which case its <code>base-uri</code> property is set to the value of that attribute, <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved (if it is relative)</a> against the <code>base-uri</code> property of its new parent node.</p></li></ol></li><li><p>Enclosed expressions are evaluated as follows: </p><ol class="enumlr"><li><p>Each array returned by the enclosed expression is flattened by calling the function <code>array:flatten()</code> before the steps that follow.</p></li><li><p>If an enclosed expression returns a <a title="function item" class="termref" href="#dt-function-item">function item</a>, a type error is raised [<a href="#ERRXQTY0105" title="err:XQTY0105">err:XQTY0105</a>].</p></li><li><p>For each adjacent sequence of one or more atomic values returned by an enclosed expression, a new text node is constructed, containing the result of casting each atomic value to a string, with a single space character inserted between adjacent values.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The insertion of blank characters between adjacent values applies even if one or both of the values is a zero-length string.</p></div></li><li><p>For each node returned by an enclosed expression, a new copy is made of the given node and all nodes that have the given node as an ancestor, collectively referred to as <b>copied nodes</b>. The properties of the copied nodes are as follows:</p><ol class="enumua"><li><p>Each copied node receives a new node identity.</p></li><li><p>The <code>parent</code>, <code>children</code>, and <code>attributes</code> properties of the copied nodes are set so as to preserve their inter-node relationships. For the topmost node (the node directly returned by the enclosed expression), the <code>parent</code> property is set to the node constructed by this constructor.</p></li><li><p>If <a title="construction mode" class="termref" href="#dt-construction-mode">construction mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> is <code>strip</code>:</p><ol class="enumur"><li><p>If the copied node is an element node, its <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> is set to <code>xs:untyped</code>. Its <code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code> properties are set to <code>false</code>.</p></li><li><p>If the copied node is an attribute node, its <code>type-name</code> property is set to <code>xs:untypedAtomic</code>. Its <code>is-idrefs</code> property is set to <code>false</code>. Its <code>is-id</code> property is set to <code>true</code> if the qualified name of the attribute node is <code>xml:id</code>; otherwise it is set to <code>false</code>.</p></li><li><p>The <code>string-value</code> of each copied element and attribute node remains unchanged, and its <code>typed-value</code> becomes equal to its <code>string-value</code> as an instance of <code>xs:untypedAtomic</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p> Implementations that store only the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> of a node are required at this point to convert the typed value to a string form.</p></div></li></ol><p>On the other hand, if <a title="construction mode" class="termref" href="#dt-construction-mode">construction mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> is <code>preserve</code>, the <code>type-name</code>, <code>nilled</code>, <code>string-value</code>, <code>typed-value</code>, <code>is-id</code>, and <code>is-idrefs</code> properties of the copied nodes are preserved.</p></li><li><p>The <code>in-scope-namespaces</code> property of a copied element node is determined by the following rules. In applying these rules, the default namespace or absence of a default namespace is treated like any other namespace binding:</p><ol class="enumur"><li><p>If <a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> specifies <code>preserve</code>, all in-scope-namespaces of the original element are retained in the new copy. If <a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> specifies <code>no-preserve</code>, the new copy retains only those in-scope namespaces of the original element that are used in the names of the element and its attributes.</p></li><li><p>If <a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> specifies <code>inherit</code>, the copied node inherits all the in-scope namespaces of the constructed node, augmented and overridden by the in-scope namespaces of the original element that were preserved by the preceding rule. If <a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> specifies <code>no-inherit</code>, the copied node does not inherit any in-scope namespaces from the constructed node.</p></li></ol></li><li><p>An enclosed expression in the content of an element constructor may cause one or more existing nodes to be copied. Type error [<a href="#ERRXQTY0086" title="err:XQTY0086">err:XQTY0086</a>] is raised in the following cases:</p><ol class="enumur"><li><p> An element node is copied, and the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> of the element node or one of its attributes is <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a>, and <a title="construction mode" class="termref" href="#dt-construction-mode">construction mode</a> is <code>preserve</code>, and <a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> is <code>no-preserve</code>. </p></li><li><p> An attribute node is copied but its parent element node is not copied, and the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> of the copied attribute node is <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a>, and <a title="construction mode" class="termref" href="#dt-construction-mode">construction mode</a> is <code>preserve</code>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p> The rationale for error [<a href="#ERRXQTY0086" title="err:XQTY0086">err:XQTY0086</a>] is as follows: It is not possible to preserve the type of a QName without also preserving the namespace binding that defines the prefix of the QName.</p></div></li><li><p>When an element or processing instruction node is copied, its <code>base-uri</code> property is set to be the same as that of its new parent, with the following exception: if a copied element node has an <code>xml:base</code> attribute, its <code>base-uri</code> property is set to the value of that attribute, <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved (if it is relative)</a> against the <code>base-uri</code> property of the new parent node.</p></li><li><p>All other properties of the copied nodes are preserved.</p></li></ol></li></ol></li></ol></li><li><p> If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</p></li><li><p>Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</p></li><li><p>If the content sequence contains an attribute node or a namespace node following a node that is not an attribute node or a namespace node, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXQTY0024" title="err:XQTY0024">err:XQTY0024</a>].</p></li><li><p>The properties of the newly constructed element node are determined as follows:</p><ol class="enumla"><li><p><span style="display: none;" class="delete_version"><code>node-name</code> is the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> resulting from resolving the element name in the start tag, including its original namespace prefix (if any), as described in <a href="#id-element-constructor"><span class="delete_version"><b>4.13.1 Direct Element Constructors</b></span><span class="modify_version"><b>4.13.1 Direct Element Constructors</b></span></a>.</span><span style="display: none;" class="add_version"><code>node-name</code> is the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> resulting from resolving the element name in the start tag, including its original namespace prefix (if any), as described in <a href="#id-element-constructor"><span class="add_version"><b>4.12.1 Direct Element Constructors</b></span><span class="modify_version"><b>4.12.1 Direct Element Constructors</b></span></a>.</span><span class="modify_version"><code>node-name</code> is the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> resulting from resolving the element name in the start tag, including its original namespace prefix (if any), as described in <a href="#id-element-constructor"><span style="display: none;" class="delete_version"><b>4.13.1 Direct Element Constructors</b></span><span style="display: none;" class="add_version"><b>4.12.1 Direct Element Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1</span><span class="deltaxml-new">4.12.1</span> Direct Element Constructors</b></span></a>.</span></p></li><li><p><code>parent</code> is set to empty.</p></li><li><p><span style="display: none;" class="delete_version"><code>attributes</code> consist of all the attributes specified in the start tag as described in <a href="#id-attributes"><span class="delete_version"><b>4.13.1.1 Attributes</b></span><span class="modify_version"><b>4.13.1.1 Attributes</b></span></a>, together with all the attribute nodes in the content sequence, in <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order. Note that the <code>parent</code> property of each of these attribute nodes has been set to the newly constructed element node. If two or more attributes have the same <code>node-name</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0025" title="err:XQDY0025">err:XQDY0025</a>]. If an attribute named <code>xml:space</code> has a value other than <code>preserve</code> or <code>default</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> may be raised [<a href="#ERRXQDY0092" title="err:XQDY0092">err:XQDY0092</a>].</span><span style="display: none;" class="add_version"><code>attributes</code> consist of all the attributes specified in the start tag as described in <a href="#id-attributes"><span class="add_version"><b>4.12.1.1 Attributes</b></span><span class="modify_version"><b>4.12.1.1 Attributes</b></span></a>, together with all the attribute nodes in the content sequence, in <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order. Note that the <code>parent</code> property of each of these attribute nodes has been set to the newly constructed element node. If two or more attributes have the same <code>node-name</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0025" title="err:XQDY0025">err:XQDY0025</a>]. If an attribute named <code>xml:space</code> has a value other than <code>preserve</code> or <code>default</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> may be raised [<a href="#ERRXQDY0092" title="err:XQDY0092">err:XQDY0092</a>].</span><span class="modify_version"><code>attributes</code> consist of all the attributes specified in the start tag as described in <a href="#id-attributes"><span style="display: none;" class="delete_version"><b>4.13.1.1 Attributes</b></span><span style="display: none;" class="add_version"><b>4.12.1.1 Attributes</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1.1</span><span class="deltaxml-new">4.12.1.1</span> Attributes</b></span></a>, together with all the attribute nodes in the content sequence, in <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order. Note that the <code>parent</code> property of each of these attribute nodes has been set to the newly constructed element node. If two or more attributes have the same <code>node-name</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0025" title="err:XQDY0025">err:XQDY0025</a>]. If an attribute named <code>xml:space</code> has a value other than <code>preserve</code> or <code>default</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> may be raised [<a href="#ERRXQDY0092" title="err:XQDY0092">err:XQDY0092</a>].</span></p></li><li><p><code>children</code> consist of all the element, text, comment, and processing instruction nodes in the content sequence. Note that the <code>parent</code> property of each of these nodes has been set to the newly constructed element node.</p></li><li><p><span style="display: none;" class="delete_version"><code>base-uri</code> is set to the following value:</span><span style="display: none;" class="add_version"><code>base-uri</code> is set to the following value: </span><span class="modify_version"><code>base-uri</code> is set to the following value:<span class="deltaxml-new"> </span></span></p><ol class="enumlr"><li><p><span style="display: none;" class="delete_version">If the constructed node has an attribute named <code>xml:base</code>, then the value of this attribute, <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved (if it is relative)</a> against the <span><a class="termref" title="Executable Base URI" href="#dt-executable-base-uri">Executable Base URI</a></span>, as described in <a href="#id-resolve-relative-uri"><b>2.5.6 Resolving a Relative URI Reference</b></a>. </span><span style="display: none;" class="add_version">If the constructed node has an attribute named <code>xml:base</code>, then the value of this attribute, <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved (if it is relative)</a> against the <a class="termref" title="Static Base URI" href="#dt-static-base-uri">Static Base URI</a>, as described in <a href="#id-resolve-relative-uri"><b>2.5.6 Resolving a Relative URI Reference</b></a>. </span><span class="modify_version">If the constructed node has an attribute named <code>xml:base</code>, then the value of this attribute, <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved (if it is relative)</a> against the <a class="termref" title="Static Base URI" href="#dt-static-base-uri"><span class="deltaxml-old">Executable</span><span class="deltaxml-new">Static</span> Base URI</a>, as described in <a href="#id-resolve-relative-uri"><b>2.5.6 Resolving a Relative URI Reference</b></a>. </span></p></li><li><p><span style="display: none;" class="delete_version">Otherwise, the <span><a class="termref" title="Executable Base URI" href="#dt-executable-base-uri">Executable Base URI</a></span>.</span><span style="display: none;" class="add_version">Otherwise, the <a class="termref" title="Static Base URI" href="#dt-static-base-uri">Static Base URI</a>.</span><span class="modify_version">Otherwise, the <a class="termref" title="Static Base URI" href="#dt-static-base-uri"><span class="deltaxml-old">Executable</span><span class="deltaxml-new">Static</span> Base URI</a>.</span></p></li></ol></li><li><p><span style="display: none;" class="delete_version"><code>in-scope-namespaces</code> consist of all the namespace bindings resulting from namespace declaration attributes as described in <a href="#id-namespaces"><span class="delete_version"><b>4.13.1.2 Namespace Declaration Attributes</b></span><span class="modify_version"><b>4.13.1.2 Namespace Declaration Attributes</b></span></a>, and possibly additional namespace bindings as described in <a href="#id-ns-nodes-on-elements"><span class="delete_version"><b>4.13.4 In-scope Namespaces of a Constructed Element</b></span><span class="modify_version"><b>4.13.4 In-scope Namespaces of a Constructed Element</b></span></a>.</span><span style="display: none;" class="add_version"><code>in-scope-namespaces</code> consist of all the namespace bindings resulting from namespace declaration attributes as described in <a href="#id-namespaces"><span class="add_version"><b>4.12.1.2 Namespace Declaration Attributes</b></span><span class="modify_version"><b>4.12.1.2 Namespace Declaration Attributes</b></span></a>, and possibly additional namespace bindings as described in <a href="#id-ns-nodes-on-elements"><span class="add_version"><b>4.12.4 In-scope Namespaces of a Constructed Element</b></span><span class="modify_version"><b>4.12.4 In-scope Namespaces of a Constructed Element</b></span></a>.</span><span class="modify_version"><code>in-scope-namespaces</code> consist of all the namespace bindings resulting from namespace declaration attributes as described in <a href="#id-namespaces"><span style="display: none;" class="delete_version"><b>4.13.1.2 Namespace Declaration Attributes</b></span><span style="display: none;" class="add_version"><b>4.12.1.2 Namespace Declaration Attributes</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1.2</span><span class="deltaxml-new">4.12.1.2</span> Namespace Declaration Attributes</b></span></a>, and possibly additional namespace bindings as described in <a href="#id-ns-nodes-on-elements"><span style="display: none;" class="delete_version"><b>4.13.4 In-scope Namespaces of a Constructed Element</b></span><span style="display: none;" class="add_version"><b>4.12.4 In-scope Namespaces of a Constructed Element</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.4</span><span class="deltaxml-new">4.12.4</span> In-scope Namespaces of a Constructed Element</b></span></a>.</span></p></li><li><p>The <code>nilled</code> property is <code>false</code>.</p></li><li><p>The <code>string-value</code> property is equal to the concatenated contents of the text-node descendants in document order. If there are no text-node descendants, the <code>string-value</code> property is a zero-length string.</p></li><li><p>The <code>typed-value</code> property is equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p></li><li><p>If <a title="construction mode" class="termref" href="#dt-construction-mode">construction mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> is <code>strip</code>, the <code>type-name</code> property is <code>xs:untyped</code>. On the other hand, if construction mode is <code>preserve</code>, the <code>type-name</code> property is <code>xs:anyType</code>.</p></li><li><p>The <code>is-id</code> and <code>is-idrefs</code> properties are set to <code>false</code>.</p></li></ol></li></ol><ul><li><p>Example:</p><div class="exampleInner"><pre>&lt;a&gt;{1}&lt;/a&gt;</pre></div><p><span style="display: none;" class="delete_version">The constructed element node has one child, a text node containing the value <code>"1"</code>.</span><span style="display: none;" class="add_version">The constructed element node has one child, a text node containing the value "<code>1</code>".</span><span class="modify_version">The constructed element node has one child, a text node containing the value "<code>1<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;a&gt;{1, 2, 3}&lt;/a&gt;</pre></div><p><span style="display: none;" class="delete_version">The constructed element node has one child, a text node containing the value <code>"1 2 3"</code>.</span><span style="display: none;" class="add_version">The constructed element node has one child, a text node containing the value "<code>1 2 3</code>".</span><span class="modify_version">The constructed element node has one child, a text node containing the value "<code>1 2 3<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;c&gt;{1}{2}{3}&lt;/c&gt;</pre></div><p><span style="display: none;" class="delete_version">The constructed element node has one child, a text node containing the value <code>"123"</code>.</span><span style="display: none;" class="add_version">The constructed element node has one child, a text node containing the value "<code>123</code>".</span><span class="modify_version">The constructed element node has one child, a text node containing the value "<code>123<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;b&gt;{1, "2", "3"}&lt;/b&gt;</pre></div><p><span style="display: none;" class="delete_version">The constructed element node has one child, a text node containing the value <code>"1 2 3"</code>.</span><span style="display: none;" class="add_version">The constructed element node has one child, a text node containing the value "<code>1 2 3</code>".</span><span class="modify_version">The constructed element node has one child, a text node containing the value "<code>1 2 3<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;fact&gt;I saw 8 cats.&lt;/fact&gt;</pre></div><p><span style="display: none;" class="delete_version">The constructed element node has one child, a text node containing the value <code>"I saw 8 cats."</code>.</span><span style="display: none;" class="add_version">The constructed element node has one child, a text node containing the value "<code>I saw 8 cats.</code>".</span><span class="modify_version">The constructed element node has one child, a text node containing the value "<code>I saw 8 cats.<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;fact&gt;I saw {5 + 3} cats.&lt;/fact&gt;</pre></div><p><span style="display: none;" class="delete_version">The constructed element node has one child, a text node containing the value <code>"I saw 8 cats."</code>.</span><span style="display: none;" class="add_version">The constructed element node has one child, a text node containing the value "<code>I saw 8 cats.</code>".</span><span class="modify_version">The constructed element node has one child, a text node containing the value "<code>I saw 8 cats.<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;fact&gt;I saw &lt;howmany&gt;{5 + 3}&lt;/howmany&gt; cats.&lt;/fact&gt;</pre></div><p><span style="display: none;" class="delete_version">The constructed element node has three children: a text node containing <code>"I saw </code> ", a child element node named <code>howmany</code>, and a text node containing <code>" cats."</code>. The child element node in turn has a single text node child containing the value <code>"8"</code>.</span><span style="display: none;" class="add_version">The constructed element node has three children: a text node containing "<code>I saw </code> ", a child element node named <code>howmany</code>, and a text node containing "<code> cats.</code>". The child element node in turn has a single text node child containing the value "<code>8</code>".</span><span class="modify_version">The constructed element node has three children: a text node containing "<code>I saw </code> ", a child element node named <code>howmany</code>, and a text node containing "<code> cats.<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>. The child element node in turn has a single text node child containing the value "<code>8<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p></li></ul></div><div class="div4"><h5><a id="id-whitespace"></a><span class="deltaxml-old">4.13.1.4</span><span class="deltaxml-new">4.12.1.4</span> Boundary Whitespace</h5><p>In a direct element constructor, whitespace characters may appear in the content of the constructed element. In some cases, enclosed expressions and/or nested elements may be separated only by whitespace characters. For example, in the expression below, the end-tag <code>&lt;/title&gt;</code> and the start-tag <code>&lt;author&gt;</code> are separated by a newline character and four space characters:</p><div class="exampleInner"><pre>&lt;book isbn="isbn-0060229357"&gt; &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt; &lt;author&gt; &lt;first&gt;Crockett&lt;/first&gt; &lt;last&gt;Johnson&lt;/last&gt; &lt;/author&gt; &lt;/book&gt;</pre></div><p> [<a id="dt-boundary-whitespace" title="boundary whitespace">Definition</a>: <b>Boundary whitespace</b> is a sequence of consecutive whitespace characters within the content of a <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a>, that is delimited at each end either by the start or end of the content, or by a <a href="#doc-xquery40-DirectConstructor">DirectConstructor</a>, or by an <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a>. For this purpose, characters generated by <a title="character reference" class="termref" href="#dt-character-reference">character references</a> such as <code>&amp;#x20;</code> or by <a href="#doc-xquery40-CDataSection">CDataSections</a> are not considered to be whitespace characters.] </p><p>The <a title="boundary-space policy" class="termref" href="#dt-boundary-space-policy">boundary-space policy</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> controls whether boundary whitespace is preserved by element constructors. If boundary-space policy is <code>strip</code>, boundary whitespace is not considered significant and is discarded. On the other hand, if boundary-space policy is <code>preserve</code>, boundary whitespace is considered significant and is preserved.</p><ul><li><p>Example:</p><div class="exampleInner"><pre>&lt;cat&gt; &lt;breed&gt;{$b}&lt;/breed&gt; &lt;color&gt;{$c}&lt;/color&gt; &lt;/cat&gt;</pre></div><p>The constructed <code>cat</code> element node has two child element nodes named <code>breed</code> and <code>color</code>. Whitespace surrounding the child elements will be stripped away by the element constructor if boundary-space policy is <code>strip</code>.</p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;a&gt; {"abc"} &lt;/a&gt;</pre></div><p>If boundary-space policy is <code>strip</code>, this example is equivalent to <code>&lt;a&gt;abc&lt;/a&gt;</code>. However, if boundary-space policy is <code>preserve</code>, this example is equivalent to <code>&lt;a&gt;&nbsp;&nbsp;abc&nbsp;&nbsp;&lt;/a&gt;</code>.</p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;a&gt; z {"abc"}&lt;/a&gt;</pre></div><p>Since the whitespace surrounding the <code>z</code> is not boundary whitespace, it is always preserved. This example is equivalent to <code>&lt;a&gt;&nbsp;z&nbsp;abc&lt;/a&gt;</code>.</p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;a&gt;&amp;#x20;{"abc"}&lt;/a&gt;</pre></div><p>This example is equivalent to <code>&lt;a&gt;&nbsp;abc&lt;/a&gt;</code>, regardless of the boundary-space policy, because the space generated by the <a title="character reference" class="termref" href="#dt-character-reference">character reference</a> is not treated as a whitespace character.</p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;a&gt;{" "}&lt;/a&gt;</pre></div><p>This example constructs an element containing two space characters, regardless of the boundary-space policy, because whitespace inside an enclosed expression is never considered to be boundary whitespace.</p></li><li><p>Example:</p><div class="exampleInner"><pre>&lt;a&gt;{ [ "one", "little", "fish" ] }&lt;/a&gt;</pre></div><p>This example constructs an element containing the text <code>one little fish</code>, because the array is flattened, and the resulting sequence of atomic values is converted to a text node with a single blank between values.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>Element constructors treat attributes named <code>xml:space</code> as ordinary attributes. An <code>xml:space</code> attribute does not affect the handling of whitespace by an element constructor.</p></div></div></div><div class="div3"><h4><a id="id-otherConstructors"></a><span class="deltaxml-old">4.13.2</span><span class="deltaxml-new">4.12.2</span> Other Direct Constructors</h4><p>XQuery allows an expression to generate a processing instruction node or a comment node. This can be accomplished by using a <b>direct processing instruction constructor</b> or a <b>direct comment constructor</b>. In each case, the syntax of the constructor expression is based on the syntax of a similar construct in XML.</p><a id="d3e21037"></a><a id="d3e18930"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DirPIConstructor"></a>[<span class="deltaxml-old">189</span><span class="deltaxml-new">176</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DirPIConstructor">DirPIConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"&lt;?" <a href="#prod-xquery40-PITarget">PITarget</a> (<a href="#prod-xquery40-S">S</a><a href="#doc-xquery40-DirPIContents">DirPIContents</a>)? "?&gt;"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DirPIContents"></a>[<span class="deltaxml-old">190</span><span class="deltaxml-new">177</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DirPIContents">DirPIContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a>* - (Char* '?&gt;' Char*))</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DirCommentConstructor"></a>[<span class="deltaxml-old">187</span><span class="deltaxml-new">174</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DirCommentConstructor">DirCommentConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"&lt;!--" <a href="#doc-xquery40-DirCommentContents">DirCommentContents</a> "--&gt;"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DirCommentContents"></a>[<span class="deltaxml-old">188</span><span class="deltaxml-new">175</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DirCommentContents">DirCommentContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>((<a href="#prod-xquery40-Char">Char</a> - '-') | ('-' (<a href="#prod-xquery40-Char">Char</a> - '-')))*</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody></table><p>A direct processing instruction constructor creates a processing instruction node whose <code>target</code> property is <a href="#prod-xquery40-PITarget">PITarget</a> and whose <code>content</code> property is <a href="#doc-xquery40-DirPIContents">DirPIContents</a>. The <code>base-uri</code> property of the node is empty. The <code>parent</code> property of the node is empty.</p><p><span style="display: none;" class="delete_version">The <a href="#prod-xquery40-PITarget">PITarget</a> of a processing instruction must not consist of the characters <code>XML</code> in any combination of upper and lower case, <span>and must not contain a colon</span>. The <a href="#doc-xquery40-DirPIContents">DirPIContents</a> of a processing instruction must not contain the string <code>"?&gt;"</code>.</span><span style="display: none;" class="add_version">The <a href="#prod-xquery40-PITarget">PITarget</a> of a processing instruction must not consist of the characters "XML" in any combination of upper and lower case, <span>and must not contain a colon</span>. The <a href="#doc-xquery40-DirPIContents">DirPIContents</a> of a processing instruction must not contain the string "<code>?&gt;</code>".</span><span class="modify_version">The <a href="#prod-xquery40-PITarget">PITarget</a> of a processing instruction must not consist of the characters <span class="deltaxml-new">"</span>XML<span class="deltaxml-new">"</span> in any combination of upper and lower case, <span>and must not contain a colon</span>. The <a href="#doc-xquery40-DirPIContents">DirPIContents</a> of a processing instruction must not contain the string "<code>?&gt;<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p><p>The following example illustrates a direct processing instruction constructor:</p><div class="exampleInner"><pre>&lt;?format role="output" ?&gt;</pre></div><p>A direct comment constructor creates a comment node whose <code>content</code> property is <a href="#doc-xquery40-DirCommentContents">DirCommentContents</a>. Its <code>parent</code> property is empty.</p><p>The <a href="#doc-xquery40-DirCommentContents">DirCommentContents</a> of a comment must not contain two consecutive hyphens or end with a hyphen. These rules are syntactically enforced by the grammar shown above.</p><p>The following example illustrates a direct comment constructor:</p><div class="exampleInner"><pre>&lt;!-- Tags are ignored in the following section --&gt;</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>A direct comment constructor is different from a <a href="#doc-xquery40-Comment">comment</a>, since a direct comment constructor actually constructs a comment node, whereas a <a href="#doc-xquery40-Comment">comment</a> is simply used in documenting a query and is not evaluated.</p></div></div><div class="div3"><h4><a id="id-computedConstructors"></a><span class="deltaxml-old">4.13.3</span><span class="deltaxml-new">4.12.3</span> Computed Constructors</h4><a id="d3e21161"></a><a id="d3e19052"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComputedConstructor"></a>[<span class="deltaxml-old">193</span><span class="deltaxml-new">180</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ComputedConstructor">ComputedConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CompDocConstructor">CompDocConstructor</a><br>| <a href="#doc-xquery40-CompElemConstructor">CompElemConstructor</a><br>| <a href="#doc-xquery40-CompAttrConstructor">CompAttrConstructor</a><br>| <a href="#doc-xquery40-CompNamespaceConstructor">CompNamespaceConstructor</a><br>| <a href="#doc-xquery40-CompTextConstructor">CompTextConstructor</a><br>| <a href="#doc-xquery40-CompCommentConstructor">CompCommentConstructor</a><br>| <a href="#doc-xquery40-CompPIConstructor">CompPIConstructor</a></code></td><td></td></tr></tbody></table><p>An alternative way to create nodes is by using a <b>computed constructor</b>. A computed constructor begins with a keyword that identifies the type of node to be created: <code>element</code>, <code>attribute</code>, <code>document</code>, <code>text</code>, <code>processing-instruction</code>, <code>comment</code>, or <code>namespace</code>.</p><p>For those kinds of nodes that have names (element, attribute, and processing instruction nodes), the keyword that specifies the node kind is followed by the name of the node to be created. This name may be specified either as an EQName or as an expression enclosed in braces. [<a id="dt-name-expression" title="name expression">Definition</a>: When an expression is used to specify the name of a constructed node, that expression is called the <b>name expression</b> of the constructor.] </p><p>The following example illustrates the use of computed element and attribute constructors in a simple case where the names of the constructed nodes are constants. This example generates exactly the same result as the first example in <a href="#id-element-constructor"><span style="display: none;" class="delete_version"><b>4.13.1 Direct Element Constructors</b></span><span style="display: none;" class="add_version"><b>4.12.1 Direct Element Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1</span><span class="deltaxml-new">4.12.1</span> Direct Element Constructors</b></span></a>:</p><div class="exampleInner"><pre>element book { attribute isbn {"isbn-0060229357" }, element title { "Harold and the Purple Crayon"}, element author { element first { "Crockett" }, element last {"Johnson" } } }</pre></div><div class="div4"><h5><a id="id-computedElements"></a><span class="deltaxml-old">4.13.3.1</span><span class="deltaxml-new">4.12.3.1</span> Computed Element Constructors</h5><a id="d3e21237"></a><a id="d3e19128"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompElemConstructor"></a>[<span class="deltaxml-old">195</span><span class="deltaxml-new">182</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CompElemConstructor">CompElemConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"element" (<a href="#doc-xquery40-EQName">EQName</a> | ("{" <a href="#doc-xquery40-Expr">Expr</a> "}")) <a href="#doc-xquery40-EnclosedContentExpr">EnclosedContentExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e19068.doc-xquery40-EQName"></a><a id="noid_d4e17098.doc-xquery40-EQName"></a>[<span class="deltaxml-old">266</span><span class="deltaxml-new">252</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EQName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-QName">QName</a> | <a href="#doc-xquery40-URIQualifiedName">URIQualifiedName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-EnclosedContentExpr"></a>[<span class="deltaxml-old">196</span><span class="deltaxml-new">183</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EnclosedContentExpr">EnclosedContentExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e19070.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e17100.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p> [<a id="dt-computed-elem-const" title="computed element constructor">Definition</a>: A <b>computed element constructor</b> creates an element node, allowing both the name and the content of the node to be computed.] </p><p>If the keyword <code>element</code> is followed by an EQName, it is expanded to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> as follows: if the EQName has a BracedURILiteral it is expanded using the specified URI; if the EQName is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> with a namespace prefix it is expanded using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>; if the EQName is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> without a prefix it is implicitly qualified by the <span>namespace URI that is bound to the zero-length prefix in the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>; if there is no such binding, the expanded name will be in no namespace. </span>. The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is used as the <code>node-name</code> property of the constructed element node. If expansion of the QName is not successful, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>].</p><p>If the keyword <code>element</code> is followed by a <a title="name expression" class="termref" href="#dt-name-expression">name expression</a>, the name expression is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a>. If the result of atomization is not a single atomic value of type <code>xs:QName</code>, <code>xs:string</code>, or <code>xs:untypedAtomic</code>, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If the atomized value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a> is of type <code>xs:QName</code>, that <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is used as the <code>node-name</code> property of the constructed element, retaining the prefix part of the QName.</p></li><li><p>If the atomized value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a> is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, that value is converted to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a><span>as follows:</span></p><ol class="enumla"><li><p>Leading and trailing whitespace is removed.</p></li><li><p><span style="display: none;" class="delete_version">If the value is an unprefixed <code>NCName</code>, it is interpreted according to the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>.</span><span style="display: none;" class="add_version">If the value is an unprefixed <code>NCName</code>, it is treated as a local name in the <a class="termref" title="default element namespace" href="#dt-def-element-ns">default element namespace</a>.</span><span class="modify_version">If the value is an unprefixed <code>NCName</code>, it is <span class="deltaxml-old">interpreted according to</span><span class="deltaxml-new">treated as a local name in</span> the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><a class="termref" title="default element namespace" href="#dt-def-element-ns"><span class="deltaxml-new">default element namespace</span></a>.</span></p></li><li><p>If the value is a lexical QName with a prefix, that prefix is <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved to a namespace URI</a> using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>.</p></li><li><p>If the value is a URI-qualified name (<code>Q{uri}local</code>), it is converted to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> with the supplied namespace URI and local name, and with no prefix.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>This was under-specified in XQuery 3.1.</p></div><p>The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is used as the <code>node-name</code> property of the constructed element, retaining the prefix part of the QName <span>(or its absence)</span>. If conversion of the atomized <a title="name expression" class="termref" href="#dt-name-expression">name expression</a> to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is not successful, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0074" title="err:XQDY0074">err:XQDY0074</a>].</p></li></ol><p>A <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0096" title="err:XQDY0096">err:XQDY0096</a>] if the node-name of the constructed element node has any of the following properties: </p><ul><li><p>Its namespace prefix is <code>xmlns</code>. </p></li><li><p>Its namespace URI is <code>http://www.w3.org/2000/xmlns/</code>. </p></li><li><p>Its namespace prefix is <code>xml</code> and its namespace URI is not <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Its namespace prefix is other than <code>xml</code> and its namespace URI is <code>http://www.w3.org/XML/1998/namespace</code>. </p></li></ul><p><span style="display: none;" class="delete_version">The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed element constructor (if present) is processed in exactly the same way as an enclosed expression in the content of a <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a>, as described in Step 1e of <a href="#id-content"><span class="delete_version"><b>4.13.1.3 Content</b></span><span class="modify_version"><b>4.13.1.3 Content</b></span></a>. The result of processing the content expression is a sequence of nodes called the <b>content sequence</b>. If the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> is absent, the content sequence is an empty sequence.</span><span style="display: none;" class="add_version">The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed element constructor (if present) is processed in exactly the same way as an enclosed expression in the content of a <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a>, as described in Step 1e of <a href="#id-content"><span class="add_version"><b>4.12.1.3 Content</b></span><span class="modify_version"><b>4.12.1.3 Content</b></span></a>. The result of processing the content expression is a sequence of nodes called the <b>content sequence</b>. If the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> is absent, the content sequence is an empty sequence.</span><span class="modify_version">The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed element constructor (if present) is processed in exactly the same way as an enclosed expression in the content of a <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a>, as described in Step 1e of <a href="#id-content"><span style="display: none;" class="delete_version"><b>4.13.1.3 Content</b></span><span style="display: none;" class="add_version"><b>4.12.1.3 Content</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1.3</span><span class="deltaxml-new">4.12.1.3</span> Content</b></span></a>. The result of processing the content expression is a sequence of nodes called the <b>content sequence</b>. If the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> is absent, the content sequence is an empty sequence.</span></p><p>Processing of the computed element constructor proceeds as follows:</p><ol class="enumar"><li><p>If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</p></li><li><p>Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</p></li><li><p> If the content sequence contains an attribute node or a namespace node following a node that is not an attribute node or a namespace node, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXQTY0024" title="err:XQTY0024">err:XQTY0024</a>].</p></li><li><p>The properties of the newly constructed element node are determined as follows:</p><ol class="enumla"><li><p><code>node-name</code> is the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> resulting from processing the specified <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> or <a title="name expression" class="termref" href="#dt-name-expression">name expression</a>, as described above.</p></li><li><p><code>parent</code> is empty.</p></li><li><p><code>attributes</code> consist of all the attribute nodes in the content sequence, in <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order. Note that the <code>parent</code> property of each of these attribute nodes has been set to the newly constructed element node. If two or more attributes have the same <code>node-name</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0025" title="err:XQDY0025">err:XQDY0025</a>]. If an attribute named <code>xml:space</code> has a value other than <code>preserve</code> or <code>default</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> may be raised [<a href="#ERRXQDY0092" title="err:XQDY0092">err:XQDY0092</a>].</p></li><li><p><code>children</code> consist of all the element, text, comment, and processing instruction nodes in the content sequence. Note that the <code>parent</code> property of each of these nodes has been set to the newly constructed element node.</p></li><li><p><code>base-uri</code> is set to the following value: </p><ol class="enumlr"><li><p><span style="display: none;" class="delete_version">If the constructed node has an attribute named <code>xml:base</code>, then the value of this attribute, <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved (if it is relative)</a> against the <span><a class="termref" title="Executable Base URI" href="#dt-executable-base-uri">Executable Base URI</a></span>, as described in <a href="#id-resolve-relative-uri"><b>2.5.6 Resolving a Relative URI Reference</b></a>.</span><span style="display: none;" class="add_version">If the constructed node has an attribute named <code>xml:base</code>, then the value of this attribute, <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved (if it is relative)</a> against the <a class="termref" title="Static Base URI" href="#dt-static-base-uri">Static Base URI</a>, as described in <a href="#id-resolve-relative-uri"><b>2.5.6 Resolving a Relative URI Reference</b></a>.</span><span class="modify_version">If the constructed node has an attribute named <code>xml:base</code>, then the value of this attribute, <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved (if it is relative)</a> against the <a class="termref" title="Static Base URI" href="#dt-static-base-uri"><span class="deltaxml-old">Executable</span><span class="deltaxml-new">Static</span> Base URI</a>, as described in <a href="#id-resolve-relative-uri"><b>2.5.6 Resolving a Relative URI Reference</b></a>.</span></p></li><li><p><span style="display: none;" class="delete_version">Otherwise, the <span><a class="termref" title="Executable Base URI" href="#dt-executable-base-uri">Executable Base URI</a></span>.</span><span style="display: none;" class="add_version">Otherwise, the <a class="termref" title="Static Base URI" href="#dt-static-base-uri">Static Base URI</a>.</span><span class="modify_version">Otherwise, the <a class="termref" title="Static Base URI" href="#dt-static-base-uri"><span class="deltaxml-old">Executable</span><span class="deltaxml-new">Static</span> Base URI</a>.</span></p></li></ol></li><li><p><span style="display: none;" class="delete_version"><code>in-scope-namespaces</code> are computed as described in <a href="#id-ns-nodes-on-elements"><span class="delete_version"><b>4.13.4 In-scope Namespaces of a Constructed Element</b></span><span class="modify_version"><b>4.13.4 In-scope Namespaces of a Constructed Element</b></span></a>.</span><span style="display: none;" class="add_version"><code>in-scope-namespaces</code> are computed as described in <a href="#id-ns-nodes-on-elements"><span class="add_version"><b>4.12.4 In-scope Namespaces of a Constructed Element</b></span><span class="modify_version"><b>4.12.4 In-scope Namespaces of a Constructed Element</b></span></a>.</span><span class="modify_version"><code>in-scope-namespaces</code> are computed as described in <a href="#id-ns-nodes-on-elements"><span style="display: none;" class="delete_version"><b>4.13.4 In-scope Namespaces of a Constructed Element</b></span><span style="display: none;" class="add_version"><b>4.12.4 In-scope Namespaces of a Constructed Element</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.4</span><span class="deltaxml-new">4.12.4</span> In-scope Namespaces of a Constructed Element</b></span></a>.</span></p></li><li><p>The <code>nilled</code> property is <code>false</code>.</p></li><li><p>The <code>string-value</code> property is equal to the concatenated contents of the text-node descendants in document order.</p></li><li><p>The <code>typed-value</code> property is equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p></li><li><p>If <a title="construction mode" class="termref" href="#dt-construction-mode">construction mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> is <code>strip</code>, the <code>type-name</code> property is <code>xs:untyped</code>. On the other hand, if construction mode is <code>preserve</code>, the <code>type-name</code> property is <code>xs:anyType</code>.</p></li><li><p>The <code>is-id</code> and <code>is-idrefs</code> properties are set to <code>false</code>.</p></li></ol></li></ol><p>A computed element constructor might be used to make a modified copy of an existing element. For example, if the variable <code>$e</code> is bound to an element with <a title="numeric" class="termref" href="#dt-numeric">numeric</a> content, the following constructor might be used to create a new element with the same name and attributes as <code>$e</code> and with numeric content equal to twice the value of <code>$e</code>:</p><div class="exampleInner"><pre><span class="deltaxml-old">element {node-name($e)} {$e/@*, 2 * data($e)}</span></pre><pre><span class="deltaxml-new">element {fn:node-name($e)} {$e/@*, 2 * fn:data($e)}</span></pre></div><p>In this example, if <code>$e</code> is bound by the expression <code>let $e := &lt;length units="inches"&gt;{5}&lt;/length&gt;</code>, then the result of the example expression is the element <code>&lt;length units="inches"&gt;10&lt;/length&gt;</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a title="static type" class="termref" href="#dt-static-type">static type</a> of the expression <code>fn:node-name($e)</code> is <code>xs:QName?</code>, denoting zero or one QName. Therefore, if the <a title="static     typing feature" class="termref" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect, the above example raises a static type error, since the name expression in a computed element constructor is required to return exactly one string or QName. In order to avoid the static type error, the name expression <code>fn:node-name($e)</code> could be rewritten as <code>fn:exactly-one(fn:node-name($e))</code>. If the <a title="static     typing feature" class="termref" href="#dt-static-typing-feature">Static Typing Feature</a> is not in effect, the example can be successfully evaluated as written, provided that <code>$e</code> is bound to exactly one element node with numeric content.</p></div><p><span style="display: none;" class="delete_version">One important purpose of computed constructors is to allow the name of a node to be computed. We will illustrate this feature by an expression that translates the name of an element from one language to another. Suppose that the variable <code>$dict</code> is bound to a <code>dictionary</code> element containing a sequence of <code>entry</code> elements, each of which encodes translations for a specific word. Here is an example entry that encodes the German and Italian variants of the word “address”:</span><span style="display: none;" class="add_version">One important purpose of computed constructors is to allow the name of a node to be computed. We will illustrate this feature by an expression that translates the name of an element from one language to another. Suppose that the variable <code>$dict</code> is bound to a <code>dictionary</code> element containing a sequence of <code>entry</code> elements, each of which encodes translations for a specific word. Here is an example entry that encodes the German and Italian variants of the word "address":</span><span class="modify_version">One important purpose of computed constructors is to allow the name of a node to be computed. We will illustrate this feature by an expression that translates the name of an element from one language to another. Suppose that the variable <code>$dict</code> is bound to a <code>dictionary</code> element containing a sequence of <code>entry</code> elements, each of which encodes translations for a specific word. Here is an example entry that encodes the German and Italian variants of the word <span class="deltaxml-old">“address”</span><span class="deltaxml-new">"address"</span>:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">&lt;entry word="address"&gt; &lt;variant xml:lang="de"&gt;Adresse&lt;/variant&gt; &lt;variant xml:lang="it"&gt;indirizzo&lt;/variant&gt; &lt;/entry&gt;</span></pre><pre><span class="deltaxml-new">&lt;entry word="address"&gt; &lt;variant xml:lang="de"&gt;Adresse&lt;/variant&gt; &lt;variant xml:lang="it"&gt;indirizzo&lt;/variant&gt; &lt;/entry&gt; </span></pre></div><p>Suppose further that the variable <code>$e</code> is bound to the following element:</p><div class="exampleInner"><pre>&lt;address&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/address&gt;</pre></div><p>Then the following expression generates a new element in which the name of <code>$e</code> has been translated into Italian and the content of <code>$e</code> (including its attributes, if any) has been preserved. The first enclosed expression after the <code>element</code> keyword generates the name of the element, and the second enclosed expression generates the content and attributes:</p><div class="exampleInner"><pre> element {$dict/entry[@word=name($e)]/variant[@xml:lang="it"]} {$e/@*, $e/node()}</pre></div><p>The result of this expression is as follows:</p><div class="exampleInner"><pre>&lt;indirizzo&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/indirizzo&gt;</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>As in the previous example, if the <a title="static     typing feature" class="termref" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect, the enclosed expression that computes the element name in the above computed element constructor must be wrapped in a call to the <code>fn:exactly-one</code> function in order to avoid a static type error.</p></div><p>Additional examples of computed element constructors can be found in <a href="#id-recursive-transformations"><span style="display: none;" class="delete_version"><b>J.3 Recursive Transformations</b></span><span style="display: none;" class="add_version"><b>I.3 Recursive Transformations</b></span><span class="modify_version"><b><span class="deltaxml-old">J</span><span class="deltaxml-new">I</span>.3 Recursive Transformations</b></span></a>.</p></div><div class="div4"><h5><a id="id-computedAttributes"></a><span class="deltaxml-old">4.13.3.2</span><span class="deltaxml-new">4.12.3.2</span> Computed Attribute Constructors</h5><a id="d3e21726"></a><a id="d3e19614"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompAttrConstructor"></a>[<span class="deltaxml-old">197</span><span class="deltaxml-new">184</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CompAttrConstructor">CompAttrConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"attribute" (<a href="#doc-xquery40-EQName">EQName</a> | ("{" <a href="#doc-xquery40-Expr">Expr</a> "}")) <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e19524.doc-xquery40-EQName"></a><a id="noid_d4e17551.doc-xquery40-EQName"></a>[<span class="deltaxml-old">266</span><span class="deltaxml-new">252</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EQName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-QName">QName</a> | <a href="#doc-xquery40-URIQualifiedName">URIQualifiedName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e19525.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e17552.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p>A computed attribute constructor creates a new attribute node, with its own node identity.</p><p>Attributes have no default namespace. The rules that expand attribute names create an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> prefix if an attribute name has a namespace URI but no prefix is provided.</p><p>If the keyword <code>attribute</code> is followed by an EQName, it is expanded to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> as follows:</p><ul><li><p>If the EQName has a BracedURILiteral it is expanded using the specified URI to create an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>; the name of the attribute is constructed using the namespace URI and local name of the expanded QName and an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> prefix.</p></li><li><p>If the EQName is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> with a namespace prefix it is expanded using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>.</p></li><li><p>If the EQName is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> without a prefix, the expanded QName is in no namespace.</p></li></ul><p>The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (including its prefix) is used as the <code>node-name</code> property of the constructed attribute node. If expansion of the QName is not successful, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>].</p><p>If the keyword <code>attribute</code> is followed by a <a title="name expression" class="termref" href="#dt-name-expression">name expression</a>, the name expression is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the result of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a>. If the result of <a title="atomization" class="termref" href="#dt-atomization">atomization</a> is not a single atomic value of type <code>xs:QName</code>, <code>xs:string</code>, or <code>xs:untypedAtomic</code>, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If the atomized value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a> is of type <code>xs:QName</code>:</p><ol class="enumla"><li><p>If the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> returned by the atomized name expression has a namespace URI but has no prefix, it is given an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> prefix.</p></li><li><p>The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (including its prefix) is used as the <code>node-name</code> property of the constructed attribute node.</p></li></ol></li><li><p>If the atomized value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a> is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, that value is converted to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a><span>as follows:</span></p><ol class="enumla"><li><p>Leading and trailing whitespace is removed.</p></li><li><p>If the value is an unprefixed <code>NCName</code>, it is treated as a local name in no namespace.</p></li><li><p>If the value is a lexical QName with a prefix, that prefix is <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved to a namespace URI</a> using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>.</p></li><li><p>If the value is a URI-qualified name (<code>Q{uri}local</code>), it is converted to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> with the supplied namespace URI and local name, and with an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation dependent</a> prefix.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>This was under-specified in XQuery 3.1.</p></div><p>The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (including its prefix) is used as the <code>node-name</code> property of the constructed attribute. If conversion of the atomized <a title="name expression" class="termref" href="#dt-name-expression">name expression</a> to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is not successful, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0074" title="err:XQDY0074">err:XQDY0074</a>].</p></li></ol><p>A <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0044" title="err:XQDY0044">err:XQDY0044</a>] if the node-name of the constructed attribute node has any of the following properties: </p><ul><li><p>Its namespace prefix is <code>xmlns</code>. </p></li><li><p>It has no namespace prefix and its local name is <code>xmlns</code>. </p></li><li><p>Its namespace URI is <code>http://www.w3.org/2000/xmlns/</code>. </p></li><li><p>Its namespace prefix is <code>xml</code> and its namespace URI is not <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Its namespace prefix is other than <code>xml</code> and its namespace URI is <code>http://www.w3.org/XML/1998/namespace</code>. </p></li></ul><p>The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed attribute constructor is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the result of the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a>, converting it to a sequence of atomic values. (If the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> is absent, the result of this step is an empty sequence.)</p></li><li><p>If the result of atomization is an empty sequence, the value of the attribute is the zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the <code>string-value</code> property of the new attribute node. The <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> (<code>type-name</code> property) of the new attribute node is <code>xs:untypedAtomic</code>. The <code>typed-value</code> property of the attribute node is the same as its <code>string-value</code>, as an instance of <code>xs:untypedAtomic</code>.</p></li><li><p>The <code>parent</code> property of the attribute node is set to empty.</p></li><li><p>If the attribute name is <code>xml:id</code>, then <code>xml:id</code> processing is performed as defined in <a href="#XMLID">[XML ID]</a>. This ensures that the attribute node has the type <code>xs:ID</code> and that its value is properly normalized. If an error is encountered during <code>xml:id</code> processing, an implementation may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0091" title="err:XQDY0091">err:XQDY0091</a>].</p></li><li><p>If the attribute name is <code>xml:id</code>, the <code>is-id</code> property of the resulting attribute node is set to <code>true</code>; otherwise the <code>is-id</code> property is set to <code>false</code>. The <code>is-idrefs</code> property of the attribute node is unconditionally set to <code>false</code>.</p></li><li><p>If the attribute name is <code>xml:space</code> and the attribute value is other than <code>preserve</code> or <code>default</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> may be raised [<a href="#ERRXQDY0092" title="err:XQDY0092">err:XQDY0092</a>].</p></li></ol><ul><li><p>Example:</p><div class="exampleInner"><pre>attribute size {4 + 3}</pre></div><p><span style="display: none;" class="delete_version">The <a title="string value" class="termref" href="#dt-string-value">string value</a> of the <code>size</code> attribute is <code>"7"</code> and its type is <code>xs:untypedAtomic</code>.</span><span style="display: none;" class="add_version">The <a title="string value" class="termref" href="#dt-string-value">string value</a> of the <code>size</code> attribute is "<code>7</code>" and its type is <code>xs:untypedAtomic</code>.</span><span class="modify_version">The <a title="string value" class="termref" href="#dt-string-value">string value</a> of the <code>size</code> attribute is "<code>7<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span> and its type is <code>xs:untypedAtomic</code>.</span></p></li><li><p>Example:</p><div class="exampleInner"><pre><span class="deltaxml-old">attribute { if ($sex = "M") then "husband" else "wife" } { &lt;a&gt;Hello&lt;/a&gt;, 1 to 3, &lt;b&gt;Goodbye&lt;/b&gt; }</span></pre><pre><span class="deltaxml-new">attribute { if ($sex = "M") then "husband" else "wife" } { &lt;a&gt;Hello&lt;/a&gt;, 1 to 3, &lt;b&gt;Goodbye&lt;/b&gt; } </span></pre></div><p>The name of the constructed attribute is either <code>husband</code> or <code>wife</code>. Its <a title="string value" class="termref" href="#dt-string-value">string value</a> is "<code>Hello 1 2 3 Goodbye</code>".</p></li></ul></div><div class="div4"><h5><a id="id-documentConstructors"></a><span class="deltaxml-old">4.13.3.3</span><span class="deltaxml-new">4.12.3.3</span> Document Node Constructors</h5><a id="d3e22097"></a><a id="d3e19985"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompDocConstructor"></a>[<span class="deltaxml-old">194</span><span class="deltaxml-new">181</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CompDocConstructor">CompDocConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"document" <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e19868.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e17895.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p>All document node constructors are computed constructors. The result of a document node constructor is a new document node, with its own node identity.</p><p>A document node constructor is useful when the result of a query is to be a document in its own right. The following example illustrates a query that returns an XML document containing a root element named <code>author-list</code>:</p><div class="exampleInner"><pre><span class="deltaxml-old">document { &lt;author-list&gt; {doc("bib.xml")/bib/book/author} &lt;/author-list&gt; }</span></pre><pre><span class="deltaxml-new">document { &lt;author-list&gt; {fn:doc("bib.xml")/bib/book/author} &lt;/author-list&gt; }</span></pre></div><p><span style="display: none;" class="delete_version">The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a document node constructor is processed in exactly the same way as an enclosed expression in the content of a <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a>, as described in Step 1e of <a href="#id-content"><span class="delete_version"><b>4.13.1.3 Content</b></span><span class="modify_version"><b>4.13.1.3 Content</b></span></a>. The result of processing the content expression is a sequence of nodes called the <b>content sequence</b>. Processing of the document node constructor then proceeds as follows:</span><span style="display: none;" class="add_version">The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a document node constructor is processed in exactly the same way as an enclosed expression in the content of a <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a>, as described in Step 1e of <a href="#id-content"><span class="add_version"><b>4.12.1.3 Content</b></span><span class="modify_version"><b>4.12.1.3 Content</b></span></a>. The result of processing the content expression is a sequence of nodes called the <b>content sequence</b>. Processing of the document node constructor then proceeds as follows:</span><span class="modify_version">The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a document node constructor is processed in exactly the same way as an enclosed expression in the content of a <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a>, as described in Step 1e of <a href="#id-content"><span style="display: none;" class="delete_version"><b>4.13.1.3 Content</b></span><span style="display: none;" class="add_version"><b>4.12.1.3 Content</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1.3</span><span class="deltaxml-new">4.12.1.3</span> Content</b></span></a>. The result of processing the content expression is a sequence of nodes called the <b>content sequence</b>. Processing of the document node constructor then proceeds as follows:</span></p><ol class="enumar"><li><p>If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</p></li><li><p>Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</p></li><li><p> If the content sequence contains an attribute node, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p> If the content sequence contains a namespace node, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>The properties of the newly constructed document node are determined as follows:</p><ol class="enumla"><li><p><span style="display: none;" class="delete_version"><code>base-uri</code> is set to the <span><a class="termref" title="Executable Base URI" href="#dt-executable-base-uri">Executable Base URI</a></span>.</span><span style="display: none;" class="add_version"><code>base-uri</code> is set to the <a class="termref" title="Static Base URI" href="#dt-static-base-uri">Static Base URI</a>.</span><span class="modify_version"><code>base-uri</code> is set to the <a class="termref" title="Static Base URI" href="#dt-static-base-uri"><span class="deltaxml-old">Executable</span><span class="deltaxml-new">Static</span> Base URI</a>.</span></p></li><li><p><code>children</code> consist of all the element, text, comment, and processing instruction nodes in the content sequence. Note that the <code>parent</code> property of each of these nodes has been set to the newly constructed document node.</p></li><li><p>The <code>unparsed-entities</code> and <code>document-uri</code> properties are empty.</p></li><li><p>The <code>string-value</code> property is equal to the concatenated contents of the text-node descendants in document order.</p></li><li><p>The <code>typed-value</code> property is equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p></li></ol></li></ol><p>No validation is performed on the constructed document node. The <a href="#XML">[XML 1.0]</a> rules that govern the structure of an XML document (for example, the document node must have exactly one child that is an element node) are not enforced by the XQuery document node constructor.</p></div><div class="div4"><h5><a id="id-textConstructors"></a><span class="deltaxml-old">4.13.3.4</span><span class="deltaxml-new">4.12.3.4</span> Text Node Constructors</h5><a id="d3e22200"></a><a id="d3e20086"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompTextConstructor"></a>[<span class="deltaxml-old">202</span><span class="deltaxml-new">189</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CompTextConstructor">CompTextConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"text" <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e19959.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e17984.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p>All text node constructors are computed constructors. The result of a text node constructor is a new text node, with its own node identity.</p><p>The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a text node constructor is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a>, converting it to a sequence of atomic values.</p></li><li><p>If the result of atomization is an empty sequence, no text node is constructed. Otherwise, each atomic value in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the <code>content</code> property of the constructed text node.</p></li></ol><p>The <code>parent</code> property of the constructed text node is set to empty.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is possible for a text node constructor to construct a text node containing a zero-length string. However, if used in the content of a constructed element or document node, such a text node will be deleted or merged with another text node.</p></div><p>The following example illustrates a text node constructor:</p><div class="exampleInner"><pre>text {"Hello"}</pre></div></div><div class="div4"><h5><a id="id-computed-pis"></a><span class="deltaxml-old">4.13.3.5</span><span class="deltaxml-new">4.12.3.5</span> Computed Processing Instruction Constructors</h5><a id="d3e22250"></a><a id="d3e20136"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompPIConstructor"></a>[<span class="deltaxml-old">204</span><span class="deltaxml-new">191</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CompPIConstructor">CompPIConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"processing-instruction" (<a href="#prod-xquery40-NCName">NCName</a> | ("{" <a href="#doc-xquery40-Expr">Expr</a> "}")) <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e19997.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e18022.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p>A computed processing instruction constructor (<a href="#doc-xquery40-CompPIConstructor">CompPIConstructor</a>) constructs a new processing instruction node with its own node identity. </p><p>If the keyword <code>processing-instruction</code> is followed by an NCName, that NCName is used as the <code>target</code> property of the constructed node. If the keyword <code>processing-instruction</code> is followed by a <a title="name expression" class="termref" href="#dt-name-expression">name expression</a>, the name expression is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a>. If the result of <a title="atomization" class="termref" href="#dt-atomization">atomization</a> is not a single atomic value of type <code>xs:NCName</code>, <code>xs:string</code>, or <code>xs:untypedAtomic</code>, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If the atomized value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a> is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, that value is cast to the type <code>xs:NCName</code>. If the value cannot be cast to <code>xs:NCName</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0041" title="err:XQDY0041">err:XQDY0041</a>].</p></li><li><p><span style="display: none;" class="delete_version">The resulting NCName is then used as the <code>target</code> property of the newly constructed processing instruction node. However, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised if the NCName is equal to <code>"XML"</code> (in any combination of upper and lower case) [<a href="#ERRXQDY0064" title="err:XQDY0064">err:XQDY0064</a>].</span><span style="display: none;" class="add_version">The resulting NCName is then used as the <code>target</code> property of the newly constructed processing instruction node. However, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised if the NCName is equal to "<code>XML</code>" (in any combination of upper and lower case) [<a href="#ERRXQDY0064" title="err:XQDY0064">err:XQDY0064</a>].</span><span class="modify_version">The resulting NCName is then used as the <code>target</code> property of the newly constructed processing instruction node. However, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised if the NCName is equal to "<code>XML<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span> (in any combination of upper and lower case) [<a href="#ERRXQDY0064" title="err:XQDY0064">err:XQDY0064</a>].</span></p></li></ol><p>The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed processing instruction constructor is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a>, converting it to a sequence of atomic values. (If the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> is absent, the result of this step is an empty sequence.)</p></li><li><p><span style="display: none;" class="delete_version">If the result of atomization is an empty sequence, it is replaced by a zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string. If any of the resulting strings contains the string <code>"?&gt;"</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0026" title="err:XQDY0026">err:XQDY0026</a>] is raised.</span><span style="display: none;" class="add_version">If the result of atomization is an empty sequence, it is replaced by a zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string. If any of the resulting strings contains the string "<code>?&gt;</code>", a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0026" title="err:XQDY0026">err:XQDY0026</a>] is raised.</span><span class="modify_version">If the result of atomization is an empty sequence, it is replaced by a zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string. If any of the resulting strings contains the string "<code>?&gt;<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0026" title="err:XQDY0026">err:XQDY0026</a>] is raised.</span></p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. Leading whitespace is removed from the resulting string. The resulting string then becomes the <code>content</code> property of the constructed processing instruction node.</p></li></ol><p>The remaining properties of the new processing instruction node are determined as follows:</p><ol class="enumar"><li><p>The <code>parent</code> property is empty.</p></li><li><p>The <code>base-uri</code> property is empty.</p></li></ol><p>The following example illustrates a computed processing instruction constructor:</p><div class="exampleInner"><pre>let $target := "audio-output", $content := "beep" return processing-instruction {$target} {$content}</pre></div><p>The processing instruction node constructed by this example might be serialized as follows:</p><div class="exampleInner"><pre>&lt;?audio-output beep?&gt;</pre></div></div><div class="div4"><h5><a id="id-computed-comments"></a><span class="deltaxml-old">4.13.3.6</span><span class="deltaxml-new">4.12.3.6</span> Computed Comment Constructors</h5><a id="d3e22400"></a><a id="d3e20286"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompCommentConstructor"></a>[<span class="deltaxml-old">203</span><span class="deltaxml-new">190</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CompCommentConstructor">CompCommentConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"comment" <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e20129.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e18154.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p>A computed comment constructor (<a href="#doc-xquery40-CompCommentConstructor">CompCommentConstructor</a>) constructs a new comment node with its own node identity. The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed comment constructor is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a>, converting it to a sequence of atomic values.</p></li><li><p>If the result of atomization is an empty sequence, it is replaced by a zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the <code>content</code> property of the constructed comment node.</p></li><li><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0072" title="err:XQDY0072">err:XQDY0072</a>] if the result of the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed comment constructor contains two adjacent hyphens or ends with a hyphen.</p></li></ol><p>The <code>parent</code> property of the constructed comment node is set to empty.</p><p>The following example illustrates a computed comment constructor:</p><div class="exampleInner"><pre><span class="deltaxml-old">let $homebase := "Houston" return comment {concat($homebase, ", we have a problem.")}</span></pre><pre><span class="deltaxml-new">let $homebase := "Houston" return comment {fn:concat($homebase, ", we have a problem.")}</span></pre></div><p>The comment node constructed by this example might be serialized as follows:</p><div class="exampleInner"><pre>&lt;!--Houston, we have a problem.--&gt;</pre></div></div><div class="div4"><h5><a id="id-computed-namespaces"></a><span class="deltaxml-old">4.13.3.7</span><span class="deltaxml-new">4.12.3.7</span> Computed Namespace Constructors</h5><a id="d3e22464"></a><a id="d3e20350"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompNamespaceConstructor"></a>[<span class="deltaxml-old">198</span><span class="deltaxml-new">185</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CompNamespaceConstructor">CompNamespaceConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"namespace" (<a href="#doc-xquery40-Prefix">Prefix</a> | <a href="#doc-xquery40-EnclosedPrefixExpr">EnclosedPrefixExpr</a>) <a href="#doc-xquery40-EnclosedURIExpr">EnclosedURIExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Prefix"></a>[<span class="deltaxml-old">199</span><span class="deltaxml-new">186</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Prefix">Prefix</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NCName">NCName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-EnclosedPrefixExpr"></a>[<span class="deltaxml-old">200</span><span class="deltaxml-new">187</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EnclosedPrefixExpr">EnclosedPrefixExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-EnclosedURIExpr"></a>[<span class="deltaxml-old">201</span><span class="deltaxml-new">188</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EnclosedURIExpr">EnclosedURIExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e20184.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e18209.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p>A computed namespace constructor creates a new namespace node, with its own node identity. The parent of the newly created namespace node is empty.</p><p>If the constructor specifies a <code>Prefix</code>, it is used as the prefix for the namespace node.</p><p>If the constructor specifies a <code>PrefixExpr</code>, the prefix expression is evaluated as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the result of the <code>PrefixExpr</code>.</p></li><li><p> If the result of <a title="atomization" class="termref" href="#dt-atomization">atomization</a> is an empty sequence or a single atomic value of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, then the following rules are applied in order:</p><ol class="enumla"><li><p>If the result is castable to <code>xs:NCName</code>, then it is used as the local name of the newly constructed namespace node. (The local name of a namespace node represents the prefix part of the namespace binding.)</p></li><li><p>If the result is the empty sequence or a zero-length <code>xs:string</code> or <code>xs:untypedAtomic</code> value, the new namespace node has no name (such a namespace node represents a binding for the default namespace).</p></li><li><p>Otherwise, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0074" title="err:XQDY0074">err:XQDY0074</a>].</p></li></ol></li><li><p>If the result of atomization is not an empty sequence or a single atomic value of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li></ol><p>The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> is evaluated, and the result is cast to <code>xs:anyURI</code> to create the <code>URI</code> property for the newly created node. An implementation may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0074" title="err:XQDY0074">err:XQDY0074</a>] if the <code>URIExpr</code> of a computed namespace constructor is not a valid instance of <code>xs:anyURI</code>.</p><p>An error [<a href="#ERRXQDY0101" title="err:XQDY0101">err:XQDY0101</a>] is raised if a computed namespace constructor attempts to do any of the following:</p><ul><li><p>Bind the prefix <code>xml</code> to some namespace URI other than <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Bind a prefix other than <code>xml</code> to the namespace URI <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Bind the prefix <code>xmlns</code> to any namespace URI. </p></li><li><p>Bind a prefix to the namespace URI <code>http://www.w3.org/2000/xmlns/</code>. </p></li><li><p>Bind any prefix (including the empty prefix) to a zero-length namespace URI.</p></li></ul><p>By itself, a computed namespace constructor has no effect on in-scope namespaces, but if an element <span class="deltaxml-old">constructor’s</span><span class="deltaxml-new">constructor's</span> content sequence contains a namespace node, the namespace binding it represents is added to the <span class="deltaxml-old">element’s</span><span class="deltaxml-new">element's</span> <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a>.</p><p>A computed namespace constructor has no effect on the statically known namespaces.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The newly created namespace node has all properties defined for a namespace node in the data model. As defined in the data model, the name of the node is the prefix, the string value of the node is the URI, the relative order of nodes that share no common ancestor is implementation dependent, and the relative order of namespace nodes that share a parent is also implementation dependent.</p></div><p>Examples:</p><ul><li><p>A computed namespace constructor with a prefix:</p><div class="exampleInner"><pre>namespace a {"http://a.example.com" }</pre></div></li><li><p>A computed namespace constructor with a prefix expression:</p><div class="exampleInner"><pre>namespace {"a"} {"http://a.example.com" }</pre></div></li><li><p>A computed namespace constructor with an empty prefix:</p><div class="exampleInner"><pre>namespace { "" } {"http://a.example.com" }</pre></div></li></ul><p>Computed namespace constructors are generally used to add to the in-scope namespaces of elements created with element constructors:</p><div class="exampleInner"><pre><span class="deltaxml-old">&lt;age xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; { namespace xs {"http://www.w3.org/2001/XMLSchema"}, attribute xsi:type {"xs:integer"}, 23 }&lt;/age&gt;</span></pre><pre><span class="deltaxml-new">&lt;age xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; { namespace xs {"http://www.w3.org/2001/XMLSchema"}, attribute xsi:type {"xs:integer"}, 23 }&lt;/age&gt; </span></pre></div><p><span style="display: none;" class="delete_version">In the above example, note that the <code>xsi</code> namespace binding is created for the element because it is used in an attribute name. The attribute’s content is simply character data, and has no effect on namespace bindings. The computed namespace constructor ensures that the <code>xs</code> binding is created.</span><span style="display: none;" class="add_version">In the above example, note that the <code>xsi</code> namespace binding is created for the element because it is used in an attribute name. The attribute's content is simply character data, and has no effect on namespace bindings. The computed namespace constructor ensures that the <code>xs</code> binding is created.</span><span class="modify_version">In the above example, note that the <code>xsi</code> namespace binding is created for the element because it is used in an attribute name. The <span class="deltaxml-old">attribute’s</span><span class="deltaxml-new">attribute's</span> content is simply character data, and has no effect on namespace bindings. The computed namespace constructor ensures that the <code>xs</code> binding is created.</span></p><p>Computed namespace constructors have no effect on the statically known namespaces. If the prefix a is not already defined in the statically known namespaces, the following expression results in a static error [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>].</p><div class="exampleInner"><pre><span class="deltaxml-old">&lt;a:form&gt; { namespace a { "http://a.example.com" } } &lt;/a:form&gt;</span></pre><pre><span class="deltaxml-new">&lt;a:form&gt; { namespace a { "http://a.example.com" } } &lt;/a:form&gt; </span></pre></div></div></div><div class="div3"><h4><a id="id-ns-nodes-on-elements"></a><span class="deltaxml-old">4.13.4</span><span class="deltaxml-new">4.12.4</span> In-scope Namespaces of a Constructed Element</h4><p>An element node constructed by a direct or computed element constructor has an <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> property that consists of a set of <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">namespace bindings</a>. The in-scope namespaces of an element node may affect the way the node is serialized (see <a href="#id-serialization"><b>2.3.4 Serialization</b></a>), and may also affect the behavior of certain functions that operate on nodes, such as <code>fn:name</code>. Note the difference between <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a>, which is a dynamic property of an element node, and <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>, which is a static property of an expression. Also note that one of the namespace bindings in the in-scope namespaces may have no prefix (denoting the default namespace for the given element). The in-scope namespaces of a constructed element node consist of the following namespace bindings:</p><ul><li><p>A namespace binding is created for each namespace declared in the current element constructor by a <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attribute</a>.</p></li><li><p>A namespace binding is created for each namespace node in the content sequence of the current element constructor.</p></li><li><p>A namespace binding is created for each namespace that is declared in a <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attribute</a> of an enclosing <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a> and not overridden by the current element constructor or an intermediate constructor.</p></li><li><p>A namespace binding is always created to bind the prefix <code>xml</code> to the namespace URI <code>http://www.w3.org/XML/1998/namespace</code>.</p></li><li><p>For each prefix used in the name of the constructed element or in the names of its attributes, a namespace binding must exist. If a namespace binding does not already exist for one of these prefixes, a new namespace binding is created for it. If this would result in a conflict, because it would require two different bindings of the same prefix, then the prefix used in the node name is changed to an arbitrary <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> prefix that does not cause such a conflict, and a namespace binding is created for this new prefix. If there is an in-scope default namespace, then a binding is created between the empty prefix and that URI.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p><a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode">Copy-namespaces mode</a> does not affect the namespace bindings of a newly constructed element node. It applies only to existing nodes that are copied by a constructor expression.</p></div><p>In an element constructor, if two or more namespace bindings in the in-scope bindings would have the same prefix, then an error is raised if they have different URIs [<a href="#ERRXQDY0102" title="err:XQDY0102">err:XQDY0102</a>]; if they would have the same prefix and URI, duplicate bindings are ignored. If the name of an element in an element constructor is in no namespace, creating a default namespace for that element using a computed namespace constructor is an error [<a href="#ERRXQDY0102" title="err:XQDY0102">err:XQDY0102</a>]. For instance, the following computed constructor raises an error because the <span class="deltaxml-old">element’s</span><span class="deltaxml-new">element's</span> name is not in a namespace, but a default namespace is defined.</p><div class="exampleInner"><pre>element e { namespace {''} {'u'} }</pre></div><p>The following query illustrates the in-scope namespaces of a constructed element:</p><div class="exampleInner"><pre><span class="deltaxml-old">declare namespace p="http://example.com/ns/p"; declare namespace q="http://example.com/ns/q"; declare namespace f="http://example.com/ns/f"; &lt;p:a q:b="{f:func(2)}" xmlns:r="http://example.com/ns/r"/&gt;</span></pre><pre><span class="deltaxml-new">declare namespace p="http://example.com/ns/p"; declare namespace q="http://example.com/ns/q"; declare namespace f="http://example.com/ns/f"; &lt;p:a q:b="{f:func(2)}" xmlns:r="http://example.com/ns/r"/&gt; </span></pre></div><p>The <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> of the resulting <code>p:a</code> element consists of the following namespace bindings:</p><ul><li><p><code>p = "http://example.com/ns/p"</code></p></li><li><p><code>q = "http://example.com/ns/q"</code></p></li><li><p><code>r = "http://example.com/ns/r"</code></p></li><li><p><code>xml = "http://www.w3.org/XML/1998/namespace"</code></p></li></ul><p>The namespace bindings for <code>p</code> and <code>q</code> are added to the result element because their respective namespaces are used in the names of the element and its attributes. The namespace binding <code>r="http://example.com/ns/r"</code> is added to the in-scope namespaces of the constructed element because it is defined by a <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attribute</a>, even though it is not used in a name.</p><p>No namespace binding corresponding to <code>f="http://example.com/ns/f"</code> is created, because the namespace prefix <code>f</code> appears only in the query prolog and is not used in an element or attribute name of the constructed node. This namespace binding does not appear in the query result, even though it is present in the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> and is available for use during processing of the query.</p><p>Note that the following constructed element, if nested within a <code>validate</code> expression, cannot be validated: </p><div class="exampleInner"><pre>&lt;p xsi:type="xs:integer"&gt;3&lt;/p&gt;</pre></div><p>The constructed element will have namespace bindings for the prefixes <code>xsi</code> (because it is used in a name) and <code>xml</code> (because it is defined for every constructed element node). During validation of the constructed element, the validator will be unable to interpret the namespace prefix <code>xs</code> because it is has no namespace binding. Validation of this constructed element could be made possible by providing a <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attribute</a>, as in the following example:</p><div class="exampleInner"><pre>&lt;p xmlns:xs="http://www.w3.org/2001/XMLSchema" xsi:type="xs:integer"&gt;3&lt;/p&gt;</pre></div></div></div><div class="div2"><h3><a id="id-maps-and-arrays"></a><span class="deltaxml-old">4.14</span><span class="deltaxml-new">4.13</span> Maps and Arrays</h3><p>Most modern programming languages have support for collections of key/value pairs, which may be called maps, dictionaries, associative arrays, hash tables, keyed lists, or objects (these are not the same thing as objects in object-oriented systems). In XQuery 4.0, we call these maps. Most modern programming languages also support ordered lists of values, which may be called arrays, vectors, or sequences. In XQuery 4.0, we have both sequences and arrays. Unlike sequences, an array is an item, and can appear as an item in a sequence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The XQuery 4.0 specification focuses on syntax provided for maps and arrays, especially constructors and lookup.</p><p><span style="display: none;" class="delete_version">Some of the functionality typically needed for maps and arrays is provided by functions defined in <span class="markup-error">[TITLE OF FO40 SPEC, TITLE OF maps-and-arrays SECTION]<sup><small>FO40</small></sup></span>, including functions used to read JSON to create maps and arrays, serialize maps and arrays to JSON, combine maps to create a new map, remove map entries to create a new map, iterate over the keys of a map, convert an array to create a sequence, combine arrays to form a new array, and iterate over arrays in various ways.</span><span style="display: none;" class="add_version">Some of the functionality typically needed for maps and arrays is provided by functions defined in <a href="https://www.w3.org/TR/xpath-functions-31/#maps-and-arrays">Section 17 Maps and Arrays </a><sup><small>FO31</small></sup>, including functions used to read JSON to create maps and arrays, serialize maps and arrays to JSON, combine maps to create a new map, remove map entries to create a new map, iterate over the keys of a map, convert an array to create a sequence, combine arrays to form a new array, and iterate over arrays in various ways.</span><span class="modify_version">Some of the functionality typically needed for maps and arrays is provided by functions defined in <span class="deltaxml-old">[TITLE OF FO40 SPEC, TITLE OF maps-and-arrays SECTION]</span><a href="https://www.w3.org/TR/xpath-functions-31/#maps-and-arrays"><span class="deltaxml-new">Section 17 Maps and Arrays </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>, including functions used to read JSON to create maps and arrays, serialize maps and arrays to JSON, combine maps to create a new map, remove map entries to create a new map, iterate over the keys of a map, convert an array to create a sequence, combine arrays to form a new array, and iterate over arrays in various ways.</span></p></div><div class="div3"><h4><a id="id-maps"></a><span class="deltaxml-old">4.14.1</span><span class="deltaxml-new">4.13.1</span> Maps</h4><p> [<a id="dt-map" title="map">Definition</a>: A <b>map</b> is a function that associates a set of keys with values, resulting in a collection of key / value pairs.] [<a id="dt-entry" title="entry">Definition</a>: Each key / value pair in a map is called an <b>entry</b>.] [<a id="dt-associated-value" title="associated value">Definition</a>: The value associated with a given key is called the <b>associated value</b> of the key.] </p><div class="div4"><h5><a id="id-map-constructors"></a><span class="deltaxml-old">4.14.1.1</span><span class="deltaxml-new">4.13.1.1</span> Map Constructors</h5><p>A Map is created using a <a href="#doc-xquery40-MapConstructor">MapConstructor</a>.</p><a id="d3e22827"></a><a id="d3e20713"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-MapConstructor"></a>[<span class="deltaxml-old">208</span><span class="deltaxml-new">195</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-MapConstructor">MapConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"map" "{" (<a href="#doc-xquery40-MapConstructorEntry">MapConstructorEntry</a> ("," <a href="#doc-xquery40-MapConstructorEntry">MapConstructorEntry</a>)*)? "}"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-MapConstructorEntry"></a>[<span class="deltaxml-old">209</span><span class="deltaxml-new">196</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-MapConstructorEntry">MapConstructorEntry</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-MapKeyExpr">MapKeyExpr</a> ":" <a href="#doc-xquery40-MapValueExpr">MapValueExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-MapKeyExpr"></a>[<span class="deltaxml-old">210</span><span class="deltaxml-new">197</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-MapKeyExpr">MapKeyExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-MapValueExpr"></a>[<span class="deltaxml-old">211</span><span class="deltaxml-new">198</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-MapValueExpr">MapValueExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p> In some circumstances, it is necessary to include whitespace before or after the colon of a <a href="#doc-xquery40-MapConstructorEntry">MapConstructorEntry</a> to ensure that it is parsed as intended. </p><p> For instance, consider the expression <code>map{a:b}</code>. Although it matches the EBNF for MapConstructor (with <code>a</code> matching MapKeyExpr and <code>b</code> matching MapValueExpr), the "longest possible match" rule requires that <code>a:b</code> be parsed as a QName, which results in a syntax error. Changing the expression to <code>map{a :b}</code> or <code>map{a: b}</code> will prevent this, resulting in the intended parse. </p><p>Similarly, consider these three expressions:</p><div class="exampleInner"><pre> map{a:b:c} map{a:*:c} map{*:b:c}</pre></div><p><span style="display: none;" class="delete_version"> In each case, the expression matches the EBNF in two different ways, but the “longest possible match” rule forces the parse in which the MapKeyExpr is <code>a:b</code>, <code>a:*</code>, or <code>*:b</code> (respectively) and the MapValueExpr is <code>c</code>. To achieve the alternative parse (in which the MapKeyExpr is merely <code>a</code> or <code>*</code>), insert whitespace before and/or after the first colon. </span><span style="display: none;" class="add_version"> In each case, the expression matches the EBNF in two different ways, but the "longest possible match" rule forces the parse in which the MapKeyExpr is <code>a:b</code>, <code>a:*</code>, or <code>*:b</code> (respectively) and the MapValueExpr is <code>c</code>. To achieve the alternative parse (in which the MapKeyExpr is merely <code>a</code> or <code>*</code>), insert whitespace before and/or after the first colon. </span><span class="modify_version"> In each case, the expression matches the EBNF in two different ways, but the <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>longest possible match<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> rule forces the parse in which the MapKeyExpr is <code>a:b</code>, <code>a:*</code>, or <code>*:b</code> (respectively) and the MapValueExpr is <code>c</code>. To achieve the alternative parse (in which the MapKeyExpr is merely <code>a</code> or <code>*</code>), insert whitespace before and/or after the first colon. </span></p><p>See <a href="#lexical-structure"><span style="display: none;" class="delete_version"><b>A.3 Lexical structure</b></span><span style="display: none;" class="add_version"><b>A.2 Lexical structure</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">3</span><span class="deltaxml-new">2</span> Lexical structure</b></span></a>.</p></div><p>The value of the expression is a map whose entries correspond to the key-value pairs obtained by evaluating the successive <a href="#doc-xquery40-MapKeyExpr">MapKeyExpr</a> and <a href="#doc-xquery40-MapValueExpr">MapValueExpr</a> expressions.</p><p><span style="display: none;" class="delete_version">Each <a href="#doc-xquery40-MapKeyExpr">MapKeyExpr</a> expression is evaluated and atomized; a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] occurs if the result is not a single atomic value. The associated value is the result of evaluating the corresponding <a href="#doc-xquery40-MapValueExpr">MapValueExpr</a>. If the <a href="#doc-xquery40-MapValueExpr">MapValueExpr</a> evaluates to a node, the associated value is the node itself, not a new node with the same values. [<a id="dt-same-key" title="same key">Definition</a>: Two atomic values <code>K1</code> and <code>K2</code> have the <b>same key value</b> if <code>fn:atomic-equal(K1, K2)</code> returns <code>true</code>, as specified in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-atomic-equal">Section 14.2.1 fn:atomic-equal</a><sup><small>FO40</small></sup> ] If two or more entries have the <a title="same key" class="termref" href="#dt-same-key">same key value</a> then a dynamic error is raised [<a href="#ERRXQDY0137" title="err:XQDY0137">err:XQDY0137</a>]. </span><span style="display: none;" class="add_version">Each <a href="#doc-xquery40-MapKeyExpr">MapKeyExpr</a> expression is evaluated and atomized; a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] occurs if the result is not a single atomic value. The associated value is the result of evaluating the corresponding <a href="#doc-xquery40-MapValueExpr">MapValueExpr</a>. If the <a href="#doc-xquery40-MapValueExpr">MapValueExpr</a> evaluates to a node, the associated value is the node itself, not a new node with the same values. [<a id="dt-same-key" title="same key">Definition</a>: Two atomic values <code>K1</code> and <code>K2</code> have the <b>same key value</b> if <code>fn:atomic-equal(K1, K2)</code> returns <code>true</code>, as specified in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-atomic-equal">Section 18.1.1 fn:atomic-equal</a><sup><small>FO40</small></sup> ] If two or more entries have the <a title="same key" class="termref" href="#dt-same-key">same key value</a> then a dynamic error is raised [<a href="#ERRXQDY0137" title="err:XQDY0137">err:XQDY0137</a>]. </span><span class="modify_version">Each <a href="#doc-xquery40-MapKeyExpr">MapKeyExpr</a> expression is evaluated and atomized; a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] occurs if the result is not a single atomic value. The associated value is the result of evaluating the corresponding <a href="#doc-xquery40-MapValueExpr">MapValueExpr</a>. If the <a href="#doc-xquery40-MapValueExpr">MapValueExpr</a> evaluates to a node, the associated value is the node itself, not a new node with the same values. [<a id="dt-same-key" title="same key">Definition</a>: Two atomic values <code>K1</code> and <code>K2</code> have the <b>same key value</b> if <code>fn:atomic-equal(K1, K2)</code> returns <code>true</code>, as specified in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-atomic-equal">Section <span class="deltaxml-old">14.2.1</span><span class="deltaxml-new">18.1.1</span> fn:atomic-equal</a><sup><small>FO40</small></sup> ] If two or more entries have the <a title="same key" class="termref" href="#dt-same-key">same key value</a> then a dynamic error is raised [<a href="#ERRXQDY0137" title="err:XQDY0137">err:XQDY0137</a>]. </span></p><p>Example:</p><p>The following expression constructs a map with seven entries:</p><div class="exampleInner"><a id="map-weekdays"></a><pre>map { "Su" : "Sunday", "Mo" : "Monday", "Tu" : "Tuesday", "We" : "Wednesday", "Th" : "Thursday", "Fr" : "Friday", "Sa" : "Saturday" }</pre></div><p>Maps can nest, and can contain any XDM value. Here is an example of a nested map with values that can be string values, numeric values, or arrays:</p><div class="exampleInner"><a id="map-book"></a><pre><span class="deltaxml-old">map { "book": map { "title": "Data on the Web", "year": 2000, "author": [ map { "last": "Abiteboul", "first": "Serge" }, map { "last": "Buneman", "first": "Peter" }, map { "last": "Suciu", "first": "Dan" } ], "publisher": "Morgan Kaufmann Publishers", "price": 39.95 } }</span></pre><pre><span class="deltaxml-new">map { "book": map { "title": "Data on the Web", "year": 2000, "author": [ map { "last": "Abiteboul", "first": "Serge" }, map { "last": "Buneman", "first": "Peter" }, map { "last": "Suciu", "first": "Dan" } ], "publisher": "Morgan Kaufmann Publishers", "price": 39.95 } } </span></pre></div></div><div class="div4"><h5><a id="id-map-lookup"></a><span class="deltaxml-old">4.14.1.2</span><span class="deltaxml-new">4.13.1.2</span> Map Lookup using Function Call Syntax</h5><p><span style="display: none;" class="delete_version">Maps are <a title="function item" class="termref" href="#dt-function-item">function items</a>, and a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a> can be used to look up the value associated with a key in a map. If <code>$map</code> is a map and <code>$key</code> is a key, then <code>$map($key)</code> is equivalent to <code>map:get($map, $key)</code>. The semantics of such a function call are formally defined in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-map-get">Section 18.2.9 map:get</a><sup><small>FO40</small></sup>. </span><span style="display: none;" class="add_version">Maps are <a title="function item" class="termref" href="#dt-function-item">function items</a>, and a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a> can be used to look up the value associated with a key in a map. If <code>$map</code> is a map and <code>$key</code> is a key, then <code>$map($key)</code> is equivalent to <code>map:get($map, $key)</code>. The semantics of such a function call are formally defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-map-get">Section 17.1.6 map:get </a><sup><small>FO31</small></sup>. </span><span class="modify_version">Maps are <a title="function item" class="termref" href="#dt-function-item">function items</a>, and a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a> can be used to look up the value associated with a key in a map. If <code>$map</code> is a map and <code>$key</code> is a key, then <code>$map($key)</code> is equivalent to <code>map:get($map, $key)</code>. The semantics of such a function call are formally defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-map-get">Section <span class="deltaxml-old">18.2.9</span><span class="deltaxml-new">17.1.6</span> map:get<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>. </span></p><p>Examples:</p><ul><li><p><code>$weekdays("Su")</code> returns the <a title="associated value" class="termref" href="#dt-associated-value">associated value</a> of the key <code>Su</code>.</p></li><li><p><code>$books("Green Eggs and Ham")</code> returns <a title="associated value" class="termref" href="#dt-associated-value">associated value</a> of the key <code>Green Eggs and Ham</code>.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>XQuery 4.0 also provides an alternate syntax for map and array lookup that is more terse, supports wildcards, and allows lookup to iterate over a sequence of maps or arrays. See <a href="#id-lookup"><span style="display: none;" class="delete_version"><b>4.14.3 The Lookup Operators ("?" and "??") for Maps and Arrays</b></span><span style="display: none;" class="add_version"><b>4.13.3 The Lookup Operator ("?") for Maps and Arrays</b></span><span class="modify_version"><b><span class="deltaxml-old">4.14.3</span><span class="deltaxml-new">4.13.3</span> The Lookup <span class="deltaxml-old">Operators</span><span class="deltaxml-new">Operator</span> ("?"<span class="deltaxml-old"> and "??"</span>) for Maps and Arrays</b></span></a> for details.</p></div><p>Map lookups can be chained.</p><p>Examples: (These examples assume that <code>$b</code> is bound to the books map from the previous section)</p><ul><li><p>The expression <code>$b("book")("title")</code> returns the string <code>Data on the Web</code>.</p></li><li><p>The expression <code>$b("book")("author")</code> returns the array of authors.</p></li><li><p>The expression <code>$b("book")("author")(1)("last")</code> returns the string <code>Abiteboul</code>.</p><p>(This example combines <a href="#id-array-lookup"><span style="display: none;" class="delete_version"><b>4.14.2.2 Array Lookup using Function Call Syntax</b></span><span style="display: none;" class="add_version"><b>4.13.2.2 Array Lookup using Function Call Syntax</b></span><span class="modify_version"><b><span class="deltaxml-old">4.14.2.2</span><span class="deltaxml-new">4.13.2.2</span> Array Lookup using Function Call Syntax</b></span></a> with map lookups.)</p></li></ul></div></div><div class="div3"><h4><a id="id-arrays"></a><span class="deltaxml-old">4.14.2</span><span class="deltaxml-new">4.13.2</span> Arrays</h4><div class="div4"><h5><a id="id-array-constructors"></a><span class="deltaxml-old">4.14.2.1</span><span class="deltaxml-new">4.13.2.1</span> Array Constructors</h5><p> [<a id="dt-array" title="array">Definition</a>: An <b>array</b> is a <a title="function item" class="termref" href="#dt-function-item">function item</a> that associates a set of positions, represented as positive integer keys, with values.] The first position in an array is associated with the integer 1. [<a id="dt-member" title="member">Definition</a>: The values of an array are called its <b>members</b>.] In the type hierarchy, array has a distinct type, which is derived from function. Atomization converts arrays to sequences (see <a title="atomization" class="termref" href="#dt-atomization">Atomization</a>). </p><p>An array is created using an <a href="#doc-xquery40-ArrayConstructor">ArrayConstructor</a>.</p><a id="d3e23070"></a><a id="d3e20956"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ArrayConstructor"></a>[<span class="deltaxml-old">212</span><span class="deltaxml-new">199</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ArrayConstructor">ArrayConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SquareArrayConstructor">SquareArrayConstructor</a> | <a href="#doc-xquery40-CurlyArrayConstructor">CurlyArrayConstructor</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SquareArrayConstructor"></a>[<span class="deltaxml-old">213</span><span class="deltaxml-new">200</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SquareArrayConstructor">SquareArrayConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"[" (<a href="#doc-xquery40-ExprSingle">ExprSingle</a> ("," <a href="#doc-xquery40-ExprSingle">ExprSingle</a>)*)? "]"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CurlyArrayConstructor"></a>[<span class="deltaxml-old">214</span><span class="deltaxml-new">201</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CurlyArrayConstructor">CurlyArrayConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"array" <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody></table><p> If a member of an array is a node, its node identity is preserved. In both forms of an <a href="#doc-xquery40-ArrayConstructor">ArrayConstructor</a>, if a member expression evaluates to a node, the associated value is the node itself, not a new node with the same values. If the member expression evaluates to a map or array, the associated value is a new map or array with the same values. </p><p>A <a href="#doc-xquery40-SquareArrayConstructor">SquareArrayConstructor</a> consists of a comma-delimited set of argument expressions. It returns an array in which each member contains the value of the corresponding argument expression.</p><p>Examples:</p><ul><li><p><code>[ 1, 2, 5, 7 ]</code> creates an array with four members: <code>1</code>, <code>2</code>, <code>5</code>, and <code>7</code>.</p></li><li><p><code>[ (), (27, 17, 0)]</code> creates an array with two members: <code>()</code> and the sequence <code>(27, 17, 0)</code>.</p></li><li><p><code>[ $x, local:items(), &lt;tautology&gt;It is what it is.&lt;/tautology&gt; ]</code> creates an array with three members: the value of $x, the result of evaluating the function call, and a tautology element.</p></li></ul><p>A <a href="#doc-xquery40-CurlyArrayConstructor">CurlyArrayConstructor</a> can use any expression to create its members. It evaluates its operand expression to obtain a sequence of items and creates an array with these items as members. Unlike a SquareArrayConstructor, a comma in a CurlyArrayConstructor is the <a title="comma operator" class="termref" href="#dt-comma-operator">comma operator</a>, not a delimiter. </p><p>Examples:</p><ul><li><p><code>array { $x }</code> creates an array with one member for each item in the sequence to which $x is bound.</p></li><li><p><code>array { local:items() }</code> creates an array with one member for each item in the sequence to which <code>local:items()</code> evaluates.</p></li><li><p><code>array { 1, 2, 5, 7 }</code> creates an array with four members: <code>1</code>, <code>2</code>, <code>5</code>, and <code>7</code>.</p></li><li><p><code>array { (), (27, 17, 0) }</code> creates an array with three members: <code>27</code>, <code>17</code>, and <code>0</code>.</p></li><li><p><code>array{ $x, local:items(), &lt;tautology&gt;It is what it is.&lt;/tautology&gt; }</code> creates an array with the following members: the items to which <code>$x</code> is bound, followed by the items to which <code>local:items()</code> evaluates, followed by a tautology element.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">XQuery 4.0 does not provide explicit support for sparse arrays. Use integer-valued maps to represent sparse arrays, for example: <code>map { 27 : -1, 153 : 17 } </code>.</span><span style="display: none;" class="add_version">XQuery 4.0 does not provide explicit support for sparse arrays. Use integer-valued maps to represent sparse arrays, e.g. <code>map { 27 : -1, 153 : 17 } </code>.</span><span class="modify_version">XQuery 4.0 does not provide explicit support for sparse arrays. Use integer-valued maps to represent sparse arrays, <span class="deltaxml-old">for example:</span><span class="deltaxml-new">e.g.</span> <code>map { 27 : -1, 153 : 17 } </code>.</span></p></div></div><div class="div4"><h5><a id="id-array-lookup"></a><span class="deltaxml-old">4.14.2.2</span><span class="deltaxml-new">4.13.2.2</span> Array Lookup using Function Call Syntax</h5><p><span style="display: none;" class="delete_version">Arrays are <a title="function item" class="termref" href="#dt-function-item">function items</a>, and a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a> can be used to look up the value associated with position in an array. If <code>$array</code> is an array and <code>$index</code> is an integer corresponding to a position in the array, then <code>$array($key)</code> is equivalent to <code>array:get($array, $key)</code>. The semantics of such a function call are formally defined in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-array-get">Section 19.1.11 array:get</a><sup><small>FO40</small></sup>. </span><span style="display: none;" class="add_version">Arrays are <a title="function item" class="termref" href="#dt-function-item">function items</a>, and a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a> can be used to look up the value associated with position in an array. If <code>$array</code> is an array and <code>$index</code> is an integer corresponding to a position in the array, then <code>$array($key)</code> is equivalent to <code>array:get($array, $key)</code>. The semantics of such a function call are formally defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-array-get">Section 17.3.2 array:get </a><sup><small>FO31</small></sup>. </span><span class="modify_version">Arrays are <a title="function item" class="termref" href="#dt-function-item">function items</a>, and a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a> can be used to look up the value associated with position in an array. If <code>$array</code> is an array and <code>$index</code> is an integer corresponding to a position in the array, then <code>$array($key)</code> is equivalent to <code>array:get($array, $key)</code>. The semantics of such a function call are formally defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-array-get">Section <span class="deltaxml-old">19.1.11</span><span class="deltaxml-new">17.3.2</span> array:get<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>. </span></p><p>Examples:</p><ul><li><p><code>[ 1, 2, 5, 7 ](4)</code> evaluates to <code>7</code>.</p></li><li><p><code>[ [1, 2, 3], [4, 5, 6]](2)</code> evaluates to <code>[4, 5, 6]</code>.</p></li><li><p><code>[ [1, 2, 3], [4, 5, 6]](2)(2)</code> evaluates to <code>5</code>.</p></li><li><p><code>[ 'a', 123, &lt;name&gt;Robert Johnson&lt;/name&gt; ](3)</code> evaluates to <code>&lt;name&gt;Robert Johnson&lt;/name&gt;</code>.</p></li><li><p><code>array { (), (27, 17, 0) }(1)</code> evaluates to <code>27</code>.</p></li><li><p><code>array { (), (27, 17, 0) }(2)</code> evaluates to <code>17</code>.</p></li><li><p><span style="display: none;" class="delete_version"><code>array { "licorice", "ginger" }(20)</code> raises a dynamic error [<a title="err:FOAY0001" href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOAY0001">err:FOAY0001</a>]<sup><small>FO40</small></sup>.</span><span style="display: none;" class="add_version"><code>array { "licorice", "ginger" }(20)</code> raises a dynamic error [<a title="err:FOAY0001" href="https://www.w3.org/TR/xpath-functions-31/#ERRFOAY0001">err:FOAY0001</a>]<sup><small>FO31</small></sup>.</span><span class="modify_version"><code>array { "licorice", "ginger" }(20)</code> raises a dynamic error [<a title="err:FOAY0001" href="https://www.w3.org/TR/xpath-functions-31/#ERRFOAY0001">err:FOAY0001</a>]<sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>.</span></p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>XQuery 4.0 also provides an alternate syntax for map and array lookup that is more terse, supports wildcards, and allows lookup to iterate over a sequence of maps or arrays. See <a href="#id-lookup"><span style="display: none;" class="delete_version"><b>4.14.3 The Lookup Operators ("?" and "??") for Maps and Arrays</b></span><span style="display: none;" class="add_version"><b>4.13.3 The Lookup Operator ("?") for Maps and Arrays</b></span><span class="modify_version"><b><span class="deltaxml-old">4.14.3</span><span class="deltaxml-new">4.13.3</span> The Lookup <span class="deltaxml-old">Operators</span><span class="deltaxml-new">Operator</span> ("?"<span class="deltaxml-old"> and "??"</span>) for Maps and Arrays</b></span></a> for details.</p></div></div></div><div class="div3"><h4><a id="id-lookup"></a><span class="deltaxml-old">4.14.3</span><span class="deltaxml-new">4.13.3</span> The Lookup <span class="deltaxml-old">Operators</span><span class="deltaxml-new">Operator</span> ("?"<span class="deltaxml-old"> and "??"</span>) for Maps and Arrays</h4><p><span class="deltaxml-old">XQuery 4.0 provides two lookup operators for maps and arrays. These provide a terse syntax for accessing the entries in a map or the members of an array.</span></p><p><span class="deltaxml-old">The operator "?", known as the shallow lookup operator, returns values found immediately in the operand map or array. The operator "??", known as the deep lookup operator, also searches nested maps and arrays. The effect of the deep lookup operator "??" is explained in </span><a href="#id-deep-lookup"><b><span class="deltaxml-old">4.14.3.3 Deep Lookup</span></b></a><span class="deltaxml-old">.</span></p><div class="div4"><h5><a id="id-postfix-lookup"></a><span class="deltaxml-old">4.14.3.1 Postfix Lookup Expressions</span></h5><a id="d3e23284"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LookupExpr"></a><span class="deltaxml-old">[160]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-LookupExpr"><span class="deltaxml-old">LookupExpr</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-PostfixExpr"><span class="deltaxml-old">PostfixExpr</span></a><a href="#doc-xquery40-Lookup"><span class="deltaxml-old">Lookup</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Lookup"></a><span class="deltaxml-old">[161]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-Lookup"><span class="deltaxml-old">Lookup</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">("?" | "??") </span><a href="#doc-xquery40-KeySpecifier"><span class="deltaxml-old">KeySpecifier</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e20912.doc-xquery40-KeySpecifier"></a><span class="deltaxml-old">[162]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">KeySpecifier</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-NCName"><span class="deltaxml-old">NCName</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-IntegerLiteral"><span class="deltaxml-old">IntegerLiteral</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-VarRef"><span class="deltaxml-old">VarRef</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-ParenthesizedExpr"><span class="deltaxml-old">ParenthesizedExpr</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-LookupWildcard"><span class="deltaxml-old">LookupWildcard</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e20913.doc-xquery40-LookupWildcard"></a><span class="deltaxml-old">[163]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">LookupWildcard</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"*" ("::" </span><a href="#doc-xquery40-SequenceType"><span class="deltaxml-old">SequenceType</span></a><span class="deltaxml-old">)?</span></code></td><td></td></tr></tbody></table><p><span class="deltaxml-old">The semantics of a postfix lookup expression </span><code><span class="deltaxml-old">E?KS</span></code><span class="deltaxml-old"> are defined as follows:</span></p><ol class="enumar"><li><p><var><span class="deltaxml-old">E</span></var><span class="deltaxml-old"> is evaluated to produce a value </span><code><span class="deltaxml-old">$V</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">If </span><code><span class="deltaxml-old">$V</span></code><span class="deltaxml-old"> is not a singleton (that is if </span><code><span class="deltaxml-old">count($V) ne 1</span></code><span class="deltaxml-old">), then the result (by recursive application of these rules) is the value of </span><code><span class="deltaxml-old">for $v in $V return $v?KS</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">If </span><code><span class="deltaxml-old">$V</span></code><span class="deltaxml-old"> is a singleton array (that is, if </span><code><span class="deltaxml-old">$V instance of array(*)</span></code><span class="deltaxml-old">) then:</span></p><ol class="enumla"><li><p><span class="deltaxml-old">If </span><code><span class="deltaxml-old">KS</span></code><span class="deltaxml-old"> is a </span><code><span class="deltaxml-old">ParenthesizedExpr</span></code><span class="deltaxml-old">, then it is evaluated to produce a value </span><code><span class="deltaxml-old">$K</span></code><span class="deltaxml-old"> and the result is:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">for $k in data($K) return array:get($V, $k)</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The focus for evaluating the key specifier expression is the same as the focus for the </span><code><span class="deltaxml-old">Lookup</span></code><span class="deltaxml-old"> expression itself.</span></p></div></li><li><p><span class="deltaxml-old">If the </span><a href="#doc-xquery40-KeySpecifier"><span class="deltaxml-old">KeySpecifier</span></a><span class="deltaxml-old"> is an </span><a href="#doc-xquery40-IntegerLiteral"><span class="deltaxml-old">IntegerLiteral</span></a><span class="deltaxml-old"> with value </span><code><span class="deltaxml-old">$i</span></code><span class="deltaxml-old">, the result is </span><code><span class="deltaxml-old">array:get($V, $i)</span></code></p></li><li><p><span class="deltaxml-old">If the </span><a href="#doc-xquery40-KeySpecifier"><span class="deltaxml-old">KeySpecifier</span></a><span class="deltaxml-old"> is an </span><code><span class="deltaxml-old">NCName</span></code><span><span class="deltaxml-old">or </span><code><span class="deltaxml-old">StringLiteral</span></code></span><span class="deltaxml-old">, the expression raises a type error [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-old">err:XPTY0004</span></a><span class="deltaxml-old">].</span></p></li><li><p><span class="deltaxml-old">If </span><code><span class="deltaxml-old">KS</span></code><span class="deltaxml-old"> is a wildcard (</span><code><span class="deltaxml-old">*</span></code><span class="deltaxml-old">) qualified by a SequenceType </span><var><span class="deltaxml-old">ST</span></var><span class="deltaxml-old">, the result is given by the following expression:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">for $k in 1 to array:size($V) let $m := array:get($V, $k) return if ($m instance of ST) {$m}</span></pre></div><p><span class="deltaxml-old">If no SequenceType is provided, it defaults to </span><code><span class="deltaxml-old">item()*</span></code><span class="deltaxml-old">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Note that array items are returned in order.</span></p></div></li></ol></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">$V</span></var><span class="deltaxml-old"> is a singleton map (that is, if </span><code><span class="deltaxml-old">$V instance of map(*)</span></code><span class="deltaxml-old">) then:</span></p><ol class="enumla"><li><p><span class="deltaxml-old">If </span><code><span class="deltaxml-old">KS</span></code><span class="deltaxml-old"> is a </span><code><span class="deltaxml-old">ParenthesizedExpr</span></code><span class="deltaxml-old">, then it is evaluated to produce a value </span><code><span class="deltaxml-old">$K</span></code><span class="deltaxml-old"> and the result is:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">for $k in data($K) return map:get($V, $k)</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The focus for evaluating the key specifier expression is the same as the focus for the </span><code><span class="deltaxml-old">Lookup</span></code><span class="deltaxml-old"> expression itself.</span></p></div></li><li><p><span class="deltaxml-old">If </span><code><span class="deltaxml-old">KS</span></code><span class="deltaxml-old"> is an </span><code><span class="deltaxml-old">NCName</span></code><span><span class="deltaxml-old">or a </span><code><span class="deltaxml-old">StringLiteral</span></code></span><span class="deltaxml-old">, the result is </span><code><span class="deltaxml-old">map:get($V, $k)</span></code><span class="deltaxml-old">, where </span><code><span class="deltaxml-old">$k</span></code><span class="deltaxml-old"> is the value of the </span><code><span class="deltaxml-old">NCName</span></code><span><span class="deltaxml-old">or </span><code><span class="deltaxml-old">StringLiteral</span></code><span class="deltaxml-old">.</span></span></p></li><li><p><span class="deltaxml-old">If </span><code><span class="deltaxml-old">KS</span></code><span class="deltaxml-old"> is an </span><code><span class="deltaxml-old">IntegerLiteral</span></code><span class="deltaxml-old">, the result is </span><code><span class="deltaxml-old">map:get($V, $k)</span></code><span class="deltaxml-old">, where </span><code><span class="deltaxml-old">$k</span></code><span class="deltaxml-old"> is the value of the </span><code><span class="deltaxml-old">IntegerLiteral</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">If the </span><a href="#doc-xquery40-KeySpecifier"><span class="deltaxml-old">KeySpecifier</span></a><span class="deltaxml-old"> is a wildcard (</span><code><span class="deltaxml-old">*</span></code><span class="deltaxml-old">) qualified by a SequenceType </span><var><span class="deltaxml-old">ST</span></var><span class="deltaxml-old">, the result is given by the following expression:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">map:for-each($V, function($k, $v){if ($v instance of ST) {$v}})</span></pre></div><p><span class="deltaxml-old">If no SequenceType is provided, it defaults to </span><code><span class="deltaxml-old">item()*</span></code><span class="deltaxml-old">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The order of entries in </span><code><span class="deltaxml-old">map:for-each</span></code><span class="deltaxml-old"> is implementation-dependent, so the order of values in the result sequence is also implementation-dependent.</span></p></div></li></ol></li><li><p><span class="deltaxml-old">Otherwise (that is, if </span><code><span class="deltaxml-old">$V</span></code><span class="deltaxml-old"> is neither a map nor an array) a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-old">type error</span></a><span class="deltaxml-old"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-old">err:XPTY0004</span></a><span class="deltaxml-old">].</span></p></li></ol><p><span class="deltaxml-old">Examples:</span></p><ul><li><p><code><span class="deltaxml-old">map { "first" : "Jenna", "last" : "Scott" }?first</span></code><span class="deltaxml-old"> evaluates to </span><code><span class="deltaxml-old">"Jenna"</span></code></p></li><li><p><code><span class="deltaxml-old">map { "first name" : "Jenna", "last name" : "Scott" }?"first name"</span></code><span class="deltaxml-old"> evaluates to </span><code><span class="deltaxml-old">"Jenna"</span></code></p></li><li><p><code><span class="deltaxml-old">[4, 5, 6]?2</span></code><span class="deltaxml-old"> evaluates to </span><code><span class="deltaxml-old">5</span></code><span class="deltaxml-old">.</span></p></li><li><p><code><span class="deltaxml-old">(map {"first": "Tom"}, map {"first": "Dick"}, map {"first": "Harry"})?first</span></code><span class="deltaxml-old"> evaluates to the sequence </span><code><span class="deltaxml-old">("Tom", "Dick", "Harry")</span></code><span class="deltaxml-old">.</span></p></li><li><p><code><span class="deltaxml-old">([1,2,3], [4,5,6])?2</span></code><span class="deltaxml-old"> evaluates to the sequence </span><code><span class="deltaxml-old">(2, 5)</span></code><span class="deltaxml-old">.</span></p></li><li><p><code><span class="deltaxml-old">["a","b"]?3</span></code><span class="deltaxml-old"> raises a dynamic error [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOAY0001" title="err:FOAY0001"><span class="deltaxml-old">err:FOAY0001</span></a><span class="deltaxml-old">]</span><sup><small><span class="deltaxml-old">FO40</span></small></sup></p></li></ul></div><p><span class="deltaxml-new">XQuery 4.0 provides a lookup operator for maps and arrays that is more convenient for some common cases. It provides a terse syntax for simple strings as keys in maps or integers as keys in arrays, supports wildcards, and iterates over sequences of maps and arrays.</span></p><div class="div4"><h5><a id="id-unary-lookup"></a><span class="deltaxml-old">4.14.3.2</span><span class="deltaxml-new">4.13.3.1</span> Unary Lookup</h5><a id="d3e23561"></a><a id="d3e21166"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-UnaryLookup"></a>[<span class="deltaxml-old">222</span><span class="deltaxml-new">209</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-UnaryLookup">UnaryLookup</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>("?" | "??") <a href="#doc-xquery40-KeySpecifier">KeySpecifier</a></code></span><span style="display: none;" class="add_version"><code>"?" <a href="#doc-xquery40-KeySpecifier">KeySpecifier</a></code></span><span class="modify_version"><code><span class="deltaxml-old">(</span>"?" <span class="deltaxml-old">| "??") </span><a href="#doc-xquery40-KeySpecifier">KeySpecifier</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-KeySpecifier"></a>[<span class="deltaxml-old">162</span><span class="deltaxml-new">150</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-KeySpecifier">KeySpecifier</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-NCName">NCName</a> | <a href="#doc-xquery40-IntegerLiteral">IntegerLiteral</a> | <a href="#doc-xquery40-StringLiteral">StringLiteral</a> | <a href="#doc-xquery40-VarRef">VarRef</a> | <a href="#doc-xquery40-ParenthesizedExpr">ParenthesizedExpr</a> | <a href="#doc-xquery40-LookupWildcard">LookupWildcard</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-NCName">NCName</a> | <a href="#doc-xquery40-IntegerLiteral">IntegerLiteral</a> | <a href="#doc-xquery40-StringLiteral">StringLiteral</a> | <a href="#doc-xquery40-VarRef">VarRef</a> | <a href="#doc-xquery40-ParenthesizedExpr">ParenthesizedExpr</a> | "*"</code></span><span class="modify_version"><code><a href="#prod-xquery40-NCName">NCName</a> | <a href="#doc-xquery40-IntegerLiteral">IntegerLiteral</a> | <a href="#doc-xquery40-StringLiteral">StringLiteral</a> | <a href="#doc-xquery40-VarRef">VarRef</a> | <a href="#doc-xquery40-ParenthesizedExpr">ParenthesizedExpr</a> | <a href="#doc-xquery40-LookupWildcard"><span class="deltaxml-old">LookupWildcard</span></a><span class="deltaxml-new">"*"</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LookupWildcard"></a><span class="deltaxml-old">[163]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-LookupWildcard"><span class="deltaxml-old">LookupWildcard</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"*" ("::" </span><a href="#doc-xquery40-SequenceType"><span class="deltaxml-old">SequenceType</span></a><span class="deltaxml-old">)?</span></code></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version">Unary lookup is most commonly used in predicates (for example, <code>$map[?name='Mike']</code>) or with the simple map operator (for example, <code>avg($maps ! (?price - ?discount))</code>).</span><span style="display: none;" class="add_version">Unary lookup is used in predicates (e.g. <code>$map[?name='Mike']</code> or with the simple map operator (e.g. <code>$maps ! ?name='Mike'</code>). See <a href="#id-postfix-lookup"><b>4.13.3.2 Postfix Lookup</b></a> for the postfix lookup operator.</span><span class="modify_version">Unary lookup is <span class="deltaxml-old">most commonly </span>used in predicates (<span class="deltaxml-old">for example,</span><span class="deltaxml-new">e.g.</span> <code>$map[?name='Mike']</code><span class="deltaxml-old">)</span> or with the simple map operator (<span class="deltaxml-old">for example,</span><span class="deltaxml-new">e.g.</span> <code><span class="deltaxml-old">avg(</span>$maps ! <span class="deltaxml-old">(?price - ?discount))</span><span class="deltaxml-new">?name='Mike'</span></code>).<span class="deltaxml-new"> See </span><a href="#id-postfix-lookup"><b><span class="deltaxml-new">4.13.3.2 Postfix Lookup</span></b></a><span class="deltaxml-new"> for the postfix lookup operator.</span></span></p><p><span class="deltaxml-old">The unary lookup expression </span><code><span class="deltaxml-old">?KS</span></code><span class="deltaxml-old"> is defined to be equivalent to the postfix lookup expression </span><code><span class="deltaxml-old">.?KS</span></code><span class="deltaxml-old"> which has the context value (</span><code><span class="deltaxml-old">.</span></code><span class="deltaxml-old">) as the implicit first operand. See </span><a href="#id-postfix-lookup"><b><span class="deltaxml-old">4.14.3.1 Postfix Lookup Expressions</span></b></a><span class="deltaxml-old"> for the postfix lookup operator.</span></p><p><span class="deltaxml-new">UnaryLookup returns a sequence of values selected from the context item, which must be a map or array. If the context item is not a map or an array, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new">type error</span></a><span class="deltaxml-new"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new">err:XPTY0004</span></a><span class="deltaxml-new">]. </span></p><p><span class="deltaxml-new">If the context item is a map:</span></p><ol class="enumar"><li><p><span class="deltaxml-new">If the </span><a href="#doc-xquery40-KeySpecifier"><span class="deltaxml-new">KeySpecifier</span></a><span class="deltaxml-new"> is an </span><code><span class="deltaxml-new">NCName</span></code><span><span class="deltaxml-new">or a </span><code><span class="deltaxml-new">StringLiteral</span></code></span><span class="deltaxml-new">, the </span><a href="#doc-xquery40-UnaryLookup"><span class="deltaxml-new">UnaryLookup</span></a><span class="deltaxml-new"> operator is equivalent to </span><code><span class="deltaxml-new">.(KS)</span></code><span class="deltaxml-new">, where </span><code><span class="deltaxml-new">KS</span></code><span class="deltaxml-new"> is the value of the </span><code><span class="deltaxml-new">NCName</span></code><span><span class="deltaxml-new">or </span><code><span class="deltaxml-new">StringLiteral</span></code><span class="deltaxml-new">.</span></span></p></li><li><p><span class="deltaxml-new">If the </span><a href="#doc-xquery40-KeySpecifier"><span class="deltaxml-new">KeySpecifier</span></a><span class="deltaxml-new"> is an </span><a href="#doc-xquery40-IntegerLiteral"><span class="deltaxml-new">IntegerLiteral</span></a><span class="deltaxml-new">, the </span><a href="#doc-xquery40-UnaryLookup"><span class="deltaxml-new">UnaryLookup</span></a><span class="deltaxml-new"> operator is equivalent to </span><code><span class="deltaxml-new">.(KS)</span></code><span class="deltaxml-new">, where </span><code><span class="deltaxml-new">KS</span></code><span class="deltaxml-new"> is the value of the </span><a href="#doc-xquery40-IntegerLiteral"><span class="deltaxml-new">IntegerLiteral</span></a><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">If the </span><a href="#doc-xquery40-KeySpecifier"><span class="deltaxml-new">KeySpecifier</span></a><span class="deltaxml-new"> is a </span><a href="#doc-xquery40-ParenthesizedExpr"><span class="deltaxml-new">ParenthesizedExpr</span></a><span><span class="deltaxml-new">or a </span><a href="#doc-xquery40-VarRef"><span class="deltaxml-new">VarRef</span></a></span><span class="deltaxml-new"> the </span><a href="#doc-xquery40-UnaryLookup"><span class="deltaxml-new">UnaryLookup</span></a><span class="deltaxml-new"> operator is equivalent to the following expression, where </span><code><span class="deltaxml-new">KS</span></code><span class="deltaxml-new"> is the value of the </span><a href="#doc-xquery40-ParenthesizedExpr"><span class="deltaxml-new">ParenthesizedExpr</span></a><span><span class="deltaxml-new">or </span><a href="#doc-xquery40-VarRef"><span class="deltaxml-new">VarRef</span></a></span><span class="deltaxml-new">:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">for $k in fn:data(KS) return .($k) </span></pre></div></li><li><p><span class="deltaxml-new">If the </span><a href="#doc-xquery40-KeySpecifier"><span class="deltaxml-new">KeySpecifier</span></a><span class="deltaxml-new"> is a wildcard ("</span><code><span class="deltaxml-new">*</span></code><span class="deltaxml-new">"), the </span><a href="#doc-xquery40-UnaryLookup"><span class="deltaxml-new">UnaryLookup</span></a><span class="deltaxml-new"> operator is equivalent to the following expression:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">for $k in map:keys(.) return .($k) </span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">The order of keys in map:keys() is implementation-dependent, so the order of values in the result sequence is also implementation-dependent.</span></p></div></li></ol><p><span class="deltaxml-new">If the context item is an array:</span></p><ol class="enumar"><li><p><span class="deltaxml-new">If the </span><a href="#doc-xquery40-KeySpecifier"><span class="deltaxml-new">KeySpecifier</span></a><span class="deltaxml-new"> is an </span><a href="#doc-xquery40-IntegerLiteral"><span class="deltaxml-new">IntegerLiteral</span></a><span class="deltaxml-new">, the </span><a href="#doc-xquery40-UnaryLookup"><span class="deltaxml-new">UnaryLookup</span></a><span class="deltaxml-new"> operator is equivalent to </span><code><span class="deltaxml-new">.(KS)</span></code><span class="deltaxml-new">, where </span><code><span class="deltaxml-new">KS</span></code><span class="deltaxml-new"> is the value of the </span><a href="#doc-xquery40-IntegerLiteral"><span class="deltaxml-new">IntegerLiteral</span></a><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">If the </span><a href="#doc-xquery40-KeySpecifier"><span class="deltaxml-new">KeySpecifier</span></a><span class="deltaxml-new"> is an </span><code><span class="deltaxml-new">NCName</span></code><span><span class="deltaxml-new">or </span><code><span class="deltaxml-new">StringLiteral</span></code></span><span class="deltaxml-new">, the </span><a href="#doc-xquery40-UnaryLookup"><span class="deltaxml-new">UnaryLookup</span></a><span class="deltaxml-new"> operator raises a type error [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new">err:XPTY0004</span></a><span class="deltaxml-new">].</span></p></li><li><p><span class="deltaxml-new">If the </span><a href="#doc-xquery40-KeySpecifier"><span class="deltaxml-new">KeySpecifier</span></a><span class="deltaxml-new"> is a </span><a href="#doc-xquery40-ParenthesizedExpr"><span class="deltaxml-new">ParenthesizedExpr</span></a><span><span class="deltaxml-new">or a </span><a href="#doc-xquery40-VarRef"><span class="deltaxml-new">VarRef</span></a></span><span class="deltaxml-new">, the </span><a href="#doc-xquery40-UnaryLookup"><span class="deltaxml-new">UnaryLookup</span></a><span class="deltaxml-new"> operator is equivalent to the following expression, where </span><code><span class="deltaxml-new">KS</span></code><span class="deltaxml-new"> is the value of the </span><a href="#doc-xquery40-ParenthesizedExpr"><span class="deltaxml-new">ParenthesizedExpr</span></a><span><span class="deltaxml-new">or </span><a href="#doc-xquery40-VarRef"><span class="deltaxml-new">VarRef</span></a></span><span class="deltaxml-new">:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">for $k in fn:data(KS) return .($k) </span></pre></div></li><li><p><span class="deltaxml-new">If the </span><a href="#doc-xquery40-KeySpecifier"><span class="deltaxml-new">KeySpecifier</span></a><span class="deltaxml-new"> is a wildcard ("</span><code><span class="deltaxml-new">*</span></code><span class="deltaxml-new">"), the </span><a href="#doc-xquery40-UnaryLookup"><span class="deltaxml-new">UnaryLookup</span></a><span class="deltaxml-new"> operator is equivalent to the following expression:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">for $k in 1 to array:size(.) return .($k) </span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">Note that array items are returned in order.</span></p></div></li></ol><p>Examples:</p><ul><li><p><code>?name</code> is equivalent to <code>.("name")</code>, an appropriate lookup for a map.</p></li><li><p><code>?2</code> is equivalent to <code>.(2)</code>, an appropriate lookup for an array or an integer-valued map.</p></li><li class="delete_version" style="display: none;"><p>If the context item is the result of parsing the JSON input:</p><div class="exampleInner"><pre>{ "name": "John Smith", "address": {"street": "18 Acacia Avenue", "postcode": "MK12 2EX"}, "previous-address": {"street": "12 Seaview Road", "postcode": "EX8 9AA"} }</pre></div><p>then <code>?*::record(street, postcode)?postcode</code> returns <code>("MK12 2EX", "EX8 9AA")</code> (or some permutation thereof).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Writing <code>?*?postcode</code> would raise a type error, because the result of the initial step <code>?*</code> includes an item (the string <code>"John Smith"</code>) that is neither a map nor an array.</p></div></li><li class="modify_version"><p><span class="deltaxml-old">If the context item is the result of parsing the JSON input:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">{ "name": "John Smith", "address": {"street": "18 Acacia Avenue", "postcode": "MK12 2EX"}, "previous-address": {"street": "12 Seaview Road", "postcode": "EX8 9AA"} }</span></pre></div><p><span class="deltaxml-old">then </span><code><span class="deltaxml-old">?*::record(street, postcode)?postcode</span></code><span class="deltaxml-old"> returns </span><code><span class="deltaxml-old">("MK12 2EX", "EX8 9AA")</span></code><span class="deltaxml-old"> (or some permutation thereof).</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Writing </span><code><span class="deltaxml-old">?*?postcode</span></code><span class="deltaxml-old"> would raise a type error, because the result of the initial step </span><code><span class="deltaxml-old">?*</span></code><span class="deltaxml-old"> includes an item (the string </span><code><span class="deltaxml-old">"John Smith"</span></code><span class="deltaxml-old">) that is neither a map nor an array.</span></p></div></li><li><p><code>?"first name"</code> is equivalent to <code>.("first name")</code></p></li><li class="xquery"><p><code>?("$funky / &lt;looking @string")</code> is equivalent to <code>.("$funky / &lt;looking @string")</code>, an appropriate lookup for a map with rather odd conventions for keys.</p></li><li><p><code>?($a)</code><span>and <code>?$a</code> are</span> equivalent to <code>for $k in $a return .($k)</code>, allowing keys for an array or map to be passed using a variable.</p></li><li><p><code>?(2 to 4)</code> is equivalent to <code>for $k in (2,3,4) return .($k)</code>, a convenient way to return a range of values from an array.</p></li><li><p><span style="display: none;" class="delete_version"><code>?(3.5)</code> raises a type error if the context value is an array because the parameter must be an integer.</span><span style="display: none;" class="add_version"><code>?(3.5)</code> raises a type error if the context item is an array because the parameter must be an integer.</span><span class="modify_version"><code>?(3.5)</code> raises a type error if the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> is an array because the parameter must be an integer.</span></p></li><li class="xquery"><p><span style="display: none;" class="delete_version">If the context value is an array, <code>let $x:= &lt;node i="3"/&gt; return ?($x/@i)</code> does not raise a type error because the attribute is untyped.</span><span style="display: none;" class="add_version">If the context item is an array, <code>let $x:= &lt;node i="3"/&gt; return ?($x/@i)</code> does not raise a type error because the attribute is untyped.</span><span class="modify_version">If the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> is an array, <code>let $x:= &lt;node i="3"/&gt; return ?($x/@i)</code> does not raise a type error because the attribute is untyped.</span></p><p>But <code>let $x:= &lt;node i="3"/&gt; return ?($x/@i+1)</code> does raise a type error because the <code>+</code> operator with an untyped operand returns a double.</p></li><li><p><code>([1,2,3], [1,2,5], [1,2])[?3 = 5]</code> raises an error because <code>?3</code> on one of the items in the sequence fails.</p></li><li><p><span style="display: none;" class="delete_version">If <code>$m</code> is bound to the weekdays map described in <a href="#id-maps"><span class="delete_version"><b>4.14.1 Maps</b></span><span class="modify_version"><b>4.14.1 Maps</b></span></a>, then <code>$m?*</code> returns the values <code>("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday")</code>, in <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order.</span><span style="display: none;" class="add_version">If <code>$m</code> is bound to the weekdays map described in <a href="#id-maps"><span class="add_version"><b>4.13.1 Maps</b></span><span class="modify_version"><b>4.13.1 Maps</b></span></a>, then <code>$m?*</code> returns the values <code>("Sunday","Monday","Tuesday","Wednesday", "Thursday", "Friday","Saturday")</code>, in <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order.</span><span class="modify_version">If <code>$m</code> is bound to the weekdays map described in <a href="#id-maps"><span style="display: none;" class="delete_version"><b>4.14.1 Maps</b></span><span style="display: none;" class="add_version"><b>4.13.1 Maps</b></span><span class="modify_version"><b><span class="deltaxml-old">4.14.1</span><span class="deltaxml-new">4.13.1</span> Maps</b></span></a>, then <code>$m?*</code> returns the values <code>("Sunday",<span class="deltaxml-old"> </span>"Monday",<span class="deltaxml-old"> </span>"Tuesday",<span class="deltaxml-old"> </span>"Wednesday", "Thursday", "Friday",<span class="deltaxml-old"> </span>"Saturday")</code>, in <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order.</span></p></li><li><p><code>[1, 2, 5, 7]?*</code> evaluates to <code>(1, 2, 5, 7)</code>.</p></li><li><p><code>[[1, 2, 3], [4, 5, 6]]?*</code> evaluates to <code>([1, 2, 3], [4, 5, 6])</code></p></li><li class="delete_version" style="display: none;"><p><code>[[1, 2, 3], 4, 5]?*::array(*)</code> evaluates to <code>([1, 2, 3])</code></p></li><li class="modify_version"><p><code><span class="deltaxml-old">[[1, 2, 3], 4, 5]?*::array(*)</span></code><span class="deltaxml-old"> evaluates to </span><code><span class="deltaxml-old">([1, 2, 3])</span></code></p></li><li class="delete_version" style="display: none;"><p><code>[[1, 2, 3], [4, 5, 6], 7]?*::array(*)?2</code> evaluates to <code>(2, 5)</code></p></li><li class="modify_version"><p><code><span class="deltaxml-old">[[1, 2, 3], [4, 5, 6], 7]?*::array(*)?2</span></code><span class="deltaxml-old"> evaluates to </span><code><span class="deltaxml-old">(2, 5)</span></code></p></li><li class="delete_version" style="display: none;"><p><code>[[1, 2, 3], 4, 5]?*::xs:integer</code> evaluates to <code>(4, 5)</code></p></li><li class="modify_version"><p><code><span class="deltaxml-old">[[1, 2, 3], 4, 5]?*::xs:integer</span></code><span class="deltaxml-old"> evaluates to </span><code><span class="deltaxml-old">(4, 5)</span></code></p></li></ul></div><div class="div4"><h5><a id="id-deep-lookup"></a><span class="deltaxml-old">4.14.3.3 Deep Lookup</span></h5><p><span class="deltaxml-old">The deep lookup operator </span><code><span class="deltaxml-old">??</span></code><span class="deltaxml-old"> has both unary and postfix forms. The unary form </span><code><span class="deltaxml-old">??KS</span></code><span class="deltaxml-old"> (where </span><var><span class="deltaxml-old">KS</span></var><span class="deltaxml-old"> is any </span><code><span class="deltaxml-old">KeySpecifier</span></code><span class="deltaxml-old">) has the same effect as the binary form </span><code><span class="deltaxml-old">.??KS</span></code><span class="deltaxml-old">. </span></p><p><span class="deltaxml-old">The semantics are defined as follows.</span></p><p><span class="deltaxml-old">First we define the </span><b><span class="deltaxml-old">recursive content</span></b><span class="deltaxml-old"> of an item as follows:</span></p><div class="exampleInner"><pre><span class="deltaxml-old"> declare function immediate-content($item as item()) as map(*)* { if ($item instance of map(*)) { map:entries($item) } else if ($item instance of array(*)) { for member $m at $p in $item return map:entry($p, $m) } }; declare function recursive-content($item as item()) as map(*)* { immediate-content($item) ! (., map:values(.) =!&gt; recursive-content()) };</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Explanation: the immediate content of a map is obtained by splitting it into a sequence of singleton maps, each representing one entry. The immediate content of an array is obtained by constructing a sequence of singleton maps, one for each array member, where the key of the map is the array index and the value is the corresponding member. The recursive content of an item contains the singleton maps in its immediate content, each followed by the recursive content obtained by expanding any maps or arrays in the immediate content. </span></p></div><p><span class="deltaxml-old">In addition we define the function </span><code><span class="deltaxml-old">array-or-map</span></code><span class="deltaxml-old"> as follows:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">declare function array-or-map($item as item()) { typeswitch ($item) { case array(*) | map(*) return $item default return error(xs:QName("err:XPTY0004")) } }</span></pre></div><p><span class="deltaxml-old">The result of the expression </span><code><span class="deltaxml-old">E??KS</span></code><span class="deltaxml-old">, where </span><code><span class="deltaxml-old">E</span></code><span class="deltaxml-old"> is any expression and </span><code><span class="deltaxml-old">KS</span></code><span class="deltaxml-old"> is any </span><code><span class="deltaxml-old">KeySpecifier</span></code><span class="deltaxml-old">, is then:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">(</span><var><span class="deltaxml-old">E</span></var><span class="deltaxml-old"> =!&gt; array-or-map() =&gt; recursive-content())?</span><var><span class="deltaxml-old">KS</span></var></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">This is best explained by considering examples.</span></p><p><span class="deltaxml-old">Consider the expression </span><code><span class="deltaxml-old">let $value := [map{"first":"John", "last":"Smith"}, map{"first":"Mary", "last":"Evans"}]</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">The recursive content of this array is the sequence of six singleton maps:</span></p><ol class="enumar"><li><p><code><span class="deltaxml-old">map{1: map{"first":"John", "last":"Smith"}}</span></code></p></li><li><p><code><span class="deltaxml-old">map{2: map{"first":"Mary", "last":"Evans"}}</span></code></p></li><li><p><code><span class="deltaxml-old">map{"first":"John"}</span></code></p></li><li><p><code><span class="deltaxml-old">map{"last":"Smith"}</span></code></p></li><li><p><code><span class="deltaxml-old">map{"first":"Mary"}</span></code></p></li><li><p><code><span class="deltaxml-old">map{"last":"Evans"}</span></code></p></li></ol><p><span class="deltaxml-old">The expression </span><code><span class="deltaxml-old">$value??*</span></code><span class="deltaxml-old"> returns the sequence </span><code><span class="deltaxml-old">map{"first":"John", "last":"Smith"}, map{"first":"Mary", "last":"Evans"}, "John", "Smith", "Mary", "Evans"</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">The expression </span><code><span class="deltaxml-old">$value??first</span></code><span class="deltaxml-old"> returns the sequence </span><code><span class="deltaxml-old">"John", "Mary"</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">The expression </span><code><span class="deltaxml-old">$value??last</span></code><span class="deltaxml-old"> returns the sequence </span><code><span class="deltaxml-old">"Smith", "Evans"</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">The expression </span><code><span class="deltaxml-old">$value??1</span></code><span class="deltaxml-old"> returns the sequence </span><code><span class="deltaxml-old">map{"first":"John", "last":"Smith"}</span></code><span class="deltaxml-old">.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The effect of evaluating all shallow lookups on maps rather than arrays is that no error arises if an array subscript is out of bounds. In the above example, </span><code><span class="deltaxml-old">$value?3</span></code><span class="deltaxml-old"> would return an empty sequence, it would not raise an error.</span></p><p><span class="deltaxml-old">This also affects the way an </span><code><span class="deltaxml-old">xs:untypedAtomic</span></code><span class="deltaxml-old"> key value is handled. Given the shallow lookup expression </span><code><span class="deltaxml-old">$A?$x</span></code><span class="deltaxml-old">, if </span><code><span class="deltaxml-old">$A</span></code><span class="deltaxml-old"> is an array and </span><code><span class="deltaxml-old">$x</span></code><span class="deltaxml-old"> (after atomization) is </span><code><span class="deltaxml-old">xs:untypedAtomic</span></code><span class="deltaxml-old"> then the value of </span><code><span class="deltaxml-old">$x</span></code><span class="deltaxml-old"> is converted to an integer (by virtue of the coercion rules applying to a call on </span><code><span class="deltaxml-old">array:get</span></code><span class="deltaxml-old">). With a deep lookup expression </span><code><span class="deltaxml-old">$A??$x</span></code><span class="deltaxml-old">, by contrast, the semantics are defined in terms of a map lookup, in which </span><code><span class="deltaxml-old">xs:untypedAtomic</span></code><span class="deltaxml-old"> values are always treated as strings. </span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The definition of the </span><code><span class="deltaxml-old">recursive-content</span></code><span class="deltaxml-old"> function is such that items in the top-level value that are not maps or arrays are ignored, whereas items that are not themselves maps or arrays, but which appear in the content of a map or array at the top level, are included. This means that </span><code><span class="deltaxml-old">E??X</span></code><span class="deltaxml-old"> mirrors the behavior of </span><code><span class="deltaxml-old">E//X</span></code><span class="deltaxml-old">, in that it includes all items that are one-or-more levels deep in the tree.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The result of the deep lookup operator retains order when processing sequences and arrays, but not when processing maps.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">An expression involving multiple deep lookup operators may return duplicates. For example, the result of the expression </span><code><span class="deltaxml-old">[[["a"],["b"]],[["c"],["d"]]] ?? 1 ?? 1</span></code><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">(["a"], "a", "b", "a", "c")</span></code><span class="deltaxml-old">. This is because the first </span><code><span class="deltaxml-old">??</span></code><span class="deltaxml-old"> operator selects members in position 1 at all three levels, that is it selects the arrays </span><code><span class="deltaxml-old">[["a"],["b"]]</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">["a"]</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">["c"]</span></code><span class="deltaxml-old"> as well as each of the four string values. The second </span><code><span class="deltaxml-old">??</span></code><span class="deltaxml-old"> operator selects members in position 1 within each of these values, which results in the string </span><code><span class="deltaxml-old">"a"</span></code><span class="deltaxml-old"> being selected twice.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">A type error is raised if the value of the left-hand expression includes an item that is neither a map nor an array.</span></p></div><div class="example"><div class="exampleHeader"><a id="ex-deep-lookup"></a><span class="deltaxml-old">Example: Examples of Deep Lookup Expressions</span></div><p><span class="deltaxml-old">Consider the tree </span><code><span class="deltaxml-old">$tree</span></code><span class="deltaxml-old"> of maps and arrays that results from applying the </span><code><span class="deltaxml-old">fn:parse-json</span></code><span class="deltaxml-old"> function to the following input:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">{ "desc" : "Distances between several cities, in kilometers.", "updated" : "2014-02-04T18:50:45", "uptodate": true, "author" : null, "cities" : { "Brussels": [ {"to": "London", "distance": 322}, {"to": "Paris", "distance": 265}, {"to": "Amsterdam", "distance": 173} ], "London": [ {"to": "Brussels", "distance": 322}, {"to": "Paris", "distance": 344}, {"to": "Amsterdam", "distance": 358} ], "Paris": [ {"to": "Brussels", "distance": 265}, {"to": "London", "distance": 344}, {"to": "Amsterdam", "distance": 431} ], "Amsterdam": [ {"to": "Brussels", "distance": 173}, {"to": "London", "distance": 358}, {"to": "Paris", "distance": 431} ] } }</span></pre></div><p><span class="deltaxml-old">Given two variables </span><code><span class="deltaxml-old">$from</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">$to</span></code><span class="deltaxml-old"> containing the names of two cities that are present in this table, the distance between the two cities can be obtained with the expression:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">$tree ??$from ??*::record(to, distance) [?to=$to] ?distance</span></pre></div><p><span class="deltaxml-old">The names of all pairs of cities whose distance is represented in the data can be obtained with the expression:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">$tree ??$cities =&gt; map:for-each( fn($key, $val){$val ??to ! ($key || "-" || .)} )</span></pre></div></div><p><span class="deltaxml-old">&nbsp;</span></p><div class="example"><div class="exampleHeader"><a id="d3e23944"></a><span class="deltaxml-old">Example: Comparison with JSONPath</span></div><p><span class="deltaxml-old">This example provides XPath equivalents to some examples given in the JSONPath specification. [TODO: add a reference].</span></p><p><span class="deltaxml-old">The examples query the result of parsing the following JSON value, representing a store whose stock consists of four books and a bicycle:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">{ "store": { "book": [ { "category": "reference", "author": "Nigel Rees", "title": "Sayings of the Century", "price": 8.95 }, { "category": "fiction", "author": "Evelyn Waugh", "title": "Sword of Honour", "price": 12.99 }, { "category": "fiction", "author": "Herman Melville", "title": "Moby Dick", "isbn": "0-553-21311-3", "price": 8.99 }, { "category": "fiction", "author": "J. R. R. Tolkien", "title": "The Lord of the Rings", "isbn": "0-395-19395-8", "price": 22.99 } ], "bicycle": { "color": "red", "price": 399 } } }</span></pre></div><p><span class="deltaxml-old">The following table illustrates some queries on this data, expressed both in JSONPath and in XQuery 4.0.</span></p><table style="width:100%" class="small"><caption><span class="deltaxml-old">JSONPath vs XQuery 4.0 Comparison</span></caption><thead><tr><th><span class="deltaxml-old">Query</span></th><th><span class="deltaxml-old">JSONPath</span></th><th><span class="deltaxml-old">XQuery 4.0</span></th></tr></thead><tbody><tr><td><span class="deltaxml-old">The authors of all books in the store</span></td><td><code><span class="deltaxml-old">$.store.book[*].author</span></code></td><td><code><span class="deltaxml-old">$m?store?book??author</span></code></td></tr><tr><td><span class="deltaxml-old">All authors</span></td><td><code><span class="deltaxml-old">$..author</span></code></td><td><code><span class="deltaxml-old">$m??author</span></code></td></tr><tr><td><span class="deltaxml-old">All things in store (four books and a red bicycle)</span></td><td><code><span class="deltaxml-old">$.store.* </span></code></td><td><code><span class="deltaxml-old">$m?store?*</span></code></td></tr><tr><td><span class="deltaxml-old">The prices of everything in the store</span></td><td><code><span class="deltaxml-old">$.store..price</span></code></td><td><code><span class="deltaxml-old">$m?store??price</span></code></td></tr><tr><td><span class="deltaxml-old">The third book</span></td><td><code><span class="deltaxml-old">$..book[2] </span></code></td><td><code><span class="deltaxml-old">$m??book?3</span></code></td></tr><tr><td><span class="deltaxml-old">The third book's author</span></td><td><code><span class="deltaxml-old">$..book[2].author</span></code></td><td><code><span class="deltaxml-old">$m??book?3?author</span></code></td></tr><tr><td><span class="deltaxml-old">The third book's publisher (empty result)</span></td><td><code><span class="deltaxml-old">$..book[2].publisher</span></code></td><td><code><span class="deltaxml-old">$m??book?3?publisher</span></code></td></tr><tr><td><span class="deltaxml-old">The last book (in order)</span></td><td><code><span class="deltaxml-old">$..book[-1]</span></code></td><td><code><span class="deltaxml-old">$m??book =&gt; array:foot()</span></code></td></tr><tr><td><span class="deltaxml-old">The first two books</span></td><td><code><span class="deltaxml-old">$..book[0,1]</span></code></td><td><code><span class="deltaxml-old">$m??book?(1,2)</span></code></td></tr><tr><td><span class="deltaxml-old">All books with an ISBN</span></td><td><code><span class="deltaxml-old">$..book[?@.isbn]</span></code></td><td><code><span class="deltaxml-old">$m??book[?isbn]</span></code></td></tr><tr><td><span class="deltaxml-old">All books cheaper than 10</span></td><td><code><span class="deltaxml-old">$..book[?@.price&lt;10]</span></code></td><td><code><span class="deltaxml-old">$m??book[?price lt 10]</span></code></td></tr><tr><td><span class="deltaxml-old">All member values and array elements contained in the input value</span></td><td><code><span class="deltaxml-old">$..*</span></code></td><td><code><span class="deltaxml-old">$m??*</span></code></td></tr></tbody></table></div><h5><a id="id-postfix-lookup"></a><span class="deltaxml-new">4.13.3.2 Postfix Lookup</span></h5><a id="d3e21496"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Lookup"></a><span class="deltaxml-new">[149]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-Lookup"><span class="deltaxml-new">Lookup</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">"?" </span><a href="#doc-xquery40-KeySpecifier"><span class="deltaxml-new">KeySpecifier</span></a></code></td><td></td></tr></tbody></table><p><span class="deltaxml-new"> The semantics of a Postfix Lookup expression depend on the form of the KeySpecifier, as follows: </span></p><ul><li><p><span class="deltaxml-new">If the </span><code><span class="deltaxml-new">KeySpecifier</span></code><span class="deltaxml-new"> is an </span><code><span class="deltaxml-new">NCName</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">StringLiteral</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">VarRef</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">IntegerLiteral</span></code><span class="deltaxml-new">, or </span><code><span class="deltaxml-new">Wildcard</span></code><span class="deltaxml-new"> ("</span><code><span class="deltaxml-new">*</span></code><span class="deltaxml-new">"), then the expression </span><code><span class="deltaxml-new">E?S</span></code><span class="deltaxml-new"> is equivalent to </span><code><span class="deltaxml-new">E!?S</span></code><span class="deltaxml-new">. (That is, the semantics of the postfix lookup operator are defined in terms of the unary lookup operator).</span></p></li><li><p><span class="deltaxml-new">If the </span><code><span class="deltaxml-new">KeySpecifier</span></code><span class="deltaxml-new"> is a </span><code><span class="deltaxml-new">ParenthesizedExpr</span></code><span class="deltaxml-new">, then the expression </span><code><span class="deltaxml-new">E?(S)</span></code><span class="deltaxml-new"> is equivalent to</span></p><div class="exampleInner"><pre><span class="deltaxml-new">for $e in E, $s in fn:data(S) return $e($s)</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">The focus for evaluating </span><code><span class="deltaxml-new">S</span></code><span class="deltaxml-new"> is the same as the focus for the </span><code><span class="deltaxml-new">Lookup</span></code><span class="deltaxml-new"> expression itself.</span></p></div></li></ul><p><span class="deltaxml-new">Examples:</span></p><ul><li><p><code><span class="deltaxml-new">map { "first" : "Jenna", "last" : "Scott" }?first</span></code><span class="deltaxml-new"> evaluates to </span><code><span class="deltaxml-new">"Jenna"</span></code></p></li><li><p><code><span class="deltaxml-new">map { "first name" : "Jenna", "last name" : "Scott" }?"first name"</span></code><span class="deltaxml-new"> evaluates to </span><code><span class="deltaxml-new">"Jenna"</span></code></p></li><li><p><code><span class="deltaxml-new">[4, 5, 6]?2</span></code><span class="deltaxml-new"> evaluates to </span><code><span class="deltaxml-new">5</span></code><span class="deltaxml-new">.</span></p></li><li><p><code><span class="deltaxml-new">(map {"first": "Tom"}, map {"first": "Dick"}, map {"first": "Harry"})?first</span></code><span class="deltaxml-new"> evaluates to the sequence </span><code><span class="deltaxml-new">("Tom", "Dick", "Harry")</span></code><span class="deltaxml-new">.</span></p></li><li><p><code><span class="deltaxml-new">([1,2,3], [4,5,6])?2</span></code><span class="deltaxml-new"> evaluates to the sequence </span><code><span class="deltaxml-new">(2, 5)</span></code><span class="deltaxml-new">.</span></p></li><li><p><code><span class="deltaxml-new">["a","b"]?3</span></code><span class="deltaxml-new"> raises a dynamic error [</span><a href="https://www.w3.org/TR/xpath-functions-31/#ERRFOAY0001" title="err:FOAY0001"><span class="deltaxml-new">err:FOAY0001</span></a><span class="deltaxml-new">]</span><sup><small><span class="deltaxml-new">FO31</span></small></sup></p></li></ul></div><div class="div4"><h5><a id="id-implausible-lookup-expressions"></a><span class="deltaxml-old">4.14.3.4 Implausible Lookup Expressions</span></h5><p><span class="deltaxml-old">Under certain conditions a lookup expression that will never select anything is classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-old">implausible</span></a><span class="deltaxml-old">. During the static analysis phase, a processor </span><strong><span class="deltaxml-old">may</span></strong><span class="deltaxml-old"> (subject to the rules in </span><a href="#id-implausible-expressions"><b><span class="deltaxml-old">2.4.6 Implausible Expressions</span></b></a><span class="deltaxml-old">) report a static error when such lookup expressions are encountered: [</span><a href="#ERRXPTY0145" title="err:XPTY0145"><span class="deltaxml-old">err:XPTY0145</span></a><span class="deltaxml-old">].</span></p><p><span class="deltaxml-old">More specifically, a shallow unary or postfix lookup is classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-old">implausible</span></a><span class="deltaxml-old"> if any of the following conditions applies:</span></p><ol class="enumar"><li><p><span class="deltaxml-old">The inferred type of the left-hand operand (or the context value, in the case of a unary expression) is a record test (see </span><a href="#id-record-test"><b><span class="deltaxml-old">3.6.4.3 Record Test</span></b></a><span class="deltaxml-old">), and the </span><code><span class="deltaxml-old">KeySpecifier</span></code><span class="deltaxml-old"> is an </span><code><span class="deltaxml-old">IntegerLiteral</span></code><span class="deltaxml-old">. </span></p></li><li><p><span class="deltaxml-old">The inferred type of the left-hand operand (or the context value, in the case of a unary expression) is a record test (see </span><a href="#id-record-test"><b><span class="deltaxml-old">3.6.4.3 Record Test</span></b></a><span class="deltaxml-old">), and the </span><code><span class="deltaxml-old">KeySpecifier</span></code><span class="deltaxml-old"> is an </span><code><span class="deltaxml-old">NCName</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">StringLiteral</span></code><span class="deltaxml-old"> that cannot validly appear as a field name in the record. </span></p></li><li><p><span class="deltaxml-old">The inferred type of the left-hand operand (or the context value, in the case of a unary expression) is a map type, and the inferred type of the </span><code><span class="deltaxml-old">KeySpecifier</span></code><span class="deltaxml-old">, after coercion, is a type that is disjoint with the key type of the map. </span></p></li><li><p><span class="deltaxml-old">The inferred type of the left-hand operand (or the context value, in the case of a unary expression) is an array type, and the </span><code><span class="deltaxml-old">KeySpecifier</span></code><span class="deltaxml-old"> is the </span><code><span class="deltaxml-old">IntegerLiteral</span></code><code><span class="deltaxml-old">0</span></code><span class="deltaxml-old"> (zero). </span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Other errors, such as using an </span><code><span class="deltaxml-old">NCName</span></code><code><span class="deltaxml-old">KeySpecifier</span></code><span class="deltaxml-old"> for an array lookup, are handled under the general provisions for type errors.</span></p></div><p><span class="deltaxml-old">Examples of implausible lookup expressions include the following:</span></p><ul><li><p><code><span class="deltaxml-old">parse-uri($uri)?3</span></code><span class="deltaxml-old">: the declared result type of </span><code><span class="deltaxml-old">parse-uri</span></code><span class="deltaxml-old"> is a record test, so the selector </span><code><span class="deltaxml-old">3</span></code><span class="deltaxml-old"> will never select anything.</span></p></li><li><p><code><span class="deltaxml-old">in-scope-namespaces($node)(current-date())</span></code><span class="deltaxml-old">: the result type of </span><code><span class="deltaxml-old">in-scope-namespaces</span></code><span class="deltaxml-old"> is a map with </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> keys, so the selector </span><code><span class="deltaxml-old">current-date()</span></code><span class="deltaxml-old"> will never select anything.</span></p></li><li><p><code><span class="deltaxml-old">array:subarray($a, 2, 5)?0</span></code><span class="deltaxml-old">: the integer zero cannot select any member of an array, because numbering starts at 1.</span></p></li></ul></div></div><div class="div3"><h4><a id="id-pinned-maps-and-arrays"></a><span class="deltaxml-old">4.14.4 Pinned Maps and Arrays</span></h4><p><span class="deltaxml-old">Unlike navigation within node trees derived from XML, navigation within a tree of maps and arrays derived from JSON is normally “downwards only”: there is no equivalent of the parent or ancestor axis. This means, for example, that having selected leav nodes in the tree with an expression such as </span><code><span class="deltaxml-old">??name</span></code><span class="deltaxml-old">, there is no way of navigating from the items in the result to any related items. Pinned maps and arrays provide a solution to this problem; if a map or array is pinned (by calling the </span><code><span class="deltaxml-old">fn:pin</span></code><span class="deltaxml-old"> function), then values found by navigating within the map or array are </span><b><span class="deltaxml-old">labeled</span></b><span class="deltaxml-old">, which provides supplementary information about their location within the containing tree structure.</span></p><p><span class="deltaxml-old">For further information about pinned and labeled values see </span><span class="markup-error"><span class="deltaxml-old">[TITLE OF DM40 SPEC, TITLE OF id-labeled-items SECTION]</span><sup><small><span class="deltaxml-old">DM40</span></small></sup></span><span class="deltaxml-old">. </span></p><p><span class="deltaxml-old">More specifically, if a map </span><code><span class="deltaxml-old">$M</span></code><span class="deltaxml-old"> or an array </span><code><span class="deltaxml-old">$A</span></code><span class="deltaxml-old"> is pinned, then any value returned by </span><code><span class="deltaxml-old">map:get($M, $key)</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">array:get($A, $index)</span></code><span class="deltaxml-old"> will be a sequence of labeled items. The label can be obtained by calling the function </span><code><span class="deltaxml-old">fn:label</span></code><span class="deltaxml-old">, and the result will be a map having the following properties:</span></p><ul><li><p><code><span class="deltaxml-old">pinned</span></code><span class="deltaxml-old">: set to </span><code><span class="deltaxml-old">true</span></code><span class="deltaxml-old">. This means that any further selections from this value (if it is itself a map or array) will also deliver labeled items.</span></p></li><li><p><code><span class="deltaxml-old">parent</span></code><span class="deltaxml-old">: the containing map (</span><code><span class="deltaxml-old">$M</span></code><span class="deltaxml-old">) or array (</span><code><span class="deltaxml-old">$A</span></code><span class="deltaxml-old">).</span></p></li><li><p><code><span class="deltaxml-old">key</span></code><span class="deltaxml-old">: the key (</span><code><span class="deltaxml-old">$key</span></code><span class="deltaxml-old">) or index (</span><code><span class="deltaxml-old">$index</span></code><span class="deltaxml-old">) that was used to select the item.</span></p></li><li><p><code><span class="deltaxml-old">position</span></code><span class="deltaxml-old">: in the general case the value returned by </span><code><span class="deltaxml-old">map:get</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">array:get</span></code><span class="deltaxml-old"> is a sequence, and each item in the sequence is labeled with its 1-based position in that sequence.</span></p></li><li><p><code><span class="deltaxml-old">ancestors</span></code><span class="deltaxml-old">: a zero-arity function that delivers the item's parent (its containing map or array), that item's parent, and so on, recursively, up to the map or array that was the root of the selection. The sequence is in upwards navigation order (the immediate parent comes first).</span></p></li><li><p><code><span class="deltaxml-old">path</span></code><span class="deltaxml-old">: a zero-arity function that delivers the sequence of keys (in the case of maps) or integer indexes (in the case of arrays) by which the item was reached. The sequence is in downwards navigation order (the immediate key or index of the item comes last).</span></p></li></ul><p><span class="deltaxml-old">The formal model for the </span><code><span class="deltaxml-old">fn:pin</span></code><span class="deltaxml-old"> is that it returns a deep copy of the supplied map or array in which all items in the recursive content have been labeled. This is a useful model because it avoids the need to specify the effect of each individual function and operator on the structure. For example, the rule has the consequence that the result of </span><code><span class="deltaxml-old">pin([11,12,13,14]) =&gt; array:remove(3) =&gt; array:for-each(fn{label(.)?key})</span></code><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">[1,2,4]</span></code><span class="deltaxml-old">. In a practical implementation, however, it is likely that labels will be attached to items lazily, at the time they are retrieved. Such an implementation will need to recognize pinned maps and arrays and treat them specially when operations such as </span><code><span class="deltaxml-old">array:get</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">array:remove</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">array:for-each</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">array:subarray</span></code><span class="deltaxml-old">, and their map counterparts, are evaluated.</span></p><p><span class="deltaxml-old">Because maps and arrays selected from a pinned map or array are themselves pinned, deep lookup operations (whether conducted using the deep lookup operator </span><code><span class="deltaxml-old">??</span></code><span class="deltaxml-old">, or the </span><code><span class="deltaxml-old">map:find</span></code><span class="deltaxml-old"> function, or by user-written recursive code) will deliver a labeled value whose </span><code><span class="deltaxml-old">parent</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">ancestor</span></code><span class="deltaxml-old"> properties can be used to navigate back up through the tree.</span></p><p><span class="deltaxml-old">For example, given the example map shown in </span><a href="#id-map-constructors"><b><span class="deltaxml-old">4.14.1.1 Map Constructors</span></b></a><span class="deltaxml-old">, the expression </span><code><span class="deltaxml-old">$map??last[. = "Suciu"]</span></code><span class="deltaxml-old"> selects the map entry with key </span><code><span class="deltaxml-old">"last"</span></code><span class="deltaxml-old"> and value </span><code><span class="deltaxml-old">"Suciu"</span></code><span class="deltaxml-old">, but by itself gives no information about where this entry was found. By first pinning the map, this extra information can be made available through the label on the result. For example you can select all co-authors of "Suciu" by writing:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">pin($map)??last[. = "Suciu"] =&gt; label()?ancestors()?author??last</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">When an entry in a map, or a member of an array, has the empty sequence as its value, the value contains no items and is therefore unchanged in the pinned version of the containing structure. In addition, the lookup operators </span><code><span class="deltaxml-old">?</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">??</span></code><span class="deltaxml-old"> flatten their result to a single sequence, so any empty values are effectively discarded from the result. For this reason, pinned arrays and maps work best when all values in arrays and maps are singleton items. An option is therefore provided on the </span><code><span class="deltaxml-old">fn:parse-json</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">fn:json-doc</span></code><span class="deltaxml-old"> functions to change the representation of JSON </span><code><span class="deltaxml-old">null</span></code><span class="deltaxml-old"> values (whose default is an empty sequence, </span><code><span class="deltaxml-old">()</span></code><span class="deltaxml-old">) to a user-supplied value.</span></p></div><table class="ednote" caption="Editorial note"><tbody><tr><td style="text-align: left; vertical-align:top; width: 50%;"><b><span class="deltaxml-old">Editorial note</span></b></td><td style="text-align: right; vertical-align:top; width: 50%;"><span class="deltaxml-old">&nbsp;</span></td></tr><tr style="text-align: left; vertical-align: top;"><td colspan="2"><span class="deltaxml-old">That note is anticipating a proposal in a separate PR.</span></td></tr></tbody></table></div></div><div class="div2"><h3><a id="id-flwor-expressions"></a><span class="deltaxml-old">4.15</span><span class="deltaxml-new">4.14</span> FLWOR Expressions</h3><p>XQuery provides a versatile expression called a FLWOR expression that may contain multiple clauses. The FLWOR expression can be used for many purposes, including iterating over sequences, joining multiple documents, and performing grouping and aggregation. The name FLWOR, pronounced "flower", is suggested by the keywords <code>for</code>, <code>let</code>, <code>where</code>, <code>order by</code>, and <code>return</code>, which introduce some of the clauses used in FLWOR expressions (but this is not a complete list of such clauses.)</p><p>The complete syntax of a FLWOR expression is shown here, and relevant parts of the syntax are repeated in subsequent sections of this document.</p><a id="d3e24325"></a><a id="d3e21611"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FLWORExpr"></a>[<span class="deltaxml-old">49</span><span class="deltaxml-new">48</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-FLWORExpr">FLWORExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-InitialClause">InitialClause</a><a href="#doc-xquery40-IntermediateClause">IntermediateClause</a>* <a href="#doc-xquery40-ReturnClause">ReturnClause</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-InitialClause"></a>[<span class="deltaxml-old">50</span><span class="deltaxml-new">49</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-InitialClause">InitialClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-ForClause">ForClause</a> | <a href="#doc-xquery40-LetClause">LetClause</a> | <a href="#doc-xquery40-WindowClause">WindowClause</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-ForClause">ForClause</a> | <a href="#doc-xquery40-ForMemberClause">ForMemberClause</a> | <a href="#doc-xquery40-LetClause">LetClause</a> | <a href="#doc-xquery40-WindowClause">WindowClause</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-ForClause">ForClause</a> | <a href="#doc-xquery40-ForMemberClause"><span class="deltaxml-new">ForMemberClause</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-LetClause">LetClause</a> | <a href="#doc-xquery40-WindowClause">WindowClause</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-IntermediateClause"></a>[<span class="deltaxml-old">51</span><span class="deltaxml-new">50</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-IntermediateClause">IntermediateClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-InitialClause">InitialClause</a> | <a href="#doc-xquery40-WhereClause">WhereClause</a> | <a href="#doc-xquery40-WhileClause">WhileClause</a> | <a href="#doc-xquery40-GroupByClause">GroupByClause</a> | <a href="#doc-xquery40-OrderByClause">OrderByClause</a> | <a href="#doc-xquery40-CountClause">CountClause</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-InitialClause">InitialClause</a> | <a href="#doc-xquery40-WhereClause">WhereClause</a> | <a href="#doc-xquery40-GroupByClause">GroupByClause</a> | <a href="#doc-xquery40-OrderByClause">OrderByClause</a> | <a href="#doc-xquery40-CountClause">CountClause</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-InitialClause">InitialClause</a> | <a href="#doc-xquery40-WhereClause">WhereClause</a> | <a href="#doc-xquery40-WhileClause"><span class="deltaxml-old">WhileClause</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-GroupByClause">GroupByClause</a> | <a href="#doc-xquery40-OrderByClause">OrderByClause</a> | <a href="#doc-xquery40-CountClause">CountClause</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e21877.doc-xquery40-ForClause"></a><a id="noid_d4e19349.doc-xquery40-ForClause"></a>[<span class="deltaxml-old">52</span><span class="deltaxml-new">51</span>]&nbsp;&nbsp;&nbsp;</td><td><code>ForClause</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"for" <a href="#doc-xquery40-ForBinding">ForBinding</a> ("," <a href="#doc-xquery40-ForBinding">ForBinding</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e21878.doc-xquery40-ForBinding"></a><span class="deltaxml-old">[53]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">ForBinding</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-ForItemBinding"><span class="deltaxml-old">ForItemBinding</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-ForMemberBinding"><span class="deltaxml-old">ForMemberBinding</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e21879.doc-xquery40-ForItemBinding"></a><a id="noid_d4e19350.doc-xquery40-ForBinding"></a>[<span class="deltaxml-old">54</span><span class="deltaxml-new">52</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>ForItemBinding</code></span><span style="display: none;" class="add_version"><code>ForBinding</code></span><span class="modify_version"><code><span class="deltaxml-old">ForItemBinding</span><span class="deltaxml-new">ForBinding</span></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? <a href="#doc-xquery40-AllowingEmpty">AllowingEmpty</a>? <a href="#doc-xquery40-PositionalVar">PositionalVar</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e21880.doc-xquery40-ForMemberBinding"></a><span class="deltaxml-old">[55]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">ForMemberBinding</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"member" "$" </span><a href="#doc-xquery40-VarName"><span class="deltaxml-old">VarName</span></a><a href="#doc-xquery40-TypeDeclaration"><span class="deltaxml-old">TypeDeclaration</span></a><span class="deltaxml-old">? </span><a href="#doc-xquery40-PositionalVar"><span class="deltaxml-old">PositionalVar</span></a><span class="deltaxml-old">? "in" </span><a href="#doc-xquery40-ExprSingle"><span class="deltaxml-old">ExprSingle</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e21881.doc-xquery40-LetClause"></a><a id="noid_d4e19351.doc-xquery40-LetClause"></a>[<span class="deltaxml-old">58</span><span class="deltaxml-new">57</span>]&nbsp;&nbsp;&nbsp;</td><td><code>LetClause</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"let" <a href="#doc-xquery40-LetBinding">LetBinding</a> ("," <a href="#doc-xquery40-LetBinding">LetBinding</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e21882.doc-xquery40-LetBinding"></a><a id="noid_d4e19352.doc-xquery40-LetBinding"></a>[<span class="deltaxml-old">59</span><span class="deltaxml-new">58</span>]&nbsp;&nbsp;&nbsp;</td><td><code>LetBinding</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? ":=" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeDeclaration"></a>[<span class="deltaxml-old">224</span><span class="deltaxml-new">211</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"as" <a href="#doc-xquery40-SequenceType">SequenceType</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AllowingEmpty"></a>[<span class="deltaxml-old">56</span><span class="deltaxml-new">53</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AllowingEmpty">AllowingEmpty</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"allowing" "empty"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PositionalVar"></a>[<span class="deltaxml-old">57</span><span class="deltaxml-new">56</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-PositionalVar">PositionalVar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"at" "$" <a href="#doc-xquery40-VarName">VarName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-WindowClause"></a>[<span class="deltaxml-old">60</span><span class="deltaxml-new">59</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-WindowClause">WindowClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"for" (<a href="#doc-xquery40-TumblingWindowClause">TumblingWindowClause</a> | <a href="#doc-xquery40-SlidingWindowClause">SlidingWindowClause</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TumblingWindowClause"></a>[<span class="deltaxml-old">61</span><span class="deltaxml-new">60</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-TumblingWindowClause">TumblingWindowClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"tumbling" "window" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a>? <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a>?</code></span><span style="display: none;" class="add_version"><code>"tumbling" "window" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a><a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a>?</code></span><span class="modify_version"><code>"tumbling" "window" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a><span class="deltaxml-old">? </span><a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a>?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SlidingWindowClause"></a>[<span class="deltaxml-old">62</span><span class="deltaxml-new">61</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SlidingWindowClause">SlidingWindowClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"sliding" "window" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a>? <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a></code></span><span style="display: none;" class="add_version"><code>"sliding" "window" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a><a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a></code></span><span class="modify_version"><code>"sliding" "window" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a><span class="deltaxml-old">? </span><a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-WindowStartCondition"></a>[<span class="deltaxml-old">63</span><span class="deltaxml-new">62</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-WindowStartCondition">WindowStartCondition</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"start" <a href="#doc-xquery40-WindowVars">WindowVars</a> ("when" <a href="#doc-xquery40-ExprSingle">ExprSingle</a>)?</code></span><span style="display: none;" class="add_version"><code>"start" <a href="#doc-xquery40-WindowVars">WindowVars</a> "when" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></span><span class="modify_version"><code>"start" <a href="#doc-xquery40-WindowVars">WindowVars</a> <span class="deltaxml-old">(</span>"when" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><span class="deltaxml-old">)?</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-WindowEndCondition"></a>[<span class="deltaxml-old">64</span><span class="deltaxml-new">63</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-WindowEndCondition">WindowEndCondition</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"only"? "end" <a href="#doc-xquery40-WindowVars">WindowVars</a> ("when" <a href="#doc-xquery40-ExprSingle">ExprSingle</a>)?</code></span><span style="display: none;" class="add_version"><code>"only"? "end" <a href="#doc-xquery40-WindowVars">WindowVars</a> "when" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></span><span class="modify_version"><code>"only"? "end" <a href="#doc-xquery40-WindowVars">WindowVars</a> <span class="deltaxml-old">(</span>"when" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><span class="deltaxml-old">)?</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-WindowVars"></a>[<span class="deltaxml-old">65</span><span class="deltaxml-new">64</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-WindowVars">WindowVars</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("$" <a href="#doc-xquery40-CurrentItem">CurrentItem</a>)? <a href="#doc-xquery40-PositionalVar">PositionalVar</a>? ("previous" "$" <a href="#doc-xquery40-PreviousItem">PreviousItem</a>)? ("next" "$" <a href="#doc-xquery40-NextItem">NextItem</a>)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CurrentItem"></a>[<span class="deltaxml-old">66</span><span class="deltaxml-new">65</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CurrentItem">CurrentItem</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PreviousItem"></a>[<span class="deltaxml-old">67</span><span class="deltaxml-new">66</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-PreviousItem">PreviousItem</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NextItem"></a>[<span class="deltaxml-old">68</span><span class="deltaxml-new">67</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NextItem">NextItem</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e21897.doc-xquery40-CountClause"></a><a id="noid_d4e19366.doc-xquery40-CountClause"></a>[<span class="deltaxml-old">69</span><span class="deltaxml-new">68</span>]&nbsp;&nbsp;&nbsp;</td><td><code>CountClause</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"count" "$" <a href="#doc-xquery40-VarName">VarName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e21898.doc-xquery40-WhereClause"></a><a id="noid_d4e19367.doc-xquery40-WhereClause"></a>[<span class="deltaxml-old">70</span><span class="deltaxml-new">69</span>]&nbsp;&nbsp;&nbsp;</td><td><code>WhereClause</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"where" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e21899.doc-xquery40-WhileClause"></a><span class="deltaxml-old">[71]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">WhileClause</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"while" </span><a href="#doc-xquery40-ExprSingle"><span class="deltaxml-old">ExprSingle</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GroupByClause"></a>[<span class="deltaxml-old">72</span><span class="deltaxml-new">70</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-GroupByClause">GroupByClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"group" "by" <a href="#doc-xquery40-GroupingSpecList">GroupingSpecList</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GroupingSpecList"></a>[<span class="deltaxml-old">73</span><span class="deltaxml-new">71</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-GroupingSpecList">GroupingSpecList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-GroupingSpec">GroupingSpec</a> ("," <a href="#doc-xquery40-GroupingSpec">GroupingSpec</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GroupingSpec"></a>[<span class="deltaxml-old">74</span><span class="deltaxml-new">72</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-GroupingSpec">GroupingSpec</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-GroupingVariable">GroupingVariable</a> (<a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? ":=" <a href="#doc-xquery40-ExprSingle">ExprSingle</a>)? ("collation" <a href="#doc-xquery40-URILiteral">URILiteral</a>)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GroupingVariable"></a>[<span class="deltaxml-old">75</span><span class="deltaxml-new">73</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-GroupingVariable">GroupingVariable</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#doc-xquery40-VarName">VarName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e21904.doc-xquery40-OrderByClause"></a><a id="noid_d4e19373.doc-xquery40-OrderByClause"></a>[<span class="deltaxml-old">76</span><span class="deltaxml-new">74</span>]&nbsp;&nbsp;&nbsp;</td><td><code>OrderByClause</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(("order" "by") | ("stable" "order" "by")) <a href="#doc-xquery40-OrderSpecList">OrderSpecList</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-OrderSpecList"></a>[<span class="deltaxml-old">77</span><span class="deltaxml-new">75</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-OrderSpecList">OrderSpecList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-OrderSpec">OrderSpec</a> ("," <a href="#doc-xquery40-OrderSpec">OrderSpec</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-OrderSpec"></a>[<span class="deltaxml-old">78</span><span class="deltaxml-new">76</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-OrderSpec">OrderSpec</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-OrderModifier">OrderModifier</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-OrderModifier"></a>[<span class="deltaxml-old">79</span><span class="deltaxml-new">77</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-OrderModifier">OrderModifier</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("ascending" | "descending")? ("empty" ("greatest" | "least"))? ("collation" <a href="#doc-xquery40-URILiteral">URILiteral</a>)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ReturnClause"></a>[<span class="deltaxml-old">80</span><span class="deltaxml-new">78</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ReturnClause">ReturnClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"return" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody></table><p>The semantics of FLWOR expressions are based on a concept called a <b>tuple stream</b>. [<a id="id-tuple-stream-foobar" title="tuple stream">Definition</a>: A <b>tuple stream</b> is an ordered sequence of zero or more <b>tuples</b>.] [<a id="id-tuple-foobar" title="tuple">Definition</a>: A <b>tuple</b> is a set of zero or more named variables, each of which is bound to a value that is an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a>.] Each tuple stream is homogeneous in the sense that all its tuples contain variables with the same names and the same <a title="static type" class="termref" href="#dt-static-type">static types</a>. The following example illustrates a tuple stream consisting of four tuples, each containing three variables named <code>$x</code>, <code>$y</code>, and <code>$z</code>:</p><div class="exampleInner"><pre>($x = 1003, $y = "Fred", $z = &lt;age&gt;21&lt;/age&gt;) ($x = 1017, $y = "Mary", $z = &lt;age&gt;35&lt;/age&gt;) ($x = 1020, $y = "Bill", $z = &lt;age&gt;18&lt;/age&gt;) ($x = 1024, $y = "John", $z = &lt;age&gt;29&lt;/age&gt;)</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In this section, tuple streams are represented as shown in the above example. Each tuple is on a separate line and is enclosed in parentheses, and the variable bindings inside each tuple are separated by commas. This notation does not represent XQuery syntax, but is simply a representation of a tuple stream for the purpose of defining the semantics of FLWOR expressions.</p></div><p>Tuples and tuple streams are not part of the <a title="data model" class="termref" href="#dt-datamodel">data model</a>. They exist only as conceptual intermediate results during the processing of a FLWOR expression.</p><p>Conceptually, the first clause generates a tuple stream. Each clause between the first clause and the return clause takes the tuple stream generated by the previous clause as input and generates a (possibly different) tuple stream as output. The return clause takes a tuple stream as input and, for each tuple in this tuple stream, generates an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a>; the final result of the FLWOR expression is the ordered concatenation of these <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instances</a>.</p><p>The initial clause in a FLWOR expression may be a <code>for</code>, <code>let</code>, or <code>window</code> clause. Intermediate clauses may be <code>for</code>, <code>let</code>, <code>window</code>, <code>count</code>, <code>where</code>, <code>group by</code>, or <code>order by</code> clauses. These intermediate clauses may be repeated as many times as desired, in any order. The final clause of the FLWOR expression must be a <code>return</code> clause. The semantics of the various clauses are described in the following sections.</p><div class="div3"><h4><a id="id-binding-rules"></a><span class="deltaxml-old">4.15.1</span><span class="deltaxml-new">4.14.1</span> Variable Bindings</h4><p><span style="display: none;" class="delete_version">The following clauses in FLWOR expressions bind values to variables: <code>for</code>, <code>let</code>, <code>window</code>, <code>count</code>, and <code>group by</code>. The binding of variables for <code>for</code>, <code>let</code>, and <code>count</code> is governed by the following rules (the binding of variables in <code>group by</code> is discussed in <a href="#id-group-by"><span class="delete_version"><b>4.15.8 Group By Clause</b></span><span class="modify_version"><b>4.15.8 Group By Clause</b></span></a>, the binding of variables in <code>window</code> clauses is discussed in <a href="#id-windows"><span class="delete_version"><b>4.15.4 Window Clause</b></span><span class="modify_version"><b>4.15.4 Window Clause</b></span></a>):</span><span style="display: none;" class="add_version">The following clauses in FLWOR expressions bind values to variables: <code>for</code>, <code>let</code>, <code>window</code>, <code>count</code>, and <code>group by</code>. The binding of variables for <code>for</code>, <code>let</code>, and <code>count</code> is governed by the following rules (the binding of variables in <code>group by</code> is discussed in <a href="#id-group-by"><span class="add_version"><b>4.14.7 Group By Clause</b></span><span class="modify_version"><b>4.14.7 Group By Clause</b></span></a>, the binding of variables in <code>window</code> clauses is discussed in <a href="#id-windows"><span class="add_version"><b>4.14.4 Window Clause</b></span><span class="modify_version"><b>4.14.4 Window Clause</b></span></a>):</span><span class="modify_version">The following clauses in FLWOR expressions bind values to variables: <code>for</code>, <code>let</code>, <code>window</code>, <code>count</code>, and <code>group by</code>. The binding of variables for <code>for</code>, <code>let</code>, and <code>count</code> is governed by the following rules (the binding of variables in <code>group by</code> is discussed in <a href="#id-group-by"><span style="display: none;" class="delete_version"><b>4.15.8 Group By Clause</b></span><span style="display: none;" class="add_version"><b>4.14.7 Group By Clause</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.8</span><span class="deltaxml-new">4.14.7</span> Group By Clause</b></span></a>, the binding of variables in <code>window</code> clauses is discussed in <a href="#id-windows"><span style="display: none;" class="delete_version"><b>4.15.4 Window Clause</b></span><span style="display: none;" class="add_version"><b>4.14.4 Window Clause</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.4</span><span class="deltaxml-new">4.14.4</span> Window Clause</b></span></a>):</span></p><ol class="enumar"><li><p>The scope of a bound variable includes all subexpressions of the containing FLWOR that appear after the variable binding. The scope does not include the expression to which the variable is bound. The following code fragment, containing two <code>let</code> clauses, illustrates how variable bindings may reference variables that were bound in earlier clauses, or in earlier bindings in the same clause:</p><div class="exampleInner"><pre>let $x := 47, $y := f($x) let $z := g($x, $y)</pre></div></li><li><p>A given variable may be bound more than once in a FLWOR expression, or even within one clause of a FLWOR expression. In such a case, each new binding occludes the previous one, which becomes inaccessible in the remainder of the FLWOR expression.</p></li><li><p> [<a id="dt-type-declaration" title="type declaration">Definition</a>: A variable binding may be accompanied by a <b>type declaration</b>, which consists of the keyword <code>as</code> followed by the static type of the variable, declared using the syntax in <a href="#id-sequencetype-syntax"><b>3.4 Sequence Types</b></a>.] <span>The type declaration defines a required type for the value. At run-time, the supplied value for the variable is converted to the required type by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. If conversion is not possible, </span> a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. For example, the following <code>let</code> clause raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> because the variable <code>$salary</code> has a type declaration that is not satisfied by the value that is bound to it:</p><div class="exampleInner"><pre>let $salary as xs:decimal := "cat"</pre></div><p>The following <code>let</code> clause, however, succeeds, because the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> allow an <code>xs:decimal</code> to be supplied where an <code>xs:double</code> is required:</p><div class="exampleInner"><pre>let $temperature as xs:double := 32.5</pre></div><p>In applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, <a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> does not apply.</p></li><li><p> [<a id="dt-binding-collection" title="binding collection">Definition</a>: In a <code>for</code> clause, when an expression is preceded by the keyword <code>in</code>, the value of that expression is called a <b>binding collection</b>.] The collection may be either a sequence or an array. The <code>for</code> clause iterates over its binding collection, producing multiple bindings for one or more variables. Details on how binding collections are used in <code>for</code> clauses are described in the following sections.</p></li><li><p> [<a id="dt-binding-sequence" title="binding sequence">Definition</a>: In a <code>window</code> clause, when an expression is preceded by the keyword <code>in</code>, the value of that expression is called a <b>binding sequence</b>.] The <code>window</code> clause iterates over its binding sequence, producing multiple bindings for one or more variables. Details on how binding sequences are used in <code>for</code> and <code>window</code> clauses are described in the following sections.</p></li></ol></div><div class="div3"><h4><a id="id-xquery-for-clause"></a><span class="deltaxml-old">4.15.2</span><span class="deltaxml-new">4.14.2</span> For Clause</h4><a id="d3e24879"></a><a id="d3e22130"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause"></a>[<span class="deltaxml-old">52</span><span class="deltaxml-new">51</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ForClause">ForClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"for" <a href="#doc-xquery40-ForBinding">ForBinding</a> ("," <a href="#doc-xquery40-ForBinding">ForBinding</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForBinding"></a><a id="doc-xquery40-ForMemberClause"></a>[<span class="deltaxml-old">53</span><span class="deltaxml-new">54</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-ForBinding">ForBinding</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-ForMemberClause">ForMemberClause</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-ForBinding"><span class="deltaxml-old">ForBinding</span></a><a href="#prod-xquery40-ForMemberClause"><span class="deltaxml-new">ForMemberClause</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-ForItemBinding">ForItemBinding</a> | <a href="#doc-xquery40-ForMemberBinding">ForMemberBinding</a></code></span><span style="display: none;" class="add_version"><code>"for" "member" <a href="#doc-xquery40-ForMemberBinding">ForMemberBinding</a> ("," <a href="#doc-xquery40-ForMemberBinding">ForMemberBinding</a>)*</code></span><span class="modify_version"><code><a href="#doc-xquery40-ForItemBinding"><span class="deltaxml-old">ForItemBinding</span></a><span class="deltaxml-old"> |</span><span class="deltaxml-new">"for" "member"</span> <a href="#doc-xquery40-ForMemberBinding"><span class="deltaxml-new">ForMemberBinding</span></a><span class="deltaxml-new"> ("," </span><a href="#doc-xquery40-ForMemberBinding">ForMemberBinding</a><span class="deltaxml-new">)*</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForItemBinding"></a><a id="doc-xquery40-ForBinding"></a>[<span class="deltaxml-old">54</span><span class="deltaxml-new">52</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-ForItemBinding">ForItemBinding</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-ForBinding">ForBinding</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-ForItemBinding"><span class="deltaxml-old">ForItemBinding</span></a><a href="#prod-xquery40-ForBinding"><span class="deltaxml-new">ForBinding</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? <a href="#doc-xquery40-AllowingEmpty">AllowingEmpty</a>? <a href="#doc-xquery40-PositionalVar">PositionalVar</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForMemberBinding"></a>[55]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ForMemberBinding">ForMemberBinding</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"member" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? <a href="#doc-xquery40-PositionalVar">PositionalVar</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></span><span style="display: none;" class="add_version"><code>"$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? <a href="#doc-xquery40-PositionalVar">PositionalVar</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></span><span class="modify_version"><code>"<span class="deltaxml-old">member" "</span>$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? <a href="#doc-xquery40-PositionalVar">PositionalVar</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22114.doc-xquery40-TypeDeclaration"></a><a id="noid_d4e19582.doc-xquery40-TypeDeclaration"></a>[<span class="deltaxml-old">224</span><span class="deltaxml-new">211</span>]&nbsp;&nbsp;&nbsp;</td><td><code>TypeDeclaration</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"as" <a href="#doc-xquery40-SequenceType">SequenceType</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22115.doc-xquery40-AllowingEmpty"></a><a id="noid_d4e19583.doc-xquery40-AllowingEmpty"></a>[<span class="deltaxml-old">56</span><span class="deltaxml-new">53</span>]&nbsp;&nbsp;&nbsp;</td><td><code>AllowingEmpty</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"allowing" "empty"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22116.doc-xquery40-PositionalVar"></a><a id="noid_d4e19584.doc-xquery40-PositionalVar"></a>[<span class="deltaxml-old">57</span><span class="deltaxml-new">56</span>]&nbsp;&nbsp;&nbsp;</td><td><code>PositionalVar</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"at" "$" <a href="#doc-xquery40-VarName">VarName</a></code></td><td></td></tr></tbody></table><p>A <code>for</code> clause is used for iteration. Each variable in a <code>for</code> clause iterates over a sequence <span>or array</span> and is bound in turn to each item in the sequence, <span>or to each member in the array</span>.</p><p>If a <code>for</code> clause contains multiple variables, it is semantically equivalent to multiple <code>for</code> clauses, each containing one of the variables in the original <code>for</code> clause.</p><p>Example:</p><ul><li><p>The clause</p><div class="exampleInner"><pre>for $x in $expr1, $y in $expr2</pre></div><p>is semantically equivalent to:</p><div class="exampleInner"><pre>for $x in $expr1 for $y in $expr2</pre></div></li><li><p>The clause</p><div class="exampleInner"><pre>for member $x in $expr1, member $y in $expr2</pre></div><p>is semantically equivalent to:</p><div class="exampleInner"><pre>for member $x in $expr1 for member $y in $expr2</pre></div></li></ul><p>Without the <code>member</code> keyword, the expression iterates over the items in a sequence. With the <code>member</code> keyword, it iterates over the members of an array. We refer to the sequence or array generically as the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, and to its items or members as the <code>components</code> of the collection.</p><p><span style="display: none;" class="delete_version">If <code>member</code> is specified, then the corresponding <code>ExprSingle</code> must evaluate to a single array, otherwise a type error is raised [<a title="err:XPTY0141" href="#ERRXPTY0141">err:XPTY0141</a>].</span><span style="display: none;" class="add_version">If <code>member</code> is specified, then the corresponding <code>ExprSingle</code> must evaluate to a single array, otherwise a type error is raised [<a title="err:XPTY0143" href="#ERRXPTY0143">err:XPTY0143</a>].</span><span class="modify_version">If <code>member</code> is specified, then the corresponding <code>ExprSingle</code> must evaluate to a single array, otherwise a type error is raised [<a title="err:XPTY0141" href="#ERRXPTY0141"><span class="deltaxml-old">err:XPTY0141</span></a><a title="err:XPTY0143" href="#ERRXPTY0143"><span class="deltaxml-new">err:XPTY0143</span></a>].</span></p><p>In the remainder of this section, we define the semantics of a <code>for</code> clause containing a single variable and an associated expression (following the keyword <code>in</code>) whose value is the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> for that variable.</p><p>If a single-variable <code>for</code> clause is the initial clause in a FLWOR expression, it iterates over its <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, binding the variable to each component in turn. The resulting sequence of variable bindings becomes the initial tuple stream that serves as input to the next clause of the FLWOR expression. If <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the order of tuples in the tuple stream preserves the order of the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>; otherwise the order of the tuple stream is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p><span style="display: none;" class="delete_version">If the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding collection</a> is empty, the output tuple stream depends on whether <code>allowing empty</code> is specified. If <code>allowing empty</code> is specified, the output tuple stream consists of one tuple in which the variable is bound to an empty sequence. This option is not available with "for member". If <code>allowing empty</code> is not specified, the output tuple stream consists of zero tuples.</span><span style="display: none;" class="add_version">If the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding collection</a> is empty, the output tuple stream depends on whether <code>allowing empty</code> is specified. If <code>allowing empty</code> is specified, the output tuple stream consists of one tuple in which the variable is bound to an empty sequence. If <code>allowing empty</code> is not specified, the output tuple stream consists of zero tuples.</span><span class="modify_version">If the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding collection</a> is empty, the output tuple stream depends on whether <code>allowing empty</code> is specified. If <code>allowing empty</code> is specified, the output tuple stream consists of one tuple in which the variable is bound to an empty sequence. <span class="deltaxml-old">This option is not available with "for member". </span>If <code>allowing empty</code> is not specified, the output tuple stream consists of zero tuples.</span></p><p>The following examples illustrates tuple streams that are generated by initial <code>for</code> clauses:</p><ul><li><p>Initial clause:</p><div class="exampleInner"><pre>for $x in (100, 200, 300)</pre></div><p>or (equivalently):</p><div class="exampleInner"><pre>for $x allowing empty in (100, 200, 300)</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre>($x = 100) ($x = 200) ($x = 300)</pre></div></li><li><p>Initial clause:</p><div class="exampleInner"><pre>for $x in ()</pre></div><p>Output tuple stream contains no tuples.</p></li><li><p>Initial clause:</p><div class="exampleInner"><pre>for $x allowing empty in ()</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre>($x = ())</pre></div></li><li><p>Initial clause:</p><div class="exampleInner"><pre>for member $x in [1, 2, (5 to 10)</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre>($x = (1)) ($x = (2)) ($x = (5, 6, 7, 8, 9, 10)</pre></div></li><li><p>Initial clause:</p><div class="exampleInner"><pre>for member $x in []</pre></div><p>Output tuple stream contains no tuples.</p></li><li><p>Initial clause:</p><div class="exampleInner"><pre><span class="deltaxml-old">for member $x allowing empty in []</span></pre><pre><span class="deltaxml-new">for member $x allowing empty in [] </span></pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre>($x = ())</pre></div></li></ul><p> [<a id="dt-positional-variable" title="positional variable">Definition</a>: A <b>positional variable</b> is a variable that is preceded by the keyword <code>at</code>.] A positional variable may be associated with a variable that is bound in a <code>for</code> clause. In this case, as the main variable iterates over the components of its <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, the positional variable iterates over the integers that represent the ordinal numbers of these component in the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, starting with one. Each tuple in the output tuple stream contains bindings for both the main variable and the positional variable. If the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> is empty and <code>allowing empty</code> is specified, the positional variable in the output tuple is bound to the integer zero. Positional variables always have the implied type <code>xs:integer</code>.</p><p>The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of a positional variable must be distinct from the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the main variable with which it is associated [<a href="#ERRXQST0089" title="err:XQST0089">err:XQST0089</a>].</p><p>The following examples illustrate how a positional variable would have affected the results of the previous examples that generated tuples:</p><ul><li><p>Initial clause:</p><div class="exampleInner"><pre>for $x at $i in (100, 200, 300)</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre>($x = 100, $i = 1) ($x = 200, $i = 2) ($x = 300, $i = 3)</pre></div></li><li><p>Initial clause:</p><div class="exampleInner"><pre>for $x at $i in [1 to 3, 11 to 13, 21 to 23</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre>($x = (1, 2, 3), $i = 1) ($x = (11, 12, 13), $i = 2) ($x = (21, 22, 23), $i = 3)</pre></div></li><li><p>Initial clause:</p><div class="exampleInner"><pre>for $x allowing empty at $i in ()</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre>($x = (), $i = 0)</pre></div></li></ul><p>If a single-variable <code>for</code> clause is an intermediate clause in a FLWOR expression, its <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> is evaluated for each input tuple, given the bindings in that input tuple. Each input tuple generates zero or more tuples in the output tuple stream. Each of these output tuples consists of the original variable bindings of the input tuple plus a binding of the new variable to one of the items in its <a title="binding collection" class="termref" href="#dt-binding-collection">binding collecction</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Although the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> is conceptually evaluated independently for each input tuple, an optimized implementation may sometimes be able to avoid re-evaluating the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> if it can show that the variables that the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> depends on have the same values as in a previous evaluation.</p></div><p><span style="display: none;" class="delete_version">For a given input tuple, if the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> for the new variable in the <code>for</code> clause <span>is empty (that is, it is an empty sequence or an empty array depending on whether <code>member</code> is specified)</span>, and if <code>allowing empty</code> is not specified, the input tuple generates zero output tuples (it is not represented in the output tuple stream.)</span><span style="display: none;" class="add_version">For a given input tuple, if the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> for the new variable in the <code>for</code> clause <span>is empty (that is, it is an empty sequence or an empty array depending on whether <code>member</code> is specified)</span>, the result depends on whether <code>allowing empty</code> is specified. If <code>allowing empty</code> is specified, the input tuple generates one output tuple, with the original variable bindings plus a binding of the new variable to an empty sequence. If <code>allowing empty</code> is not specified, the input tuple generates zero output tuples (it is not represented in the output tuple stream.)</span><span class="modify_version">For a given input tuple, if the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> for the new variable in the <code>for</code> clause <span>is empty (that is, it is an empty sequence or an empty array depending on whether <code>member</code> is specified)</span>, <span class="deltaxml-old">and if</span><span class="deltaxml-new">the result depends on whether</span> <code>allowing empty</code> is <span class="deltaxml-new">specified. If </span><code><span class="deltaxml-new">allowing empty</span></code><span class="deltaxml-new"> is specified, the input tuple generates one output tuple, with the original variable bindings plus a binding of the new variable to an empty sequence. If </span><code><span class="deltaxml-new">allowing empty</span></code><span class="deltaxml-new"> is </span>not specified, the input tuple generates zero output tuples (it is not represented in the output tuple stream.)</span></p><p><span class="deltaxml-old">The </span><code><span class="deltaxml-old">allowing empty</span></code><span class="deltaxml-old"> option is available only when processing sequences, not when processing arrays. The effect is that if the binding collection is an empty sequence, the input tuple generates one output tuple, with the original variable bindings plus a binding of the new variable to an empty sequence.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">If a type declaration is present and </span><code><span class="deltaxml-old">allowing empty</span></code><span class="deltaxml-old"> is specified, the type declaration should include an occurrence indicator of </span><code><span class="deltaxml-old">"?"</span></code><span class="deltaxml-old"> to indicate that the variable may be bound to an empty sequence.</span></p></div><p>If the new variable introduced by a <code>for</code> clause has an associated <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a>, the output tuples generated by the <code>for</code> clause also contain bindings for the <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a>. In this case, as the new variable is bound to each item in its <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, the <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a> is bound to the ordinal position of that item within the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, starting with one. Note that, since the <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a> represents a position within a <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, the output tuples corresponding to each input tuple are independently numbered, starting with one. For a given input tuple, if the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> is empty and <code>allowing empty</code> is specified, the <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a> in the output tuple is bound to the integer zero.</p><p>If <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the tuples in the output tuple stream are ordered primarily by the order of the input tuples from which they are derived, and secondarily by the order of the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> for the new variable; otherwise the order of the output tuple stream is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p>The following examples illustrates the effects of intermediate <code>for</code> clauses:</p><ul><li><p>Input tuple stream:</p><div class="exampleInner"><pre>($x = 1) ($x = 2) ($x = 3) ($x = 4)</pre></div><p>Intermediate <code>for</code> clause:</p><div class="exampleInner"><pre>for $y in ($x to 3)</pre></div><p>Output tuple stream (assuming <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>):</p><div class="exampleInner"><pre><span class="deltaxml-old">($x = 1, $y = 1) ($x = 1, $y = 2) ($x = 1, $y = 3) ($x = 2, $y = 2) ($x = 2, $y = 3) ($x = 3, $y = 3)</span></pre><pre><span class="deltaxml-new">($x = 1, $y = 1) ($x = 1, $y = 2) ($x = 1, $y = 3) ($x = 2, $y = 2) ($x = 2, $y = 3) ($x = 3, $y = 3) </span></pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In this example, there is no output tuple that corresponds to the input tuple <code>($x = 4)</code> because, when the <code>for</code> clause is evaluated with the bindings in this input tuple, the resulting <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> for <code>$y</code> is empty.</p></div></li><li><p>This example shows how the previous example would have been affected by a <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a> (assuming the same input tuple stream):</p><div class="exampleInner"><pre>for $y at $j in ($x to 3)</pre></div><p>Output tuple stream (assuming <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>):</p><div class="exampleInner"><pre><span class="deltaxml-old">($x = 1, $y = 1, $j = 1) ($x = 1, $y = 2, $j = 2) ($x = 1, $y = 3, $j = 3) ($x = 2, $y = 2, $j = 1) ($x = 2, $y = 3, $j = 2) ($x = 3, $y = 3, $j = 1)</span></pre><pre><span class="deltaxml-new">($x = 1, $y = 1, $j = 1) ($x = 1, $y = 2, $j = 2) ($x = 1, $y = 3, $j = 3) ($x = 2, $y = 2, $j = 1) ($x = 2, $y = 3, $j = 2) ($x = 3, $y = 3, $j = 1) </span></pre></div></li><li><p><span style="display: none;" class="delete_version">This example shows how the previous example would have been affected by <code>allowing empty</code>. Note that <code>allowing empty</code> causes the input tuple <code>($x = 4)</code> to be represented in the output tuple stream, even though the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> for <code>$y</code> contains no items for this input tuple. This example illustrates that <code>allowing empty</code> in a <code>for</code> clause serves a purpose similar to that of an “outer join” in a relational database query. (Assume the same input tuple stream as in the previous example.)</span><span style="display: none;" class="add_version">This example shows how the previous example would have been affected by <code>allowing empty</code>. Note that <code>allowing empty</code> causes the input tuple <code>($x = 4)</code> to be represented in the output tuple stream, even though the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> for <code>$y</code> contains no items for this input tuple. This example illustrates that <code>allowing empty</code> in a <code>for</code> clause serves a purpose similar to that of an "outer join" in a relational database query. (Assume the same input tuple stream as in the previous example.)</span><span class="modify_version">This example shows how the previous example would have been affected by <code>allowing empty</code>. Note that <code>allowing empty</code> causes the input tuple <code>($x = 4)</code> to be represented in the output tuple stream, even though the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> for <code>$y</code> contains no items for this input tuple. This example illustrates that <code>allowing empty</code> in a <code>for</code> clause serves a purpose similar to that of an <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>outer join<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> in a relational database query. (Assume the same input tuple stream as in the previous example.)</span></p><div class="exampleInner"><pre>for $y allowing empty at $j in ($x to 3)</pre></div><p>Output tuple stream (assuming <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>):</p><div class="exampleInner"><pre><span class="deltaxml-old">($x = 1, $y = 1, $j = 1) ($x = 1, $y = 2, $j = 2) ($x = 1, $y = 3, $j = 3) ($x = 2, $y = 2, $j = 1) ($x = 2, $y = 3, $j = 2) ($x = 3, $y = 3, $j = 1) ($x = 4, $y = (), $j = 0)</span></pre><pre><span class="deltaxml-new">($x = 1, $y = 1, $j = 1) ($x = 1, $y = 2, $j = 2) ($x = 1, $y = 3, $j = 3) ($x = 2, $y = 2, $j = 1) ($x = 2, $y = 3, $j = 2) ($x = 3, $y = 3, $j = 1) ($x = 4, $y = (), $j = 0) </span></pre></div></li><li><p>This example illustrates processing of arrays:</p><p>Input tuple stream:</p><div class="exampleInner"><pre>($x = 1) ($x = 2) ($x = 3)</pre></div><p>Intermediate <code>for</code> clause:</p><div class="exampleInner"><pre><span class="deltaxml-old">for member $y in [[$x+1, $x+2], [[$x+3, $x+4]]</span></pre><pre><span class="deltaxml-new">for member $y in [[$x+1, $x+2], [[$x+3, $x+4]] </span></pre></div><p>Output tuple stream (assuming <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>):</p><div class="exampleInner"><pre><span class="deltaxml-old">($x = 1, $y = [2, 3]) ($x = 1, $y = [4, 5]) ($x = 2, $y = [3, 4]) ($x = 2, $y = [5, 6]) ($x = 3, $y = [4, 5]) ($x = 3, $y = [6, 7])</span></pre><pre><span class="deltaxml-new">($x = 1, $y = [2, 3]) ($x = 1, $y = [4, 5]) ($x = 2, $y = [3, 4]) ($x = 2, $y = [5, 6]) ($x = 3, $y = [4, 5]) ($x = 3, $y = [6, 7]) </span></pre></div></li><li><p>This example shows how a <code>for</code> clause that binds two variables is semantically equivalent to two <code>for</code> clauses that bind one variable each. We assume that this <code>for</code> clause occurs at the beginning of a FLWOR expression. It is equivalent to an initial single-variable <code>for</code> clause that provides an input tuple stream to an intermediate single-variable <code>for</code> clause.</p><div class="exampleInner"><pre>for $x in (1, 2, 3, 4), $y in ($x to 3)</pre></div><p>Output tuple stream (assuming <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>):</p><div class="exampleInner"><pre><span class="deltaxml-old">($x = 1, $y = 1) ($x = 1, $y = 2) ($x = 1, $y = 3) ($x = 2, $y = 2) ($x = 2, $y = 3) ($x = 3, $y = 3)</span></pre><pre><span class="deltaxml-new">($x = 1, $y = 1) ($x = 1, $y = 2) ($x = 1, $y = 3) ($x = 2, $y = 2) ($x = 2, $y = 3) ($x = 3, $y = 3) </span></pre></div></li></ul><p>In the above examples, if <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> had been <code>unordered</code>, the output tuple streams would have consisted of the same tuples, with the same values for the <a title="positional variable" class="termref" href="#dt-positional-variable">positional variables</a>, but the ordering of the tuples would have been <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p><span style="display: none;" class="delete_version">A <code>for</code> clause may contain one or more <a title="type declaration" class="termref" href="#dt-type-declaration">type declarations</a>, identified by the keyword <code>as</code>. The semantics of <a title="type declaration" class="termref" href="#dt-type-declaration">type declarations</a> are defined in <a href="#id-binding-rules"><span class="delete_version"><b>4.15.1 Variable Bindings</b></span><span class="modify_version"><b>4.15.1 Variable Bindings</b></span></a>.</span><span style="display: none;" class="add_version">A <code>for</code> clause may contain one or more <a title="type declaration" class="termref" href="#dt-type-declaration">type declarations</a>, identified by the keyword <code>as</code>. The semantics of <a title="type declaration" class="termref" href="#dt-type-declaration">type declarations</a> are defined in <a href="#id-binding-rules"><span class="add_version"><b>4.14.1 Variable Bindings</b></span><span class="modify_version"><b>4.14.1 Variable Bindings</b></span></a>.</span><span class="modify_version">A <code>for</code> clause may contain one or more <a title="type declaration" class="termref" href="#dt-type-declaration">type declarations</a>, identified by the keyword <code>as</code>. The semantics of <a title="type declaration" class="termref" href="#dt-type-declaration">type declarations</a> are defined in <a href="#id-binding-rules"><span style="display: none;" class="delete_version"><b>4.15.1 Variable Bindings</b></span><span style="display: none;" class="add_version"><b>4.14.1 Variable Bindings</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.1</span><span class="deltaxml-new">4.14.1</span> Variable Bindings</b></span></a>.</span></p></div><div class="div3"><h4><a id="id-xquery-let-clause"></a><span class="deltaxml-old">4.15.3</span><span class="deltaxml-new">4.14.3</span> Let Clause</h4><a id="d3e25406"></a><a id="d3e22651"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LetClause"></a>[<span class="deltaxml-old">58</span><span class="deltaxml-new">57</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-LetClause">LetClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"let" <a href="#doc-xquery40-LetBinding">LetBinding</a> ("," <a href="#doc-xquery40-LetBinding">LetBinding</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LetBinding"></a>[<span class="deltaxml-old">59</span><span class="deltaxml-new">58</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-LetBinding">LetBinding</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? ":=" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22574.doc-xquery40-TypeDeclaration"></a><a id="noid_d4e20036.doc-xquery40-TypeDeclaration"></a>[<span class="deltaxml-old">224</span><span class="deltaxml-new">211</span>]&nbsp;&nbsp;&nbsp;</td><td><code>TypeDeclaration</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"as" <a href="#doc-xquery40-SequenceType">SequenceType</a></code></td><td></td></tr></tbody></table><p>The purpose of a <code>let</code> clause is to bind values to one or more variables. Each variable is bound to the result of evaluating an expression.</p><p>If a <code>let</code> clause contains multiple variables, it is semantically equivalent to multiple <code>let</code> clauses, each containing a single variable. For example, the clause</p><div class="exampleInner"><pre>let $x := $expr1, $y := $expr2</pre></div><p>is semantically equivalent to the following sequence of clauses:</p><div class="exampleInner"><pre>let $x := $expr1 let $y := $expr2</pre></div><p>In the remainder of this section, we define the semantics of a <code>let</code> clause containing a single variable <em>V</em> and an associated expression <em>E</em>.</p><p>If a single-variable <code>let</code> clause is the initial clause in a FLWOR expression, it simply binds the variable <em>V</em> to the result of the expression <em>E</em>. The result of the <code>let</code> clause is a tuple stream consisting of one tuple with a single binding that binds <em>V</em> to the result of <em>E</em>. This tuple stream serves as input to the next clause in the FLWOR expression.</p><p>If a single-variable <code>let</code> clause is an intermediate clause in a FLWOR expression, it adds a new binding for variable <em>V</em> to each tuple in the input tuple stream. For each input tuple, the value bound to <em>V</em> is the result of evaluating expression <em>E</em>, given the bindings that are already present in that input tuple. The resulting tuples become the output tuple stream of the <code>let</code> clause.</p><p>The number of tuples in the output tuple stream of an intermediate <code>let</code> clause is the same as the number of tuples in the input tuple stream. The number of bindings in the output tuples is one more than the number of bindings in the input tuples, unless the input tuples already contain bindings for <em>V</em>; in this case, the new binding for <em>V</em> occludes (replaces) the earlier binding for <em>V</em>, and the number of bindings is unchanged.</p><p><span style="display: none;" class="delete_version">A <code>let</code> clause may contain one or more <a title="type declaration" class="termref" href="#dt-type-declaration">type declarations</a>, identified by the keyword <code>as</code>. The semantics of type declarations are defined in <a href="#id-binding-rules"><span class="delete_version"><b>4.15.1 Variable Bindings</b></span><span class="modify_version"><b>4.15.1 Variable Bindings</b></span></a>.</span><span style="display: none;" class="add_version">A <code>let</code> clause may contain one or more <a title="type declaration" class="termref" href="#dt-type-declaration">type declarations</a>, identified by the keyword <code>as</code>. The semantics of type declarations are defined in <a href="#id-binding-rules"><span class="add_version"><b>4.14.1 Variable Bindings</b></span><span class="modify_version"><b>4.14.1 Variable Bindings</b></span></a>.</span><span class="modify_version">A <code>let</code> clause may contain one or more <a title="type declaration" class="termref" href="#dt-type-declaration">type declarations</a>, identified by the keyword <code>as</code>. The semantics of type declarations are defined in <a href="#id-binding-rules"><span style="display: none;" class="delete_version"><b>4.15.1 Variable Bindings</b></span><span style="display: none;" class="add_version"><b>4.14.1 Variable Bindings</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.1</span><span class="deltaxml-new">4.14.1</span> Variable Bindings</b></span></a>.</span></p><p>The following code fragment illustrates how a <code>for</code> clause and a <code>let</code> clause can be used together. The <code>for</code> clause produces an initial tuple stream containing a binding for variable <code>$d</code> to each department number found in a given input document. The <code>let</code> clause adds an additional binding to each tuple, binding variable <code>$e</code> to a sequence of employees whose department number matches the value of <code>$d</code> in that tuple.</p><div class="exampleInner"><pre><span class="deltaxml-old">for $d in doc("depts.xml")/depts/deptno let $e := doc("emps.xml")/emps/emp[deptno eq $d]</span></pre><pre><span class="deltaxml-new">for $d in fn:doc("depts.xml")/depts/deptno let $e := fn:doc("emps.xml")/emps/emp[deptno eq $d]</span></pre></div></div><div class="div3"><h4><a id="id-windows"></a><span class="deltaxml-old">4.15.4</span><span class="deltaxml-new">4.14.4</span> Window Clause</h4><a id="d3e25531"></a><a id="d3e22776"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22670.doc-xquery40-WindowClause"></a><a id="noid_d4e20132.doc-xquery40-WindowClause"></a>[<span class="deltaxml-old">60</span><span class="deltaxml-new">59</span>]&nbsp;&nbsp;&nbsp;</td><td><code>WindowClause</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"for" (<a href="#doc-xquery40-TumblingWindowClause">TumblingWindowClause</a> | <a href="#doc-xquery40-SlidingWindowClause">SlidingWindowClause</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22671.doc-xquery40-TumblingWindowClause"></a><a id="noid_d4e20133.doc-xquery40-TumblingWindowClause"></a>[<span class="deltaxml-old">61</span><span class="deltaxml-new">60</span>]&nbsp;&nbsp;&nbsp;</td><td><code>TumblingWindowClause</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"tumbling" "window" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a>? <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a>?</code></span><span style="display: none;" class="add_version"><code>"tumbling" "window" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a><a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a>?</code></span><span class="modify_version"><code>"tumbling" "window" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a><span class="deltaxml-old">? </span><a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a>?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22672.doc-xquery40-SlidingWindowClause"></a><a id="noid_d4e20134.doc-xquery40-SlidingWindowClause"></a>[<span class="deltaxml-old">62</span><span class="deltaxml-new">61</span>]&nbsp;&nbsp;&nbsp;</td><td><code>SlidingWindowClause</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"sliding" "window" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a>? <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a></code></span><span style="display: none;" class="add_version"><code>"sliding" "window" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a><a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a></code></span><span class="modify_version"><code>"sliding" "window" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a><span class="deltaxml-old">? </span><a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22673.doc-xquery40-WindowStartCondition"></a><a id="noid_d4e20135.doc-xquery40-WindowStartCondition"></a>[<span class="deltaxml-old">63</span><span class="deltaxml-new">62</span>]&nbsp;&nbsp;&nbsp;</td><td><code>WindowStartCondition</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"start" <a href="#doc-xquery40-WindowVars">WindowVars</a> ("when" <a href="#doc-xquery40-ExprSingle">ExprSingle</a>)?</code></span><span style="display: none;" class="add_version"><code>"start" <a href="#doc-xquery40-WindowVars">WindowVars</a> "when" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></span><span class="modify_version"><code>"start" <a href="#doc-xquery40-WindowVars">WindowVars</a> <span class="deltaxml-old">(</span>"when" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><span class="deltaxml-old">)?</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22674.doc-xquery40-WindowEndCondition"></a><a id="noid_d4e20136.doc-xquery40-WindowEndCondition"></a>[<span class="deltaxml-old">64</span><span class="deltaxml-new">63</span>]&nbsp;&nbsp;&nbsp;</td><td><code>WindowEndCondition</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"only"? "end" <a href="#doc-xquery40-WindowVars">WindowVars</a> ("when" <a href="#doc-xquery40-ExprSingle">ExprSingle</a>)?</code></span><span style="display: none;" class="add_version"><code>"only"? "end" <a href="#doc-xquery40-WindowVars">WindowVars</a> "when" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></span><span class="modify_version"><code>"only"? "end" <a href="#doc-xquery40-WindowVars">WindowVars</a> <span class="deltaxml-old">(</span>"when" <a href="#doc-xquery40-ExprSingle">ExprSingle</a><span class="deltaxml-old">)?</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22675.doc-xquery40-WindowVars"></a><a id="noid_d4e20137.doc-xquery40-WindowVars"></a>[<span class="deltaxml-old">65</span><span class="deltaxml-new">64</span>]&nbsp;&nbsp;&nbsp;</td><td><code>WindowVars</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("$" <a href="#doc-xquery40-CurrentItem">CurrentItem</a>)? <a href="#doc-xquery40-PositionalVar">PositionalVar</a>? ("previous" "$" <a href="#doc-xquery40-PreviousItem">PreviousItem</a>)? ("next" "$" <a href="#doc-xquery40-NextItem">NextItem</a>)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22676.doc-xquery40-CurrentItem"></a><a id="noid_d4e20138.doc-xquery40-CurrentItem"></a>[<span class="deltaxml-old">66</span><span class="deltaxml-new">65</span>]&nbsp;&nbsp;&nbsp;</td><td><code>CurrentItem</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22677.doc-xquery40-PositionalVar"></a><a id="noid_d4e20139.doc-xquery40-PositionalVar"></a>[<span class="deltaxml-old">57</span><span class="deltaxml-new">56</span>]&nbsp;&nbsp;&nbsp;</td><td><code>PositionalVar</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"at" "$" <a href="#doc-xquery40-VarName">VarName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22678.doc-xquery40-PreviousItem"></a><a id="noid_d4e20140.doc-xquery40-PreviousItem"></a>[<span class="deltaxml-old">67</span><span class="deltaxml-new">66</span>]&nbsp;&nbsp;&nbsp;</td><td><code>PreviousItem</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e22679.doc-xquery40-NextItem"></a><a id="noid_d4e20141.doc-xquery40-NextItem"></a>[<span class="deltaxml-old">68</span><span class="deltaxml-new">67</span>]&nbsp;&nbsp;&nbsp;</td><td><code>NextItem</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody></table><p>Like a <code>for</code> clause, a <code>window</code> clause iterates over its <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> and generates a sequence of tuples. In the case of a <code>window</code> clause, each tuple represents a window. [<a id="dt-window" title="window">Definition</a>: A <b>window</b> is a sequence of consecutive items drawn from the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>.] Each window is represented by at least one and at most nine bound variables. The variables have user-specified names, but their roles are as follows:</p><ul><li><p><em>Window-variable:</em> Bound to the sequence of items from the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> that comprise the window.</p></li><li><p><em>Start-item:</em> (Optional) Bound to the first item in the window.</p></li><li><p><em>Start-item-position:</em> (Optional) Bound to the ordinal position of the first window item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>. <em>Start-item-position</em> is a <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a>; hence, its type is <code>xs:integer</code></p></li><li><p><em>Start-previous-item:</em> (Optional) Bound to the item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> that precedes the first item in the window (empty sequence if none).</p></li><li><p><em>Start-next-item:</em> (Optional) Bound to the item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> that follows the first item in the window (empty sequence if none).</p></li><li><p><em>End-item:</em> (Optional) Bound to the last item in the window.</p></li><li><p><em>End-item-position:</em> (Optional) Bound to the ordinal position of the last window item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>. <em>End-item-position</em> is a <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a>; hence, its type is <code>xs:integer</code></p></li><li><p><em>End-previous-item:</em> (Optional) Bound to the item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> that precedes the last item in the window (empty sequence if none).</p></li><li><p><em>End-next-item:</em> (Optional) Bound to the item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> that follows the last item in the window (empty sequence if none).</p></li></ul><p>All variables in a <code>window</code> clause must have distinct names; otherwise a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0103" title="err:XQST0103">err:XQST0103</a>].</p><p>The following is an example of a <code>window</code> clause that binds nine variables to the roles listed above. In this example, the variables are named <code>$w</code>, <code>$s</code>, <code>$spos</code>, <code>$sprev</code>, <code>$snext</code>, <code>$e</code>, <code>$epos</code>, <code>$eprev</code>, and <code>$enext</code> respectively. A <code>window</code> clause always binds the window variable, but typically binds only a subset of the other variables.</p><div class="exampleInner"><pre>for tumbling window $w in (2, 4, 6, 8, 10) start $s at $spos previous $sprev next $snext when true() end $e at $epos previous $eprev next $enext when true()</pre></div><p><span style="display: none;" class="delete_version">Windows are created by iterating over the items in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>, in order, identifying the start item and the end item of each window by evaluating the <a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a> and the <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a>. Each of these conditions is satisfied if the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of the expression following the <code>when</code> keyword is <code>true</code>. The start item of the window is an item that satisfies the <a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a> (see <a href="#id-tumbling-windows"><span class="delete_version"><b>4.15.4.1 Tumbling Windows</b></span><span class="modify_version"><b>4.15.4.1 Tumbling Windows</b></span></a> and <a href="#id-sliding-windows"><span class="delete_version"><b>4.15.4.2 Sliding Windows</b></span><span class="modify_version"><b>4.15.4.2 Sliding Windows</b></span></a> for a more complete explanation.) The end item of the window is the first item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>, beginning with the start item, that satisfies the <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a> (again, see <a href="#id-tumbling-windows"><span class="delete_version"><b>4.15.4.1 Tumbling Windows</b></span><span class="modify_version"><b>4.15.4.1 Tumbling Windows</b></span></a> and <a href="#id-sliding-windows"><span class="delete_version"><b>4.15.4.2 Sliding Windows</b></span><span class="modify_version"><b>4.15.4.2 Sliding Windows</b></span></a> for more details.) Each window contains its start item, its end item, and all items that occur between them in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>. If the end item is the start item, then the window contains only one item. If a start item is identified, but no following item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> satisfies the <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a>, then the <code>only</code> keyword determines whether a window is generated: if <code>only end</code> is specified, then no window is generated; otherwise, the end item is set to the last item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> and a window is generated.</span><span style="display: none;" class="add_version">Windows are created by iterating over the items in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>, in order, identifying the start item and the end item of each window by evaluating the <a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a> and the <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a>. Each of these conditions is satisfied if the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of the expression following the <code>when</code> keyword is <code>true</code>. The start item of the window is an item that satisfies the <a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a> (see <a href="#id-tumbling-windows"><span class="add_version"><b>4.14.4.1 Tumbling Windows</b></span><span class="modify_version"><b>4.14.4.1 Tumbling Windows</b></span></a> and <a href="#id-sliding-windows"><span class="add_version"><b>4.14.4.2 Sliding Windows</b></span><span class="modify_version"><b>4.14.4.2 Sliding Windows</b></span></a> for a more complete explanation.) The end item of the window is the first item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>, beginning with the start item, that satisfies the <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a> (again, see <a href="#id-tumbling-windows"><span class="add_version"><b>4.14.4.1 Tumbling Windows</b></span><span class="modify_version"><b>4.14.4.1 Tumbling Windows</b></span></a> and <a href="#id-sliding-windows"><span class="add_version"><b>4.14.4.2 Sliding Windows</b></span><span class="modify_version"><b>4.14.4.2 Sliding Windows</b></span></a> for more details.) Each window contains its start item, its end item, and all items that occur between them in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>. If the end item is the start item, then the window contains only one item. If a start item is identified, but no following item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> satisfies the <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a>, then the <code>only</code> keyword determines whether a window is generated: if <code>only end</code> is specified, then no window is generated; otherwise, the end item is set to the last item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> and a window is generated.</span><span class="modify_version">Windows are created by iterating over the items in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>, in order, identifying the start item and the end item of each window by evaluating the <a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a> and the <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a>. Each of these conditions is satisfied if the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of the expression following the <code>when</code> keyword is <code>true</code>. The start item of the window is an item that satisfies the <a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a> (see <a href="#id-tumbling-windows"><span style="display: none;" class="delete_version"><b>4.15.4.1 Tumbling Windows</b></span><span style="display: none;" class="add_version"><b>4.14.4.1 Tumbling Windows</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.4.1</span><span class="deltaxml-new">4.14.4.1</span> Tumbling Windows</b></span></a> and <a href="#id-sliding-windows"><span style="display: none;" class="delete_version"><b>4.15.4.2 Sliding Windows</b></span><span style="display: none;" class="add_version"><b>4.14.4.2 Sliding Windows</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.4.2</span><span class="deltaxml-new">4.14.4.2</span> Sliding Windows</b></span></a> for a more complete explanation.) The end item of the window is the first item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>, beginning with the start item, that satisfies the <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a> (again, see <a href="#id-tumbling-windows"><span style="display: none;" class="delete_version"><b>4.15.4.1 Tumbling Windows</b></span><span style="display: none;" class="add_version"><b>4.14.4.1 Tumbling Windows</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.4.1</span><span class="deltaxml-new">4.14.4.1</span> Tumbling Windows</b></span></a> and <a href="#id-sliding-windows"><span style="display: none;" class="delete_version"><b>4.15.4.2 Sliding Windows</b></span><span style="display: none;" class="add_version"><b>4.14.4.2 Sliding Windows</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.4.2</span><span class="deltaxml-new">4.14.4.2</span> Sliding Windows</b></span></a> for more details.) Each window contains its start item, its end item, and all items that occur between them in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>. If the end item is the start item, then the window contains only one item. If a start item is identified, but no following item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> satisfies the <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a>, then the <code>only</code> keyword determines whether a window is generated: if <code>only end</code> is specified, then no window is generated; otherwise, the end item is set to the last item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> and a window is generated.</span></p><p>In the above example, the <a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a> and <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a> are both <code>true</code>, which causes each item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> to be in a separate window. Typically, the <a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a> and <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a> are expressed in terms of bound variables. For example, the following <a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a> might be used to start a new window for every item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> that is larger than both the previous item and the following item:</p><div class="exampleInner"><pre>start $s previous $sprev next $snext when $s &gt; $sprev and $s &gt; $snext</pre></div><p>The scoping rules for the variables bound by a <code>window</code> clause are as follows:</p><ul><li><p>In the <code>when</code>-expression of the <a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a>, the following variables (identified here by their roles) are in scope (if bound): <em>start-item, start-item-position, start-previous-item, start-next-item.</em></p></li><li><p>In the <code>when</code>-expression of the <a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a>, the following variables (identified here by their roles) are in scope (if bound): <em>start-item, start-item-position, start-previous-item, start-next-item, end-item, end-item-position, end-previous-item, end-next-item.</em></p></li><li><p>In the clauses of the FLWOR expression that follow the <code>window</code> clause, all nine of the variables bound by the <code>window</code> clause (including <em>window-variable</em>) are in scope (if bound).</p></li></ul><p><span class="deltaxml-old">The </span><code><span class="deltaxml-old">when</span></code><span class="deltaxml-old"> keyword of a condition and the associated expression is optional. If omitted, the expression defaults to </span><code><span class="deltaxml-old">true()</span></code><span class="deltaxml-old">. If the complete </span><code><span class="deltaxml-old">start</span></code><span class="deltaxml-old"> clause is omitted, no variables are bound and the expression also defaults to </span><code><span class="deltaxml-old">true()</span></code><span class="deltaxml-old">. The </span><code><span class="deltaxml-old">end</span></code><span class="deltaxml-old"> clause can be omitted only within a </span><a href="#doc-xquery40-TumblingWindowClause"><span class="deltaxml-old">TumblingWindowClause</span></a><span class="deltaxml-old">.</span></p><p>In a <code>window</code> clause, the keyword <code>tumbling</code> or <code>sliding</code> determines the way in which the starting item of each window is identified, as explained in the following sections.</p><div class="div4"><h5><a id="id-tumbling-windows"></a><span class="deltaxml-old">4.15.4.1</span><span class="deltaxml-new">4.14.4.1</span> Tumbling Windows</h5><p><span style="display: none;" class="delete_version">If the window type is <code>tumbling</code>, then windows never overlap. The search for the start of the first window begins at the beginning of the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>. After each window is generated, the search for the start of the next window begins with the item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> that occurs after the ending item of the last generated window. Thus, no item that occurs in one window can occur in another window drawn from the same <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> (unless the sequence contains the same item more than once). In a tumbling window clause, the <code>end</code> clause is optional; if it is omitted, the <code>start</code> clause is applied to identify all potential starting items in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>, and a window is constructed for each starting item, including all items from that starting item up to the item before the next window’s starting item, or the end of the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>, whichever comes first.</span><span style="display: none;" class="add_version">If the window type is <code>tumbling</code>, then windows never overlap. The search for the start of the first window begins at the beginning of the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>. After each window is generated, the search for the start of the next window begins with the item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> that occurs after the ending item of the last generated window. Thus, no item that occurs in one window can occur in another window drawn from the same <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> (unless the sequence contains the same item more than once). In a tumbling window clause, the <code>end</code> clause is optional; if it is omitted, the <code>start</code> clause is applied to identify all potential starting items in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>, and a window is constructed for each starting item, including all items from that starting item up to the item before the next window's starting item, or the end of the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>, whichever comes first.</span><span class="modify_version">If the window type is <code>tumbling</code>, then windows never overlap. The search for the start of the first window begins at the beginning of the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>. After each window is generated, the search for the start of the next window begins with the item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> that occurs after the ending item of the last generated window. Thus, no item that occurs in one window can occur in another window drawn from the same <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> (unless the sequence contains the same item more than once). In a tumbling window clause, the <code>end</code> clause is optional; if it is omitted, the <code>start</code> clause is applied to identify all potential starting items in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>, and a window is constructed for each starting item, including all items from that starting item up to the item before the next <span class="deltaxml-old">window’s</span><span class="deltaxml-new">window's</span> starting item, or the end of the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>, whichever comes first.</span></p><p>The following examples illustrate the use of tumbling windows.</p><ul><li><p>Show non-overlapping windows of three items.</p><div class="exampleInner"><pre><span class="deltaxml-old">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14) start at $s only end at $e when $e - $s eq 2 return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre><pre><span class="deltaxml-new">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14) start at $s when fn:true() only end at $e when $e - $s eq 2 return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre></div><p>Result<span class="deltaxml-new"> of the above query</span>:</p><div class="exampleInner"><pre>&lt;window&gt;2 4 6&lt;/window&gt; &lt;window&gt;8 10 12&lt;/window&gt;</pre></div></li><li><p>Show averages of non-overlapping three-item windows.</p><div class="exampleInner"><pre><span class="deltaxml-old">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14) start at $s only end at $e when $e - $s eq 2 return avg($w)</span></pre><pre><span class="deltaxml-new">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14) start at $s when fn:true() only end at $e when $e - $s eq 2 return avg($w)</span></pre></div><p>Result<span class="deltaxml-new"> of the above query</span>:</p><div class="exampleInner"><pre>4 10</pre></div></li><li><p>Show first and last items in each window of three items.</p><div class="exampleInner"><pre><span class="deltaxml-old">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14) start $first at $s only end $last at $e when $e - $s eq 2 return &lt;window&gt;{ $first, $last }&lt;/window&gt;</span></pre><pre><span class="deltaxml-new">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14) start $first at $s when fn:true() only end $last at $e when $e - $s eq 2 return &lt;window&gt;{ $first, $last }&lt;/window&gt;</span></pre></div><p>Result<span class="deltaxml-new"> of the above query</span>:</p><div class="exampleInner"><pre>&lt;window&gt;2 6&lt;/window&gt; &lt;window&gt;8 12&lt;/window&gt;</pre></div></li><li><p>Show non-overlapping windows of up to three items (illustrates <code>end</code> clause without the <code>only</code> keyword).</p><div class="exampleInner"><pre><span class="deltaxml-old">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14) start at $s end at $e when $e - $s eq 2 return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre><pre><span class="deltaxml-new">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14) start at $s when fn:true() end at $e when $e - $s eq 2 return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre></div><p>Result<span class="deltaxml-new"> of the above query</span>:</p><div class="exampleInner"><pre>&lt;window&gt;2 4 6&lt;/window&gt; &lt;window&gt;8 10 12&lt;/window&gt; &lt;window&gt;14&lt;/window&gt;</pre></div></li><li><p>Show non-overlapping windows of up to three items (illustrates use of <code>start</code> without explicit <code>end</code>).</p><div class="exampleInner"><pre>for tumbling window $w in (2, 4, 6, 8, 10, 12, 14) start at $s when $s mod 3 = 1 return &lt;window&gt;{ $w }&lt;/window&gt;</pre></div><p>Result<span class="deltaxml-new"> of the above query</span>:</p><div class="exampleInner"><pre>&lt;window&gt;2 4 6&lt;/window&gt; &lt;window&gt;8 10 12&lt;/window&gt; &lt;window&gt;14&lt;/window&gt;</pre></div></li><li><p>Show non-overlapping sequences starting with a number divisible by 3.</p><div class="exampleInner"><pre><span class="deltaxml-old">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14) start $first when $first mod 3 = 2 return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre><pre><span class="deltaxml-new">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14) start $first when $first mod 3 = 0 return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre></div><p>Result<span class="deltaxml-new"> of the above query</span>:</p><div class="exampleInner"><pre><span class="deltaxml-old">&lt;window&gt;2 4 6&lt;/window&gt; &lt;window&gt;8 10 12&lt;/window&gt; &lt;window&gt;14&lt;/window&gt;</span></pre><pre><span class="deltaxml-new">&lt;window&gt;6 8 10&lt;/window&gt; &lt;window&gt;12 14&lt;/window&gt;</span></pre></div></li><li class="delete_version" style="display: none;"><p>Show non-overlapping sequences ending with a number divisible by 3.</p><div class="exampleInner"><pre>for tumbling window $w in (2, 4, 6, 8, 10, 12, 14) end $last when $last mod 3 = 0 return &lt;window&gt;{ $w }&lt;/window&gt;</pre></div><p>Result (identical to the result of the previous query):</p><div class="exampleInner"><pre>&lt;window&gt;2 4 6&lt;/window&gt; &lt;window&gt;8 10 12&lt;/window&gt; &lt;window&gt;14&lt;/window&gt;</pre></div></li><li class="modify_version"><p><span class="deltaxml-old">Show non-overlapping sequences ending with a number divisible by 3.</span></p><div class="exampleInner"><pre><span class="deltaxml-old">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14) end $last when $last mod 3 = 0 return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre></div><p><span class="deltaxml-old">Result (identical to the result of the previous query):</span></p><div class="exampleInner"><pre><span class="deltaxml-old">&lt;window&gt;2 4 6&lt;/window&gt; &lt;window&gt;8 10 12&lt;/window&gt; &lt;window&gt;14&lt;/window&gt;</span></pre></div></li></ul></div><div class="div4"><h5><a id="id-sliding-windows"></a><span class="deltaxml-old">4.15.4.2</span><span class="deltaxml-new">4.14.4.2</span> Sliding Windows</h5><p>If the window type is <code>sliding window</code>, then windows may overlap. Every item in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> that satisfies the <a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a> is the starting item of a new window. Thus, a given item may be found in multiple windows drawn from the same <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>.</p><p>The following examples illustrate the use of sliding windows.</p><ul><li><p>Show windows of three items.</p><div class="exampleInner"><pre><span class="deltaxml-old">for sliding window $w in (2, 4, 6, 8, 10, 12, 14) start at $s only end at $e when $e - $s eq 2 return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre><pre><span class="deltaxml-new">for sliding window $w in (2, 4, 6, 8, 10, 12, 14) start at $s when fn:true() only end at $e when $e - $s eq 2 return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre></div><p>Result<span class="deltaxml-new"> of the above query</span>:</p><div class="exampleInner"><pre>&lt;window&gt;2 4 6&lt;/window&gt; &lt;window&gt;4 6 8&lt;/window&gt; &lt;window&gt;6 8 10&lt;/window&gt; &lt;window&gt;8 10 12&lt;/window&gt; &lt;window&gt;10 12 14&lt;/window&gt;</pre></div></li><li><p>Show moving averages of three items.</p><div class="exampleInner"><pre><span class="deltaxml-old">for sliding window $w in (2, 4, 6, 8, 10, 12, 14) start at $s only end at $e when $e - $s eq 2 return avg($w)</span></pre><pre><span class="deltaxml-new">for sliding window $w in (2, 4, 6, 8, 10, 12, 14) start at $s when fn:true() only end at $e when $e - $s eq 2 return avg($w)</span></pre></div><p>Result<span class="deltaxml-new"> of the above query</span>:</p><div class="exampleInner"><pre>4 6 8 10 12</pre></div></li><li><p>Show overlapping windows of up to three items (illustrates <code>end</code> clause without the <code>only</code> keyword).</p><div class="exampleInner"><pre><span class="deltaxml-old">for sliding window $w in (2, 4, 6, 8, 10, 12, 14) start at $s end at $e when $e - $s eq 2 return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre><pre><span class="deltaxml-new">for sliding window $w in (2, 4, 6, 8, 10, 12, 14) start at $s when fn:true() end at $e when $e - $s eq 2 return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre></div><p>Result<span class="deltaxml-new"> of the above query</span>:</p><div class="exampleInner"><pre>&lt;window&gt;2 4 6&lt;/window&gt; &lt;window&gt;4 6 8&lt;/window&gt; &lt;window&gt;6 8 10&lt;/window&gt; &lt;window&gt;8 10 12&lt;/window&gt; &lt;window&gt;10 12 14&lt;/window&gt; &lt;window&gt;12 14&lt;/window&gt; &lt;window&gt;14&lt;/window&gt;</pre></div></li></ul></div><div class="div4"><h5><a id="id-effects-of-window-clauses"></a><span class="deltaxml-old">4.15.4.3</span><span class="deltaxml-new">4.14.4.3</span> Effects of Window Clauses on the Tuple Stream</h5><p><span style="display: none;" class="delete_version">The effects of a <code>window</code> clause on the tuple stream are similar to the effects of a <code>for</code> clause. As described in <a href="#id-windows"><span class="delete_version"><b>4.15.4 Window Clause</b></span><span class="modify_version"><b>4.15.4 Window Clause</b></span></a>, a <code>window</code> clause generates zero or more windows, each of which is represented by at least one and at most nine bound variables.</span><span style="display: none;" class="add_version">The effects of a <code>window</code> clause on the tuple stream are similar to the effects of a <code>for</code> clause. As described in <a href="#id-windows"><span class="add_version"><b>4.14.4 Window Clause</b></span><span class="modify_version"><b>4.14.4 Window Clause</b></span></a>, a <code>window</code> clause generates zero or more windows, each of which is represented by at least one and at most nine bound variables.</span><span class="modify_version">The effects of a <code>window</code> clause on the tuple stream are similar to the effects of a <code>for</code> clause. As described in <a href="#id-windows"><span style="display: none;" class="delete_version"><b>4.15.4 Window Clause</b></span><span style="display: none;" class="add_version"><b>4.14.4 Window Clause</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.4</span><span class="deltaxml-new">4.14.4</span> Window Clause</b></span></a>, a <code>window</code> clause generates zero or more windows, each of which is represented by at least one and at most nine bound variables.</span></p><p>If the <code>window</code> clause is the initial clause in a FLWOR expression, the bound variables that describe each window become an output tuple. These tuples form the initial tuple stream that serves as input to the next clause of the FLWOR expression. If <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the order of tuples in the tuple stream is the order in which their start items appear in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>; otherwise the order of the tuple stream is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. The cardinality of the tuple stream is equal to the number of windows.</p><p>If a <code>window</code> clause is an intermediate clause in a FLWOR expression, each input tuple generates zero or more output tuples, each consisting of the original bound variables of the input tuple plus the new bound variables that represent one of the generated windows. For each tuple <em>T</em> in the input tuple stream, the output tuple stream will contain <em>N<sub>T</sub></em> tuples, where <em>N<sub>T</sub></em> is the number of windows generated by the <code>window</code> clause, given the bindings in the input tuple <em>T</em>. Input tuples for which no windows are generated are not represented in the output tuple stream. If <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the order of tuples in the output stream is determined primarily by the order of the input tuples from which they were derived, and secondarily by the order in which their start items appear in the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>. If <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>unordered</code>, the order of tuples in the output stream is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p>The following example illustrates a <code>window</code> clause that is the initial clause in a FLWOR expression. The example is based on input data that consists of a sequence of closing stock prices for a specific company. For this example we assume the following input data (assume that the <code>price</code> elements have a validated type of <code>xs:decimal</code>):</p><div class="exampleInner"><pre>&lt;stock&gt; &lt;closing&gt; &lt;date&gt;2008-01-01&lt;/date&gt; &lt;price&gt;105&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;date&gt;2008-01-02&lt;/date&gt; &lt;price&gt;101&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;date&gt;2008-01-03&lt;/date&gt; &lt;price&gt;102&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;date&gt;2008-01-04&lt;/date&gt; &lt;price&gt;103&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;date&gt;2008-01-05&lt;/date&gt; &lt;price&gt;102&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;date&gt;2008-01-06&lt;/date&gt; &lt;price&gt;104&lt;/price&gt; &lt;/closing&gt; &lt;/stock&gt;</pre></div><p>A user wishes to find <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>run-ups,<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> which are defined as sequences of dates that begin with a <span class="deltaxml-old">“low”</span><span class="deltaxml-new">"low"</span> and end with a <span class="deltaxml-old">“high”</span><span class="deltaxml-new">"high"</span> price (that is, the stock price begins to rise on the first day of the run-up, and continues to rise or remain even through the last day of the run-up.) The following query uses a tumbling window to find run-ups in the input data:</p><div class="exampleInner"><pre><span class="deltaxml-old">for tumbling window $w in //closing start $first next $second when $first/price &lt; $second/price end $last next $beyond when $last/price &gt; $beyond/price return &lt;run-up&gt; &lt;start-date&gt;{data($first/date)}&lt;/start-date&gt; &lt;start-price&gt;{data($first/price)}&lt;/start-price&gt; &lt;end-date&gt;{data($last/date)}&lt;/end-date&gt; &lt;end-price&gt;{data($last/price)}&lt;/end-price&gt; &lt;/run-up&gt;</span></pre><pre><span class="deltaxml-new">for tumbling window $w in //closing start $first next $second when $first/price &lt; $second/price end $last next $beyond when $last/price &gt; $beyond/price return &lt;run-up&gt; &lt;start-date&gt;{fn:data($first/date)}&lt;/start-date&gt; &lt;start-price&gt;{fn:data($first/price)}&lt;/start-price&gt; &lt;end-date&gt;{fn:data($last/date)}&lt;/end-date&gt; &lt;end-price&gt;{fn:data($last/price)}&lt;/end-price&gt; &lt;/run-up&gt;</span></pre></div><p>For our sample input data, this <code>tumbling window</code> clause generates a tuple stream consisting of two tuples, each representing a window and containing five bound variables named <code>$w</code>, <code>$first</code>, <code>$second</code>, <code>$last</code>, and <code>$beyond</code>. The <code>return</code> clause is evaluated for each of these tuples, generating the following query result:</p><div class="exampleInner"><pre>&lt;run-up&gt; &lt;start-date&gt;2008-01-02&lt;/start-date&gt; &lt;start-price&gt;101&lt;/start-price&gt; &lt;end-date&gt;2008-01-04&lt;/end-date&gt; &lt;end-price&gt;103&lt;/end-price&gt; &lt;/run-up&gt; &lt;run-up&gt; &lt;start-date&gt;2008-01-05&lt;/start-date&gt; &lt;start-price&gt;102&lt;/start-price&gt; &lt;end-date&gt;2008-01-06&lt;/end-date&gt; &lt;end-price&gt;104&lt;/end-price&gt; &lt;/run-up&gt;</pre></div><p>The following example illustrates a <code>window</code> clause that is an intermediate clause in a FLWOR expression. In this example, the input data contains closing stock prices for several different companies, each identified by a three-letter symbol. We assume the following input data (again assuming that the type of the <code>price</code> element is <code>xs:decimal</code>):</p><div class="exampleInner"><pre>&lt;stocks&gt; &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-01&lt;/date&gt; &lt;price&gt;105&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-01&lt;/date&gt; &lt;price&gt;057&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-02&lt;/date&gt; &lt;price&gt;101&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-02&lt;/date&gt; &lt;price&gt;054&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-03&lt;/date&gt; &lt;price&gt;102&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-03&lt;/date&gt; &lt;price&gt;056&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-04&lt;/date&gt; &lt;price&gt;103&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-04&lt;/date&gt; &lt;price&gt;052&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-05&lt;/date&gt; &lt;price&gt;101&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-05&lt;/date&gt; &lt;price&gt;055&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-06&lt;/date&gt; &lt;price&gt;104&lt;/price&gt; &lt;/closing&gt; &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-06&lt;/date&gt; &lt;price&gt;059&lt;/price&gt; &lt;/closing&gt; &lt;/stocks&gt;</pre></div><p>As in the previous example, we want to find "run-ups," which are defined as sequences of dates that begin with a "low" and end with a "high" price for a specific company. In this example, however, the input data consists of stock prices for multiple companies. Therefore it is necessary to isolate the stock prices of each company before forming windows. This can be accomplished by an initial <code>for</code> and <code>let</code> clause, followed by a <code>window</code> clause, as follows:</p><div class="exampleInner"><pre><span class="deltaxml-old">for $symbol in distinct-values(//symbol) let $closings := //closing[symbol = $symbol] for tumbling window $w in $closings start $first next $second when $first/price &lt; $second/price end $last next $beyond when $last/price &gt; $beyond/price return &lt;run-up symbol="{$symbol}"&gt; &lt;start-date&gt;{data($first/date)}&lt;/start-date&gt; &lt;start-price&gt;{data($first/price)}&lt;/start-price&gt; &lt;end-date&gt;{data($last/date)}&lt;/end-date&gt; &lt;end-price&gt;{data($last/price)}&lt;/end-price&gt; &lt;/run-up&gt;</span></pre><pre><span class="deltaxml-new">for $symbol in fn:distinct-values(//symbol) let $closings := //closing[symbol = $symbol] for tumbling window $w in $closings start $first next $second when $first/price &lt; $second/price end $last next $beyond when $last/price &gt; $beyond/price return &lt;run-up symbol="{$symbol}"&gt; &lt;start-date&gt;{fn:data($first/date)}&lt;/start-date&gt; &lt;start-price&gt;{fn:data($first/price)}&lt;/start-price&gt; &lt;end-date&gt;{fn:data($last/date)}&lt;/end-date&gt; &lt;end-price&gt;{fn:data($last/price)}&lt;/end-price&gt; &lt;/run-up&gt;</span></pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In the above example, the <code>for</code> and <code>let</code> clauses could be rewritten as follows:</p><div class="exampleInner"><pre>for $closings in //closing let $symbol := $closings/symbol group by $symbol</pre></div><p><span style="display: none;" class="delete_version">The <code>group by</code> clause is described in <a href="#id-group-by"><span class="delete_version"><b>4.15.8 Group By Clause</b></span><span class="modify_version"><b>4.15.8 Group By Clause</b></span></a>.</span><span style="display: none;" class="add_version">The <code>group by</code> clause is described in <a href="#id-group-by"><span class="add_version"><b>4.14.7 Group By Clause</b></span><span class="modify_version"><b>4.14.7 Group By Clause</b></span></a>.</span><span class="modify_version">The <code>group by</code> clause is described in <a href="#id-group-by"><span style="display: none;" class="delete_version"><b>4.15.8 Group By Clause</b></span><span style="display: none;" class="add_version"><b>4.14.7 Group By Clause</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.8</span><span class="deltaxml-new">4.14.7</span> Group By Clause</b></span></a>.</span></p></div><p>The <code>for</code> and <code>let</code> clauses in this query generate an initial tuple stream consisting of two tuples. In the first tuple, <code>$symbol</code> is bound to "ABC" and <code>$closings</code> is bound to the sequence of <code>closing</code> elements for company ABC. In the second tuple, <code>$symbol</code> is bound to "DEF" and <code>$closings</code> is bound to the sequence of <code>closing</code> elements for company DEF.</p><p>The <code>window</code> clause operates on this initial tuple stream, generating two windows for the first tuple and two windows for the second tuple. The result is a tuple stream consisting of four tuples, each with the following bound variables: <code>$symbol</code>, <code>$closings</code>, <code>$w</code>, <code>$first</code>, <code>$second</code>, <code>$last</code>, and <code>$beyond</code>. The <code>return</code> clause is then evaluated for each of these tuples, generating the following query result:</p><div class="exampleInner"><pre>&lt;run-up symbol="ABC"&gt; &lt;start-date&gt;2008-01-02&lt;/start-date&gt; &lt;start-price&gt;101&lt;/start-price&gt; &lt;end-date&gt;2008-01-04&lt;/end-date&gt; &lt;end-price&gt;103&lt;/end-price&gt; &lt;/run-up&gt; &lt;run-up symbol="ABC"&gt; &lt;start-date&gt;2008-01-05&lt;/start-date&gt; &lt;start-price&gt;101&lt;/start-price&gt; &lt;end-date&gt;2008-01-06&lt;/end-date&gt; &lt;end-price&gt;104&lt;/end-price&gt; &lt;/run-up&gt; &lt;run-up symbol="DEF"&gt; &lt;start-date&gt;2008-01-02&lt;/start-date&gt; &lt;start-price&gt;054&lt;/start-price&gt; &lt;end-date&gt;2008-01-03&lt;/end-date&gt; &lt;end-price&gt;056&lt;/end-price&gt; &lt;/run-up&gt; &lt;run-up symbol="DEF"&gt; &lt;start-date&gt;2008-01-04&lt;/start-date&gt; &lt;start-price&gt;052&lt;/start-price&gt; &lt;end-date&gt;2008-01-06&lt;/end-date&gt; &lt;end-price&gt;059&lt;/end-price&gt; &lt;/run-up&gt;</pre></div></div></div><div class="div3"><h4><a id="id-where"></a><span class="deltaxml-old">4.15.5</span><span class="deltaxml-new">4.14.5</span> Where Clause</h4><a id="d3e26229"></a><a id="d3e23451"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-WhereClause"></a>[<span class="deltaxml-old">70</span><span class="deltaxml-new">69</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-WhereClause">WhereClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"where" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody></table><p>A <code>where</code> clause serves as a filter for the tuples in its input tuple stream. The expression in the <code>where</code> clause, called the <b>where-expression</b>, is evaluated once for each of these tuples. If the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of the where-expression is <code>true</code>, the tuple is retained in the output tuple stream; otherwise the tuple is discarded.</p><p>Examples:</p><ul><li><p>This example illustrates the effect of a <code>where</code> clause on a tuple stream:</p><p>Input tuple stream:</p><div class="exampleInner"><pre>($a = 5, $b = 11) ($a = 91, $b = 42) ($a = 17, $b = 30) ($a = 85, $b = 63)</pre></div><p><code>where</code> clause:</p><div class="exampleInner"><pre>where $a &gt; $b</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre>($a = 91, $b = 42) ($a = 85, $b = 63)</pre></div></li><li><p>The following query illustrates how a <code>where</code> clause might be used with a <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a> to perform sampling on an input sequence. The query returns one value out of each one hundred input values.</p><div class="exampleInner"><pre><span class="parse-test">for $x at $i in $inputvalues where $i mod 100 = 0 return $x</span></pre></div></li></ul></div><div class="div3"><h4><a id="id-while"></a><span class="deltaxml-old">4.15.6 While Clause</span></h4><a id="d3e26285"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-WhileClause"></a><span class="deltaxml-old">[71]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-WhileClause"><span class="deltaxml-old">WhileClause</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"while" </span><a href="#doc-xquery40-ExprSingle"><span class="deltaxml-old">ExprSingle</span></a></code></td><td></td></tr></tbody></table><p><span class="deltaxml-old">A </span><code><span class="deltaxml-old">while</span></code><span class="deltaxml-old"> clause serves as a filter for the tuples in its input tuple stream. The expression in the while clause, called the </span><code><span class="deltaxml-old">while-expression</span></code><span class="deltaxml-old">, is evaluated once for each of these tuples. If the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-old">effective boolean value</span></a><span class="deltaxml-old"> of the </span><code><span class="deltaxml-old">while-expression</span></code><span class="deltaxml-old"> is true, the tuple is retained in the output tuple stream; otherwise the tuple and all subsequent tuples in the stream are discarded.</span></p><p><span class="deltaxml-old">Examples:</span></p><ul><li><p><span class="deltaxml-old">This example illustrates the effect of a </span><code><span class="deltaxml-old">while</span></code><span class="deltaxml-old"> clause on a tuple stream.</span></p><p><span class="deltaxml-old">Input tuple stream:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">($a = 13, $b = 11) ($a = 91, $b = 42) ($a = 17, $b = 30) ($a = 85, $b = 63)</span></pre></div><p><span class="deltaxml-old">while clause:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">while $a &gt; $b</span></pre></div><p><span class="deltaxml-old"> Output tuple stream:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">($a = 13, $b = 11) ($a = 91, $b = 42)</span></pre></div></li><li><p><span class="deltaxml-old">The following query illustrates how a </span><code><span class="deltaxml-old">while</span></code><span class="deltaxml-old"> clause might be used to extract all items in an input sequence before the first one that fails to satisfy some condition. In this case it selects the leading </span><code><span class="deltaxml-old">para</span></code><span class="deltaxml-old"> elements in the input sequence, stopping before the first element that is not a </span><code><span class="deltaxml-old">para</span></code><span class="deltaxml-old"> element. </span></p><div class="exampleInner"><pre><span class="deltaxml-old">for $x in $section/* while $x[self::para] return $x</span></pre></div></li><li><p><span class="deltaxml-old">The following query illustrates how a </span><code><span class="deltaxml-old">while</span></code><span class="deltaxml-old"> clause might be used to limit the number of items returned in the query result. </span></p><div class="exampleInner"><pre><span class="deltaxml-old">for $x in $section/para where contains($x, 'the') count $total while $total le 10 return $x</span></pre></div><p><span class="deltaxml-old">In this example a </span><code><span class="deltaxml-old">where</span></code><span class="deltaxml-old"> clause would have exactly the same effect, but might require a smarter optimizer to deliver the same performance.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Although the semantics are described in terms of discarding all the tuples following the first one that fails to match the condition, a practical implementation is likely to avoid evaluating those tuples, thus giving an "early exit" from the iteration performed by the FLWOR expression. </span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The expression </span><code><span class="deltaxml-old">for $i in $input while $i le 3</span></code><span class="deltaxml-old"> differs from the expression </span><code><span class="deltaxml-old">subsequence-where($input, to:=fn{. gt 3})</span></code><span class="deltaxml-old"> in that the </span><code><span class="deltaxml-old">while</span></code><span class="deltaxml-old"> expression drops the first item that is greater than 3, while the </span><code><span class="deltaxml-old">subsequence-where</span></code><span class="deltaxml-old"> expression retains it.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The effect of the </span><code><span class="deltaxml-old">while</span></code><span class="deltaxml-old"> clause is unpredictable in cases where the ordering of the tuple stream is unpredictable. This can happen, for example, when </span><a title="ordering mode" class="termref" href="#dt-ordering-mode"><span class="deltaxml-old">ordering mode</span></a><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">unordered</span></code><span class="deltaxml-old">, or when iterating over the entries in a map.</span></p></div><table class="ednote" caption="Editorial note"><tbody><tr><td style="text-align: left; vertical-align:top; width: 50%;"><b><span class="deltaxml-old">Editorial note</span></b></td><td style="text-align: right; vertical-align:top; width: 50%;"><span class="deltaxml-old">&nbsp;</span></td></tr><tr style="text-align: left; vertical-align: top;"><td colspan="2"><span class="deltaxml-old">Add to changes appendix.</span></td></tr></tbody></table></div><div class="div3"><h4><a id="id-count"></a><span class="deltaxml-old">4.15.7</span><span class="deltaxml-new">4.14.6</span> Count Clause</h4><a id="d3e26369"></a><a id="d3e23507"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CountClause"></a>[<span class="deltaxml-old">69</span><span class="deltaxml-new">68</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CountClause">CountClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"count" "$" <a href="#doc-xquery40-VarName">VarName</a></code></td><td></td></tr></tbody></table><p>The purpose of a <code>count</code> clause is to enhance the tuple stream with a new variable that is bound, in each tuple, to the ordinal position of that tuple in the tuple stream. The name of the new variable is specified in the <code>count</code> clause.</p><p>The output tuple stream of a <code>count</code> clause is the same as its input tuple stream, with each tuple enhanced by one additional variable that is bound to the ordinal position of that tuple in the tuple stream. However, if the name of the new variable is the same as the name of an existing variable in the input tuple stream, the new variable occludes (replaces) the existing variable of the same name, and the number of bound variables in each tuple is unchanged.</p><p>The following examples illustrate uses of the <code>count</code> clause:</p><ul><li><p>This example illustrates the effect of a <code>count</code> clause on an input tuple stream:</p><p>Input tuple stream:</p><div class="exampleInner"><pre>($name = "Bob", $age = 21) ($name = "Carol", $age = 19) ($name = "Ted", $age = 20) ($name = "Alice", $age = 22)</pre></div><p><code>count</code> clause:</p><div class="exampleInner"><pre>count $counter</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre>($name = "Bob", $age = 21, $counter = 1) ($name = "Carol", $age = 19, $counter = 2) ($name = "Ted", $age = 20, $counter = 3) ($name = "Alice", $age = 22, $counter = 4)</pre></div></li><li><p>This example illustrates how a counter might be used to filter the result of a query. The query ranks products in order by decreasing sales, and returns the three products with the highest sales. Assume that the variable <code>$products</code> is bound to a sequence of <code>product</code> elements, each of which has <code>name</code> and <code>sales</code> child-elements.</p><div class="exampleInner"><pre><span class="deltaxml-old">for $p in $products order by $p/sales descending count $rank while $rank &lt;= 3 return &lt;product rank="{$rank}"&gt; {$p/name, $p/sales} &lt;/product&gt;</span></pre><pre><span class="deltaxml-new">for $p in $products order by $p/sales descending count $rank where $rank &lt;= 3 return &lt;product rank="{$rank}"&gt; {$p/name, $p/sales} &lt;/product&gt;</span></pre></div><p>The result of this query has the following structure:</p><div class="exampleInner"><pre>&lt;product rank="1"&gt; &lt;name&gt;Toaster&lt;/name&gt; &lt;sales&gt;968&lt;/sales&gt; &lt;/product&gt; &lt;product rank="2"&gt; &lt;name&gt;Blender&lt;/name&gt; &lt;sales&gt;520&lt;/sales&gt; &lt;/product&gt; &lt;product rank="3"&gt; &lt;name&gt;Can Opener&lt;/name&gt; &lt;sales&gt;475&lt;/sales&gt; &lt;/product&gt;</pre></div></li></ul></div><div class="div3"><h4><a id="id-group-by"></a><span class="deltaxml-old">4.15.8</span><span class="deltaxml-new">4.14.7</span> Group By Clause</h4><a id="d3e26428"></a><a id="d3e23566"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e23447.doc-xquery40-GroupByClause"></a><a id="noid_d4e20808.doc-xquery40-GroupByClause"></a>[<span class="deltaxml-old">72</span><span class="deltaxml-new">70</span>]&nbsp;&nbsp;&nbsp;</td><td><code>GroupByClause</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"group" "by" <a href="#doc-xquery40-GroupingSpecList">GroupingSpecList</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e23448.doc-xquery40-GroupingSpecList"></a><a id="noid_d4e20809.doc-xquery40-GroupingSpecList"></a>[<span class="deltaxml-old">73</span><span class="deltaxml-new">71</span>]&nbsp;&nbsp;&nbsp;</td><td><code>GroupingSpecList</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-GroupingSpec">GroupingSpec</a> ("," <a href="#doc-xquery40-GroupingSpec">GroupingSpec</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e23449.doc-xquery40-GroupingSpec"></a><a id="noid_d4e20810.doc-xquery40-GroupingSpec"></a>[<span class="deltaxml-old">74</span><span class="deltaxml-new">72</span>]&nbsp;&nbsp;&nbsp;</td><td><code>GroupingSpec</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-GroupingVariable">GroupingVariable</a> (<a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? ":=" <a href="#doc-xquery40-ExprSingle">ExprSingle</a>)? ("collation" <a href="#doc-xquery40-URILiteral">URILiteral</a>)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e23450.doc-xquery40-GroupingVariable"></a><a id="noid_d4e20811.doc-xquery40-GroupingVariable"></a>[<span class="deltaxml-old">75</span><span class="deltaxml-new">73</span>]&nbsp;&nbsp;&nbsp;</td><td><code>GroupingVariable</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#doc-xquery40-VarName">VarName</a></code></td><td></td></tr></tbody></table><p>A <code>group by</code> clause generates an output tuple stream in which each tuple represents a group of tuples from the input tuple stream that have equivalent grouping keys. We will refer to the tuples in the input tuple stream as <b>pre-grouping tuples</b>, and the tuples in the output tuple stream as <b>post-grouping tuples</b>.</p><p>The <code>group by</code> clause assigns each pre-grouping tuple to a group, and generates one post-grouping tuple for each group. In the post-grouping tuple for a group, each grouping key is represented by a variable that was specified in a <a href="#doc-xquery40-GroupingSpec">GroupingSpec</a>, and every variable that appears in the pre-grouping tuples that were assigned to that group is represented by a variable of the same name, bound to a sequence of all values bound to the variable in any of these pre-grouping tuples. Subsequent clauses in the FLWOR expression see only the variable bindings in the post-grouping tuples; they no longer have access to the variable bindings in the pre-grouping tuples. The number of post-grouping tuples is less than or equal to the number of pre-grouping tuples.</p><p>A <code>group by</code> clause contains one or more <a href="#doc-xquery40-GroupingSpec">grouping specifications</a>, as shown in the grammar. [<a id="dt-grouping-variable" title="grouping variable">Definition</a>: Each grouping specification specifies one <a href="#doc-xquery40-GroupingVariable">grouping variable</a>, which refers to variable bindings in the pre-grouping tuples. The values of the grouping variables are used to assign pre-grouping tuples to groups.] Each grouping specification may optionally provide an expression to which its grouping variable is bound. If no expression is provided, the grouping variable name must be equal (by the <code>eq</code> operator on <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a>) to the name of a variable in the input tuple stream, and it refers to that variable; otherwise a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0094" title="err:XQST0094">err:XQST0094</a>]. For each grouping specification that contains a binding expression, a <code>let</code> binding is created in the pre-grouping tuples, and the grouping variable refers to that <code>let</code> binding. For example, the clause:</p><div class="exampleInner"><pre>group by $g1, $g2 := $expr1, $g3 := $expr2 collation "Spanish"</pre></div><p>is semantically equivalent to the following sequence of clauses:</p><div class="exampleInner"><pre>let $g2 := $expr1 let $g3 := $expr2 group by $g1, $g2, $g3 collation "Spanish"</pre></div><p>The process of group formation proceeds as follows: </p><ol class="enumar"><li><p> [<a id="dt-grouping-key" title="grouping key">Definition</a>: The atomized value of a <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a> is called a <b>grouping key</b>.] For each pre-grouping tuple, the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping keys</a> are created by <a title="atomization" class="termref" href="#dt-atomization">atomizing</a> the values of the <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variables</a> (in the post-grouping tuples, each grouping variable is set to the value of the corresponding grouping key, as discussed below). If the value of any <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a> consists of more than one item, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. If a type declaration is present and the resulting atomized value is not an instance of the specified type, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p><span style="display: none;" class="delete_version">The input tuple stream is partitioned into groups of tuples whose grouping keys are <a title="equivalent grouping keys" class="termref" href="#dt-equivalent-grouping-keys">equivalent</a>. [<a id="dt-equivalent-grouping-keys" title="equivalent grouping keys">Definition</a>: Two tuples <var>T<sub>1</sub></var> and <var>T<sub>2</sub></var> have <b>equivalent grouping keys</b> if and only if, for each grouping variable <var>GV</var>, the atomized value of <var>GV</var> in <var>T<sub>1</sub></var> is deep-equal to the atomized value of <var>GV</var> in <var>T<sub>2</sub></var>, as defined by applying the function <code>fn:deep-equal</code> using the appropriate collation.] </span><span style="display: none;" class="add_version">The input tuple stream is partitioned into groups of tuples whose grouping keys are <a title="equivalent grouping keys" class="termref" href="#dt-equivalent-grouping-keys">equivalent</a>. [<a id="dt-equivalent-grouping-keys" title="equivalent grouping keys">Definition</a>: Two tuples <var>T<sub>1</sub></var> and <var>T<sub>2</sub></var> have <b>equivalent grouping keys</b> if and only if, for each grouping variable <var>GV</var>, the atomized value of <var>GV</var> in <var>T<sub>1</sub></var> is deep-equal to the atomized value of <var>GV</var> in <var>T<sub>2</sub></var>, as defined by applying the function <code>fn:deep-equal</code> using the appropriate collation.] If these values are of different numeric types, and differ from each other by small amounts, then the deep-equal relationship is not transitive, because of rounding effects occurring during type promotion. When comparing three values <code>A</code>, <code>B</code>, and <code>C</code> such that <code>A eq B</code>, <code>B eq C</code>, but <code>A ne C</code>, then the number of items in the result of the function (as well as the choice of which items are returned) is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, subject only to the constraints that (a) no two items in the result sequence compare equal to each other, and (b) every input item that does not appear in the result sequence compares equal to some item that does appear in the result sequence. See <a href="https://www.w3.org/TR/xpath-functions-31/#func-distinct-values">Section 14.2.1 fn:distinct-values </a><sup><small>FO31</small></sup> for further discussion of this issue in a different context.</span><span class="modify_version">The input tuple stream is partitioned into groups of tuples whose grouping keys are <a title="equivalent grouping keys" class="termref" href="#dt-equivalent-grouping-keys">equivalent</a>. [<a id="dt-equivalent-grouping-keys" title="equivalent grouping keys">Definition</a>: Two tuples <var>T<sub>1</sub></var> and <var>T<sub>2</sub></var> have <b>equivalent grouping keys</b> if and only if, for each grouping variable <var>GV</var>, the atomized value of <var>GV</var> in <var>T<sub>1</sub></var> is deep-equal to the atomized value of <var>GV</var> in <var>T<sub>2</sub></var>, as defined by applying the function <code>fn:deep-equal</code> using the appropriate collation.] <span class="deltaxml-new">If these values are of different numeric types, and differ from each other by small amounts, then the deep-equal relationship is not transitive, because of rounding effects occurring during type promotion. When comparing three values </span><code><span class="deltaxml-new">A</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">B</span></code><span class="deltaxml-new">, and </span><code><span class="deltaxml-new">C</span></code><span class="deltaxml-new"> such that </span><code><span class="deltaxml-new">A eq B</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">B eq C</span></code><span class="deltaxml-new">, but </span><code><span class="deltaxml-new">A ne C</span></code><span class="deltaxml-new">, then the number of items in the result of the function (as well as the choice of which items are returned) is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new">implementation-dependent</span></a><span class="deltaxml-new">, subject only to the constraints that (a) no two items in the result sequence compare equal to each other, and (b) every input item that does not appear in the result sequence compares equal to some item that does appear in the result sequence. See </span><a href="https://www.w3.org/TR/xpath-functions-31/#func-distinct-values"><span class="deltaxml-new">Section 14.2.1 fn:distinct-values </span></a><sup><small><span class="deltaxml-new">FO31</span></small></sup><span class="deltaxml-new"> for further discussion of this issue in a different context.</span></span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The </span><code><span class="deltaxml-old">fn:deep-equal</span></code><span class="deltaxml-old"> has been changed in XQuery 4.0 so that it is now transitive; the problem that existed in earlier versions when comparing numeric values of different types has thereby been resolved.</span></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The atomized grouping key will always be either an empty sequence or a single atomic value. Defining equivalence by reference to the <code>fn:deep-equal</code> function ensures that the empty sequence is equivalent only to the empty sequence, that <code>NaN</code> is equivalent to <code>NaN</code>, that untypedAtomic values are compared as strings, and that values for which the <code>eq</code> operator is not defined are considered non-equivalent.</p></div></li><li><p><span style="display: none;" class="delete_version">The appropriate collation for comparing two grouping keys is the collation specified in the pertinent <a href="#doc-xquery40-GroupingSpec">GroupingSpec</a> if present, or the default collation from the <span>dynamic</span> context otherwise. If the collation is specified by a relative URI, that relative URI is <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved to an absolute URI</a> using the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a>. If the specified collation is not found in statically known collations, a static error is raised [<a href="#ERRXQST0076" title="err:XQST0076">err:XQST0076</a>].</span><span style="display: none;" class="add_version">The appropriate collation for comparing two grouping keys is the collation specified in the pertinent <a href="#doc-xquery40-GroupingSpec">GroupingSpec</a> if present, or the default collation from the static context otherwise. If the collation is specified by a relative URI, that relative URI is <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved to an absolute URI</a> using the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a>. If the specified collation is not found in statically known collations, a static error is raised [<a href="#ERRXQST0076" title="err:XQST0076">err:XQST0076</a>].</span><span class="modify_version">The appropriate collation for comparing two grouping keys is the collation specified in the pertinent <a href="#doc-xquery40-GroupingSpec">GroupingSpec</a> if present, or the default collation from the <span class="deltaxml-old">dynamic</span><span class="deltaxml-new">static</span> context otherwise. If the collation is specified by a relative URI, that relative URI is <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved to an absolute URI</a> using the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a>. If the specified collation is not found in statically known collations, a static error is raised [<a href="#ERRXQST0076" title="err:XQST0076">err:XQST0076</a>].</span></p></li></ol><p><span style="display: none;" class="delete_version">Each group of tuples produced by the above process results in one post-grouping tuple. The pre-grouping tuples from which the group is derived have <em>equivalent</em><a title="grouping key" class="termref" href="#dt-grouping-key">grouping keys</a>, but these keys are not necessarily identical (for example, the strings <code>"Frog"</code> and <code>"frog"</code> might be <em>equivalent</em> according to the collation in use.) In the post-grouping tuple, each <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a> is bound to the value of the corresponding grouping key. </span><span style="display: none;" class="add_version">Each group of tuples produced by the above process results in one post-grouping tuple. The pre-grouping tuples from which the group is derived have <em>equivalent</em><a title="grouping key" class="termref" href="#dt-grouping-key">grouping keys</a>, but these keys are not necessarily identical (for example, the strings "Frog" and "frog" might be <em>equivalent</em> according to the collation in use.) In the post-grouping tuple, each <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a> is bound to the value of the corresponding grouping key. </span><span class="modify_version">Each group of tuples produced by the above process results in one post-grouping tuple. The pre-grouping tuples from which the group is derived have <em>equivalent</em><a title="grouping key" class="termref" href="#dt-grouping-key">grouping keys</a>, but these keys are not necessarily identical (for example, the strings "Frog" and "frog" might be <em>equivalent</em> according to the collation in use.) In the post-grouping tuple, each <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a> is bound to the value of the corresponding grouping key. </span></p><p>In the post-grouping tuple generated for a given group, each non-grouping variable is bound to a sequence containing the concatenated values of that variable in all the pre-grouping tuples that were assigned to that group. If <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the values derived from individual tuples are concatenated in a way that preserves the order of the pre-grouping tuple stream; otherwise the ordering of these values is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This behavior may be surprising to SQL programmers, since SQL reduces the equivalent of a non-grouping variable to one representative value. Consider the following query:</p><div class="exampleInner"><pre>let $x := 64000 for $c in //customer where $c/salary &gt; $x group by $d := $c/department return &lt;department name="{$d}"&gt; Number of employees earning more than ${$x} is {count($c)} &lt;/department&gt;</pre></div><p>If there are three qualifying customers in the sales department this evaluates to:</p><div class="exampleInner"><pre> &lt;department name="sales"&gt; Number of employees earning more than $64000 64000 64000 is 3 &lt;/department&gt;</pre></div><p>In XQuery, each group is a sequence of items that match the group by criteria—in a tree-structured language like XQuery, this is convenient, because further structures can be built based on the items in this sequence. Because there are three items in the group, <code>$x</code> evaluates to a sequence of three items. To reduce this to one item, use <code>fn:distinct-values()</code>:</p><div class="exampleInner"><pre>let $x := 64000 for $c in //customer let $d := $c/department where $c/salary &gt; $x group by $d return &lt;department name="{$d}"&gt; Number of employees earning more than ${distinct-values($x)} is {count($c)} &lt;/department&gt;</pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In general, the <a title="static type" class="termref" href="#dt-static-type">static type</a> of a variable in a post-grouping tuple is different from the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the variable with the same name in the pre-grouping tuples.</p></div><p>The order in which tuples appear in the post-grouping tuple stream is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An <code>order by</code> clause can be used to impose a value-based ordering on the post-grouping tuple stream. Similarly, if it is desired to impose a value-based ordering within a group (i.e., on the sequence of items bound to a non-grouping variable), this can be accomplished by a nested FLWOR expression that iterates over these items and applies an <code>order by</code> clause. In some cases, a value-based ordering within groups can be accomplished by applying an <code>order by</code> clause on a non-grouping variable before applying the <code>group by</code> clause.</p></div><p>A <code>group by</code> clause rebinds all the variables in the input tuple stream. The scopes of these variables are not affected by the <code>group by</code> clause, but in post-grouping tuples the values of the variables represent group properties rather than properties of individual pre-grouping tuples.</p><p>Examples:</p><ul><li><p>This example illustrates the effect of a <code>group by</code> clause on a tuple stream.</p><p>Input tuple stream:</p><div class="exampleInner"><pre><span class="deltaxml-old">($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P78395&lt;/itemno&gt;) ($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P94738&lt;/itemno&gt;) ($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P41653&lt;/itemno&gt;) ($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P70421&lt;/itemno&gt;)</span></pre><pre><span class="deltaxml-new">($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P78395&lt;/itemno&gt;) ($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P94738&lt;/itemno&gt;) ($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P41653&lt;/itemno&gt;) ($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P70421&lt;/itemno&gt;) </span></pre></div><p><code>group by</code> clause:</p><div class="exampleInner"><pre>group by $storeno</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre>($storeno = S101, $itemno = (&lt;itemno&gt;P78395&lt;/itemno&gt;, &lt;itemno&gt;P41653&lt;/itemno&gt;)) ($storeno = S102, $itemno = (&lt;itemno&gt;P94738&lt;/itemno&gt;, &lt;itemno&gt;P70421&lt;/itemno&gt;))</pre></div></li></ul><ul><li><p>This example and the ones that follow are based on two separate sequences of elements, named <code>$sales</code> and <code>$products</code>. We assume that the variable <code>$sales</code> is bound to a sequence of elements with the following structure:</p><div class="exampleInner"><pre>&lt;sales&gt; &lt;storeno&gt;S101&lt;/storeno&gt; &lt;itemno&gt;P78395&lt;/itemno&gt; &lt;qty&gt;125&lt;/qty&gt; &lt;/sales&gt;</pre></div><p>We also assume that the variable <code>$products</code> is bound to a sequence of elements with the following structure:</p><div class="exampleInner"><pre>&lt;product&gt; &lt;itemno&gt;P78395&lt;/itemno&gt; &lt;price&gt;25.00&lt;/price&gt; &lt;category&gt;Men's Wear&lt;/category&gt; &lt;/product&gt;</pre></div><p>The simplest kind of grouping query has a single <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a>. The query in this example finds the total quantity of items sold by each store:</p><div class="exampleInner"><pre>for $s in $sales let $storeno := $s/storeno group by $storeno return &lt;store number="{$storeno}" total-qty="{sum($s/qty)}"/&gt;</pre></div><p>The result of this query is a sequence of elements with the following structure:</p><div class="exampleInner"><pre>&lt;store number="S101" total-qty="1550" /&gt; &lt;store number="S102" total-qty="2125" /&gt;</pre></div></li><li><p>In a more realistic example, a user might be interested in the total revenue generated by each store for each product category. Revenue depends on both the quantity sold of various items and the price of each item. The following query joins the two input sequences and groups the resulting tuples by two <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variables</a>:</p><div class="exampleInner"><pre><span class="deltaxml-old">for $s in $sales, $p in $products[itemno = $s/itemno] let $revenue := $s/qty * $p/price group by $storeno := $s/storeno, $category := $p/category return &lt;summary storeno="{$storeno}" category="{$category}" revenue="{sum($revenue)}"/&gt;</span></pre><pre><span class="deltaxml-new">for $s in $sales, $p in $products[itemno = $s/itemno] let $revenue := $s/qty * $p/price group by $storeno := $s/storeno, $category := $p/category return &lt;summary storeno="{$storeno}" category="{$category}" revenue="{sum($revenue)}"/&gt; </span></pre></div><p>The result of this query is a sequence of elements with the following structure:</p><div class="exampleInner"><pre>&lt;summary storeno="S101" category="Men's Wear" revenue="10185"/&gt; &lt;summary storeno="S101" category="Stationery" revenue="4520"/&gt; &lt;summary storeno="S102" category="Men's Wear" revenue="9750"/&gt; &lt;summary storeno="S102" category="Appliances" revenue="22650"/&gt; &lt;summary storeno="S102" category="Jewelry" revenue="30750"/&gt;</pre></div></li><li><p>The result of the previous example was a <span class="deltaxml-old">“flat”</span><span class="deltaxml-new">"flat"</span> list of elements. A user might prefer the query result to be presented in the form of a hierarchical report, grouped primarily by store (in order by store number) and secondarily by product category. Within each store, the user might want to see only those product categories whose total revenue exceeds $10,000, presented in descending order by their total revenue. This report is generated by the following query:</p><div class="exampleInner"><pre><span class="deltaxml-old">for $s1 in $sales let $storeno := $s1/storeno group by $storeno order by $storeno return &lt;store storeno="{$storeno}"&gt; {for $s2 in $s1, $p in $products[itemno = $s2/itemno] let $category := $p/category, $revenue := $s2/qty * $p/price group by $category let $group-revenue := sum($revenue) where $group-revenue &gt; 10000 order by $group-revenue descending return &lt;category name="{$category}" revenue="{$group-revenue}"/&gt; } &lt;/store&gt;</span></pre><pre><span class="deltaxml-new">for $s1 in $sales let $storeno := $s1/storeno group by $storeno order by $storeno return &lt;store storeno="{$storeno}"&gt; {for $s2 in $s1, $p in $products[itemno = $s2/itemno] let $category := $p/category, $revenue := $s2/qty * $p/price group by $category let $group-revenue := sum($revenue) where $group-revenue &gt; 10000 order by $group-revenue descending return &lt;category name="{$category}" revenue="{$group-revenue}"/&gt; } &lt;/store&gt; </span></pre></div><p>The result of this example query has the following structure:</p><div class="exampleInner"><pre>&lt;store storeno="S101"&gt; &lt;category name="Men's Wear" revenue="10185"/&gt; &lt;/store&gt; &lt;store storeno="S102"&gt; &lt;category name="Jewelry" revenue="30750"/&gt; &lt;category name="Appliances" revenue="22650"/&gt; &lt;/store&gt;</pre></div></li><li><p>The following example illustrates how to avoid a possible pitfall in writing grouping queries.</p><p>In each post-grouping tuple, all variables except for the grouping variable are bound to sequences of items derived from all the pre-grouping tuples from which the group was formed. For instance, in the following query, <code>$high-price</code> is bound to a sequence of items in the post-grouping tuple.</p><div class="exampleInner"><pre><span class="deltaxml-old">let $high-price := 1000 for $p in $products[price &gt; $high-price] let $category := $p/category group by $category return &lt;category name="{$category}"&gt; {count($p)} products have price greater than {$high-price}. &lt;/category&gt;</span></pre><pre><span class="deltaxml-new">let $high-price := 1000 for $p in $products[price &gt; $high-price] let $category := $p/category group by $category return &lt;category name="{$category}"&gt; {fn:count($p)} products have price greater than {$high-price}. &lt;/category&gt;</span></pre></div><p>If three products in the <span class="deltaxml-old">“Men’s Wear”</span><span class="deltaxml-new">"Men's Wear"</span> category have prices greater than 1000, the result of this query might look (in part) like this:</p><div class="exampleInner"><pre><span class="deltaxml-old">&lt;category name="Men’s Wear"&gt; 3 products have price greater than 1000 1000 1000. &lt;/category&gt;</span></pre><pre><span class="deltaxml-new">&lt;category name="Men's Wear"&gt; 3 products have price greater than 1000 1000 1000. &lt;/category&gt;</span></pre></div><p>The repetition of "1000" in this query result is due to the fact that <code>$high-price</code> is not a <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a>. One way to avoid this repetition is to move the binding of <code>$high-price</code> to an outer-level FLWOR expression, as follows:</p><div class="exampleInner"><pre><span class="deltaxml-old">let $high-price := 1000 return for $p in $products[price &gt; $high-price] let $category := $p/category group by $category return &lt;category name="{$category}"&gt; {count($p)} products have price greater than {$high-price}. &lt;/category&gt;</span></pre><pre><span class="deltaxml-new">let $high-price := 1000 return for $p in $products[price &gt; $high-price] let $category := $p/category group by $category return &lt;category name="{$category}"&gt; {fn:count($p)} products have price greater than {$high-price}. &lt;/category&gt;</span></pre></div><p>The result of the revised query might contain the following element:</p><div class="exampleInner"><pre>&lt;category name="Men's Wear"&gt; 3 products have price greater than 1000. &lt;/category&gt;</pre></div></li></ul></div><div class="div3"><h4><a id="id-order-by-clause"></a><span class="deltaxml-old">4.15.9</span><span class="deltaxml-new">4.14.8</span> Order By Clause</h4><a id="d3e26783"></a><a id="d3e23926"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-OrderByClause"></a>[<span class="deltaxml-old">76</span><span class="deltaxml-new">74</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-OrderByClause">OrderByClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(("order" "by") | ("stable" "order" "by")) <a href="#doc-xquery40-OrderSpecList">OrderSpecList</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e23767.doc-xquery40-OrderSpecList"></a><a id="noid_d4e21133.doc-xquery40-OrderSpecList"></a>[<span class="deltaxml-old">77</span><span class="deltaxml-new">75</span>]&nbsp;&nbsp;&nbsp;</td><td><code>OrderSpecList</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-OrderSpec">OrderSpec</a> ("," <a href="#doc-xquery40-OrderSpec">OrderSpec</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e23768.doc-xquery40-OrderSpec"></a><a id="noid_d4e21134.doc-xquery40-OrderSpec"></a>[<span class="deltaxml-old">78</span><span class="deltaxml-new">76</span>]&nbsp;&nbsp;&nbsp;</td><td><code>OrderSpec</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ExprSingle">ExprSingle</a><a href="#doc-xquery40-OrderModifier">OrderModifier</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e23769.doc-xquery40-OrderModifier"></a><a id="noid_d4e21135.doc-xquery40-OrderModifier"></a>[<span class="deltaxml-old">79</span><span class="deltaxml-new">77</span>]&nbsp;&nbsp;&nbsp;</td><td><code>OrderModifier</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("ascending" | "descending")? ("empty" ("greatest" | "least"))? ("collation" <a href="#doc-xquery40-URILiteral">URILiteral</a>)?</code></td><td></td></tr></tbody></table><p>The purpose of an <code>order by</code> clause is to impose a value-based ordering on the tuples in the tuple stream. The output tuple stream of the <code>order by</code> clause contains the same tuples as its input tuple stream, but the tuples may be in a different order.</p><p>An <code>order by</code> clause contains one or more ordering specifications, called <a href="#doc-xquery40-OrderSpec">orderspecs</a>, as shown in the grammar. For each tuple in the input tuple stream, the orderspecs are evaluated, using the variable bindings in that tuple. The relative order of two tuples is determined by comparing the values of their orderspecs, working from left to right until a pair of unequal values is encountered. If an orderspec specifies a <a title="collation" class="termref" href="#dt-collation">collation</a>, that collation is used in comparing values of type <code>xs:string</code>, <code>xs:anyURI</code>, or types derived from them (otherwise, the <a title="default collation" class="termref" href="#dt-def-collation">default collation</a> is used in comparing values of these types). If an orderspec specifies a collation by a relative URI, that relative URI is <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved to an absolute URI</a> using the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a>. If an orderspec specifies a collation that is not found in <a title="statically known collations" class="termref" href="#dt-static-collations">statically known collations</a>, an error is raised [<a href="#ERRXQST0076" title="err:XQST0076">err:XQST0076</a>].</p><p>The process of evaluating and comparing the orderspecs is based on the following rules:</p><ul><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the result of the expression in each orderspec. If the result of atomization is neither a single atomic value nor an empty sequence, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li class="add_version" style="display: none;"><p>If the value of an orderspec has the <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a><code>xs:untypedAtomic</code> (such as character data in a schemaless document), it is cast to the type <code>xs:string</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Consistently treating untyped values as strings enables the sorting process to begin without complete knowledge of the types of all the values to be sorted.</p></div></li><li class="modify_version"><p><span class="deltaxml-new">If the value of an orderspec has the </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new">dynamic type</span></a><code><span class="deltaxml-new">xs:untypedAtomic</span></code><span class="deltaxml-new"> (such as character data in a schemaless document), it is cast to the type </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">Consistently treating untyped values as strings enables the sorting process to begin without complete knowledge of the types of all the values to be sorted.</span></p></div></li><li class="add_version" style="display: none;"><p>If the resulting sequence contains values that are instances of more than one primitive type (meaning the 19 primitive types defined in <a href="https://www.w3.org/TR/xmlschema-2/#built-in-primitive-datatypes">Section 3.2 Primitive datatypes</a><sup><small>XS2</small></sup>, then:</p><ol class="enumar"><li><p>If each value is an instance of one of the types <code>xs:string</code> or <code>xs:anyURI</code>, then all values are cast to type <code>xs:string</code>.</p></li><li><p>If each value is an instance of one of the types <code>xs:decimal</code> or <code>xs:float</code>, then all values are cast to type <code>xs:float</code>.</p></li><li><p>If each value is an instance of one of the types <code>xs:decimal</code>, <code>xs:float</code>, or <code>xs:double</code>, then all values are cast to type <code>xs:double</code>.</p></li><li><p>Otherwise, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The primitive type of an <code>xs:integer</code> value for this purpose is <code>xs:decimal</code>.</p></div></li></ol></li><li class="modify_version"><p><span class="deltaxml-new">If the resulting sequence contains values that are instances of more than one primitive type (meaning the 19 primitive types defined in </span><a href="https://www.w3.org/TR/xmlschema-2/#built-in-primitive-datatypes"><span class="deltaxml-new">Section 3.2 Primitive datatypes</span></a><sup><small><span class="deltaxml-new">XS2</span></small></sup><span class="deltaxml-new">, then:</span></p><ol class="enumar"><li><p><span class="deltaxml-new">If each value is an instance of one of the types </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new">, then all values are cast to type </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">If each value is an instance of one of the types </span><code><span class="deltaxml-new">xs:decimal</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">xs:float</span></code><span class="deltaxml-new">, then all values are cast to type </span><code><span class="deltaxml-new">xs:float</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">If each value is an instance of one of the types </span><code><span class="deltaxml-new">xs:decimal</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">xs:float</span></code><span class="deltaxml-new">, or </span><code><span class="deltaxml-new">xs:double</span></code><span class="deltaxml-new">, then all values are cast to type </span><code><span class="deltaxml-new">xs:double</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">Otherwise, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new">type error</span></a><span class="deltaxml-new"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new">err:XPTY0004</span></a><span class="deltaxml-new">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">The primitive type of an </span><code><span class="deltaxml-new">xs:integer</span></code><span class="deltaxml-new"> value for this purpose is </span><code><span class="deltaxml-new">xs:decimal</span></code><span class="deltaxml-new">.</span></p></div></li></ol></li></ul><p><span style="display: none;" class="delete_version">For the purpose of determining their relative position in the ordering sequence, the <em>greater-than</em> relationship between two orderspec values <var>W</var> and <var>V</var> is defined as follows:</span><span style="display: none;" class="add_version">For the purpose of determining their relative position in the ordering sequence, the <em>greater-than</em> relationship between two orderspec values <em>W</em> and <em>V</em> is defined as follows:</span><span class="modify_version">For the purpose of determining their relative position in the ordering sequence, the <em>greater-than</em> relationship between two orderspec values <em>W</em> and <em>V</em> is defined as follows:</span></p><ul><li><p>When the orderspec specifies <code>empty least</code>, the following rules are applied in order: </p><ol class="enumar"><li><p><span style="display: none;" class="delete_version">If <var>V</var> is an empty sequence and <var>W</var> is not an empty sequence, then <var>W</var><em>greater-than</em><var>V </var> is true.</span><span style="display: none;" class="add_version">If <em>V</em> is an empty sequence and <em>W</em> is not an empty sequence, then <em>W</em><em>greater-than</em><em>V </em> is true.</span><span class="modify_version">If <em>V</em> is an empty sequence and <em>W</em> is not an empty sequence, then <em>W</em><em>greater-than</em><em>V </em> is true.</span></p></li><li><p><span style="display: none;" class="delete_version">If <var>V</var> is <code>NaN</code> and <var>W</var> is neither <code>NaN</code> nor an empty sequence, then <var>W</var><em>greater-than</em><var>V</var> is true.</span><span style="display: none;" class="add_version">If <em>V</em> is <code>NaN</code> and <em>W</em> is neither <code>NaN</code> nor an empty sequence, then <em>W</em><em>greater-than</em><em>V</em> is true.</span><span class="modify_version">If <em>V</em> is <code>NaN</code> and <em>W</em> is neither <code>NaN</code> nor an empty sequence, then <em>W</em><em>greater-than</em><em>V</em> is true.</span></p></li><li class="delete_version" style="display: none;"><p>If <var>V</var> and <var>W</var> are both instances of <code>xs:string</code>, <code>xs:anyURI</code>, or <code>xs:untypedAtomic</code>, they are compared using the function <code>fn:compare(V, W, C)</code> where <var>C</var> is the requested collation, defaulting to the default collation from the static context.</p><p>If <code>fn:compare(V, W, C)</code> is less than zero, then <em>W</em><em>greater-than</em><em>V</em> is true; otherwise <em>W</em><em>greater-than</em><em>V</em> is false.</p></li><li class="modify_version"><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old"> and </span><var><span class="deltaxml-old">W</span></var><span class="deltaxml-old"> are both instances of </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">xs:anyURI</span></code><span class="deltaxml-old">, or </span><code><span class="deltaxml-old">xs:untypedAtomic</span></code><span class="deltaxml-old">, they are compared using the function </span><code><span class="deltaxml-old">fn:compare(V, W, C)</span></code><span class="deltaxml-old"> where </span><var><span class="deltaxml-old">C</span></var><span class="deltaxml-old"> is the requested collation, defaulting to the default collation from the static context.</span></p><p><span class="deltaxml-old">If </span><code><span class="deltaxml-old">fn:compare(V, W, C)</span></code><span class="deltaxml-old"> is less than zero, then </span><em><span class="deltaxml-old">W</span></em><em><span class="deltaxml-old">greater-than</span></em><em><span class="deltaxml-old">V</span></em><span class="deltaxml-old"> is true; otherwise </span><em><span class="deltaxml-old">W</span></em><em><span class="deltaxml-old">greater-than</span></em><em><span class="deltaxml-old">V</span></em><span class="deltaxml-old"> is false.</span></p></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old"> and </span><var><span class="deltaxml-old">W</span></var><span class="deltaxml-old"> are both instances of </span><code><span class="deltaxml-old">xs:numeric</span></code><span class="deltaxml-old">, they are compared using the function </span><code><span class="deltaxml-old">fn:compare(V, W)</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-new">If a specific collation </span><em><span class="deltaxml-new">C</span></em><span class="deltaxml-new"> is specified, and </span><em><span class="deltaxml-new">V</span></em><span class="deltaxml-new"> and </span><em><span class="deltaxml-new">W</span></em><span class="deltaxml-new"> are both of type </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> or are convertible to </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> by </span><a title="subtype substitution" class="termref" href="#dt-subtype-substitution"><span class="deltaxml-new">subtype substitution</span></a><span class="deltaxml-new"> and/or </span><a title="type promotion" class="termref" href="#dt-type-promotion"><span class="deltaxml-new">type promotion</span></a><span class="deltaxml-new">, then:</span></p><p><span style="display: none;" class="delete_version">If <code>fn:compare(V, W)</code> is less than zero, then <var>W</var><em>greater-than</em><var>V</var> is true; otherwise <var>W</var><em>greater-than</em><var>V</var> is false.</span><span style="display: none;" class="add_version">If <code>fn:compare(V, W, C)</code> is less than zero, then <em>W</em><em>greater-than</em><em>V</em> is true; otherwise <em>W</em><em>greater-than</em><em>V</em> is false.</span><span class="modify_version">If <code>fn:compare(V, W<span class="deltaxml-new">, C</span>)</code> is less than zero, then <em>W</em><em>greater-than</em><em>V</em> is true; otherwise <em>W</em><em>greater-than</em><em>V</em> is false.</span></p></li><li><p>If none of the above rules apply, then:</p><p><span style="display: none;" class="delete_version">If <code>W gt V</code> is true, then <var>W</var><em>greater-than</em><var>V</var> is true; otherwise <var>W</var><em>greater-than</em><var>V</var> is false.</span><span style="display: none;" class="add_version">If <code>W gt V</code> is true, then <em>W</em><em>greater-than</em><em>V</em> is true; otherwise <em>W</em><em>greater-than</em><em>V</em> is false.</span><span class="modify_version">If <code>W gt V</code> is true, then <em>W</em><em>greater-than</em><em>V</em> is true; otherwise <em>W</em><em>greater-than</em><em>V</em> is false.</span></p></li></ol></li><li><p>When the orderspec specifies <code>empty greatest</code>, the following rules are applied in order: </p><ol class="enumar"><li><p><span style="display: none;" class="delete_version">If <var>W</var> is an empty sequence and <em>V</em> is not an empty sequence, then <var>W</var><em>greater-than</em><var>V</var> is true.</span><span style="display: none;" class="add_version">If <em>W</em> is an empty sequence and <em>V</em> is not an empty sequence, then <em>W</em><em>greater-than</em><em>V</em> is true.</span><span class="modify_version">If <em>W</em> is an empty sequence and <em>V</em> is not an empty sequence, then <em>W</em><em>greater-than</em><em>V</em> is true.</span></p></li><li><p><span style="display: none;" class="delete_version">If <var>W</var> is <code>NaN</code> and <var>V</var> is neither <code>NaN</code> nor an empty sequence, then <var>W</var><em>greater-than</em><var>V</var> is true.</span><span style="display: none;" class="add_version">If <em>W</em> is <code>NaN</code> and <em>V</em> is neither <code>NaN</code> nor an empty sequence, then <em>W</em><em>greater-than</em><em>V</em> is true.</span><span class="modify_version">If <em>W</em> is <code>NaN</code> and <em>V</em> is neither <code>NaN</code> nor an empty sequence, then <em>W</em><em>greater-than</em><em>V</em> is true.</span></p></li><li class="delete_version" style="display: none;"><p>If <var>V</var> and <var>W</var> are both instances of <code>xs:string</code>, <code>xs:anyURI</code>, or <code>xs:untypedAtomic</code>, they are compared using the function <code>fn:compare(V, W, C)</code> where <var>C</var> is the requested collation, defaulting to the default collation from the static context.</p><p>If <code>fn:compare(V, W, C)</code> is less than zero, then <em>W</em><em>greater-than</em><em>V</em> is true; otherwise <em>W</em><em>greater-than</em><em>V</em> is false.</p></li><li class="modify_version"><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old"> and </span><var><span class="deltaxml-old">W</span></var><span class="deltaxml-old"> are both instances of </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">xs:anyURI</span></code><span class="deltaxml-old">, or </span><code><span class="deltaxml-old">xs:untypedAtomic</span></code><span class="deltaxml-old">, they are compared using the function </span><code><span class="deltaxml-old">fn:compare(V, W, C)</span></code><span class="deltaxml-old"> where </span><var><span class="deltaxml-old">C</span></var><span class="deltaxml-old"> is the requested collation, defaulting to the default collation from the static context.</span></p><p><span class="deltaxml-old">If </span><code><span class="deltaxml-old">fn:compare(V, W, C)</span></code><span class="deltaxml-old"> is less than zero, then </span><em><span class="deltaxml-old">W</span></em><em><span class="deltaxml-old">greater-than</span></em><em><span class="deltaxml-old">V</span></em><span class="deltaxml-old"> is true; otherwise </span><em><span class="deltaxml-old">W</span></em><em><span class="deltaxml-old">greater-than</span></em><em><span class="deltaxml-old">V</span></em><span class="deltaxml-old"> is false.</span></p></li><li><p><span class="deltaxml-old">If </span><var><span class="deltaxml-old">V</span></var><span class="deltaxml-old"> and </span><var><span class="deltaxml-old">W</span></var><span class="deltaxml-old"> are both instances of </span><code><span class="deltaxml-old">xs:numeric</span></code><span class="deltaxml-old">, they are compared using the function </span><code><span class="deltaxml-old">fn:compare(V, W)</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-new">If a specific collation </span><em><span class="deltaxml-new">C</span></em><span class="deltaxml-new"> is specified, and </span><em><span class="deltaxml-new">V</span></em><span class="deltaxml-new"> and </span><em><span class="deltaxml-new">W</span></em><span class="deltaxml-new"> are both of type </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> or are convertible to </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new"> by </span><a title="subtype substitution" class="termref" href="#dt-subtype-substitution"><span class="deltaxml-new">subtype substitution</span></a><span class="deltaxml-new"> and/or </span><a title="type promotion" class="termref" href="#dt-type-promotion"><span class="deltaxml-new">type promotion</span></a><span class="deltaxml-new">, then:</span></p><p><span style="display: none;" class="delete_version">If <code>fn:compare(V, W)</code> is less than zero, then <var>W</var><em>greater-than</em><var>V</var> is true; otherwise <var>W</var><em>greater-than</em><var>V</var> is false.</span><span style="display: none;" class="add_version">If <code>fn:compare(V, W, C)</code> is less than zero, then <em>W</em><em>greater-than</em><em>V</em> is true; otherwise <em>W</em><em>greater-than</em><em>V</em> is false.</span><span class="modify_version">If <code>fn:compare(V, W<span class="deltaxml-new">, C</span>)</code> is less than zero, then <em>W</em><em>greater-than</em><em>V</em> is true; otherwise <em>W</em><em>greater-than</em><em>V</em> is false.</span></p></li><li><p>If none of the above rules apply, then:</p><p><span style="display: none;" class="delete_version">If <code>W gt V</code> is true, then <var>W</var><em>greater-than</em><var>V</var> is true; otherwise <var>W</var><em>greater-than</em><var>V</var> is false.</span><span style="display: none;" class="add_version">If <code>W gt V</code> is true, then <em>W</em><em>greater-than</em><em>V</em> is true; otherwise <em>W</em><em>greater-than</em><em>V</em> is false.</span><span class="modify_version">If <code>W gt V</code> is true, then <em>W</em><em>greater-than</em><em>V</em> is true; otherwise <em>W</em><em>greater-than</em><em>V</em> is false.</span></p></li></ol></li><li><p>When the orderspec specifies neither <code>empty least</code> nor <code>empty greatest</code>, the <a title="default order for empty sequences" class="termref" href="#dt-default-empty-order">default order for empty sequences</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> determines whether the rules for <code>empty least</code> or <code>empty greatest</code> are used. </p></li></ul><p>If <em>T1</em> and <em>T2</em> are two tuples in the input tuple stream, and <em>V1</em> and <em>V2</em> are the first pair of values encountered when evaluating their orderspecs from left to right for which one value is <em>greater-than</em> the other (as defined above), then:</p><ol class="enumar"><li><p>If <em>V1</em> is <em>greater-than</em><em>V2:</em> If the orderspec specifies <code>descending</code>, then <em>T1</em> precedes <em>T2</em> in the output tuple stream; otherwise, <em>T2</em> precedes <em>T1</em> in the output tuple stream.</p></li><li><p>If <em>V2</em> is <em>greater-than</em><em>V1</em>: If the orderspec specifies <code>descending</code>, then <em>T2</em> precedes <em>T1</em> in the output tuple stream; otherwise, <em>T1</em> precedes <em>T2</em> in the output tuple stream.</p></li></ol><p>If neither <em>V1</em> nor <em>V2</em> is <em>greater-than</em> the other for any pair of orderspecs for tuples <em>T1</em> and <em>T2</em>, the following rules apply.</p><ol class="enumar"><li><p>If <code>stable</code> is specified, the original order of <em>T1</em> and <em>T2</em> is preserved in the output tuple stream.</p></li><li><p>If <code>stable</code> is not specified, the order of <em>T1</em> and <em>T2</em> in the output tuple stream is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>If two orderspecs return the special floating-point values positive and negative zero, neither of these values is <em>greater-than</em> the other, since <code>+0.0 gt -0.0</code> and <code>-0.0 gt +0.0</code> are both <code>false</code>.</p></div><p>Examples:</p><ul><li><p>This example illustrates the effect of an <code>order by</code> clause on a tuple stream. The keyword <code>stable</code> indicates that, when two tuples have equal sort keys, their order in the input tuple stream is preserved.</p><p>Input tuple stream:</p><div class="exampleInner"><pre>($license = "PFQ519", $make = "Ford", $value = 16500) ($license = "HAJ865", $make = "Honda", $value = 22750) ($license = "NKV473", $make = "Ford", $value = 21650) ($license = "RCM922", $make = "Dodge", $value = 11400) ($license = "ZBX240", $make = "Ford", $value = 16500) ($license = "KLM030", $make = "Dodge", $value = () )</pre></div><p><code>order by</code> clause:</p><div class="exampleInner"><pre>stable order by $make, $value descending empty least</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre>($license = "RCM922", $make = "Dodge", $value = 11400) ($license = "KLM030", $make = "Dodge", $value = () ) ($license = "NKV473", $make = "Ford", $value = 21650) ($license = "PFQ519", $make = "Ford", $value = 16500) ($license = "ZBX240", $make = "Ford", $value = 16500) ($license = "HAJ865", $make = "Honda", $value = 22750)</pre></div></li><li><p>The following example shows how an <code>order by</code> clause can be used to sort the result of a query, even if the sort key is not included in the query result. This query returns employee names in descending order by salary, without returning the actual salaries:</p><div class="exampleInner"><pre>for $e in $employees order by $e/salary descending return $e/name</pre></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p> An alternative way of sorting is available from XQuery 3.1 using the <code>fn:sort</code> function. In previous versions of the language, a set of books might be sorted into alphabetic order by title using the FLWOR expression:</p><div class="exampleInner"><pre>for $b in $books/book[price &lt; 100] order by $b/title return $b</pre></div><p>In XQuery 3.1 the same effect can be achieved using the expression:</p><div class="exampleInner"><pre><span class="deltaxml-old">sort( $books/book[price &lt; 100], function($book){ $book/title } )</span></pre><pre><span class="deltaxml-new">sort( $books/book[price &lt; 100], function($book){ $book/title } ) </span></pre></div></div></div><div class="div3"><h4><a id="id-return-clause"></a><span class="deltaxml-old">4.15.10</span><span class="deltaxml-new">4.14.9</span> Return Clause</h4><a id="d3e27276"></a><a id="d3e24428"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e24229.doc-xquery40-ReturnClause"></a><a id="noid_d4e21604.doc-xquery40-ReturnClause"></a>[<span class="deltaxml-old">80</span><span class="deltaxml-new">78</span>]&nbsp;&nbsp;&nbsp;</td><td><code>ReturnClause</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"return" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody></table><p>The <code>return</code> clause is the final clause of a FLWOR expression. The <code>return</code> clause is evaluated once for each tuple in its input tuple stream, using the variable bindings in the respective tuples, in the order in which these tuples appear in the input tuple stream. The results of these evaluations are concatenated, as if by the <a title="comma operator" class="termref" href="#dt-comma-operator">comma operator</a>, to form the result of the FLWOR expression.</p><p>The following example illustrates a FLWOR expression containing several clauses. The <code>for</code> clause iterates over all the departments in an input document named <code>depts.xml</code>, binding the variable <code>$d</code> to each department in turn. For each binding of <code>$d</code>, the <code>let</code> clause binds variable <code>$e</code> to all the employees in the given department, selected from another input document named <code>emps.xml</code> (the relationship between employees and departments is represented by matching their <code>deptno</code> values). Each tuple in the resulting tuple stream contains a pair of bindings for <code>$d</code> and <code>$e</code> (<code>$d</code> is bound to a department and <code>$e</code> is bound to a set of employees in that department). The <code>where</code> clause filters the tuple stream, retaining only those tuples that represent departments having at least ten employees. The <code>order by</code> clause orders the surviving tuples in descending order by the average salary of the employees in the department. The <code>return</code> clause constructs a new <code>big-dept</code> element for each surviving tuple, containing the department number, headcount, and average salary.</p><div class="exampleInner"><pre><span class="deltaxml-old">for $d in doc("depts.xml")//dept let $e := doc("emps.xml")//emp[deptno eq $d/deptno] where count($e) &gt;= 10 order by avg($e/salary) descending return &lt;big-dept&gt; { $d/deptno, &lt;headcount&gt;{count($e)}&lt;/headcount&gt;, &lt;avgsal&gt;{avg($e/salary)}&lt;/avgsal&gt; } &lt;/big-dept&gt;</span></pre><pre><span class="deltaxml-new">for $d in fn:doc("depts.xml")//dept let $e := fn:doc("emps.xml")//emp[deptno eq $d/deptno] where fn:count($e) &gt;= 10 order by fn:avg($e/salary) descending return &lt;big-dept&gt; { $d/deptno, &lt;headcount&gt;{fn:count($e)}&lt;/headcount&gt;, &lt;avgsal&gt;{fn:avg($e/salary)}&lt;/avgsal&gt; } &lt;/big-dept&gt;</span></pre></div><div class="note"><p class="prefix"><b>Notes:</b></p><ul><li><p>The order in which items appear in the result of a FLWOR expression depends on the ordering of the input tuple stream to the <code>return</code> clause, which in turn is influenced by <code>order by</code> clauses and by <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a>. For example, consider the following query, which is based on the same two input documents as the previous example:</p><div class="exampleInner"><pre><span class="deltaxml-old">for $d in doc("depts.xml")//dept order by $d/deptno for $e in doc("emps.xml")//emp[deptno eq $d/deptno] return &lt;assignment&gt; {$d/deptno, $e/name} &lt;/assignment&gt;</span></pre><pre><span class="deltaxml-new">for $d in fn:doc("depts.xml")//dept order by $d/deptno for $e in fn:doc("emps.xml")//emp[deptno eq $d/deptno] return &lt;assignment&gt; {$d/deptno, $e/name} &lt;/assignment&gt;</span></pre></div><p>The result of this query is a sequence of <code>assignment</code> elements, each containing a <code>deptno</code> element and a <code>name</code> element. The sequence will be ordered primarily by the <code>deptno</code> values because of the <code>order by</code> clause. If <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, subsequences of <code>assignment</code> elements with equal <code>deptno</code> values will be ordered by the document order of their <code>name</code> elements within the <code>emps.xml</code> document; otherwise the ordering of these subsequences will be <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p></li><li><p>Parentheses are helpful in <code>return</code> clauses that contain comma operators, since FLWOR expressions have a higher precedence than the comma operator. For example, the following query raises an error because after the comma, <code>$j</code> is no longer within the FLWOR expression, and is an undefined variable:</p><div class="exampleInner"><pre>let $i := 5, $j := 20 * $i return $i, $j</pre></div><p>Parentheses can be used to bring <code>$j</code> into the <code>return</code> clause of the FLWOR expression, as the programmer probably intended:</p><div class="exampleInner"><pre>let $i := 5, $j := 20 * $i return ($i, $j)</pre></div></li></ul></div></div></div><div class="div2"><h3><a id="id-unordered-expressions"></a><span class="deltaxml-old">4.16</span><span class="deltaxml-new">4.15</span> Ordered and Unordered Expressions</h3><a id="d3e27397"></a><a id="d3e24550"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-OrderedExpr"></a>[<span class="deltaxml-old">173</span><span class="deltaxml-new">160</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-OrderedExpr">OrderedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"ordered" <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-UnorderedExpr"></a>[<span class="deltaxml-old">174</span><span class="deltaxml-new">161</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-UnorderedExpr">UnorderedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"unordered" <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e24344.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e21720.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p>The purpose of <code>ordered</code> and <code>unordered</code> expressions is to set the <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> to <code>ordered</code> or <code>unordered</code> for the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a>. For expressions where the ordering of the result is not significant, a performance advantage may be realized by setting the ordering mode to <code>unordered</code>, thereby granting the system flexibility to return the result in the order that it finds most efficient.</p><p><span style="display: none;" class="delete_version"><a title="ordering mode" class="termref" href="#dt-ordering-mode">Ordering mode</a> affects the behavior of <a title="path expression" class="termref" href="#dt-path-expression">path expressions</a> that include a <code>/</code> or <code>//</code> operator or an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a>; <code>union</code>, <code>intersect</code>, and <code>except</code> expressions; the <code>fn:id</code>, <code>fn:element-with-id</code>, and <code>fn:idref</code> functions; and certain clauses within a FLWOR expression. If ordering mode is <code>ordered</code>, node sequences returned by path expressions, <code>union</code>, <code>intersect</code>, and <code>except</code> expressions, and the <code>fn:id</code> and <code>fn:idref</code> functions are in <a title="document order" class="termref" href="#dt-document-order">document order</a>; otherwise the order of these return sequences is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. The effect of ordering mode on FLWOR expressions is described in <a href="#id-xquery-for-clause"><span class="delete_version"><b>4.15.2 For Clause</b></span><span class="modify_version"><b>4.15.2 For Clause</b></span></a>, <a href="#id-effects-of-window-clauses"><span class="delete_version"><b>4.15.4.3 Effects of Window Clauses on the Tuple Stream</b></span><span class="modify_version"><b>4.15.4.3 Effects of Window Clauses on the Tuple Stream</b></span></a>, and <a href="#id-group-by"><span class="delete_version"><b>4.15.8 Group By Clause</b></span><span class="modify_version"><b>4.15.8 Group By Clause</b></span></a>. Ordering mode has no effect on duplicate elimination.</span><span style="display: none;" class="add_version"><a title="ordering mode" class="termref" href="#dt-ordering-mode">Ordering mode</a> affects the behavior of <a title="path expression" class="termref" href="#dt-path-expression">path expressions</a> that include a "<code>/</code>" or "<code>//</code>" operator or an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a>; <code>union</code>, <code>intersect</code>, and <code>except</code> expressions; the <code>fn:id</code>, <code>fn:element-with-id</code>, and <code>fn:idref</code> functions; and certain clauses within a FLWOR expression. If ordering mode is <code>ordered</code>, node sequences returned by path expressions, <code>union</code>, <code>intersect</code>, and <code>except</code> expressions, and the <code>fn:id</code> and <code>fn:idref</code> functions are in <a title="document order" class="termref" href="#dt-document-order">document order</a>; otherwise the order of these return sequences is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. The effect of ordering mode on FLWOR expressions is described in <a href="#id-xquery-for-clause"><span class="add_version"><b>4.14.2 For Clause</b></span><span class="modify_version"><b>4.14.2 For Clause</b></span></a>, <a href="#id-effects-of-window-clauses"><span class="add_version"><b>4.14.4.3 Effects of Window Clauses on the Tuple Stream</b></span><span class="modify_version"><b>4.14.4.3 Effects of Window Clauses on the Tuple Stream</b></span></a>, and <a href="#id-group-by"><span class="add_version"><b>4.14.7 Group By Clause</b></span><span class="modify_version"><b>4.14.7 Group By Clause</b></span></a>. Ordering mode has no effect on duplicate elimination.</span><span class="modify_version"><a title="ordering mode" class="termref" href="#dt-ordering-mode">Ordering mode</a> affects the behavior of <a title="path expression" class="termref" href="#dt-path-expression">path expressions</a> that include a <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> or <span class="deltaxml-new">"</span><code>//</code><span class="deltaxml-new">"</span> operator or an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a>; <code>union</code>, <code>intersect</code>, and <code>except</code> expressions; the <code>fn:id</code>, <code>fn:element-with-id</code>, and <code>fn:idref</code> functions; and certain clauses within a FLWOR expression. If ordering mode is <code>ordered</code>, node sequences returned by path expressions, <code>union</code>, <code>intersect</code>, and <code>except</code> expressions, and the <code>fn:id</code> and <code>fn:idref</code> functions are in <a title="document order" class="termref" href="#dt-document-order">document order</a>; otherwise the order of these return sequences is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. The effect of ordering mode on FLWOR expressions is described in <a href="#id-xquery-for-clause"><span style="display: none;" class="delete_version"><b>4.15.2 For Clause</b></span><span style="display: none;" class="add_version"><b>4.14.2 For Clause</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.2</span><span class="deltaxml-new">4.14.2</span> For Clause</b></span></a>, <a href="#id-effects-of-window-clauses"><span style="display: none;" class="delete_version"><b>4.15.4.3 Effects of Window Clauses on the Tuple Stream</b></span><span style="display: none;" class="add_version"><b>4.14.4.3 Effects of Window Clauses on the Tuple Stream</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.4.3</span><span class="deltaxml-new">4.14.4.3</span> Effects of Window Clauses on the Tuple Stream</b></span></a>, and <a href="#id-group-by"><span style="display: none;" class="delete_version"><b>4.15.8 Group By Clause</b></span><span style="display: none;" class="add_version"><b>4.14.7 Group By Clause</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.8</span><span class="deltaxml-new">4.14.7</span> Group By Clause</b></span></a>. Ordering mode has no effect on duplicate elimination.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>In a region of a query where ordering mode is <code>unordered</code>, the result of an expression is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> if the expression calls certain functions that are affected by the ordering of node sequences. These functions include <code>fn:position</code>, <code>fn:last</code>, <code>fn:index-of</code>, <code>fn:insert-before</code>, <code>fn:remove</code>, <code>fn:reverse</code>, and <code>fn:subsequence</code>. The functions <code>fn:boolean</code> and <code>fn:not</code> are <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> if ordering mode is <code>unordered</code> and the argument contains at least one node and at least one atomic value (see <a href="#id-ebv"><b>2.5.3 Effective Boolean Value</b></a>). Also, within a <a title="path expression" class="termref" href="#dt-path-expression">path expression</a> in an unordered region, <a title="numeric predicate" class="termref" href="#dt-numeric-predicate">numeric predicates</a> are <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. For example, in an ordered region, the path expression <code>(//a/b)[5]</code> will return the fifth qualifying <code>b</code>-element in <a title="document order" class="termref" href="#dt-document-order">document order</a>. In an unordered region, the same expression will return an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> qualifying <code>b</code>-element.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>fn:id</code> and <code>fn:idref</code> functions are described in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a> as returning their results in <a title="document order" class="termref" href="#dt-document-order">document order</a>. Since ordering mode is a feature of XQuery, relaxation of the ordering requirement for function results when ordering mode is <code>unordered</code> is a feature of XQuery rather than of the functions themselves.</p></div><p>The use of an <code>unordered</code> expression is illustrated by the following example, which joins together two documents named <code>parts.xml</code> and <code>suppliers.xml</code>. The example returns the part numbers of red parts, paired with the supplier numbers of suppliers who supply these parts. If an <code>unordered</code> expression were not used, the resulting list of (part number, supplier number) pairs would be required to have an ordering that is controlled primarily by the <a title="document order" class="termref" href="#dt-document-order">document order</a> of <code>parts.xml</code> and secondarily by the <a title="document order" class="termref" href="#dt-document-order">document order</a> of <code>suppliers.xml</code>. However, this might not be the most efficient way to process the query if the ordering of the result is not important. An XQuery implementation might be able to process the query more efficiently by using an index to find the red parts, or by using <code>suppliers.xml</code> rather than <code>parts.xml</code> to control the primary ordering of the result. The <code>unordered</code> expression gives the query evaluator freedom to make these kinds of optimizations.</p><div class="exampleInner"><pre><span class="deltaxml-old">unordered { for $p in doc("parts.xml")/parts/part[color = "Red"], $s in doc("suppliers.xml")/suppliers/supplier where $p/suppno = $s/suppno return &lt;ps&gt; { $p/partno, $s/suppno } &lt;/ps&gt; }</span></pre><pre><span class="deltaxml-new">unordered { for $p in fn:doc("parts.xml")/parts/part[color = "Red"], $s in fn:doc("suppliers.xml")/suppliers/supplier where $p/suppno = $s/suppno return &lt;ps&gt; { $p/partno, $s/suppno } &lt;/ps&gt; }</span></pre></div><p>In addition to <code>ordered</code> and <code>unordered</code> expressions, XQuery provides a function named <code>fn:unordered</code> that operates on any sequence of items and returns the same sequence in an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> order. A call to the <code>fn:unordered</code> function may be thought of as giving permission for the argument expression to be materialized in whatever order the system finds most efficient. The <code>fn:unordered</code> function relaxes ordering only for the sequence that is its immediate operand, whereas an <code>unordered</code> expression sets the <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> for its operand expression and all nested expressions.</p></div><div class="div2"><h3><a id="id-conditionals"></a><span class="deltaxml-old">4.17</span><span class="deltaxml-new">4.16</span> Conditional Expressions</h3><p>XQuery 4.0 allows conditional expressions to be written in several different ways.</p><a id="d3e27622"></a><a id="d3e24775"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-IfExpr"></a>[<span class="deltaxml-old">94</span><span class="deltaxml-new">87</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-IfExpr">IfExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"if" "(" <a href="#doc-xquery40-Expr">Expr</a> ")" (<a href="#doc-xquery40-UnbracedActions">UnbracedActions</a> | <a href="#doc-xquery40-BracedActions">BracedActions</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-UnbracedActions"></a>[<span class="deltaxml-old">95</span><span class="deltaxml-new">88</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-UnbracedActions">UnbracedActions</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"then" <a href="#doc-xquery40-ExprSingle">ExprSingle</a> "else" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-BracedActions"></a>[<span class="deltaxml-old">96</span><span class="deltaxml-new">89</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-BracedActions">BracedActions</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ThenAction">ThenAction</a><a href="#doc-xquery40-ElseIfAction">ElseIfAction</a>* <a href="#doc-xquery40-ElseAction">ElseAction</a>?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ThenAction"></a>[<span class="deltaxml-old">97</span><span class="deltaxml-new">90</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ThenAction">ThenAction</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ElseIfAction"></a>[<span class="deltaxml-old">98</span><span class="deltaxml-new">91</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ElseIfAction">ElseIfAction</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"else" "if" "(" <a href="#doc-xquery40-Expr">Expr</a> ")" <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ElseAction"></a>[<span class="deltaxml-old">99</span><span class="deltaxml-new">92</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ElseAction">ElseAction</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"else" <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e24555.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e21931.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p>There are two formats with essentially the same semantics.</p><ul><li><p>The unbraced expression <code>if (C) then T else E</code> is equivalent to the braced expression <code>if (C) {T} else {E}</code>.</p></li><li><p>The value <var>V</var> of a conditional expression using the braced format is obtained by applying the following rules in order, finishing as soon as <var>V</var> has a value:</p><ol class="enumar"><li><p>Let <var>C</var> be the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of the test expression, as defined in <a href="#id-ebv"><b>2.5.3 Effective Boolean Value</b></a>.</p></li><li><p>If <var>C</var> is true, <var>V</var> is the value of the <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a> in the <a href="#doc-xquery40-ThenAction">ThenAction</a>.</p></li><li><p>The <a href="#doc-xquery40-ElseIfAction">ElseIfActions</a> (if any) are processed in order as follows:</p><ol class="enumla"><li><p>Let <var>C′</var> be the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of the test expression, as defined in <a href="#id-ebv"><b>2.5.3 Effective Boolean Value</b></a>.</p></li><li><p>If <var>C′</var> is true, <var>V</var> is the value of the <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a> in the <a href="#doc-xquery40-ElseIfAction">ElseIfAction</a></p></li></ol></li><li><p>If there is an <a href="#doc-xquery40-ElseAction">ElseAction</a>, then <var>V</var> is the value of its <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a>.</p></li><li><p><var>V</var> is the empty sequence.</p></li></ol></li></ul><p>Conditional expressions have a special rule for propagating <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a>: <span>expressions whose value is not needed for computing the result are <a title="guarded" class="termref" href="#dt-guarded">guarded</a>, as described in <a href="#id-guarded-expressions"><b>2.4.5 Guarded Expressions</b></a>, to prevent spurious dynamic errors.</span></p><p>Here are some examples of conditional expressions:</p><ul><li><p>In this example, the test expression is a comparison expression:</p><div class="exampleInner"><pre>if ($widget1/unit-cost &lt; $widget2/unit-cost) then $widget1 else $widget2</pre></div></li><li><p>In this example, the test expression tests for the existence of an attribute named <code>discounted</code>, independently of its value:</p><div class="exampleInner"><pre>if ($part/@discounted) then $part/wholesale else $part/retail</pre></div></li><li><p>The above expression can equivalently be written:</p><div class="exampleInner"><pre>if ($part/@discounted) { $part/wholesale } else { $part/retail }</pre></div></li><li><p>The following example returns the attribute node <code>@discount</code> provided the value of <code>@price</code> is greater than 100; otherwise it returns the empty sequence:</p><div class="exampleInner"><pre>if (@price gt 100) {@discount}</pre></div></li><li><p>The following example tests a number of conditions:</p><div class="exampleInner"><pre>if (@code = 1) { "food" } else if (@code = 2) { "fashion" } else if (@code = 3) { "household" } else { "general" }</pre></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>dangling else ambiguity<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> found in many other languages cannot arise:</p><ul><li><p>In the unbraced format, both the <code>then</code> and <code>else</code> clauses are mandatory.</p></li><li><p>In the braced format, an <code>else</code> clause is always unambiguously associated with the immediately containing <a href="#doc-xquery40-IfExpr">IfExpr</a>.</p></li></ul></div></div><div class="div2"><h3><a id="id-otherwise"></a><span class="deltaxml-old">4.18 Otherwise Expressions</span></h3><a id="d3e27870"></a><h3><a id="id-otherwise"></a><span class="deltaxml-new">4.17 Otherwise Expression</span></h3><a id="d3e25023"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-OtherwiseExpr"></a>[<span class="deltaxml-old">108</span><span class="deltaxml-new">105</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-OtherwiseExpr">OtherwiseExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-StringConcatExpr">StringConcatExpr</a> ( "otherwise" <a href="#doc-xquery40-StringConcatExpr">StringConcatExpr</a> )*</code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-UnionExpr">UnionExpr</a> ( "otherwise" <a href="#doc-xquery40-UnionExpr">UnionExpr</a> )*</code></span><span class="modify_version"><code><a href="#doc-xquery40-StringConcatExpr"><span class="deltaxml-old">StringConcatExpr</span></a><a href="#doc-xquery40-UnionExpr"><span class="deltaxml-new">UnionExpr</span></a> ( "otherwise" <a href="#doc-xquery40-StringConcatExpr"><span class="deltaxml-old">StringConcatExpr</span></a><a href="#doc-xquery40-UnionExpr"><span class="deltaxml-new">UnionExpr</span></a> )*</code></span></td><td></td></tr></tbody></table><p>The <code>otherwise</code> expression returns the value of its first operand, unless this is an empty sequence, in which case it returns the value of its second operand.</p><p>For example, <code>@price - (@discount otherwise 0)</code> returns the value of <code>@price - @discount</code>, if the attribute <code>@discount</code> exists, or the value of <code>@price</code> if the <code>@discount</code> attribute is absent.</p><p>To prevent spurious errors, the right hand operand is <a title="guarded" class="termref" href="#dt-guarded">guarded</a>: it cannot throw any dynamic error unless the left-hand operand returns an empty sequence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The operator is associative (even under error conditions): <code>A otherwise (B otherwise C)</code> returns the same result as <code>(A otherwise B) otherwise C</code>.</p><p><span class="deltaxml-old">The </span><code><span class="deltaxml-old">otherwise</span></code><span class="deltaxml-old"> operator binds more tightly than comparison operators such as </span><code><span class="deltaxml-old">=</span></code><span class="deltaxml-old">, but less tightly than string concatenation (</span><code><span class="deltaxml-old">||</span></code><span class="deltaxml-old">) or arithemetic operators. The expression </span><code><span class="deltaxml-old">$a = @x otherwise @y + 1</span></code><span class="deltaxml-old"> parses as </span><code><span class="deltaxml-old">$a = (@x otherwise (@y + 1))</span></code><span class="deltaxml-old">.</span></p></div><table class="ednote" caption="Editorial note"><tbody><tr><td style="text-align: left; vertical-align:top; width: 50%;"><b><span class="deltaxml-new">Editorial note</span></b></td><td style="text-align: right; vertical-align:top; width: 50%;"><span class="deltaxml-new">2022-12-20</span></td></tr><tr style="text-align: left; vertical-align: top;"><td colspan="2"><span class="deltaxml-new">This change </span><a href="https://qt4cg.org/meeting/minutes/2022/12-20.html#issue-170"><span class="deltaxml-new">was approved</span></a><span class="deltaxml-new"> during QT4CG meeting 016 on 20 December, 2022</span></td></tr></tbody></table></div><div class="div2"><h3><a id="id-switch"></a><span class="deltaxml-old">4.19 Switch Expressions</span></h3><a id="d3e27923"></a><h3><a id="id-switch"></a><span class="deltaxml-new">4.18 Switch Expression</span></h3><a id="d3e25071"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SwitchExpr"></a>[<span class="deltaxml-old">83</span><span class="deltaxml-new">81</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SwitchExpr">SwitchExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"switch" <a href="#doc-xquery40-SwitchComparand">SwitchComparand</a>? (<a href="#doc-xquery40-SwitchCases">SwitchCases</a> | <a href="#doc-xquery40-BracedSwitchCases">BracedSwitchCases</a>)</code></span><span style="display: none;" class="add_version"><code>"switch" "(" <a href="#doc-xquery40-Expr">Expr</a> ")" <a href="#doc-xquery40-SwitchCaseClause">SwitchCaseClause</a>+ "default" "return" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></span><span class="modify_version"><code>"switch" <a href="#doc-xquery40-SwitchComparand"><span class="deltaxml-old">SwitchComparand</span></a><span class="deltaxml-old">? (</span><span class="deltaxml-new">"(" </span><a href="#doc-xquery40-SwitchCases"><span class="deltaxml-old">SwitchCases</span></a><a href="#doc-xquery40-Expr"><span class="deltaxml-new">Expr</span></a> <span class="deltaxml-old">|</span><span class="deltaxml-new">")"</span> <a href="#doc-xquery40-BracedSwitchCases"><span class="deltaxml-old">BracedSwitchCases</span></a><a href="#doc-xquery40-SwitchCaseClause"><span class="deltaxml-new">SwitchCaseClause</span></a><span class="deltaxml-old">)</span><span class="deltaxml-new">+ "default" "return" </span><a href="#doc-xquery40-ExprSingle"><span class="deltaxml-new">ExprSingle</span></a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SwitchComparand"></a><span class="deltaxml-old">[84]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-SwitchComparand"><span class="deltaxml-old">SwitchComparand</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"(" </span><a href="#doc-xquery40-Expr"><span class="deltaxml-old">Expr</span></a><span class="deltaxml-old"> ")"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SwitchCases"></a><span class="deltaxml-old">[85]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-SwitchCases"><span class="deltaxml-old">SwitchCases</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-SwitchCaseClause"><span class="deltaxml-old">SwitchCaseClause</span></a><span class="deltaxml-old">+ "default" "return" </span><a href="#doc-xquery40-ExprSingle"><span class="deltaxml-old">ExprSingle</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-BracedSwitchCases"></a><span class="deltaxml-old">[86]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-BracedSwitchCases"><span class="deltaxml-old">BracedSwitchCases</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"{" </span><a href="#doc-xquery40-SwitchCases"><span class="deltaxml-old">SwitchCases</span></a><span class="deltaxml-old"> "}"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SwitchCaseClause"></a>[<span class="deltaxml-old">87</span><span class="deltaxml-new">82</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SwitchCaseClause">SwitchCaseClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("case" <a href="#doc-xquery40-SwitchCaseOperand">SwitchCaseOperand</a>)+ "return" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SwitchCaseOperand"></a>[<span class="deltaxml-old">88</span><span class="deltaxml-new">83</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SwitchCaseOperand">SwitchCaseOperand</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Expr">Expr</a></code></td><td></td></tr></tbody></table><p> The <b>switch expression</b> chooses one of several expressions to evaluate based on the input value. </p><p><span style="display: none;" class="delete_version"> In a <code>switch</code> expression, the <code>switch</code> keyword is followed by an expression enclosed in parentheses, called the <b>switch comparand</b>. This is the expression whose value is being compared. <span>This expression is optional, and defaults to <code>true()</code>.</span> The remainder of the <code>switch</code> expression consists of one or more <code>case</code> clauses, with one or more <code>case operand expressions</code> each, and a <code>default</code> clause. </span><span style="display: none;" class="add_version"> In a <code>switch</code> expression, the <code>switch</code> keyword is followed by an expression enclosed in parentheses, called the <b>switch operand expression</b>. This is the expression whose value is being compared. The remainder of the <code>switch</code> expression consists of one or more <code>case</code> clauses, with one or more <code>case operand expressions</code> each, and a <code>default</code> clause. </span><span class="modify_version"> In a <code>switch</code> expression, the <code>switch</code> keyword is followed by an expression enclosed in parentheses, called the <b>switch <span class="deltaxml-old">comparand</span><span class="deltaxml-new">operand expression</span></b>. This is the expression whose value is being compared. <span class="deltaxml-old">This expression is optional, and defaults to </span><span class="deltaxml-old">true()</span><span class="deltaxml-old">.</span><span class="deltaxml-old"> </span>The remainder of the <code>switch</code> expression consists of one or more <code>case</code> clauses, with one or more <code>case operand expressions</code> each, and a <code>default</code> clause. </span></p><p><span style="display: none;" class="delete_version">The first step in evaluating a switch expression is to apply atomization to the value of the switch comparand. <span>Call the result the <b>switch value</b>. If the <b>switch value</b></span> is a sequence of length greater than one, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. In the absence of a switch comparand, the switch value is the <code>xs:boolean</code> value <code>true</code>.</span><span style="display: none;" class="add_version">The first step in evaluating a switch expression is to apply atomization to the value of the switch operand expression. <span>Call the result the <b>switch value</b>. If the <b>switch value</b></span> is a sequence of length greater than one, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</span><span class="modify_version">The first step in evaluating a switch expression is to apply atomization to the value of the switch <span class="deltaxml-old">comparand</span><span class="deltaxml-new">operand expression</span>. <span>Call the result the <b>switch value</b>. If the <b>switch value</b></span> is a sequence of length greater than one, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].<span class="deltaxml-old"> In the absence of a switch comparand, the switch value is the </span><span class="deltaxml-old">xs:boolean</span><span class="deltaxml-old"> value </span><span class="deltaxml-old">true</span><span class="deltaxml-old">.</span></span></p><p>The <span><b>switch value</b> is compared to</span> each <a href="#doc-xquery40-SwitchCaseOperand">SwitchCaseOperand</a> in turn until a match is found or the list is exhausted. The matching is performed as follows:</p><ol class="enumar"><li><p>The <a href="#doc-xquery40-SwitchCaseOperand">SwitchCaseOperand</a> is evaluated.</p></li><li><p>The resulting value is atomized: call this the <b>case value</b>.</p></li><li><p>If the <b>case value</b> is an empty sequence, then a match occurs if and only if the <b>switch value</b> is an empty sequence.</p></li><li><p>Otherwise, the singleton <b>switch value</b> is compared individually with each item in the <b>case value</b> in turn, and a match occurs if and only if these two atomic values compare equal under the rules of the <code>fn:deep-equal</code> function with default options, using the default collation in the static context.</p></li></ol><p> [<a id="id-effective-case-switch-expression" title="effective case">Definition</a>: The <b>effective case</b> of a switch expression is the first case clause that matches, using the rules given above, or the default clause if no such case clause exists.] The value of the switch expression is the value of the return expression in the effective case.</p><p>Switch expressions have rules regarding the propagation of dynamic errors: <span>see <a href="#id-guarded-expressions"><b>2.4.5 Guarded Expressions</b></a>. These rules mean that</span> the return clauses of a switch expression must not raise any dynamic errors except in the effective case. Dynamic errors raised in the operand expressions of the switch or the case clauses are propagated; however, an implementation must not raise dynamic errors in the operand expressions of case clauses that occur after the effective case. An implementation is permitted to raise dynamic errors in the operand expressions of case clauses that occur before the effective case, but not required to do so.</p><p>The following example shows how a switch expression might be used:</p><div class="exampleInner"><pre><span class="deltaxml-old">switch ($animal) { case "Cow" return "Moo" case "Cat" return "Meow" case "Duck", "Goose" return "Quack" default return "What's that odd noise?" }</span></pre><pre><span class="deltaxml-new">switch ($animal) case "Cow" return "Moo" case "Cat" return "Meow" case "Duck", "Goose" return "Quack" default return "What's that odd noise?" </span></pre></div><p><span class="deltaxml-old">The curly braces in a switch expression are optional. The above example can equally be written:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">switch ($animal) case "Cow" return "Moo" case "Cat" return "Meow" case "Duck", "Goose" return "Quack" default return "What's that odd noise?"</span></pre></div><p><span class="deltaxml-old">The following example illustrates a switch expression where the comparand is defaulted to </span><code><span class="deltaxml-old">true</span></code><span class="deltaxml-old">:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">switch { case ($a le $b) return "lesser" case ($a ge $b) return "greater" case ($a eq $b) return "equal" default return "not comparable" }</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The comparisons are performed using the </span><code><span class="deltaxml-old">fn:deep-equal</span></code><span class="deltaxml-old"> function, after atomization. This means that a case expression such as </span><code><span class="deltaxml-old">@married</span></code><span class="deltaxml-old"> tests </span><code><span class="deltaxml-old">fn:data(@married)</span></code><span class="deltaxml-old"> rather than </span><code><span class="deltaxml-old">fn:boolean(@married)</span></code><span class="deltaxml-old">. If the effective boolean value of the expression is wanted, this can be achieved with an explicit call of </span><code><span class="deltaxml-old">fn:boolean</span></code><span class="deltaxml-old">.</span></p></div></div><div class="div2"><h3><a id="id-quantified-expressions"></a><span class="deltaxml-old">4.20</span><span class="deltaxml-new">4.19</span> Quantified Expressions</h3><p>Quantified expressions support existential and universal quantification. The value of a quantified expression is always <code>true</code> or <code>false</code>.</p><a id="d3e28107"></a><a id="d3e25198"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QuantifiedExpr"></a>[<span class="deltaxml-old">81</span><span class="deltaxml-new">79</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-QuantifiedExpr">QuantifiedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("some" | "every") <a href="#doc-xquery40-QuantifierBinding">QuantifierBinding</a> ("," <a href="#doc-xquery40-QuantifierBinding">QuantifierBinding</a>)* "satisfies" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QuantifierBinding"></a>[<span class="deltaxml-old">82</span><span class="deltaxml-new">80</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-QuantifierBinding">QuantifierBinding</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e24919.doc-xquery40-TypeDeclaration"></a><a id="noid_d4e22254.doc-xquery40-TypeDeclaration"></a>[<span class="deltaxml-old">224</span><span class="deltaxml-new">211</span>]&nbsp;&nbsp;&nbsp;</td><td><code>TypeDeclaration</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"as" <a href="#doc-xquery40-SequenceType">SequenceType</a></code></td><td></td></tr></tbody></table><p>A <b>quantified expression</b> begins with a <b>quantifier</b>, which is the keyword <code>some</code> or <code>every</code>, followed by one or more in-clauses that are used to bind variables, followed by the keyword <code>satisfies</code> and a test expression. Each in-clause associates a variable with an expression that returns a sequence of items, called the binding sequence for that variable. The value of the quantified expression is defined by the following rules:</p><ol class="enumar"><li><p>If the <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a> contains more than one <a href="#doc-xquery40-QuantifierBinding">QuantifierBinding</a>, then it is equivalent to the expression obtained by replacing each comma with <code>satisfies some</code> or <code>satisfies every</code> respectively. For example, the expression <code>some $x in X, $y in Y satisfies $x = $y</code> is equivalent to <code>some $x in X satisfies some $y in Y satisfies $x = $y</code>, while the expression <code>every $x in X, $y in Y satisfies $x lt $y</code> is equivalent to <code>every $x in X satisfies every $y in Y satisfies $x lt $y</code></p></li><li><p>If the quantifier is <code>some</code>, the <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a> returns <code>true</code> if at least one evaluation of the test expression has the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a><code>true</code>; otherwise it returns <code>false</code>. In consequence, if the binding sequence is empty, the result of the <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a> is <code>false</code>.</p></li><li><p>If the quantifier is <code>every</code>, the <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a> returns <code>true</code> if every evaluation of the test expression has the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a><code>true</code>; otherwise it returns <code>false</code>. In consequence, if the binding sequence is empty, the result of the <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a> is <code>true</code>.</p></li></ol><p>The scope of a variable bound in a quantified expression comprises all subexpressions of the quantified expression that appear after the variable binding. The scope does not include the expression to which the variable is bound. </p><p class="xquery">Each variable bound in an in-clause of a quantified expression may have an optional <a href="#doc-xquery40-TypeDeclaration">type declaration</a>. If the type of a value bound to the variable does not match the declared type according to the rules for <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType matching</a>, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><p><span style="display: none;" class="delete_version">The order in which test expressions are evaluated for the various items in the binding sequence is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. If the quantifier is <code>some</code>, an implementation may return <code>true</code> as soon as it finds one item for which the test expression has an <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of <code>true</code>, and it may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one item for which the test expression raises an error. Similarly, if the quantifier is <code>every</code>, an implementation may return <code>false</code> as soon as it finds one item for which the test expression has an <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of <code>false</code>, and it may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one item for which the test expression raises an error. As a result of these rules, the value of a quantified expression is not deterministic in the presence of errors, as illustrated in the examples below.</span><span style="display: none;" class="add_version">The order in which test expressions are evaluated for the various binding tuples is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. If the quantifier is <code>some</code>, an implementation may return <code>true</code> as soon as it finds one binding tuple for which the test expression has an <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of <code>true</code>, and it may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one binding tuple for which the test expression raises an error. Similarly, if the quantifier is <code>every</code>, an implementation may return <code>false</code> as soon as it finds one binding tuple for which the test expression has an <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of <code>false</code>, and it may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one binding tuple for which the test expression raises an error. As a result of these rules, the value of a quantified expression is not deterministic in the presence of errors, as illustrated in the examples below.</span><span class="modify_version">The order in which test expressions are evaluated for the various <span class="deltaxml-old">items in the binding sequence</span><span class="deltaxml-new">binding tuples</span> is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. If the quantifier is <code>some</code>, an implementation may return <code>true</code> as soon as it finds one <span class="deltaxml-old">item</span><span class="deltaxml-new">binding tuple</span> for which the test expression has an <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of <code>true</code>, and it may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one <span class="deltaxml-old">item</span><span class="deltaxml-new">binding tuple</span> for which the test expression raises an error. Similarly, if the quantifier is <code>every</code>, an implementation may return <code>false</code> as soon as it finds one <span class="deltaxml-old">item</span><span class="deltaxml-new">binding tuple</span> for which the test expression has an <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of <code>false</code>, and it may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one <span class="deltaxml-old">item</span><span class="deltaxml-new">binding tuple</span> for which the test expression raises an error. As a result of these rules, the value of a quantified expression is not deterministic in the presence of errors, as illustrated in the examples below.</span></p><p>Here are some examples of quantified expressions:</p><ul><li><p>This expression is <code>true</code> if every <code>part</code> element has a <code>discounted</code> attribute (regardless of the values of these attributes):</p><div class="exampleInner"><pre>every $part in /parts/part satisfies $part/@discounted</pre></div></li><li><p>This expression is <code>true</code> if at least one <code>employee</code> element satisfies the given comparison expression:</p><div class="exampleInner"><pre>some $emp in /emps/employee satisfies ($emp/bonus &gt; 0.25 * $emp/salary)</pre></div></li><li><p><span style="display: none;" class="delete_version">This expression is <code>true</code> if every <code>employee</code> element has at least one <code>salary</code> child with the attribute <code>current="true"</code>:</span><span style="display: none;" class="add_version">This expression is <code>true</code> if at every <code>employee</code> element has at least one <code>salary</code> child with the attribute <code>current="true"</code>:</span><span class="modify_version">This expression is <code>true</code> if <span class="deltaxml-new">at </span>every <code>employee</code> element has at least one <code>salary</code> child with the attribute <code>current="true"</code>:</span></p><div class="exampleInner"><pre>every $emp in /emps/employee satisfies some $sal in $emp/salary satisfies $sal/@current='true'</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Like many quantified expressions, this can be simplified. This example can be written <code>every $emp in /emps/employee satisfies $emp/salary[@current='true']</code>, or even more concisely as <code>empty(/emps/employee[not(salary/@current='true')]</code>.</p><p><span style="display: none;" class="delete_version">Another alternative in XQuery 4.0 is to use the higher-order functions <code>fn:some</code> and <code>fn:every</code>. This example can be written <code>fn:every(/emps/employee, function{salary/@current='true'})</code></span><span style="display: none;" class="add_version">Another alternative in XQuery 4.0 is to use the higher-order functions <code>fn:some</code> and <code>fn:all</code>. This example can be written <code>fn:all(/emps/employee, -&gt;(){salary/@current='true'})</code></span><span class="modify_version">Another alternative in XQuery 4.0 is to use the higher-order functions <code>fn:some</code> and <code><span class="deltaxml-old">fn:every</span><span class="deltaxml-new">fn:all</span></code>. This example can be written <code><span class="deltaxml-old">fn:every</span><span class="deltaxml-new">fn:all</span>(/emps/employee, <span class="deltaxml-old">function</span><span class="deltaxml-new">-&gt;()</span>{salary/@current='true'})</code></span></p></div></li><li><p><span style="display: none;" class="delete_version">In the following examples, each quantified expression evaluates its test expression over nine pairs of items, formed from the Cartesian product of the sequences <code>(1, 2, 3)</code> and <code>(2, 3, 4)</code>. The expression beginning with <code>some</code> evaluates to <code>true</code>, and the expression beginning with <code>every</code> evaluates to <code>false</code>.</span><span style="display: none;" class="add_version">In the following examples, each quantified expression evaluates its test expression over nine pairs of variable bindings, formed from the Cartesian product of the sequences <code>(1, 2, 3)</code> and <code>(2, 3, 4)</code>. The expression beginning with <code>some</code> evaluates to <code>true</code>, and the expression beginning with <code>every</code> evaluates to <code>false</code>.</span><span class="modify_version">In the following examples, each quantified expression evaluates its test expression over nine pairs of <span class="deltaxml-old">items</span><span class="deltaxml-new">variable bindings</span>, formed from the Cartesian product of the sequences <code>(1, 2, 3)</code> and <code>(2, 3, 4)</code>. The expression beginning with <code>some</code> evaluates to <code>true</code>, and the expression beginning with <code>every</code> evaluates to <code>false</code>.</span></p><div class="exampleInner"><pre>some $x in (1, 2, 3), $y in (2, 3, 4) satisfies $x + $y = 4</pre></div><div class="exampleInner"><pre>every $x in (1, 2, 3), $y in (2, 3, 4) satisfies $x + $y = 4</pre></div></li><li><p><span style="display: none;" class="delete_version">This quantified expression may either return <code>true</code> or raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>, since its test expression returns <code>true</code> for one item and raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> for another:</span><span style="display: none;" class="add_version">This quantified expression may either return <code>true</code> or raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>, since its test expression returns <code>true</code> for one variable binding and raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> for another:</span><span class="modify_version">This quantified expression may either return <code>true</code> or raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>, since its test expression returns <code>true</code> for one <span class="deltaxml-old">item</span><span class="deltaxml-new">variable binding</span> and raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> for another:</span></p><div class="exampleInner"><pre>some $x in (1, 2, "cat") satisfies $x * 2 = 4</pre></div></li><li><p><span style="display: none;" class="delete_version">This quantified expression may either return <code>false</code> or raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>, since its test expression returns <code>false</code> for one item and raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> for another:</span><span style="display: none;" class="add_version">This quantified expression may either return <code>false</code> or raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>, since its test expression returns <code>false</code> for one variable binding and raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> for another:</span><span class="modify_version">This quantified expression may either return <code>false</code> or raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>, since its test expression returns <code>false</code> for one <span class="deltaxml-old">item</span><span class="deltaxml-new">variable binding</span> and raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> for another:</span></p><div class="exampleInner"><pre>every $x in (1, 2, "cat") satisfies $x * 2 = 4</pre></div></li><li class="delete_version" style="display: none;"><p>This quantified expression returns <code>true</code>, because the binding sequence is empty, despite the fact that the condition can never be satisfied:</p><div class="exampleInner"><pre>every $x in () satisfies ($x lt 0 and $x gt 0)</pre></div></li><li class="modify_version"><p><span class="deltaxml-old">This quantified expression returns </span><code><span class="deltaxml-old">true</span></code><span class="deltaxml-old">, because the binding sequence is empty, despite the fact that the condition can never be satisfied:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">every $x in () satisfies ($x lt 0 and $x gt 0)</span></pre></div></li><li class="xquery"><p>This quantified expression contains a <a href="#doc-xquery40-TypeDeclaration">type declaration</a> that is not satisfied by every item in the test expression. If the <a title="static     typing feature" class="termref" href="#dt-static-typing-feature">Static Typing Feature</a> is implemented, this expression raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> during the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a>. Otherwise, the expression may either return <code>true</code> or raise a <a title="type error" class="termref" href="#dt-type-error">type error</a> during the <a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation">dynamic evaluation phase</a>.</p><div class="exampleInner"><pre>some $x as xs:integer in (1, 2, "cat") satisfies $x * 2 = 4</pre></div></li></ul></div><div class="div2"><h3><a id="id-try-catch"></a><span class="deltaxml-old">4.21</span><span class="deltaxml-new">4.20</span> Try/Catch Expressions</h3><p>The try/catch expression provides error handling for dynamic errors and type errors raised during dynamic evaluation, including errors raised by the XQuery implementation and errors explicitly raised in a query using the <code>fn:error()</code> function.</p><a id="d3e28407"></a><a id="d3e25490"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TryCatchExpr"></a>[<span class="deltaxml-old">100</span><span class="deltaxml-new">93</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-TryCatchExpr">TryCatchExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-TryClause">TryClause</a><a href="#doc-xquery40-CatchClause">CatchClause</a>+</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TryClause"></a>[<span class="deltaxml-old">101</span><span class="deltaxml-new">94</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-TryClause">TryClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"try" <a href="#doc-xquery40-EnclosedTryTargetExpr">EnclosedTryTargetExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-EnclosedTryTargetExpr"></a>[<span class="deltaxml-old">102</span><span class="deltaxml-new">95</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EnclosedTryTargetExpr">EnclosedTryTargetExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CatchClause"></a>[<span class="deltaxml-old">103</span><span class="deltaxml-new">96</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CatchClause">CatchClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"catch" <a href="#doc-xquery40-NameTestUnion">NameTestUnion</a><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></span><span style="display: none;" class="add_version"><code>"catch" <a href="#doc-xquery40-CatchErrorList">CatchErrorList</a><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></span><span class="modify_version"><code>"catch" <a href="#doc-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a><a href="#doc-xquery40-CatchErrorList"><span class="deltaxml-new">CatchErrorList</span></a><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e25191.doc-xquery40-NameTestUnion"></a><a id="doc-xquery40-CatchErrorList"></a>[<span class="deltaxml-old">104</span><span class="deltaxml-new">97</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>NameTestUnion</code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-CatchErrorList">CatchErrorList</a></code></span><span class="modify_version"><code><span class="deltaxml-old">NameTestUnion</span><a href="#prod-xquery40-CatchErrorList"><span class="deltaxml-new">CatchErrorList</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-NameTest">NameTest</a> ("|" <a href="#doc-xquery40-NameTest">NameTest</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e25192.doc-xquery40-NameTest"></a><span class="deltaxml-old">[148]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">NameTest</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-EQName"><span class="deltaxml-old">EQName</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-Wildcard"><span class="deltaxml-old">Wildcard</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e25193.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e22519.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p>A try/catch expression catches <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a> and <a title="type error" class="termref" href="#dt-type-error">type errors</a> raised by the evaluation of the target expression of the <code>try</code> clause. If the the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of the try clause does not raise a dynamic error or a type error, the result of the try/catch expression is the result of the content expression.</p><p><span style="display: none;" class="delete_version">If the target expression raises a dynamic error or a type error, the result of the try/catch expression is obtained by evaluating the first <code>catch</code> clause that “matches” the error value, as described below. If no catch clause “matches” the error value, then the try/catch expression raises the error that was raised by the target expression. A <code>catch</code> clause with one or more NameTests matches any error whose error code matches one of these NameTests. For instance, if the error code is <code>err:FOER0000</code>, then it matches a <code>catch</code> clause whose ErrorList is <code>err:FOER0000 | err:FOER0001</code>. Wildcards may be used in NameTests; thus, the error code <code>err:FOER0000</code> also matches a <code>catch</code> clause whose ErrorList is <code>err:*</code> or <code>*:FOER0000</code> or <code>*</code>.</span><span style="display: none;" class="add_version">If the target expression raises a dynamic error or a type error, the result of the try/catch expression is obtained by evaluating the first <code>catch</code> clause that "matches" the error value, as described below. If no catch clause "matches" the error value, then the try/catch expression raises the error that was raised by the target expression. A <code>catch</code> clause with one or more NameTests matches any error whose error code matches one of these NameTests. For instance, if the error code is <code>err:FOER0000</code>, then it matches a <code>catch</code> clause whose ErrorList is <code>err:FOER0000 | err:FOER0001</code>. Wildcards may be used in NameTests; thus, the error code <code>err:FOER0000</code> also matches a <code>catch</code> clause whose ErrorList is <code>err:*</code> or <code>*:FOER0000</code> or <code>*</code>.</span><span class="modify_version">If the target expression raises a dynamic error or a type error, the result of the try/catch expression is obtained by evaluating the first <code>catch</code> clause that <span class="deltaxml-old">“matches”</span><span class="deltaxml-new">"matches"</span> the error value, as described below. If no catch clause <span class="deltaxml-old">“matches”</span><span class="deltaxml-new">"matches"</span> the error value, then the try/catch expression raises the error that was raised by the target expression. A <code>catch</code> clause with one or more NameTests matches any error whose error code matches one of these NameTests. For instance, if the error code is <code>err:FOER0000</code>, then it matches a <code>catch</code> clause whose ErrorList is <code>err:FOER0000 | err:FOER0001</code>. Wildcards may be used in NameTests; thus, the error code <code>err:FOER0000</code> also matches a <code>catch</code> clause whose ErrorList is <code>err:*</code> or <code>*:FOER0000</code> or <code>*</code>.</span></p><p>Within the scope of the <code>catch</code> clause, a number of variables are implicitly declared, giving information about the error that occurred. These variables are initialized as described in the following table:</p><table class="medium"><thead><tr><th style="text-align:left">Variable</th><th style="text-align:left">Type</th><th style="text-align:left">Value</th></tr></thead><tbody><tr><td style="vertical-align:top"><span style="display: none;" class="delete_version"><code>$err:code</code></span><span style="display: none;" class="add_version">err:code</span><span class="modify_version"><span class="deltaxml-old">$</span>err:code</span></td><td style="vertical-align:top">xs:QName</td><td style="vertical-align:top">The error code</td></tr><tr><td style="vertical-align:top"><span style="display: none;" class="delete_version"><code>$err:description</code></span><span style="display: none;" class="add_version">err:description</span><span class="modify_version"><span class="deltaxml-old">$</span>err:description</span></td><td style="vertical-align:top">xs:string?</td><td style="vertical-align:top">A description of the error condition; an empty sequence if no description is available (for example, if the <code>error</code> function was called with one argument).</td></tr><tr><td style="vertical-align:top"><span style="display: none;" class="delete_version"><code>$err:value</code></span><span style="display: none;" class="add_version">err:value</span><span class="modify_version"><span class="deltaxml-old">$</span>err:value</span></td><td style="vertical-align:top">item()*</td><td style="vertical-align:top">Value associated with the error. For an error raised by calling the <code>error</code> function, this is the value of the third argument (if supplied).</td></tr><tr><td style="vertical-align:top"><span style="display: none;" class="delete_version"><code>$err:module</code></span><span style="display: none;" class="add_version">err:module</span><span class="modify_version"><span class="deltaxml-old">$</span>err:module</span></td><td style="vertical-align:top">xs:string?</td><td style="vertical-align:top">The URI (or system ID) of the module containing the expression where the error occurred, or an empty sequence if the information is not available.</td></tr><tr><td style="vertical-align:top"><span style="display: none;" class="delete_version"><code>$err:line-number</code></span><span style="display: none;" class="add_version">err:line-number</span><span class="modify_version"><span class="deltaxml-old">$</span>err:line-number</span></td><td style="vertical-align:top">xs:integer?</td><td style="vertical-align:top">The line number within the module where the error occurred, or an empty sequence if the information is not available. The value <strong>may</strong> be approximate.</td></tr><tr><td style="vertical-align:top"><span style="display: none;" class="delete_version"><code>$err:column-number</code></span><span style="display: none;" class="add_version">err:column-number</span><span class="modify_version"><span class="deltaxml-old">$</span>err:column-number</span></td><td style="vertical-align:top">xs:integer?</td><td style="vertical-align:top">The column number within the module where the error occurred, or an empty sequence if the information is not available. The value <strong>may</strong> be approximate.</td></tr><tr><td style="vertical-align:top"><span style="display: none;" class="delete_version"><code>$err:additional</code></span><span style="display: none;" class="add_version">err:additional</span><span class="modify_version"><span class="deltaxml-old">$</span>err:additional</span></td><td style="vertical-align:top">item()*</td><td style="vertical-align:top"><a title="implementation defined" class="termref" href="#dt-implementation-defined">Implementation-defined</a>. This variable must be bound so that a query can reference it without raising an error. The purpose of this variable is to allow implementations to provide any additional information that might be useful.</td></tr><tr class="delete_version" style="display: none;"><td style="vertical-align:top"><code>$err:map</code></td><td style="vertical-align:top">map(*)</td><td style="vertical-align:top">A map with entries for all values that are bound to the variables above. The local names of the variables are assigned as keys. No map entries are created for those values that are empty sequences. The variable can be used to pass on all error information to another function.</td></tr><tr class="modify_version"><td style="vertical-align:top"><code><span class="deltaxml-old">$err:map</span></code></td><td style="vertical-align:top"><span class="deltaxml-old">map(*)</span></td><td style="vertical-align:top"><span class="deltaxml-old">A map with entries for all values that are bound to the variables above. The local names of the variables are assigned as keys. No map entries are created for those values that are empty sequences. The variable can be used to pass on all error information to another function.</span></td></tr></tbody></table><p>Try/catch expressions have a special rule for propagating dynamic errors. The try/catch expression ignores any dynamic errors encountered in catch clauses other than the first catch clause that matches an error raised by the try clause, and these catch clause expressions need not be evaluated.</p><p>Static errors are not caught by the try/catch expression.</p><p>If a function call occurs within a <code>try</code> clause, errors raised by evaluating the corresponding function are caught by the try/catch expression. If a variable reference is used in a <code>try</code> clause, errors raised by binding a value to the variable are not caught unless the binding expression occurs within the <code>try</code> clause.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The presence of a try/catch expression does not prevent an implementation from using a lazy evaluation strategy, nor does it prevent an optimizer performing expression rewrites. However, if the evaluation of an expression inside a try/catch is rewritten or deferred in this way, it must take its try/catch context with it. Similarly, expressions that were written outside the try/catch expression may be evaluated inside the try/catch, but only if they retain their original try/catch behavior. The presence of a try/catch does not change the rules that allow the processor to evaluate expressions in such a way that may avoid the detection of some errors. </p></div><p>Here are some examples of try/catch expressions.</p><ul><li><p>A try/catch expression without <span class="deltaxml-old">name tests</span><span class="deltaxml-new">a CatchErrorList</span> catches any error:</p><div class="exampleInner"><pre>try { $x cast as xs:integer } catch * { 0 }</pre></div></li><li><p><span class="deltaxml-old">With the following catch clause, only </span><code><span class="deltaxml-old">err:FORG0001</span></code><span class="deltaxml-old"> is caught:</span></p><p><span class="deltaxml-new">The CatchErrorList in this try/catch expression specifies that only </span><code><span class="deltaxml-new">err:FORG0001</span></code><span class="deltaxml-new"> is caught:</span></p><div class="exampleInner"><pre>try { $x cast as xs:integer } catch err:FORG0001 { 0 }</pre></div></li><li><p><span style="display: none;" class="delete_version">This try/catch expression specifies that errors <code>err:FORG0001</code> and <code>err:XPTY0004</code> are caught:</span><span style="display: none;" class="add_version">The CatchErrorList in this try/catch expression specifies that errors <code>err:FORG0001</code> and <code>err:XPTY0004</code> are caught:</span><span class="modify_version"><span class="deltaxml-old">This</span><span class="deltaxml-new">The CatchErrorList in this</span> try/catch expression specifies that errors <code>err:FORG0001</code> and <code>err:XPTY0004</code> are caught:</span></p><div class="exampleInner"><pre>try { $x cast as xs:integer } catch err:FORG0001 | err:XPTY0004 { 0 }</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In some implementations, <code>err:XPTY0004</code> is detected during static evaluation; it can only be caught if it is raised during dynamic evaluation.</p></div></li><li><p>This try/catch expression shows how to return information about the error using implicitly defined error variables<span class="deltaxml-new">. Since the CatchErrorList is a wildcard, it catches any error</span>:</p><div class="exampleInner"><pre><span class="deltaxml-old">try { error(QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')) } catch * { $err:code, $err:value, " module: ", $err:module, "(", $err:line-number, ",", $err:column-number, ")" }</span></pre><pre><span class="deltaxml-new">try { fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')) } catch * { $err:code, $err:value, " module: ", $err:module, "(", $err:line-number, ",", $err:column-number, ")" }</span></pre></div></li><li><p>Errors raised by using the result of a try/catch expression are not caught, since they are outside the scope of the <code>try</code> expression.</p><div class="exampleInner"><pre><span class="deltaxml-old">declare function local:thrice($x as xs:integer) as xs:integer { 3 * $x }; local:thrice(try { "oops" } catch * { 3 } )</span></pre><pre><span class="deltaxml-new">declare function local:thrice($x as xs:integer) as xs:integer { 3*$x }; local:thrice(try { "oops" } catch * { 3 } ) </span></pre></div><p><span style="display: none;" class="delete_version">In this example, the try block succeeds, returning the string <code>"oops"</code>, which is not a valid argument to the function.</span><span style="display: none;" class="add_version">In this example, the try block succeeds, returning the string "oops", which is not a valid argument to the function.</span><span class="modify_version">In this example, the try block succeeds, returning the string "oops", which is not a valid argument to the function.</span></p></li><li class="delete_version" style="display: none;"><p>All available information about the error is serialized:</p><div class="exampleInner"><pre>try { 1 + &lt;empty/&gt; } catch * { serialize($err:map, map { 'method': 'adaptive' }) }</pre></div></li><li class="modify_version"><p><span class="deltaxml-old">All available information about the error is serialized:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">try { 1 + &lt;empty/&gt; } catch * { serialize($err:map, map { 'method': 'adaptive' }) }</span></pre></div></li></ul></div><div class="div2"><h3><a id="id-expressions-on-datatypes"></a><span class="deltaxml-old">4.22</span><span class="deltaxml-new">4.21</span> Expressions on SequenceTypes</h3><p> The <code>instance of</code>, <code>cast</code>, <code>castable</code>, and <code>treat</code> expressions are used to test whether a value conforms to a given type or to convert it to an instance of a given type. </p><div class="div3"><h4><a id="id-instance-of"></a><span class="deltaxml-old">4.22.1</span><span class="deltaxml-new">4.21.1</span> Instance Of</h4><a id="d3e28676"></a><a id="d3e25719"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-InstanceofExpr"></a>[<span class="deltaxml-old">115</span><span class="deltaxml-new">108</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-InstanceofExpr">InstanceofExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-TreatExpr">TreatExpr</a> ( "instance" "of" <a href="#doc-xquery40-SequenceType">SequenceType</a> )?</code></td><td></td></tr></tbody></table><p>The boolean operator <code>instance of</code> returns <code>true</code> if the value of its first operand matches the <a href="#doc-xquery40-SequenceType">SequenceType</a> in its second operand, according to the rules for <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType matching</a>; otherwise it returns <code>false</code>. For example:</p><ul><li><p><code>5 instance of xs:integer</code></p><p>This example returns <code>true</code> because the given value is an instance of the given type.</p></li><li><p><code>5 instance of xs:decimal</code></p><p>This example returns <code>true</code> because the given value is an integer literal, and <code>xs:integer</code> is derived by restriction from <code>xs:decimal</code>.</p></li><li class="xquery"><p><code>&lt;a&gt;{5}&lt;/a&gt; instance of xs:integer</code></p><p>This example returns <code>false</code> because the given value is an element rather than an integer.</p></li><li><p><code>(5, 6) instance of xs:integer+</code></p><p>This example returns <code>true</code> because the given sequence contains two integers, and is a valid instance of the specified type.</p></li><li><p><code>. instance of element()</code></p><p><span style="display: none;" class="delete_version">This example returns <code>true</code> if the context value is a single element node or <code>false</code> if the context value is defined but is not a single element node. If the context value is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>, a <a class="termref" title="type error" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>].</span><span style="display: none;" class="add_version">This example returns <code>true</code> if the context item is an element node or <code>false</code> if the context item is defined but is not an element node. If the context item is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>, a <a class="termref" title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>].</span><span class="modify_version">This example returns <code>true</code> if the context <span class="deltaxml-old">value is a single</span><span class="deltaxml-new">item is an</span> element node or <code>false</code> if the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> is defined but is not <span class="deltaxml-old">a single</span><span class="deltaxml-new">an</span> element node. If the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>, a <a class="termref" title="dynamic error" href="#dt-dynamic-error"><span class="deltaxml-old">type</span><span class="deltaxml-new">dynamic</span> error</a> is raised [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>].</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">An </span><code><span class="deltaxml-old">instance of</span></code><span class="deltaxml-old"> test does not allow any kind of casting or coercion. The results may therefore be counterintuitive. For example, the expression </span><code><span class="deltaxml-old">3 instance of xs:positiveInteger</span></code><span class="deltaxml-old"> returns </span><code><span class="deltaxml-old">false</span></code><span class="deltaxml-old">, because the expression </span><code><span class="deltaxml-old">3</span></code><span class="deltaxml-old"> evaluates to an instance of </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old">, not </span><code><span class="deltaxml-old">xs:positiveInteger</span></code><span class="deltaxml-old">. For similar reasons, </span><code><span class="deltaxml-old">"red" instance of enum("red", "green", "blue")</span></code><span class="deltaxml-old"> returns false.</span></p><p><span class="deltaxml-old">On such occasions, a </span><code><span class="deltaxml-old">castable as</span></code><span class="deltaxml-old"> test may be more appropriate: see </span><a href="#id-castable"><b><span class="deltaxml-old">4.22.4 Castable</span></b></a></p></div></div><div class="div3"><h4><a id="id-typeswitch"></a><span class="deltaxml-old">4.22.2</span><span class="deltaxml-new">4.21.2</span> Typeswitch</h4><a id="d3e28790"></a><a id="d3e25810"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeswitchExpr"></a>[<span class="deltaxml-old">89</span><span class="deltaxml-new">84</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-TypeswitchExpr">TypeswitchExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"typeswitch" "(" <a href="#doc-xquery40-Expr">Expr</a> ")" (<a href="#doc-xquery40-TypeswitchCases">TypeswitchCases</a> | <a href="#doc-xquery40-BracedTypeswitchCases">BracedTypeswitchCases</a>)</code></span><span style="display: none;" class="add_version"><code>"typeswitch" "(" <a href="#doc-xquery40-Expr">Expr</a> ")" <a href="#doc-xquery40-CaseClause">CaseClause</a>+ "default" ("$" <a href="#doc-xquery40-VarName">VarName</a>)? "return" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></span><span class="modify_version"><code>"typeswitch" "(" <a href="#doc-xquery40-Expr">Expr</a> ")" <span class="deltaxml-old">(</span><a href="#doc-xquery40-TypeswitchCases"><span class="deltaxml-old">TypeswitchCases</span></a><a href="#doc-xquery40-CaseClause"><span class="deltaxml-new">CaseClause</span></a><span class="deltaxml-old"> |</span><span class="deltaxml-new">+ "default" ("$"</span> <a href="#doc-xquery40-BracedTypeswitchCases"><span class="deltaxml-old">BracedTypeswitchCases</span></a><a href="#doc-xquery40-VarName"><span class="deltaxml-new">VarName</span></a>)<span class="deltaxml-new">? "return" </span><a href="#doc-xquery40-ExprSingle"><span class="deltaxml-new">ExprSingle</span></a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeswitchCases"></a><span class="deltaxml-old">[90]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-TypeswitchCases"><span class="deltaxml-old">TypeswitchCases</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-CaseClause"><span class="deltaxml-old">CaseClause</span></a><span class="deltaxml-old">+ "default" ("$" </span><a href="#doc-xquery40-VarName"><span class="deltaxml-old">VarName</span></a><span class="deltaxml-old">)? "return" </span><a href="#doc-xquery40-ExprSingle"><span class="deltaxml-old">ExprSingle</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-BracedTypeswitchCases"></a><span class="deltaxml-old">[91]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-BracedTypeswitchCases"><span class="deltaxml-old">BracedTypeswitchCases</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"{" </span><a href="#doc-xquery40-TypeswitchCases"><span class="deltaxml-old">TypeswitchCases</span></a><span class="deltaxml-old"> "}"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CaseClause"></a>[<span class="deltaxml-old">92</span><span class="deltaxml-new">85</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CaseClause">CaseClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"case" ("$" <a href="#doc-xquery40-VarName">VarName</a> "as")? <a href="#doc-xquery40-SequenceTypeUnion">SequenceTypeUnion</a> "return" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SequenceTypeUnion"></a>[<span class="deltaxml-old">93</span><span class="deltaxml-new">86</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SequenceTypeUnion">SequenceTypeUnion</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SequenceType">SequenceType</a> ("|" <a href="#doc-xquery40-SequenceType">SequenceType</a>)*</code></td><td></td></tr></tbody></table><p class="xquery">The <b>typeswitch</b> expression chooses one of several expressions to evaluate based on the <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> of an input value.</p><p class="xquery">In a <code>typeswitch</code> expression, the <code>typeswitch</code> keyword is followed by an expression enclosed in parentheses, called the <b>operand expression</b>. This is the expression whose type is being tested. The remainder of the <code>typeswitch</code> expression consists of one or more <code>case</code> clauses and a <code>default</code> clause.</p><p class="xquery">Each <code>case</code> clause specifies one or more <a href="#doc-xquery40-SequenceType">SequenceType</a>s followed by a <code>return</code> expression. [<a id="dt-effective-case" title="effective case">Definition</a>: The <b>effective case</b> in a <code>typeswitch</code> expression is the first <code>case</code> clause in which the value of the operand expression matches a <a href="#doc-xquery40-SequenceType">SequenceType</a> in the <a href="#doc-xquery40-SequenceType">SequenceTypeUnion</a> of the <code>case</code> clause, using the rules of <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType matching</a>. ] The value of the <code>typeswitch</code> expression is the value of the <code>return</code> expression in the effective case. If the value of the operand expression does not match any <a href="#doc-xquery40-SequenceType">SequenceType</a> named in a <code>case</code> clause, the value of the <code>typeswitch</code> expression is the value of the <code>return</code> expression in the <code>default</code> clause.</p><p>In a <code>case</code> or <code>default</code> clause, if the value to be returned depends on the value of the operand expression, the clause must specify a variable name. Within the <code>return</code> expression of the <code>case</code> or <code>default</code> clause, this variable name is bound to the value of the operand expression. Inside a <code>case</code> clause, the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the variable is the union of the <a href="#doc-xquery40-SequenceType">SequenceType</a>s named in the <a href="#doc-xquery40-SequenceType">SequenceTypeUnion</a>. Inside a <code>default</code> clause, the static type of the variable is the same as the static type of the operand expression. If the value to be returned by a <code>case</code> or <code>default</code> clause does not depend on the value of the operand expression, the clause need not specify a variable.</p><p>The scope of a variable binding in a <code>case</code> or <code>default</code> clause comprises that clause. It is not an error for more than one <code>case</code> or <code>default</code> clause in the same <code>typeswitch</code> expression to bind variables with the same name. </p><p>Typeswitch expressions have rules regarding the propagation of dynamic errors: <span>see <a href="#id-guarded-expressions"><b>2.4.5 Guarded Expressions</b></a>. These rules mean that</span> a <code>typeswitch</code> expression ignores (does not raise) any dynamic errors encountered in <code>case</code> clauses other than the <a title="effective case" class="termref" href="#dt-effective-case">effective case</a>. Dynamic errors encountered in the <code>default</code> clause are raised only if there is no <a title="effective case" class="termref" href="#dt-effective-case">effective case</a>. An implementation is permitted to raise dynamic errors in the operand expressions of case clauses that occur before the <a title="effective case" class="termref" href="#dt-effective-case">effective case</a>, but not required to do so.</p><p class="xquery">The following example shows how a <code>typeswitch</code> expression might be used to process an expression in a way that depends on its <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a>.</p><div class="exampleInner"><pre><span class="deltaxml-old">typeswitch($customer/billing-address) { case $a as element(*, USAddress) return $a/state case $a as element(*, CanadaAddress) return $a/province case $a as element(*, JapanAddress) return $a/prefecture default return "unknown" }</span></pre><pre><span class="deltaxml-new">typeswitch($customer/billing-address) case $a as element(*, USAddress) return $a/state case $a as element(*, CanadaAddress) return $a/province case $a as element(*, JapanAddress) return $a/prefecture default return "unknown" </span></pre></div><p><span class="deltaxml-old">The curly braces in a </span><code><span class="deltaxml-old">typeswitch</span></code><span class="deltaxml-old"> expression are optional. The above example can equally be written:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">typeswitch($customer/billing-address) case $a as element(*, USAddress) return $a/state case $a as element(*, CanadaAddress) return $a/province case $a as element(*, JapanAddress) return $a/prefecture default return "unknown"</span></pre></div><p>The following example shows a union of sequence types in a single case:</p><div class="exampleInner"><pre><span class="deltaxml-old">typeswitch($customer/billing-address) { case $a as element(*, USAddress) | element(*, AustraliaAddress) | element(*, MexicoAddress) return $a/state case $a as element(*, CanadaAddress) return $a/province case $a as element(*, JapanAddress) return $a/prefecture default return "unknown" }</span></pre><pre><span class="deltaxml-new">typeswitch($customer/billing-address) case $a as element(*, USAddress) | element(*, AustraliaAddress) | element(*, MexicoAddress) return $a/state case $a as element(*, CanadaAddress) return $a/province case $a as element(*, JapanAddress) return $a/prefecture default return "unknown"</span></pre></div></div><div class="div3"><h4><a id="id-cast"></a><span class="deltaxml-old">4.22.3</span><span class="deltaxml-new">4.21.3</span> Cast</h4><a id="d3e29003"></a><a id="d3e26000"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CastExpr"></a>[<span class="deltaxml-old">118</span><span class="deltaxml-new">111</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CastExpr">CastExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ArrowExpr">ArrowExpr</a> ( "cast" "as" <a href="#doc-xquery40-SingleType">SingleType</a> )?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SingleType"></a>[<span class="deltaxml-old">223</span><span class="deltaxml-new">210</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SingleType">SingleType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-CastTarget">CastTarget</a> "?"?</code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-SimpleTypeName">SimpleTypeName</a> "?"?</code></span><span class="modify_version"><code><a href="#prod-xquery40-CastTarget"><span class="deltaxml-old">CastTarget</span></a><a href="#doc-xquery40-SimpleTypeName"><span class="deltaxml-new">SimpleTypeName</span></a> "?"?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e25672.doc-xquery40-TypeName"></a><a id="doc-xquery40-SimpleTypeName"></a>[<span class="deltaxml-old">246</span><span class="deltaxml-new">232</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>TypeName</code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-SimpleTypeName">SimpleTypeName</a></code></span><span class="modify_version"><code><span class="deltaxml-old">TypeName</span><a href="#prod-xquery40-SimpleTypeName"><span class="deltaxml-new">SimpleTypeName</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-EQName">EQName</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-TypeName">TypeName</a> | <a href="#doc-xquery40-LocalUnionType">LocalUnionType</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-EQName"><span class="deltaxml-old">EQName</span></a><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-LocalUnionType"><span class="deltaxml-new">LocalUnionType</span></a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e25673.doc-xquery40-LocalUnionType"></a><a id="noid_d4e22937.doc-xquery40-TypeName"></a>[<span class="deltaxml-old">259</span><span class="deltaxml-new">233</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>LocalUnionType</code></span><span style="display: none;" class="add_version"><code>TypeName</code></span><span class="modify_version"><code><span class="deltaxml-old">LocalUnionType</span><span class="deltaxml-new">TypeName</span></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"union" "(" <a href="#doc-xquery40-ItemType">ItemType</a> ("," <a href="#doc-xquery40-ItemType">ItemType</a>)* ")"</code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-EQName">EQName</a></code></span><span class="modify_version"><code><span class="deltaxml-old">"union" "(" </span><a href="#doc-xquery40-ItemType"><span class="deltaxml-old">ItemType</span></a><span class="deltaxml-old"> ("," </span><a href="#doc-xquery40-ItemType"><span class="deltaxml-old">ItemType</span></a><span class="deltaxml-old">)* ")"</span><a href="#doc-xquery40-EQName"><span class="deltaxml-new">EQName</span></a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e25674.doc-xquery40-EnumerationType"></a><a id="noid_d4e22938.doc-xquery40-LocalUnionType"></a>[<span class="deltaxml-old">260</span><span class="deltaxml-new">245</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>EnumerationType</code></span><span style="display: none;" class="add_version"><code>LocalUnionType</code></span><span class="modify_version"><code><span class="deltaxml-old">EnumerationType</span><span class="deltaxml-new">LocalUnionType</span></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"enum" "(" <a href="#doc-xquery40-StringLiteral">StringLiteral</a> ("," <a href="#doc-xquery40-StringLiteral">StringLiteral</a>)* ")"</code></span><span style="display: none;" class="add_version"><code>"union" "(" <a href="#doc-xquery40-ItemType">ItemType</a> ("," <a href="#doc-xquery40-ItemType">ItemType</a>)* ")"</code></span><span class="modify_version"><code>"<span class="deltaxml-old">enum</span><span class="deltaxml-new">union</span>" "(" <a href="#doc-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a><a href="#doc-xquery40-ItemType"><span class="deltaxml-new">ItemType</span></a> ("," <a href="#doc-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a><a href="#doc-xquery40-ItemType"><span class="deltaxml-new">ItemType</span></a>)* ")"</code></span></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version">Sometimes it is necessary to convert a value to a specific datatype. For this purpose, XQuery 4.0 provides a <code>cast</code> expression that creates a new value of a specific type based on an existing value. A <code>cast</code> expression takes two operands: an <b>input expression</b> and a <b>target type</b>. The type of the atomized value of the input expression is called the <b>input type</b>. The <span>target type</span> must be one of:</span><span style="display: none;" class="add_version">Sometimes it is necessary to convert a value to a specific datatype. For this purpose, XQuery 4.0 provides a <code>cast</code> expression that creates a new value of a specific type based on an existing value. A <code>cast</code> expression takes two operands: an <b>input expression</b> and a <b>target type</b>. The type of the atomized value of the input expression is called the <b>input type</b>. The <span>target type</span> must be either of:</span><span class="modify_version">Sometimes it is necessary to convert a value to a specific datatype. For this purpose, XQuery 4.0 provides a <code>cast</code> expression that creates a new value of a specific type based on an existing value. A <code>cast</code> expression takes two operands: an <b>input expression</b> and a <b>target type</b>. The type of the atomized value of the input expression is called the <b>input type</b>. The <span>target type</span> must be <span class="deltaxml-old">one</span><span class="deltaxml-new">either</span> of:</span></p><ul><li class="delete_version" style="display: none;"><p>The name of an <a title="named item type" class="termref" href="#dt-named-item-type">named item type</a> defined in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, which in turn must refer to an item type in one of the following categories.</p></li><li class="modify_version"><p><span class="deltaxml-old">The name of an </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-old">named item type</span></a><span class="deltaxml-old"> defined in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-old">static context</span></a><span class="deltaxml-old">, which in turn must refer to an item type in one of the following categories.</span></p></li><li><p>The name of a type defined in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a>, which must be a simple type [<a href="#ERRXQST0052" title="err:XQST0052">err:XQST0052</a>]. In addition, the target type cannot be <code>xs:NOTATION</code>, <code>xs:anySimpleType</code>, or <code>xs:anyAtomicType</code></p></li><li><p>A <code>LocalUnionType</code> such as <code>union(xs:date, xs:dateTime)</code>.</p></li><li class="delete_version" style="display: none;"><p>An <code>EnumerationType</code> such as <code>enum("red", "green", "blue")</code>.</p></li><li class="modify_version"><p><span class="deltaxml-old">An </span><code><span class="deltaxml-old">EnumerationType</span></code><span class="deltaxml-old"> such as </span><code><span class="deltaxml-old">enum("red", "green", "blue")</span></code><span class="deltaxml-old">.</span></p></li></ul><p>Otherwise, a static error is raised [<a href="#ERRXPST0080" title="err:XPST0080">err:XPST0080</a>].</p><p><span style="display: none;" class="delete_version">The optional occurrence indicator <code>?</code> denotes that an empty sequence is permitted.</span><span style="display: none;" class="add_version">The optional occurrence indicator "<code>?</code>" denotes that an empty sequence is permitted.</span><span class="modify_version">The optional occurrence indicator <span class="deltaxml-new">"</span><code>?</code><span class="deltaxml-new">"</span> denotes that an empty sequence is permitted.</span></p><p><span class="deltaxml-new">If the target type is a lexical QName that has no namespace prefix, it is considered to be in the </span><a title="default type namespace" class="termref" href="#dt-def-type-ns"><span class="deltaxml-new">default type namespace</span></a><span class="deltaxml-new">.</span></p><p>Casting a node to <code>xs:QName</code> can cause surprises because it uses the static context of the cast expression to provide the namespace bindings for this operation. Instead of casting to <code>xs:QName</code>, it is generally preferable to use the <code>fn:QName</code> function, which allows the namespace context to be taken from the document containing the QName.</p><p>The semantics of the <code>cast</code> expression are as follows:</p><ol class="enumar"><li><p>The input expression is evaluated.</p></li><li><p>The result of the first step is <a title="atomization" class="termref" href="#dt-atomization">atomized</a>.</p></li><li><p> If the result of atomization is a sequence of more than one atomic value, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If the result of atomization is an empty sequence:</p><ol class="enumla"><li><p>If <code>?</code> is specified after the target type, the result of the <code>cast</code> expression is an empty sequence.</p></li><li><p> If <code>?</code> is not specified after the target type, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li></ol></li><li><p><span style="display: none;" class="delete_version">If the result of atomization is a single atomic value, the result of the cast expression is determined by casting to the target type as described in <a href="https://qt4cg.org/specifications/xpath-functions-40/#casting">Section 21 Casting</a><sup><small>FO40</small></sup>. When casting, an implementation may need to determine whether one type is derived by restriction from another. An implementation can determine this either by examining the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> or by using an alternative, <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> mechanism such as a data dictionary. The result of a cast expression is one of the following: </span><span style="display: none;" class="add_version">If the result of atomization is a single atomic value, the result of the cast expression is determined by casting to the target type as described in <a href="https://www.w3.org/TR/xpath-functions-31/#casting">Section 19 Casting </a><sup><small>FO31</small></sup>. When casting, an implementation may need to determine whether one type is derived by restriction from another. An implementation can determine this either by examining the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> or by using an alternative, <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> mechanism such as a data dictionary. The result of a cast expression is one of the following: </span><span class="modify_version">If the result of atomization is a single atomic value, the result of the cast expression is determined by casting to the target type as described in <a href="https://www.w3.org/TR/xpath-functions-31/#casting">Section <span class="deltaxml-old">21</span><span class="deltaxml-new">19</span> Casting<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>. When casting, an implementation may need to determine whether one type is derived by restriction from another. An implementation can determine this either by examining the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> or by using an alternative, <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> mechanism such as a data dictionary. The result of a cast expression is one of the following: </span></p><ol class="enumla"><li><p> A value of the target type (or, in the case of list types, a sequence of values that are instances of the item type of the list type). </p></li><li><p> A type error, if casting from the source type to the target type is not supported (for example attempting to convert an integer to a date). </p></li><li><p> A dynamic error, if the particular input value cannot be converted to the target type (for example, attempting to convert the string <code>"three"</code> to an integer). </p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Casting to an enumeration type relies on the fact that an enumeration type is a generalized atomic type. So </span><code><span class="deltaxml-old">cast $x as enum("red")</span></code><span class="deltaxml-old"> is equivalent to casting to an anonymous atomic type derived from </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> whose enumeration facet restricts the value space to the single string </span><code><span class="deltaxml-old">"red"</span></code><span class="deltaxml-old">, while </span><code><span class="deltaxml-old">cast $x as enum("red", "green")</span></code><span class="deltaxml-old"> is equivalent to casting to </span><code><span class="deltaxml-old">union(enum("red"), enum("green"))</span></code><span class="deltaxml-old">.</span></p></div></li></ol></div><div class="div3"><h4><a id="id-castable"></a><span class="deltaxml-old">4.22.4</span><span class="deltaxml-new">4.21.4</span> Castable</h4><a id="d3e29196"></a><a id="d3e26170"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CastableExpr"></a>[<span class="deltaxml-old">117</span><span class="deltaxml-new">110</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CastableExpr">CastableExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CastExpr">CastExpr</a> ( "castable" "as" <a href="#doc-xquery40-SingleType">SingleType</a> )?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e25825.doc-xquery40-SingleType"></a><a id="noid_d4e23066.doc-xquery40-SingleType"></a>[<span class="deltaxml-old">223</span><span class="deltaxml-new">210</span>]&nbsp;&nbsp;&nbsp;</td><td><code>SingleType</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-CastTarget">CastTarget</a> "?"?</code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-SimpleTypeName">SimpleTypeName</a> "?"?</code></span><span class="modify_version"><code><a href="#prod-xquery40-CastTarget"><span class="deltaxml-old">CastTarget</span></a><a href="#doc-xquery40-SimpleTypeName"><span class="deltaxml-new">SimpleTypeName</span></a> "?"?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e25827.doc-xquery40-TypeName"></a><span class="deltaxml-old">[246]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">TypeName</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-EQName"><span class="deltaxml-old">EQName</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e25828.doc-xquery40-LocalUnionType"></a><a id="noid_d4e23067.doc-xquery40-LocalUnionType"></a>[<span class="deltaxml-old">259</span><span class="deltaxml-new">245</span>]&nbsp;&nbsp;&nbsp;</td><td><code>LocalUnionType</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"union" "(" <a href="#doc-xquery40-ItemType">ItemType</a> ("," <a href="#doc-xquery40-ItemType">ItemType</a>)* ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e23068.doc-xquery40-SimpleTypeName"></a><span class="deltaxml-new">[232]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">SimpleTypeName</span></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-TypeName"><span class="deltaxml-new">TypeName</span></a><span class="deltaxml-new"> | </span><a href="#doc-xquery40-LocalUnionType"><span class="deltaxml-new">LocalUnionType</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e23069.doc-xquery40-TypeName"></a><span class="deltaxml-new">[233]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">TypeName</span></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-EQName"><span class="deltaxml-new">EQName</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e25829.doc-xquery40-EnumerationType"></a><a id="noid_d4e23070.doc-xquery40-LocalUnionType"></a>[<span class="deltaxml-old">260</span><span class="deltaxml-new">245</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>EnumerationType</code></span><span style="display: none;" class="add_version"><code>LocalUnionType</code></span><span class="modify_version"><code><span class="deltaxml-old">EnumerationType</span><span class="deltaxml-new">LocalUnionType</span></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"enum" "(" <a href="#doc-xquery40-StringLiteral">StringLiteral</a> ("," <a href="#doc-xquery40-StringLiteral">StringLiteral</a>)* ")"</code></span><span style="display: none;" class="add_version"><code>"union" "(" <a href="#doc-xquery40-ItemType">ItemType</a> ("," <a href="#doc-xquery40-ItemType">ItemType</a>)* ")"</code></span><span class="modify_version"><code>"<span class="deltaxml-old">enum</span><span class="deltaxml-new">union</span>" "(" <a href="#doc-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a><a href="#doc-xquery40-ItemType"><span class="deltaxml-new">ItemType</span></a> ("," <a href="#doc-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a><a href="#doc-xquery40-ItemType"><span class="deltaxml-new">ItemType</span></a>)* ")"</code></span></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version">XQuery 4.0 provides an expression that tests whether a given value is castable into a given target type. The <span>target type</span> must be one of:</span><span style="display: none;" class="add_version">XQuery 4.0 provides an expression that tests whether a given value is castable into a given target type. The <span>target type</span> must be either of:</span><span class="modify_version">XQuery 4.0 provides an expression that tests whether a given value is castable into a given target type. The <span>target type</span> must be <span class="deltaxml-old">one</span><span class="deltaxml-new">either</span> of:</span></p><ul><li class="delete_version" style="display: none;"><p>The name of an <a title="named item type" class="termref" href="#dt-named-item-type">named item type</a> defined in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, which in turn must refer to an item type in one of the following categories.</p></li><li class="modify_version"><p><span class="deltaxml-old">The name of an </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-old">named item type</span></a><span class="deltaxml-old"> defined in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-old">static context</span></a><span class="deltaxml-old">, which in turn must refer to an item type in one of the following categories.</span></p></li><li><p>The name of a type defined in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a>, which must be a simple type [<a href="#ERRXQST0052" title="err:XQST0052">err:XQST0052</a>]. In addition, the target type cannot be <code>xs:NOTATION</code>, <code>xs:anySimpleType</code>, or <code>xs:anyAtomicType</code></p></li><li><p>A <code>LocalUnionType</code> such as <code>union(xs:date, xs:dateTime)</code>.</p></li><li class="delete_version" style="display: none;"><p>An <code>EnumerationType</code> such as <code>enum("red", "green", "blue")</code>.</p></li><li class="modify_version"><p><span class="deltaxml-old">An </span><code><span class="deltaxml-old">EnumerationType</span></code><span class="deltaxml-old"> such as </span><code><span class="deltaxml-old">enum("red", "green", "blue")</span></code><span class="deltaxml-old">.</span></p></li></ul><p><span style="display: none;" class="delete_version">The expression <code>E castable as T</code> returns <code>true</code> if the result of evaluating <code>E</code> can be successfully cast into the target type <code>T</code> by using a <code>cast</code> expression; otherwise it returns <code>false</code>. If evaluation of <code>E</code> fails with a dynamic error or if the value of <code>E</code> cannot be atomized, the <code>castable</code> expression as a whole fails.</span><span style="display: none;" class="add_version">The expression <code>E castable as T</code> returns <code>true</code> if the result of evaluating <code>E</code> can be successfully cast into the target type <code>T</code> by using a <code>cast</code> expression; otherwise it returns <code>false</code>. If evaluation of <code>E</code> fails with a dynamic error or if the value of <code>E</code> cannot be atomized, the <code>castable</code> expression as a whole fails. The <code>castable</code> expression can be used as a <a title="" class="termref" href="#dt-predicate">predicate</a> to avoid errors at evaluation time. It can also be used to select an appropriate type for processing of a given value, as illustrated in the following example:</span><span class="modify_version">The expression <code>E castable as T</code> returns <code>true</code> if the result of evaluating <code>E</code> can be successfully cast into the target type <code>T</code> by using a <code>cast</code> expression; otherwise it returns <code>false</code>. If evaluation of <code>E</code> fails with a dynamic error or if the value of <code>E</code> cannot be atomized, the <code>castable</code> expression as a whole fails.<span class="deltaxml-new"> The </span><code><span class="deltaxml-new">castable</span></code><span class="deltaxml-new"> expression can be used as a </span><a title="" class="termref" href="#dt-predicate"><span class="deltaxml-new">predicate</span></a><span class="deltaxml-new"> to avoid errors at evaluation time. It can also be used to select an appropriate type for processing of a given value, as illustrated in the following example:</span></span></p><p><span class="deltaxml-old">The </span><code><span class="deltaxml-old">castable</span></code><span class="deltaxml-old"> expression can be used as a </span><a title="" class="termref" href="#dt-predicate"><span class="deltaxml-old">predicate</span></a><span class="deltaxml-old"> to avoid errors at evaluation time. It can also be used to select an appropriate type for processing of a given value, as illustrated in the following example:</span></p><div class="exampleInner"><pre>if ($x castable as hatsize) then $x cast as hatsize else if ($x castable as IQ) then $x cast as IQ else $x cast as xs:string</pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The expression </span><code><span class="deltaxml-old">$x castable as enum("red", "green", "blue")</span></code><span class="deltaxml-old"> is for most practical purposes equivalent to </span><code><span class="deltaxml-old">$x = ("red", "green", "blue")</span></code><span class="deltaxml-old">; the main difference is that it uses the Unicode codepoint collation for comparing strings, not the default collation from the static context.</span></p></div></div><div class="div3"><h4><a id="id-constructor-functions"></a><span class="deltaxml-old">4.22.5</span><span class="deltaxml-new">4.21.5</span> Constructor Functions</h4><p><span style="display: none;" class="delete_version">For every simple type in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a> (except <code>xs:NOTATION</code> and <code>xs:anyAtomicType</code>, and <code>xs:anySimpleType</code>, which are not instantiable), a <b>constructor function</b> is implicitly defined. In each case, the name of the constructor function is the same as the name of its target type (including namespace). The signature of the constructor function for a given type depends on the type that is being constructed, and can be found in <a href="https://qt4cg.org/specifications/xpath-functions-40/#constructor-functions">Section 20 Constructor functions</a><sup><small>FO40</small></sup>.</span><span style="display: none;" class="add_version">For every simple type in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a> (except <code>xs:NOTATION</code> and <code>xs:anyAtomicType</code>, and <code>xs:anySimpleType</code>, which are not instantiable), a <b>constructor function</b> is implicitly defined. In each case, the name of the constructor function is the same as the name of its target type (including namespace). The signature of the constructor function for a given type depends on the type that is being constructed, and can be found in <a href="https://www.w3.org/TR/xpath-functions-31/#constructor-functions">Section 18 Constructor functions </a><sup><small>FO31</small></sup>.</span><span class="modify_version">For every simple type in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a> (except <code>xs:NOTATION</code> and <code>xs:anyAtomicType</code>, and <code>xs:anySimpleType</code>, which are not instantiable), a <b>constructor function</b> is implicitly defined. In each case, the name of the constructor function is the same as the name of its target type (including namespace). The signature of the constructor function for a given type depends on the type that is being constructed, and can be found in <a href="https://www.w3.org/TR/xpath-functions-31/#constructor-functions">Section <span class="deltaxml-old">20</span><span class="deltaxml-new">18</span> Constructor functions<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>.</span></p><p><span class="deltaxml-old">There is also a constructor function for every </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-old">named item type</span></a><span class="deltaxml-old"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-old">static context</span></a><span class="deltaxml-old"> that expands either to a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-old">generalized atomic type</span></a><span><span class="deltaxml-old">or to a </span><a href="#doc-xquery40-RecordTest"><span class="deltaxml-old">RecordTest</span></a></span><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">All such constructor functions are classified as </span><a title="system function" class="termref" href="#dt-system-function"><span class="deltaxml-old">system functions</span></a><span class="deltaxml-old">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The constructor function is present in the static context if and only if the corresponding type is present in the static context.</span></p><p><span class="deltaxml-old">For XSLT, this means that a constructor function corresponding to an imported schema type is private to the stylesheet package, and a constructor function corresponding to an </span><code><span class="deltaxml-old">xsl:item-type</span></code><span class="deltaxml-old"> declaration has the same visibility as the </span><code><span class="deltaxml-old">xsl:item-type</span></code><span class="deltaxml-old"> declaration.</span></p><p><span class="deltaxml-old">For XQuery, this means that a constructor function corresponding to an imported schema type is private to the query module, and a constructor function corresponding to a named item type declaration is </span><code><span class="deltaxml-old">%public</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">%private</span></code><span class="deltaxml-old"> according to the annotations on the item type declaration.</span></p></div><p><span style="display: none;" class="delete_version"> [<a id="dt-constructor-function" title="constructor function">Definition</a>: The <b>constructor function</b> for a given simple type is used to convert instances of other simple types into the given type. The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code>(($arg) cast as T?)</code>.] </span><span style="display: none;" class="add_version"> [<a id="dt-constructor-function" title="constructor function">Definition</a>: The <b>constructor function</b> for a given type is used to convert instances of other simple types into the given type. The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code>(($arg) cast as T?)</code>.] </span><span class="modify_version"> [<a id="dt-constructor-function" title="constructor function">Definition</a>: The <b>constructor function</b> for a given <span class="deltaxml-old">simple </span>type is used to convert instances of other simple types into the given type. The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code>(($arg) cast as T?)</code>.] </span></p><p>The following examples illustrate the use of constructor functions:</p><ul><li><p>This example is equivalent to <code>("2000-01-01" cast as xs:date?)</code>.</p><div class="exampleInner"><pre>xs:date("2000-01-01")</pre></div></li><li><p>This example is equivalent to <code>(($floatvalue * 0.2E-5) cast as xs:decimal?)</code>.</p><div class="exampleInner"><pre>xs:decimal($floatvalue * 0.2E-5)</pre></div></li><li><p>This example returns an <code>xs:dayTimeDuration</code> value equal to 21 days. It is equivalent to <code>("P21D" cast as xs:dayTimeDuration?)</code>.</p><div class="exampleInner"><pre>xs:dayTimeDuration("P21D")</pre></div></li><li><p>If <code>usa:zipcode</code> is a user-defined atomic type in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a>, then the following expression is equivalent to the expression <code>("12345" cast as usa:zipcode?)</code>.</p><div class="exampleInner"><pre>usa:zipcode("12345")</pre></div></li><li class="delete_version" style="display: none;"><p>If <code>my:chrono</code> is a named item type that expands to <code>union(xs:date, xs:time, xs:dateTime)</code>, then the result of <code>my:chrono("12:00:00Z")</code> is the <code>xs:time</code> value <code>12:00:00Z</code>.</p></li><li class="modify_version"><p><span class="deltaxml-old">If </span><code><span class="deltaxml-old">my:chrono</span></code><span class="deltaxml-old"> is a named item type that expands to </span><code><span class="deltaxml-old">union(xs:date, xs:time, xs:dateTime)</span></code><span class="deltaxml-old">, then the result of </span><code><span class="deltaxml-old">my:chrono("12:00:00Z")</span></code><span class="deltaxml-old"> is the </span><code><span class="deltaxml-old">xs:time</span></code><span class="deltaxml-old"> value </span><code><span class="deltaxml-old">12:00:00Z</span></code><span class="deltaxml-old">.</span></p></li><li class="delete_version" style="display: none;"><p>If <code>my:location</code> is a named item type that expands to <code>record(latitude as xs:double, longitude as xs:double)</code>, then the result of <code>my:location(50.52, -3.02)</code> is the map <code>map{'latitude':50.52e0, 'longitude':-3.02e0}</code>.</p></li><li class="modify_version"><p><span class="deltaxml-old">If </span><code><span class="deltaxml-old">my:location</span></code><span class="deltaxml-old"> is a named item type that expands to </span><code><span class="deltaxml-old">record(latitude as xs:double, longitude as xs:double)</span></code><span class="deltaxml-old">, then the result of </span><code><span class="deltaxml-old">my:location(50.52, -3.02)</span></code><span class="deltaxml-old"> is the map </span><code><span class="deltaxml-old">map{'latitude':50.52e0, 'longitude':-3.02e0}</span></code><span class="deltaxml-old">.</span></p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p> An instance of an atomic type that is not in a namespace can be constructed by using a <a href="#doc-xquery40-URIQualifiedName">URIQualifiedName</a> in either a cast expression or a constructor function call. Examples: </p><div class="exampleInner"><pre>17 cast as Q{}apple</pre></div><div class="exampleInner"><pre>Q{}apple(17)</pre></div><p>In either context, using an unqualified NCName might not work: in a cast expression, an unqualified name is <span class="deltaxml-old">it is interpreted according to</span><span class="deltaxml-new">resolved using</span> the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><a class="termref" title="default type namespace" href="#dt-def-type-ns"><span class="deltaxml-new">default type namespace</span></a>, while an unqualified name in a constructor function call is resolved using the <a title="default function namespace" class="termref" href="#dt-default-function-namespace">default function namespace</a> which will often be inappropriate. </p></div></div><div class="div3"><h4><a id="id-treat"></a><span class="deltaxml-old">4.22.6</span><span class="deltaxml-new">4.21.6</span> Treat</h4><a id="d3e29468"></a><a id="d3e26372"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TreatExpr"></a>[<span class="deltaxml-old">116</span><span class="deltaxml-new">109</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-TreatExpr">TreatExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CastableExpr">CastableExpr</a> ( "treat" "as" <a href="#doc-xquery40-SequenceType">SequenceType</a> )?</code></td><td></td></tr></tbody></table><p>XQuery 4.0 provides an expression called <code>treat</code> that can be used to modify the <a title="static type" class="termref" href="#dt-static-type">static type</a> of its operand.</p><p>Like <code>cast</code>, the <code>treat</code> expression takes two operands: an expression and a <a href="#doc-xquery40-SequenceType">SequenceType</a>. Unlike <code>cast</code>, however, <code>treat</code> does not change the <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> or value of its operand. Instead, the purpose of <code>treat</code> is to ensure that an expression has an expected dynamic type at evaluation time.</p><p>The semantics of <em><code>expr1</code></em><code> treat as </code><em><code>type1</code></em> are as follows:</p><ul><li><p>During static analysis:</p><p> The <a title="static type" class="termref" href="#dt-static-type">static type</a> of the <code>treat</code> expression is <em><code>type1</code></em>. This enables the expression to be used as an argument of a function that requires a parameter of <em><code>type1</code></em>.</p></li><li><p>During expression evaluation:</p><p>If <em><code>expr1</code></em> matches <em><code>type1</code></em>, using the rules for <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType matching</a>, the <code>treat</code> expression returns the value of <em><code>expr1</code></em>; otherwise, it raises a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>]. If the value of <em><code>expr1</code></em> is returned, the identity of any nodes in the value is preserved. The <code>treat</code> expression ensures that the value of its expression operand conforms to the expected type at run-time.</p></li><li><p>Example:</p><div class="exampleInner"><pre>$myaddress treat as element(*, USAddress)</pre></div><p>The <a title="static type" class="termref" href="#dt-static-type">static type</a> of <code>$myaddress</code> may be <code>element(*, Address)</code>, a less specific type than <code>element(*, USAddress)</code>. However, at run-time, the value of <code>$myaddress</code> must match the type <code>element(*, USAddress)</code> using rules for <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType matching</a>; otherwise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>].</p></li></ul></div></div><div class="div2"><h3><span style="display: none;" class="delete_version"><a id="id-map-operator"></a>4.23 Simple map operator (<code>!</code>)</span><span style="display: none;" class="add_version"><a id="id-map-operator"></a>4.22 Simple map operator (<code>!</code>)</span><span class="modify_version"><a id="id-map-operator"></a><span class="deltaxml-old">4.23</span><span class="deltaxml-new">4.22</span> Simple map operator (<code>!</code>)</span></h3><a id="d3e29610"></a><a id="d3e26514"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SimpleMapExpr"></a>[<span class="deltaxml-old">134</span><span class="deltaxml-new">125</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SimpleMapExpr">SimpleMapExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PathExpr">PathExpr</a> ("!" <a href="#doc-xquery40-PathExpr">PathExpr</a>)*</code></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version"> A mapping expression <code>S!E</code> evaluates the expression <code>E</code> once for every item in the sequence obtained by evaluating <code>S</code>. The simple mapping operator <code>!</code> can be applied to any sequence, regardless of the types of its items, and it can deliver a mixed sequence of nodes, atomic values, and functions. Unlike the similar <code>/</code> operator, it does not sort nodes into document order or eliminate duplicates. </span><span style="display: none;" class="add_version"> A mapping expression <code>S!E</code> evaluates the expression <code>E</code> once for every item in the sequence obtained by evaluating <code>S</code>. The simple mapping operator "<code>!</code>" can be applied to any sequence, regardless of the types of its items, and it can deliver a mixed sequence of nodes, atomic values, and functions. Unlike the similar "<code>/</code>" operator, it does not sort nodes into document order or eliminate duplicates. </span><span class="modify_version"> A mapping expression <code>S!E</code> evaluates the expression <code>E</code> once for every item in the sequence obtained by evaluating <code>S</code>. The simple mapping operator <span class="deltaxml-new">"</span><code>!</code><span class="deltaxml-new">"</span> can be applied to any sequence, regardless of the types of its items, and it can deliver a mixed sequence of nodes, atomic values, and functions. Unlike the similar <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> operator, it does not sort nodes into document order or eliminate duplicates. </span></p><p><span style="display: none;" class="delete_version">Each operation <code>E1!E2</code> is evaluated as follows: Expression <code>E1</code> is evaluated to a sequence <code>S</code>. Each item in <code>S</code> then serves in turn to provide an inner focus (the item as the context value, its position in <code>S</code> as the context position, the length of <code>S</code> as the context size) for an evaluation of <code>E2</code> in the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a>. The sequences resulting from all the evaluations of <code>E2</code> are combined as follows: Every evaluation of <code>E2</code> returns a (possibly empty) sequence of items. These sequences are concatenated and returned. <span class="xquery">If ordering mode is ordered, the</span> returned sequence preserves the orderings within and among the subsequences generated by the evaluations of <code>E2</code><span class="xquery">; otherwise the order of the returned sequence is implementation-dependent.</span></span><span style="display: none;" class="add_version">Each operation <code>E1!E2</code> is evaluated as follows: Expression <code>E1</code> is evaluated to a sequence <code>S</code>. Each item in <code>S</code> then serves in turn to provide an inner focus (the item as the context item, its position in <code>S</code> as the context position, the length of <code>S</code> as the context size) for an evaluation of <code>E2</code> in the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a>. The sequences resulting from all the evaluations of <code>E2</code> are combined as follows: Every evaluation of <code>E2</code> returns a (possibly empty) sequence of items. These sequences are concatenated and returned. <span class="xquery">If ordering mode is ordered, the</span> returned sequence preserves the orderings within and among the subsequences generated by the evaluations of <code>E2</code><span class="xquery">; otherwise the order of the returned sequence is implementation-dependent.</span></span><span class="modify_version">Each operation <code>E1!E2</code> is evaluated as follows: Expression <code>E1</code> is evaluated to a sequence <code>S</code>. Each item in <code>S</code> then serves in turn to provide an inner focus (the item as the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>, its position in <code>S</code> as the context position, the length of <code>S</code> as the context size) for an evaluation of <code>E2</code> in the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a>. The sequences resulting from all the evaluations of <code>E2</code> are combined as follows: Every evaluation of <code>E2</code> returns a (possibly empty) sequence of items. These sequences are concatenated and returned. <span class="xquery">If ordering mode is ordered, the</span> returned sequence preserves the orderings within and among the subsequences generated by the evaluations of <code>E2</code><span class="xquery">; otherwise the order of the returned sequence is implementation-dependent.</span></span></p><p>Simple map operators have functionality similar to <a href="#id-path-operator"><span style="display: none;" class="delete_version"><b>4.7.3 Path operator (/)</b></span><span style="display: none;" class="add_version"><b>4.6.1.1 Path operator (/)</b></span><span class="modify_version"><b><span class="deltaxml-old">4.7.3</span><span class="deltaxml-new">4.6.1.1</span> Path operator (/)</b></span></a>. The following table summarizes the differences between these two operators</p><table style="width:100%" class="medium"><thead><tr><th>Operator</th><th>Path operator (<code>E1 / E2</code>)</th><th>Simple map operator (<code>E1 ! E2</code>)</th></tr></thead><tbody><tr><th>E1</th><td>Any sequence of nodes</td><td>Any sequence of items</td></tr><tr><th>E2</th><td>Either a sequence of nodes or a sequence of non-node items</td><td>A sequence of items</td></tr><tr><th>Additional processing</th><td>Duplicate elimination and document ordering</td><td>Simple sequence concatenation</td></tr></tbody></table><p>The following examples illustrate the use of simple map operators combined with path expressions.</p><div class="example"><ul><li><p><code>child::div1 / child::para / string() ! concat("id-", .)</code></p><p>Selects the <code>para</code> element children of the <code>div1</code> element children of the context node; that is, the <code>para</code> element grandchildren of the context node that have <code>div1</code> parents. It then outputs the strings obtained by prepending <code>"id-"</code> to each of the string values of these grandchildren.</p></li><li><p><code>$emp ! (@first, @middle, @last)</code></p><p><span style="display: none;" class="delete_version">Returns the values of the attributes <code>first</code>, <code>middle</code>, and <code>last</code> for each element in <code>$emp</code>, in the order given. (The <code>/</code> operator, if used here, would return the attributes in an unpredictable order.)</span><span style="display: none;" class="add_version">Returns the values of the attributes <code>first</code>, <code>middle</code>, and <code>last</code> for element <code>$emp</code>, in the order given. (The <code>/</code> operator here returns the attributes in an unpredictable order.)</span><span class="modify_version">Returns the values of the attributes <code>first</code>, <code>middle</code>, and <code>last</code> for <span class="deltaxml-old">each </span>element <span class="deltaxml-old">in </span><code>$emp</code>, in the order given. (The <code>/</code> operator<span class="deltaxml-old">, if used here, would return</span><span class="deltaxml-new"> here returns</span> the attributes in an unpredictable order.)</span></p></li><li><p><code>$docs ! ( //employee)</code></p><p><span style="display: none;" class="delete_version">Returns all the <code>employee</code> elements within all the documents identified by the variable <code>$docs</code>, in document order within each document, but retaining the order of documents.</span><span style="display: none;" class="add_version">Returns all the employees within all the documents identified by the variable docs, in document order within each document, but retaining the order of documents.</span><span class="modify_version">Returns all the <span class="deltaxml-old">employee</span><span class="deltaxml-new">employees</span> <span class="deltaxml-old">elements </span>within all the documents identified by the variable <span class="deltaxml-old">$</span>docs, in document order within each document, but retaining the order of documents.</span></p></li><li><p><code>avg( //employee / salary ! translate(., '$', '') ! number(.))</code></p><p>Returns the average salary of the employees, having converted the salary to a number by removing any <code>$</code> sign and then converting to a number. (The second occurrence of <code>!</code> could not be written as <code>/</code> because the left-hand operand of <code>/</code> cannot be an atomic value.)</p></li><li><p><span style="display: none;" class="delete_version"><code>string-join((1 to $n)!"*")</code></span><span style="display: none;" class="add_version"><code>fn:string-join((1 to $n)!"*")</code></span><span class="modify_version"><code><span class="deltaxml-old">string</span><span class="deltaxml-new">fn:string</span>-join((1 to $n)!"*")</code></span></p><p>Returns a string containing <code>$n</code> asterisks.</p></li><li><p><span style="display: none;" class="delete_version"><code>$values!(.*.) =&gt; sum()</code></span><span style="display: none;" class="add_version"><code>$values!(.*.) =&gt; fn:sum()</code></span><span class="modify_version"><code>$values!(.*.) =&gt; <span class="deltaxml-old">sum</span><span class="deltaxml-new">fn:sum</span>()</code></span></p><p>Returns the sum of the squares of a sequence of numbers.</p></li><li><p><code>string-join(ancestor::*!name(), '/')</code></p><p><span class="deltaxml-old">Returns the names of ancestor elements, joined by </span><code><span class="deltaxml-old">/</span></code><span class="deltaxml-old"> characters, i.e., the path to the parent of the context.</span></p><p><span class="deltaxml-new">Returns a path containing the names of the ancestors of an element, separated by "</span><code><span class="deltaxml-new">/</span></code><span class="deltaxml-new">" characters.</span></p></li></ul></div></div><div class="div2"><h3><a id="id-arrow-operator"></a><span class="deltaxml-old">4.24</span><span class="deltaxml-new">4.23</span> Arrow Expressions</h3><p><span class="deltaxml-old">Arrow expressions apply a function to a value, using the value of the left-hand expression as the first argument to the function.</span></p><a id="d3e29803"></a><a id="d3e26701"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ArrowExpr"></a>[<span class="deltaxml-old">119</span><span class="deltaxml-new">112</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ArrowExpr">ArrowExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-UnaryExpr">UnaryExpr</a> ( (<a href="#doc-xquery40-SequenceArrowTarget">SequenceArrowTarget</a> | <a href="#doc-xquery40-MappingArrowTarget">MappingArrowTarget</a> | <a href="#doc-xquery40-LookupArrowTarget">LookupArrowTarget</a>) )*</code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-UnaryExpr">UnaryExpr</a> ( (<a href="#doc-xquery40-FatArrowTarget">FatArrowTarget</a> | <a href="#doc-xquery40-ThinArrowTarget">ThinArrowTarget</a>) )*</code></span><span class="modify_version"><code><a href="#doc-xquery40-UnaryExpr">UnaryExpr</a> ( (<a href="#doc-xquery40-SequenceArrowTarget"><span class="deltaxml-old">SequenceArrowTarget</span></a><a href="#doc-xquery40-FatArrowTarget"><span class="deltaxml-new">FatArrowTarget</span></a> | <a href="#doc-xquery40-MappingArrowTarget"><span class="deltaxml-old">MappingArrowTarget</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-LookupArrowTarget"><span class="deltaxml-old">LookupArrowTarget</span></a><a href="#doc-xquery40-ThinArrowTarget"><span class="deltaxml-new">ThinArrowTarget</span></a>) )*</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SequenceArrowTarget"></a><a id="doc-xquery40-FatArrowTarget"></a>[<span class="deltaxml-old">122</span><span class="deltaxml-new">115</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-SequenceArrowTarget">SequenceArrowTarget</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-FatArrowTarget">FatArrowTarget</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-SequenceArrowTarget"><span class="deltaxml-old">SequenceArrowTarget</span></a><a href="#prod-xquery40-FatArrowTarget"><span class="deltaxml-new">FatArrowTarget</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"=&gt;" <a href="#doc-xquery40-ArrowTarget">ArrowTarget</a></code></span><span style="display: none;" class="add_version"><code>"=&gt;" ((<a href="#doc-xquery40-ArrowStaticFunction">ArrowStaticFunction</a><a href="#doc-xquery40-ArgumentList">ArgumentList</a>) | (<a href="#doc-xquery40-ArrowDynamicFunction">ArrowDynamicFunction</a><a href="#doc-xquery40-PositionalArgumentList">PositionalArgumentList</a>))</code></span><span class="modify_version"><code>"=&gt;" <a href="#doc-xquery40-ArrowTarget"><span class="deltaxml-old">ArrowTarget</span></a><span class="deltaxml-new">((</span><a href="#doc-xquery40-ArrowStaticFunction"><span class="deltaxml-new">ArrowStaticFunction</span></a><a href="#doc-xquery40-ArgumentList"><span class="deltaxml-new">ArgumentList</span></a><span class="deltaxml-new">) | (</span><a href="#doc-xquery40-ArrowDynamicFunction"><span class="deltaxml-new">ArrowDynamicFunction</span></a><a href="#doc-xquery40-PositionalArgumentList"><span class="deltaxml-new">PositionalArgumentList</span></a><span class="deltaxml-new">))</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-MappingArrowTarget"></a><a id="doc-xquery40-ThinArrowTarget"></a>[<span class="deltaxml-old">123</span><span class="deltaxml-new">116</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-MappingArrowTarget">MappingArrowTarget</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-ThinArrowTarget">ThinArrowTarget</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-MappingArrowTarget"><span class="deltaxml-old">MappingArrowTarget</span></a><a href="#prod-xquery40-ThinArrowTarget"><span class="deltaxml-new">ThinArrowTarget</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"=!&gt;" <a href="#doc-xquery40-ArrowTarget">ArrowTarget</a></code></span><span style="display: none;" class="add_version"><code>"-&gt;" ((<a href="#doc-xquery40-ArrowStaticFunction">ArrowStaticFunction</a><a href="#doc-xquery40-ArgumentList">ArgumentList</a>) | (<a href="#doc-xquery40-ArrowDynamicFunction">ArrowDynamicFunction</a><a href="#doc-xquery40-PositionalArgumentList">PositionalArgumentList</a>) | <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a>)</code></span><span class="modify_version"><code>"<span class="deltaxml-old">=!</span><span class="deltaxml-new">-</span>&gt;" <a href="#doc-xquery40-ArrowTarget"><span class="deltaxml-old">ArrowTarget</span></a><span class="deltaxml-new">((</span><a href="#doc-xquery40-ArrowStaticFunction"><span class="deltaxml-new">ArrowStaticFunction</span></a><a href="#doc-xquery40-ArgumentList"><span class="deltaxml-new">ArgumentList</span></a><span class="deltaxml-new">) | (</span><a href="#doc-xquery40-ArrowDynamicFunction"><span class="deltaxml-new">ArrowDynamicFunction</span></a><a href="#doc-xquery40-PositionalArgumentList"><span class="deltaxml-new">PositionalArgumentList</span></a><span class="deltaxml-new">) | </span><a href="#doc-xquery40-EnclosedExpr"><span class="deltaxml-new">EnclosedExpr</span></a><span class="deltaxml-new">)</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LookupArrowTarget"></a><span class="deltaxml-old">[125]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-LookupArrowTarget"><span class="deltaxml-old">LookupArrowTarget</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"=?&gt;" </span><a href="#prod-xquery40-NCName"><span class="deltaxml-old">NCName</span></a><a href="#doc-xquery40-PositionalArgumentList"><span class="deltaxml-old">PositionalArgumentList</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ArrowTarget"></a><span class="deltaxml-old">[124]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-ArrowTarget"><span class="deltaxml-old">ArrowTarget</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">(</span><a href="#doc-xquery40-ArrowStaticFunction"><span class="deltaxml-old">ArrowStaticFunction</span></a><a href="#doc-xquery40-ArgumentList"><span class="deltaxml-old">ArgumentList</span></a><span class="deltaxml-old">) | (</span><a href="#doc-xquery40-ArrowDynamicFunction"><span class="deltaxml-old">ArrowDynamicFunction</span></a><a href="#doc-xquery40-PositionalArgumentList"><span class="deltaxml-old">PositionalArgumentList</span></a><span class="deltaxml-old">)</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ArrowStaticFunction"></a>[<span class="deltaxml-old">164</span><span class="deltaxml-new">151</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ArrowStaticFunction">ArrowStaticFunction</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ArrowDynamicFunction"></a>[<span class="deltaxml-old">165</span><span class="deltaxml-new">152</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ArrowDynamicFunction">ArrowDynamicFunction</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-VarRef">VarRef</a> | <a href="#doc-xquery40-InlineFunctionExpr">InlineFunctionExpr</a> | <a href="#doc-xquery40-ParenthesizedExpr">ParenthesizedExpr</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-VarRef">VarRef</a> | <a href="#doc-xquery40-ParenthesizedExpr">ParenthesizedExpr</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-VarRef">VarRef</a> | <a href="#doc-xquery40-InlineFunctionExpr"><span class="deltaxml-old">InlineFunctionExpr</span></a><span class="deltaxml-old"> | </span><a href="#doc-xquery40-ParenthesizedExpr">ParenthesizedExpr</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e26382.doc-xquery40-InlineFunctionExpr"></a><span class="deltaxml-old">[207]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">InlineFunctionExpr</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-Annotation"><span class="deltaxml-old">Annotation</span></a><span class="deltaxml-old">* ("function" | "fn") </span><a href="#doc-xquery40-FunctionSignature"><span class="deltaxml-old">FunctionSignature</span></a><span class="deltaxml-old">? </span><a href="#doc-xquery40-FunctionBody"><span class="deltaxml-old">FunctionBody</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e26383.doc-xquery40-ArgumentList"></a><a id="noid_d4e23535.doc-xquery40-ArgumentList"></a>[<span class="deltaxml-old">153</span><span class="deltaxml-new">142</span>]&nbsp;&nbsp;&nbsp;</td><td><code>ArgumentList</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"(" ((<a href="#doc-xquery40-PositionalArguments">PositionalArguments</a> ("," <a href="#prod-xquery40-KeywordArguments">KeywordArguments</a>)?) | <a href="#prod-xquery40-KeywordArguments">KeywordArguments</a>)? ")"</code></span><span style="display: none;" class="add_version"><code>"(" ((<a href="#doc-xquery40-PositionalArguments">PositionalArguments</a> ("," <a href="#doc-xquery40-KeywordArguments">KeywordArguments</a>)?) | <a href="#doc-xquery40-KeywordArguments">KeywordArguments</a>)? ")"</code></span><span class="modify_version"><code>"(" ((<a href="#doc-xquery40-PositionalArguments">PositionalArguments</a> ("," <a href="#doc-xquery40-KeywordArguments">KeywordArguments</a>)?) | <a href="#doc-xquery40-KeywordArguments">KeywordArguments</a>)? ")"</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e26384.doc-xquery40-PositionalArgumentList"></a><a id="doc-xquery40-PositionalArgumentList"></a>[<span class="deltaxml-old">154</span><span class="deltaxml-new">143</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>PositionalArgumentList</code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-PositionalArgumentList">PositionalArgumentList</a></code></span><span class="modify_version"><code><span class="deltaxml-old">PositionalArgumentList</span><a href="#prod-xquery40-PositionalArgumentList"><span class="deltaxml-new">PositionalArgumentList</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" <a href="#doc-xquery40-PositionalArguments">PositionalArguments</a>? ")"</code></td><td></td></tr></tbody></table><p><span class="deltaxml-new"> [</span><a id="dt-arrow-operator" title="arrow operator"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: An </span><b><span class="deltaxml-new">arrow operator</span></b><span class="deltaxml-new"> applies a function to the value of an expression, using the value as the first argument to the function.] </span></p><p><span class="deltaxml-new">The </span><b><span class="deltaxml-new">fat arrow</span></b><span class="deltaxml-new"> operator </span><code><span class="deltaxml-new">=&gt;</span></code><span class="deltaxml-new"> is defined as follows: </span></p><ul><li><p><span class="deltaxml-new">Given a </span><a href="#doc-xquery40-UnaryExpr"><span class="deltaxml-new">UnaryExpr</span></a><code><span class="deltaxml-new">U</span></code><span class="deltaxml-new">, an </span><a href="#doc-xquery40-ArrowStaticFunction"><span class="deltaxml-new">ArrowStaticFunction</span></a><code><span class="deltaxml-new">F</span></code><span class="deltaxml-new">, and an </span><a href="#doc-xquery40-ArgumentList"><span class="deltaxml-new">ArgumentList</span></a><code><span class="deltaxml-new">(A, B, C...)</span></code><span class="deltaxml-new">, the expression </span><code><span class="deltaxml-new">U =&gt; F(A, B, C...)</span></code><span class="deltaxml-new"> is equivalent to the expression </span><code><span class="deltaxml-new">F(U, A, B, C...)</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">Given a </span><a href="#doc-xquery40-UnaryExpr"><span class="deltaxml-new">UnaryExpr</span></a><code><span class="deltaxml-new">U</span></code><span class="deltaxml-new">, an </span><a href="#doc-xquery40-ArrowDynamicFunction"><span class="deltaxml-new">ArrowDynamicFunction</span></a><code><span class="deltaxml-new">F</span></code><span class="deltaxml-new">, and an </span><a href="#doc-xquery40-PositionalArgumentList"><span class="deltaxml-new">PositionalArgumentList</span></a><code><span class="deltaxml-new">(A, B, C...)</span></code><span class="deltaxml-new">, the expression </span><code><span class="deltaxml-new">U =&gt; F(A, B, C...)</span></code><span class="deltaxml-new"> is equivalent to the expression </span><code><span class="deltaxml-new">F(U, A, B, C...)</span></code><span class="deltaxml-new">.</span></p></li></ul><p><span class="deltaxml-new">The </span><b><span class="deltaxml-new">thin arrow</span></b><span class="deltaxml-new"> operator </span><code><span class="deltaxml-new">-&gt;</span></code><span class="deltaxml-new"> is defined as follows:</span></p><ul><li><p><span class="deltaxml-new">If the arrow is followed by an </span><a href="#doc-xquery40-ArrowStaticFunction"><span class="deltaxml-new">ArrowStaticFunction</span></a><span class="deltaxml-new">:</span></p><p><span class="deltaxml-new">Given a </span><a href="#doc-xquery40-UnaryExpr"><span class="deltaxml-new">UnaryExpr</span></a><code><span class="deltaxml-new">U</span></code><span class="deltaxml-new">, an </span><a href="#doc-xquery40-ArrowStaticFunction"><span class="deltaxml-new">ArrowStaticFunction</span></a><code><span class="deltaxml-new">F</span></code><span class="deltaxml-new">, and an </span><a href="#doc-xquery40-ArgumentList"><span class="deltaxml-new">ArgumentList</span></a><code><span class="deltaxml-new">(A, B, C...)</span></code><span class="deltaxml-new">, the expression </span><code><span class="deltaxml-new">U -&gt; F(A, B, C...)</span></code><span class="deltaxml-new"> is equivalent to the expression </span><code><span class="deltaxml-new">(U ! F(., A, B, C...))</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">If the arrow is followed by an </span><a href="#doc-xquery40-ArrowDynamicFunction"><span class="deltaxml-new">ArrowDynamicFunction</span></a><span class="deltaxml-new">:</span></p><p><span class="deltaxml-new">Given a </span><a href="#doc-xquery40-UnaryExpr"><span class="deltaxml-new">UnaryExpr</span></a><code><span class="deltaxml-new">U</span></code><span class="deltaxml-new">, an </span><a href="#doc-xquery40-ArrowDynamicFunction"><span class="deltaxml-new">ArrowDynamicFunction</span></a><code><span class="deltaxml-new">F</span></code><span class="deltaxml-new">, and an </span><a href="#doc-xquery40-PositionalArgumentList"><span class="deltaxml-new">PositionalArgumentList</span></a><code><span class="deltaxml-new">(A, B, C...)</span></code><span class="deltaxml-new">, the expression </span><code><span class="deltaxml-new">U -&gt; F(A, B, C...)</span></code><span class="deltaxml-new"> is equivalent to the expression </span><code><span class="deltaxml-new">(U ! F(., A, B, C...))</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">If the arrow is followed by an </span><a href="#doc-xquery40-EnclosedExpr"><span class="deltaxml-new">EnclosedExpr</span></a><span class="deltaxml-new">:</span></p><p><span class="deltaxml-new">Given a </span><a href="#doc-xquery40-UnaryExpr"><span class="deltaxml-new">UnaryExpr</span></a><code><span class="deltaxml-new">U</span></code><span class="deltaxml-new">, and an </span><a href="#doc-xquery40-EnclosedExpr"><span class="deltaxml-new">EnclosedExpr</span></a><code><span class="deltaxml-new">{E}</span></code><span class="deltaxml-new">, the expression </span><code><span class="deltaxml-new">U -&gt; {E}</span></code><span class="deltaxml-new"> is equivalent to the expression </span><code><span class="deltaxml-new">(U) ! (E)</span></code><span class="deltaxml-new">.</span></p><p><span class="deltaxml-new">For example, the expression </span><code><span class="deltaxml-new">$x -&gt; {.+1}</span></code><span class="deltaxml-new"> is equivalent to </span><code><span class="deltaxml-new">($x)!(.+1)</span></code><span class="deltaxml-new">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">The precedence of the </span><code><span class="deltaxml-new">!</span></code><span class="deltaxml-new"> operator is higher than that of </span><code><span class="deltaxml-new">-&gt;</span></code><span class="deltaxml-new">, so </span><code><span class="deltaxml-new">$x -&gt; f() -&gt; {.+1}</span></code><span class="deltaxml-new"> is equivalent to </span><code><span class="deltaxml-new">($x -&gt; f()) ! (.+1)</span></code><span class="deltaxml-new">. Using the </span><code><span class="deltaxml-new">-&gt;</span></code><span class="deltaxml-new"> operator in such a pipeline expression, in preference to </span><code><span class="deltaxml-new">!</span></code><span class="deltaxml-new">, can therefore reduce the need for parentheses.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">The expression </span><code><span class="deltaxml-new">$x -&gt; {.+1}</span></code><span class="deltaxml-new"> can be considered as an abbreviation for </span><code><span class="deltaxml-new">$x -&gt; (-&gt;{.+1})()</span></code><span class="deltaxml-new">: that is, it calls the anonymous function </span><code><span class="deltaxml-new">-&gt;{.+1}</span></code><span class="deltaxml-new"> once for each item in </span><code><span class="deltaxml-new">$x</span></code><span class="deltaxml-new">.</span></p></div></li></ul><p><span class="deltaxml-new">The fat arrow operator thus applies the supplied function to the result of the left-hand operand as a whole, while the thin arrow operator applies the function (or enclosed expression) to each item in the value of the left-hand operand individually. In the case where the result of the left-hand operand is a single item, the two operators have almost the same effect; the only difference is that the thin arrow binds the </span><a title="focus" class="termref" href="#dt-focus"><span class="deltaxml-new">focus</span></a><span class="deltaxml-new">.</span></p><p><span class="deltaxml-old">The arrow</span><span class="deltaxml-new">This</span> syntax is particularly helpful when applying multiple functions to a value in turn. For example, the following expression invites syntax errors due to misplaced parentheses: </p><div class="exampleInner"><pre>tokenize((normalize-unicode(upper-case($string))),"\s+")</pre></div><p>In the following reformulation, it is easier to see that the parentheses are balanced:</p><div class="exampleInner"><pre><span class="deltaxml-old">$string =&gt; upper-case() =&gt; normalize-unicode() =&gt; tokenize("\s+")</span></pre><pre><span class="deltaxml-new">$string -&gt; upper-case() -&gt; normalize-unicode() -&gt; tokenize("\s+")</span></pre></div><p><span style="display: none;" class="delete_version">When the operator is written as <code>=!&gt;</code>, the function is applied to each item in the sequence in turn. Assuming that <code>$string</code> is a single string, the above example could equally be written:</span><span style="display: none;" class="add_version">Assuming that <code>$string</code> is a single string, the above example could equally be written:</span><span class="modify_version"><span class="deltaxml-old">When the operator is written as </span><span class="deltaxml-old">=!&gt;</span><span class="deltaxml-old">, the function is applied to each item in the sequence in turn. </span>Assuming that <code>$string</code> is a single string, the above example could equally be written:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">$string =!&gt; upper-case() =!&gt; normalize-unicode() =!&gt; tokenize("\s+")</span></pre><pre><span class="deltaxml-new">$string =&gt; upper-case() =&gt; normalize-unicode() =&gt; tokenize("\s+")</span></pre></div><p>The difference between the two operators is seen when the left-hand operand evaluates to a sequence:</p><div class="exampleInner"><pre><span class="deltaxml-old">(1, 2, 3) =&gt; avg()</span></pre><pre><span class="deltaxml-new">"The cat sat on the mat" =&gt; tokenize() -&gt; concat(".") -&gt; upper-case() =&gt; string-join(" ")</span></pre></div><p><span class="deltaxml-old">returns a value of only one item, </span><code><span class="deltaxml-old">2</span></code><span class="deltaxml-old">, the average of all three items, whereas </span></p><div class="exampleInner"><pre><span class="deltaxml-old">(1, 2, 3) =!&gt; avg()</span></pre></div><p><span class="deltaxml-old">returns the original sequence of three items, </span><code><span class="deltaxml-old">(1, 2, 3)</span></code><span class="deltaxml-old">, each item being the average of itself. The following example:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">"The cat sat on the mat" =&gt; tokenize() =!&gt; concat(".") =!&gt; upper-case() =&gt; string-join(" ")</span></pre></div><p><span style="display: none;" class="delete_version">returns <code>"THE. CAT. SAT. ON. THE. MAT."</code>. The first arrow could be written either as <code>=&gt;</code> or <code>=!&gt;</code> because the operand is a singleton; the next two arrows have to be <code>=!&gt;</code> because the function is applied to each item in the tokenized sequence individually; the final arrow must be <code>=&gt;</code> because the <code>string-join</code> function applies to the sequence as a whole.</span><span style="display: none;" class="add_version">which returns <code>"THE. CAT. SAT. ON. THE. MAT."</code>. The first arrow could be written either as <code>=&gt;</code> or <code>-&gt;</code> because the operand is a singleton; the next two arrows have to be <code>-&gt;</code> because the function is applied to each item in the tokenized sequence individually; the final arrow must be <code>=&gt;</code> because the <code>string-join</code> function applies to the sequence as a whole.</span><span class="modify_version"><span class="deltaxml-new">which </span>returns <code>"THE. CAT. SAT. ON. THE. MAT."</code>. The first arrow could be written either as <code>=&gt;</code> or <code><span class="deltaxml-old">=!</span><span class="deltaxml-new">-</span>&gt;</code> because the operand is a singleton; the next two arrows have to be <code><span class="deltaxml-old">=!</span><span class="deltaxml-new">-</span>&gt;</code> because the function is applied to each item in the tokenized sequence individually; the final arrow must be <code>=&gt;</code> because the <code>string-join</code> function applies to the sequence as a whole.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">It may be useful to think of this as a map/reduce pipeline. The functions introduced by <code>=!&gt;</code> are mapping operations; the function introduced by <code>=&gt;</code> is a reduce operation.</span><span style="display: none;" class="add_version">It may be useful to think of this as a map/reduce pipeline. The functions introduced by <code>-&gt;</code> are mapping operations; the function introduced by <code>=&gt;</code> is a reduce operation.</span><span class="modify_version">It may be useful to think of this as a map/reduce pipeline. The functions introduced by <code><span class="deltaxml-old">=!</span><span class="deltaxml-new">-</span>&gt;</code> are mapping operations; the function introduced by <code>=&gt;</code> is a reduce operation.</span></p></div><p>The following example introduces an <span class="deltaxml-old">inline function</span><span class="deltaxml-new">enclosed expression</span> to the pipeline:</p><div class="exampleInner"><pre><span class="deltaxml-old">(1 to 5) =!&gt; xs:double() =!&gt; math:sqrt() =!&gt; fn($a){$a+1}() =&gt; sum()</span></pre><pre><span class="deltaxml-new">(1 to 5) -&gt; xs:double() -&gt; math:sqrt() -&gt; {.+1} =&gt; sum()</span></pre></div><p>This is equivalent to <code>sum((1 to 5) ! (math:sqrt(xs:double(.))+1))</code>.</p><p><span class="deltaxml-old">The same effect can be achieved using a </span><a title="focus function" class="termref" href="#dt-focus-function"><span class="deltaxml-old">focus function</span></a><span class="deltaxml-old">:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">(1 to 5) =!&gt; xs:double() =!&gt; math:sqrt() =!&gt; fn{.+1}() =&gt; sum()</span></pre></div><p><span class="deltaxml-old">Where the value of an expression is a map containing functions, simulating the behavior of objects in object-oriented languages, then the </span><b><span class="deltaxml-old">lookup arrow operator</span></b><code><span class="deltaxml-old">=?&gt;</span></code><span class="deltaxml-old"> can be used to retrive a function from the map and to invoke the function with the map as its first argument. For example, if </span><code><span class="deltaxml-old">my:rectangle</span></code><span class="deltaxml-old"> returns a map with entries </span><code><span class="deltaxml-old">width</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">height</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">expand</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">area</span></code><span class="deltaxml-old">, then it becomes possible to write:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">my:rectangle(3,5) =?&gt; expand(2) =?&gt; area()</span></pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">The <code>ArgumentList</code> may include <code>PlaceHolders</code>, though this is not especially useful. For example, the expression <code>"$" =&gt; concat(?)</code> is equivalent to <code>concat("$", ?)</code>: its value is a function that prepends a supplied string with a <code>$</code> symbol.</span><span style="display: none;" class="add_version">The <code>ArgumentList</code> may include <code>PlaceHolders</code>, though this is not especially useful. For example, the expression <code>"$" -&gt; concat(?)</code> is equivalent to <code>concat("$", ?)</code>: its value is a function that prepends a supplied string with a "$" symbol.</span><span class="modify_version">The <code>ArgumentList</code> may include <code>PlaceHolders</code>, though this is not especially useful. For example, the expression <code>"$" <span class="deltaxml-old">=</span><span class="deltaxml-new">-</span>&gt; concat(?)</code> is equivalent to <code>concat("$", ?)</code>: its value is a function that prepends a supplied string with a <span class="deltaxml-new">"</span>$<span class="deltaxml-new">"</span> symbol.</span></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>ArgumentList</code> may include keyword arguments if the function is identified statically (that is, by name). For example, the following is valid: <code>$xml =&gt; xml-to-json(indent:=true()) =&gt; parse-json(escape:=false())</code>.</p></div><p><span class="deltaxml-old">The sequence arrow operator thus applies the supplied function to the left-hand operand as a whole, while the mapping arrow operator applies the function to each item in the value of the left-hand operand individually. In the case where the result of the left-hand operand is a single item, the two operators have the same effect.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The mapping arrow symbol </span><code><span class="deltaxml-old">=!&gt;</span></code><span class="deltaxml-old"> is intended to suggest a combination of function application (</span><code><span class="deltaxml-old">=&gt;</span></code><span class="deltaxml-old">) and sequence mapping (</span><code><span class="deltaxml-old">!</span></code><span class="deltaxml-old">) combined in a single operation.</span></p><p><span class="deltaxml-old">Similarly, the lookup arrow symbol </span><code><span class="deltaxml-old">=?&gt;</span></code><span class="deltaxml-old"> is intended to suggest a combination of function application (</span><code><span class="deltaxml-old">=&gt;</span></code><span class="deltaxml-old">) and map lookup (</span><code><span class="deltaxml-old">?</span></code><span class="deltaxml-old">) in a single operation.</span></p></div><div class="div3"><h4><a id="id-sequence-arrow-expression"></a><span class="deltaxml-old">4.24.1 Sequence Arrow Expressions</span></h4><p><span class="deltaxml-old"> [</span><a id="dt-sequence-arrow-operator" title="sequence arrow operator"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: The </span><b><span class="deltaxml-old">sequence arrow operator</span></b><code><span class="deltaxml-old">=&gt;</span></code><span class="deltaxml-old"> applies a function to a supplied sequence.] It is defined as follows:</span></p><ul><li><p><span class="deltaxml-old">Given a </span><a href="#doc-xquery40-UnaryExpr"><span class="deltaxml-old">UnaryExpr</span></a><code><span class="deltaxml-old">U</span></code><span class="deltaxml-old">, an </span><a href="#doc-xquery40-ArrowStaticFunction"><span class="deltaxml-old">ArrowStaticFunction</span></a><code><span class="deltaxml-old">F</span></code><span class="deltaxml-old">, and an </span><a href="#doc-xquery40-ArgumentList"><span class="deltaxml-old">ArgumentList</span></a><code><span class="deltaxml-old">(A, B, C...)</span></code><span class="deltaxml-old">, the expression </span><code><span class="deltaxml-old">U =&gt; F(A, B, C...)</span></code><span class="deltaxml-old"> is equivalent to the expression </span><code><span class="deltaxml-old">F(U, A, B, C...)</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">Given a </span><a href="#doc-xquery40-UnaryExpr"><span class="deltaxml-old">UnaryExpr</span></a><code><span class="deltaxml-old">U</span></code><span class="deltaxml-old">, an </span><a href="#doc-xquery40-ArrowDynamicFunction"><span class="deltaxml-old">ArrowDynamicFunction</span></a><code><span class="deltaxml-old">F</span></code><span class="deltaxml-old">, and an </span><a href="#doc-xquery40-PositionalArgumentList"><span class="deltaxml-old">PositionalArgumentList</span></a><code><span class="deltaxml-old">(A, B, C...)</span></code><span class="deltaxml-old">, the expression </span><code><span class="deltaxml-old">U =&gt; F(A, B, C...)</span></code><span class="deltaxml-old"> is equivalent to the expression </span><code><span class="deltaxml-old">F(U, A, B, C...)</span></code><span class="deltaxml-old">.</span></p></li></ul></div><div class="div3"><h4><a id="id-mapping-arrow-expression"></a><span class="deltaxml-old">4.24.2 Mapping Arrow Expressions</span></h4><p><span class="deltaxml-old"> [</span><a id="dt-mapping-arrow-operator" title="mapping arrow operator"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: The </span><b><span class="deltaxml-old">mapping arrow operator</span></b><code><span class="deltaxml-old">=!&gt;</span></code><span class="deltaxml-old"> applies a function to each item in a sequence.] It is defined as follows:</span></p><ul><li><p><span class="deltaxml-old">If the arrow is followed by an </span><a href="#doc-xquery40-ArrowStaticFunction"><span class="deltaxml-old">ArrowStaticFunction</span></a><span class="deltaxml-old">:</span></p><p><span class="deltaxml-old">Given a </span><a href="#doc-xquery40-UnaryExpr"><span class="deltaxml-old">UnaryExpr</span></a><code><span class="deltaxml-old">U</span></code><span class="deltaxml-old">, an </span><a href="#doc-xquery40-ArrowStaticFunction"><span class="deltaxml-old">ArrowStaticFunction</span></a><code><span class="deltaxml-old">F</span></code><span class="deltaxml-old">, and an </span><a href="#doc-xquery40-ArgumentList"><span class="deltaxml-old">ArgumentList</span></a><code><span class="deltaxml-old">(A, B, C...)</span></code><span class="deltaxml-old">, the expression </span><code><span class="deltaxml-old">U =!&gt; F(A, B, C...)</span></code><span class="deltaxml-old"> is equivalent to the expression </span><code><span class="deltaxml-old">(for $u in U return F($u, A, B, C...))</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">If the arrow is followed by an </span><a href="#doc-xquery40-ArrowDynamicFunction"><span class="deltaxml-old">ArrowDynamicFunction</span></a><span class="deltaxml-old">:</span></p><p><span class="deltaxml-old">Given a </span><a href="#doc-xquery40-UnaryExpr"><span class="deltaxml-old">UnaryExpr</span></a><code><span class="deltaxml-old">U</span></code><span class="deltaxml-old">, an </span><a href="#doc-xquery40-ArrowDynamicFunction"><span class="deltaxml-old">ArrowDynamicFunction</span></a><code><span class="deltaxml-old">F</span></code><span class="deltaxml-old">, and an </span><a href="#doc-xquery40-PositionalArgumentList"><span class="deltaxml-old">PositionalArgumentList</span></a><code><span class="deltaxml-old">(A, B, C...)</span></code><span class="deltaxml-old">, the expression </span><code><span class="deltaxml-old">U =!&gt; F(A, B, C...)</span></code><span class="deltaxml-old"> is equivalent to the expression </span><code><span class="deltaxml-old">(for $u in U return F($u, A, B, C...))</span></code><span class="deltaxml-old">.</span></p></li></ul></div><div class="div3"><h4><a id="lookup-arrow-expression"></a><span class="deltaxml-old">4.24.3 Lookup Arrow Expressions</span></h4><p><span class="deltaxml-old">The lookup arrow expression simulates the behavior of method invocations in object-oriented languages. It is useful for invoking functions that are contained as entries in maps.</span></p><p><span class="deltaxml-old">For example, the expression</span></p><div class="exampleInner"><pre><span class="deltaxml-old">let $rectangle := map { "width": 20, "height": 12, "area": fn($this){$this?width * $this?height} } return $rectangle =?&gt; area()</span></pre></div><p><span class="deltaxml-old">returns the value </span><code><span class="deltaxml-old">240</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">An expression such as </span><code><span class="deltaxml-old">M =?&gt; N(A, B, C)</span></code><span class="deltaxml-old"> is evaluated as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-old">The left-hand expression </span><var><span class="deltaxml-old">M</span></var><span class="deltaxml-old"> is evaluated. If the value is an empty sequence, then the result of the expression is an empty sequence. If it is non-empty then it must be a single map: call it </span><code><span class="deltaxml-old">$m</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The lookup expression </span><code><span class="deltaxml-old">$m?N</span></code><span class="deltaxml-old"> is evaluated. The result must be a single function item: call it </span><code><span class="deltaxml-old">$f</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The dynamic function call </span><code><span class="deltaxml-old">$f($m, A, B, C)</span></code><span class="deltaxml-old"> is evaluated, and the result is returned.</span></p></li></ol><p><span class="deltaxml-old">Any of the above steps can lead to errors:</span></p><ol class="enumar"><li><p><span class="deltaxml-old">A type error [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-old">err:XPTY0004</span></a><span class="deltaxml-old">] is raised if the value of the left hand expression does not match the type </span><code><span class="deltaxml-old">map(*)?</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">A type error [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-old">err:XPTY0004</span></a><span class="deltaxml-old">] is raised if the value of the lookup expression </span><code><span class="deltaxml-old">$m?N</span></code><span class="deltaxml-old"> does not match the type </span><code><span class="deltaxml-old">function(*)</span></code><span class="deltaxml-old">, or if the arity of the function is not equal to the number of arguments in the argument list plus one.</span></p></li><li><p><span class="deltaxml-old">An error may occur in evaluating the dynamic function call, for example if the function does not expect a map to be supplied as the first argument.</span></p></li></ol></div></div><div class="div2"><h3><a id="id-validate"></a><span class="deltaxml-old">4.25</span><span class="deltaxml-new">4.24</span> Validate Expressions</h3><a id="d3e30222"></a><a id="d3e27041"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ValidateExpr"></a>[<span class="deltaxml-old">129</span><span class="deltaxml-new">120</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ValidateExpr">ValidateExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"validate" (<a href="#doc-xquery40-ValidationMode">ValidationMode</a> | ("type" <a href="#doc-xquery40-TypeName">TypeName</a>))? "{" <a href="#doc-xquery40-Expr">Expr</a> "}"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ValidationMode"></a>[<span class="deltaxml-old">130</span><span class="deltaxml-new">121</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ValidationMode">ValidationMode</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"lax" | "strict"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e26697.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e23794.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p>A <code>validate</code> expression can be used to validate a document node or an element node with respect to the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>, using the schema validation process defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>. If the operand of a <code>validate</code> expression does not evaluate to exactly one document or element node, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXQTY0030" title="err:XQTY0030">err:XQTY0030</a>]. In this specification, the node that is the operand of a <code>validate</code> expression is called the <b>operand node</b>.</p><p>A <code>validate</code> expression returns a new node with its own identity and with no parent. The new node and its descendants are given <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that are generated by applying a validation process to the operand node. In some cases, default values may also be generated by the validation process.</p><p>A <code>validate</code> expression may optionally specify a <a href="#doc-xquery40-ValidationMode">validation mode</a>. The default <a href="#doc-xquery40-ValidationMode">validation mode</a> (applicable when no type name is provided) is <code>strict</code>.</p><p><span style="display: none;" class="delete_version">A <code>validate</code> expression may optionally specify a <a href="#doc-xquery40-TypeName">TypeName</a>. This type name must be found in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>; if it is not, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0104" title="err:XQST0104">err:XQST0104</a>]. If the type name is unprefixed, it is interpreted as a name in the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>. </span><span style="display: none;" class="add_version">A <code>validate</code> expression may optionally specify a <a href="#doc-xquery40-TypeName">TypeName</a>. This type name must be found in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>; if it is not, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0104" title="err:XQST0104">err:XQST0104</a>]. If the type name is unprefixed, it is interpreted as a name in the default namespace for elements and types. </span><span class="modify_version">A <code>validate</code> expression may optionally specify a <a href="#doc-xquery40-TypeName">TypeName</a>. This type name must be found in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>; if it is not, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0104" title="err:XQST0104">err:XQST0104</a>]. If the type name is unprefixed, it is interpreted as a name in the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-new">default namespace for elements and types</span>. </span></p><p>The result of a <code>validate</code> expression is defined by the following rules.</p><ol class="enumar"><li><p> If the operand node is a document node, its children must consist of exactly one element node and zero or more comment and processing instruction nodes, in any order; otherwise, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0061" title="err:XQDY0061">err:XQDY0061</a>] is raised.</p></li><li><p>The operand node is converted to an XML Information Set (<a href="#XINFO">[XML Infoset]</a>) according to the <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>Infoset Mapping<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> rules defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a>. Note that this process discards any existing <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a>. Validity assessment is carried out on the root element information item of the resulting Infoset, using the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> as the effective schema. The process of validation applies recursively to contained elements and attributes to the extent required by the effective schema. </p></li><li><p><span style="display: none;" class="delete_version">If a type name is provided, and the type name is <code>xs:untyped</code>, all elements receive the type annotation <code>xs:untyped</code>, and all attributes receive the type annotation <code>xs:untypedAtomic</code>. If the type name is <code>xs:untypedAtomic</code>, the node receives the type annotation xs:untypedAtomic; a type error [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] is raised if the node has element children. Otherwise, schema-validity assessment is carried out according to the rules defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 1, section 3.3.4 "Element Declaration Validation Rules", “Validation Rule: Schema-Validity Assessment (Element)”, clauses 1.2 and 2, using this type definition as the “processor-stipulated type definition” for validation.</span><span style="display: none;" class="add_version">If a type name is provided, and the type name is <code>xs:untyped</code>, all elements receive the type annotation <code>xs:untyped</code>, and all attributes receive the type annotation <code>xs:untypedAtomic</code>. If the type name is <code>xs:untypedAtomic</code>, the node receives the type annotation xs:untypedAtomic; a type error [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] is raised if the node has element children. Otherwise, schema-validity assessment is carried out according to the rules defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 1, section 3.3.4 "Element Declaration Validation Rules", "Validation Rule: Schema-Validity Assessment (Element)", clauses 1.2 and 2, using this type definition as the "processor-stipulated type definition" for validation.</span><span class="modify_version">If a type name is provided, and the type name is <code>xs:untyped</code>, all elements receive the type annotation <code>xs:untyped</code>, and all attributes receive the type annotation <code>xs:untypedAtomic</code>. If the type name is <code>xs:untypedAtomic</code>, the node receives the type annotation xs:untypedAtomic; a type error [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] is raised if the node has element children. Otherwise, schema-validity assessment is carried out according to the rules defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 1, section 3.3.4 "Element Declaration Validation Rules", <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>Validation Rule: Schema-Validity Assessment (Element)<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span>, clauses 1.2 and 2, using this type definition as the <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>processor-stipulated type definition<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> for validation.</span></p><p>If the instance being validated contains an xml:id attribute, both lax and strict validation cause this attribute to be subjected to [xml:id] processing: that is, the attribute is checked for uniqueness, and is typed as xs:ID, and the containing element is therefore eligible as a target for the id() function.</p></li><li><p>When no type name is provided:</p><ol class="enumla"><li><p><span style="display: none;" class="delete_version">If <a href="#doc-xquery40-ValidationMode">validation mode</a> is <code>strict</code>, then there must be a top-level element declaration in the <a title="in-scope element declarations" class="termref" href="#dt-is-elems">in-scope element declarations</a> that matches the root element information item in the Infoset, and schema-validity assessment is carried out using that declaration in accordance with <a href="#XMLSchema10">[XML Schema 1.0]</a> Part 1, section 5.2, “Assessing Schema-Validity”, item 2, or <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 1, section 5.2, “Assessing Schema-Validity”, “element-driven validation”. If there is no such element declaration, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0084" title="err:XQDY0084">err:XQDY0084</a>].</span><span style="display: none;" class="add_version">If <a href="#doc-xquery40-ValidationMode">validation mode</a> is <code>strict</code>, then there must be a top-level element declaration in the <a title="in-scope element declarations" class="termref" href="#dt-is-elems">in-scope element declarations</a> that matches the root element information item in the Infoset, and schema-validity assessment is carried out using that declaration in accordance with <a href="#XMLSchema10">[XML Schema 1.0]</a> Part 1, section 5.2, "Assessing Schema-Validity", item 2, or <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 1, section 5.2, "Assessing Schema-Validity", "element-driven validation". If there is no such element declaration, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0084" title="err:XQDY0084">err:XQDY0084</a>].</span><span class="modify_version">If <a href="#doc-xquery40-ValidationMode">validation mode</a> is <code>strict</code>, then there must be a top-level element declaration in the <a title="in-scope element declarations" class="termref" href="#dt-is-elems">in-scope element declarations</a> that matches the root element information item in the Infoset, and schema-validity assessment is carried out using that declaration in accordance with <a href="#XMLSchema10">[XML Schema 1.0]</a> Part 1, section 5.2, <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>Assessing Schema-Validity<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span>, item 2, or <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 1, section 5.2, <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>Assessing Schema-Validity<span class="deltaxml-old">”, “</span><span class="deltaxml-new">", "</span>element-driven validation<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span>. If there is no such element declaration, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0084" title="err:XQDY0084">err:XQDY0084</a>].</span></p></li><li><p><span style="display: none;" class="delete_version">If <a href="#doc-xquery40-ValidationMode">validation mode</a> is <code>lax</code>, then schema-validity assessment is carried out in accordance with <a href="#XMLSchema10">[XML Schema 1.0]</a> Part 1, section 5.2, “Assessing Schema-Validity”, item 3, or <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 1, section 5.2, “Assessing Schema-Validity”, “lax wildcard validation”.</span><span style="display: none;" class="add_version">If <a href="#doc-xquery40-ValidationMode">validation mode</a> is <code>lax</code>, then schema-validity assessment is carried out in accordance with <a href="#XMLSchema10">[XML Schema 1.0]</a> Part 1, section 5.2, "Assessing Schema-Validity", item 3, or <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 1, section 5.2, "Assessing Schema-Validity", "lax wildcard validation".</span><span class="modify_version">If <a href="#doc-xquery40-ValidationMode">validation mode</a> is <code>lax</code>, then schema-validity assessment is carried out in accordance with <a href="#XMLSchema10">[XML Schema 1.0]</a> Part 1, section 5.2, <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>Assessing Schema-Validity<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span>, item 3, or <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 1, section 5.2, <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>Assessing Schema-Validity<span class="deltaxml-old">”, “</span><span class="deltaxml-new">", "</span>lax wildcard validation<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span>.</span></p><p>If <a href="#doc-xquery40-ValidationMode">validation mode</a> is <code>lax</code> and the root element information item has neither a top-level element declaration nor an <code>xsi:type</code> attribute, <a href="#XMLSchema10">[XML Schema 1.0]</a> defines the recursive checking of children and attributes as optional. During processing of an XQuery <code>validate</code> expression, this recursive checking is required.</p></li><li><p>If the operand node is an element node, the validation rules named <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>Validation Root Valid (ID/IDREF)<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> are not applied. This means that document-level constraints relating to uniqueness and referential integrity are not enforced.</p></li><li><p>There is no check that the document contains unparsed entities whose names match the values of nodes of type <code>xs:ENTITY</code> or <code>xs:ENTITIES</code>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Validity assessment is affected by the presence or absence of <code>xsi:type</code> attributes on the elements being validated, and may generate new information items such as default attributes.</p></div></li><li><p>The outcome of the validation expression depends on the <code>validity</code> property of the root element information item in the PSVI that results from the validation process.</p><ol class="enumla"><li><p><span style="display: none;" class="delete_version">If the <code>validity</code> property of the root element information item is <code>valid</code>, or if <a href="#doc-xquery40-ValidationMode">validation mode</a> is <code>lax</code> and the <code>validity</code> property of the root element information item is <code>notKnown</code>, the PSVI is converted back into an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> as described in <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a> Section 3.3, “Construction from a PSVI”. The resulting node (a new node of the same kind as the operand node) is returned as the result of the <code>validate</code> expression.</span><span style="display: none;" class="add_version">If the <code>validity</code> property of the root element information item is <code>valid</code>, or if <a href="#doc-xquery40-ValidationMode">validation mode</a> is <code>lax</code> and the <code>validity</code> property of the root element information item is <code>notKnown</code>, the PSVI is converted back into an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> as described in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a> Section 3.3, "Construction from a PSVI". The resulting node (a new node of the same kind as the operand node) is returned as the result of the <code>validate</code> expression.</span><span class="modify_version">If the <code>validity</code> property of the root element information item is <code>valid</code>, or if <a href="#doc-xquery40-ValidationMode">validation mode</a> is <code>lax</code> and the <code>validity</code> property of the root element information item is <code>notKnown</code>, the PSVI is converted back into an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> as described in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a> Section 3.3, <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>Construction from a PSVI<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span>. The resulting node (a new node of the same kind as the operand node) is returned as the result of the <code>validate</code> expression.</span></p></li><li><p>Otherwise, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0027" title="err:XQDY0027">err:XQDY0027</a>].</p></li></ol></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of these rules is as follows, where the <em>validated element</em> means either the operand node or (if the operand node is a document node) its element child.: </p><ul><li><p>If <a href="#doc-xquery40-ValidationMode">validation mode</a> is <code>strict</code>, the validated element must have a top-level element declaration in the effective schema, and must conform to this declaration.</p></li><li><p>If <a href="#doc-xquery40-ValidationMode">validation mode</a> is <code>lax</code>, the validated element must conform to its top-level element declaration if such a declaration exists in the effective schema. If <a href="#doc-xquery40-ValidationMode">validation mode</a> is <code>lax</code> and there is no top-level element declaration for the element, and the element has an <code>xsi:type</code> attribute, then the <code>xsi:type</code> attribute must name a top-level type definition in the effective schema, and the element must conform to that type.</p></li><li><p>If a type name is specified in the validate expression, no attempt is made to locate an element declaration matching the name of the validated element; the element can have any name, and its content is validated against the named type. </p></li></ul></div><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">During conversion of the PSVI into an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> after validation, any element information items whose validity property is <code>notKnown</code> are converted into element nodes with <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><code>xs:anyType</code>, and any attribute information items whose validity property is <code>notKnown</code> are converted into attribute nodes with <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><code>xs:untypedAtomic</code>, as described in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#PSVI2NodeTypes">Section 3.3.1.1 Element and Attribute Node Types</a><sup><small>DM40</small></sup>. </span><span style="display: none;" class="add_version">During conversion of the PSVI into an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> after validation, any element information items whose validity property is <code>notKnown</code> are converted into element nodes with <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><code>xs:anyType</code>, and any attribute information items whose validity property is <code>notKnown</code> are converted into attribute nodes with <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><code>xs:untypedAtomic</code>, as described in <a href="https://www.w3.org/TR/xpath-datamodel-31/#PSVI2NodeTypes">Section 3.3.1.1 Element and Attribute Node Types </a><sup><small>DM31</small></sup>. </span><span class="modify_version">During conversion of the PSVI into an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> after validation, any element information items whose validity property is <code>notKnown</code> are converted into element nodes with <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><code>xs:anyType</code>, and any attribute information items whose validity property is <code>notKnown</code> are converted into attribute nodes with <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><code>xs:untypedAtomic</code>, as described in <a href="https://www.w3.org/TR/xpath-datamodel-31/#PSVI2NodeTypes">Section 3.3.1.1 Element and Attribute Node Types<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>. </span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">A query might take as its primary input a document conforming to schema </span><var><span class="deltaxml-old">X</span></var><span class="deltaxml-old">, and produce as its primary output a document conforming to schema </span><var><span class="deltaxml-old">Y</span></var><span class="deltaxml-old">. To be sure that the output is indeed valid against schema </span><var><span class="deltaxml-old">Y</span></var><span class="deltaxml-old">, the safest course of action is to evaluate a </span><code><span class="deltaxml-old">validate</span></code><span class="deltaxml-old"> expression within a query module that imports schema </span><var><span class="deltaxml-old">Y</span></var><span class="deltaxml-old"> and nothing else. Otherwise, if the validation occurs within a module that imports both </span><var><span class="deltaxml-old">X</span></var><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">Y</span></code><span class="deltaxml-old">, the outcome of validation might differ because of the differences between the two schemas.</span></p></div></div><div class="div2"><h3><a id="id-extension-expressions"></a><span class="deltaxml-old">4.26</span><span class="deltaxml-new">4.25</span> Extension Expressions</h3><p> [<a id="dt-extension-expression" title="extension expression">Definition</a>: An <b>extension expression</b> is an expression whose semantics are <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.] Typically a particular extension will be recognized by some implementations and not by others. The syntax is designed so that extension expressions can be successfully parsed by all implementations, and so that fallback behavior can be defined for implementations that do not recognize a particular extension.</p><a id="d3e30545"></a><a id="d3e27342"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ExtensionExpr"></a>[<span class="deltaxml-old">131</span><span class="deltaxml-new">122</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ExtensionExpr">ExtensionExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Pragma">Pragma</a>+ "{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Pragma"></a>[<span class="deltaxml-old">132</span><span class="deltaxml-new">123</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Pragma">Pragma</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(#" <a href="#prod-xquery40-S">S</a>? <a href="#doc-xquery40-EQName">EQName</a> (<a href="#prod-xquery40-S">S</a><a href="#doc-xquery40-PragmaContents">PragmaContents</a>)? "#)"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PragmaContents"></a>[<span class="deltaxml-old">133</span><span class="deltaxml-new">124</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-PragmaContents">PragmaContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a>* - (Char* '#)' Char*))</code></td><td></td></tr></tbody></table><p>An extension expression consists of one or more <b>pragmas</b>, followed by an optional expression (the <b>associated expression</b>). [<a id="dt-pragma" title="pragma">Definition</a>: A <b>pragma</b> is denoted by the delimiters <code>(#</code> and <code>#)</code>, and consists of an identifying EQName followed by <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> content.] The content of a pragma may consist of any string of characters that does not contain the ending delimiter <code>#)</code>. If the EQName of a pragma is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, it must resolve to a namespace URI and local name, using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>]. If the EQName is an unprefixed NCName, it is interpreted as a name in no namespace (and the pragma is therefore ignored).</p><p>Each implementation recognizes an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> set of namespace URIs used to denote pragmas.</p><p>If the namespace URI of a <span class="deltaxml-old">pragma’s</span><span class="deltaxml-new">pragma's</span> <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is not recognized by the implementation as a pragma namespace, or if the name is in no namespace, then the pragma is ignored. If all the pragmas in an <a href="#doc-xquery40-ExtensionExpr">ExtensionExpr</a> are ignored, then the value of the <a href="#doc-xquery40-ExtensionExpr">ExtensionExpr</a> is the value of the associated expression; if no associated expression is provided, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0079" title="err:XQST0079">err:XQST0079</a>]. </p><p>If an implementation recognizes the namespace of one or more pragmas in an <a href="#doc-xquery40-ExtensionExpr">ExtensionExpr</a>, then the value of the <a href="#doc-xquery40-ExtensionExpr">ExtensionExpr</a>, including its error behavior, is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. For example, an implementation that recognizes the namespace of a <span class="deltaxml-old">pragma’s</span><span class="deltaxml-new">pragma's</span> <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, but does not recognize the local part of the name, might choose either to raise an error or to ignore the pragma.</p><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0013" title="err:XQST0013">err:XQST0013</a>] if an implementation recognizes a pragma but determines that its content is invalid.</p><p>If an implementation recognizes a pragma, it must report any static errors in the following expression even if it will not evaluate that expression (however, static type errors are raised only if the <a title="static     typing feature" class="termref" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect.)</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The following examples illustrate three ways in which extension expressions might be used.</p><ul><li><p>A pragma can be used to furnish a hint for how to evaluate the following expression, without actually changing the result. For example:</p><div class="exampleInner"><pre><span class="deltaxml-old">declare namespace exq = "http://example.org/XQueryImplementation"; (# exq:use-index #) { $bib/book/author[name='Berners-Lee'] }</span></pre><pre><span class="deltaxml-new">declare namespace exq = "http://example.org/XQueryImplementation"; (# exq:use-index #) { $bib/book/author[name='Berners-Lee'] } </span></pre></div><p>An implementation that recognizes the <code>exq:use-index</code> pragma might use an index to evaluate the expression that follows. An implementation that does not recognize this pragma would evaluate the expression in its normal way.</p></li><li><p>A pragma might be used to modify the semantics of the following expression in ways that would not (in the absence of the pragma) be conformant with this specification. For example, a pragma might be used to permit comparison of <code>xs:duration</code> values using implementation-defined semantics (this would normally be an error). Such changes to the language semantics must be scoped to the <a title="enclosed expression" class="termref" href="#dt-enclosed-expression">enclosed expression</a> following the pragma.</p></li><li><p>A pragma might contain syntactic constructs that are evaluated in place of the following expression. In this case, the following expression itself (if it is present) provides a fallback for use by implementations that do not recognize the pragma. For example:</p><div class="exampleInner"><pre><span class="deltaxml-old">declare namespace exq = "http://example.org/XQueryImplementation"; for $x in (# exq:distinct //city by @country #) { //city[not(@country = preceding::city/@country)] } return f:show-city($x)</span></pre><pre><span class="deltaxml-new">declare namespace exq = "http://example.org/XQueryImplementation"; for $x in (# exq:distinct //city by @country #) { //city[not(@country = preceding::city/@country)] } return f:show-city($x) </span></pre></div><p>Here an implementation that recognizes the pragma will return the result of evaluating the proprietary syntax <code>exq:distinct //city by @country</code>, while an implementation that does not recognize the pragma will instead return the result of the expression <code>//city[not(@country = preceding::city/@country)]</code>. If no fallback expression is required, or if none is feasible, then the expression between the curly braces may be omitted, in which case implementations that do not recognize the pragma will raise a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></li></ul></div></div></div><div class="div1"><h2><a id="id-query-prolog"></a>5 Modules and Prologs</h2><a id="d3e30697"></a><a id="d3e27494"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Module"></a>[1]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Module">Module</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-VersionDecl">VersionDecl</a>? (<a href="#doc-xquery40-LibraryModule">LibraryModule</a> | <a href="#doc-xquery40-MainModule">MainModule</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-MainModule"></a>[3]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-MainModule">MainModule</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Prolog">Prolog</a><a href="#doc-xquery40-QueryBody">QueryBody</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LibraryModule"></a>[4]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-LibraryModule">LibraryModule</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ModuleDecl">ModuleDecl</a><a href="#doc-xquery40-Prolog">Prolog</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Prolog"></a>[6]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Prolog">Prolog</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>((<a href="#doc-xquery40-DefaultNamespaceDecl">DefaultNamespaceDecl</a> | <a href="#doc-xquery40-Setter">Setter</a> | <a href="#doc-xquery40-NamespaceDecl">NamespaceDecl</a> | <a href="#doc-xquery40-Import">Import</a>) <a href="#doc-xquery40-Separator">Separator</a>)* ((<a href="#doc-xquery40-ContextValueDecl">ContextValueDecl</a> | <a href="#doc-xquery40-AnnotatedDecl">AnnotatedDecl</a> | <a href="#doc-xquery40-OptionDecl">OptionDecl</a>) <a href="#doc-xquery40-Separator">Separator</a>)*</code></span><span style="display: none;" class="add_version"><code>((<a href="#doc-xquery40-DefaultNamespaceDecl">DefaultNamespaceDecl</a> | <a href="#doc-xquery40-Setter">Setter</a> | <a href="#doc-xquery40-NamespaceDecl">NamespaceDecl</a> | <a href="#doc-xquery40-Import">Import</a>) <a href="#doc-xquery40-Separator">Separator</a>)* ((<a href="#doc-xquery40-ContextItemDecl">ContextItemDecl</a> | <a href="#doc-xquery40-AnnotatedDecl">AnnotatedDecl</a> | <a href="#doc-xquery40-OptionDecl">OptionDecl</a>) <a href="#doc-xquery40-Separator">Separator</a>)*</code></span><span class="modify_version"><code>((<a href="#doc-xquery40-DefaultNamespaceDecl">DefaultNamespaceDecl</a> | <a href="#doc-xquery40-Setter">Setter</a> | <a href="#doc-xquery40-NamespaceDecl">NamespaceDecl</a> | <a href="#doc-xquery40-Import">Import</a>) <a href="#doc-xquery40-Separator">Separator</a>)* ((<a href="#doc-xquery40-ContextValueDecl"><span class="deltaxml-old">ContextValueDecl</span></a><a href="#doc-xquery40-ContextItemDecl"><span class="deltaxml-new">ContextItemDecl</span></a> | <a href="#doc-xquery40-AnnotatedDecl">AnnotatedDecl</a> | <a href="#doc-xquery40-OptionDecl">OptionDecl</a>) <a href="#doc-xquery40-Separator">Separator</a>)*</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Setter"></a>[8]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Setter">Setter</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-BoundarySpaceDecl">BoundarySpaceDecl</a> | <a href="#doc-xquery40-DefaultCollationDecl">DefaultCollationDecl</a> | <a href="#doc-xquery40-BaseURIDecl">BaseURIDecl</a> | <a href="#doc-xquery40-ConstructionDecl">ConstructionDecl</a> | <a href="#doc-xquery40-OrderingModeDecl">OrderingModeDecl</a> | <a href="#doc-xquery40-EmptyOrderDecl">EmptyOrderDecl</a> | <a href="#doc-xquery40-CopyNamespacesDecl">CopyNamespacesDecl</a> | <a href="#doc-xquery40-DecimalFormatDecl">DecimalFormatDecl</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Import"></a>[20]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Import">Import</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SchemaImport">SchemaImport</a> | <a href="#doc-xquery40-ModuleImport">ModuleImport</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Separator"></a>[7]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Separator">Separator</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>";"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QueryBody"></a>[<span class="deltaxml-old">44</span><span class="deltaxml-new">43</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-QueryBody">QueryBody</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Expr">Expr</a></code></td><td></td></tr></tbody></table><p>A query can be assembled from one or more fragments called <b>modules</b>. [<a id="dt-module" title="module">Definition</a>: A <b>module</b> is a fragment of XQuery code that conforms to the <a href="#doc-xquery40-Module">Module</a> grammar and can independently undergo the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a> described in <a href="#id-expression-processing"><b>2.3.3 Expression Processing</b></a>. Each module is either a <a title="main module" class="termref" href="#dt-main-module">main module</a> or a <a title="library module" class="termref" href="#dt-library-module">library module</a>.] </p><p> [<a id="dt-main-module" title="main module">Definition</a>: A <b>main module</b> consists of a <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> followed by a <a title="query body" class="termref" href="#dt-queryBody">Query Body</a>.] A query has exactly one main module. In a main module, the <a title="query body" class="termref" href="#dt-queryBody">Query Body</a> is evaluated with respect to the static and dynamic contexts of the main module in which it is found, and its value is the result of the query.</p><p> [<a id="dt-library-module" title="library module">Definition</a>: A module that does not contain a <a title="query body" class="termref" href="#dt-queryBody">Query Body</a> is called a <b>library module</b>. A library module consists of a <a title="module declaration" class="termref" href="#dt-module-declaration">module declaration</a> followed by a <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a>.] A library module cannot be evaluated directly; instead, it provides function and variable declarations that can be imported into other modules.</p><p>The XQuery syntax does not allow a <a title="module" class="termref" href="#dt-module">module</a> to contain both a <a title="module declaration" class="termref" href="#dt-module-declaration">module declaration</a> and a <a title="query body" class="termref" href="#dt-queryBody">Query Body</a>.</p><p> [<a id="dt-prolog" title="Prolog">Definition</a>: A <b>Prolog</b> is a series of declarations and imports that define the processing environment for the <a title="module" class="termref" href="#dt-module">module</a> that contains the Prolog.] Each declaration or import is followed by a semicolon. A Prolog is organized into two parts. </p><p>The first part of the Prolog consists of setters, imports, namespace declarations, and default namespace declarations. [<a id="dt-setter" title="setter">Definition</a>: <b>Setters</b> are declarations that set the value of some property that affects query processing, such as construction mode, ordering mode, or default collation.] Namespace declarations and default namespace declarations affect the interpretation of <a title="lexical QName" class="termref" href="#dt-qname">lexical QNames</a> within the query. Imports are used to import definitions from schemas and modules. [<a id="dt-target-namespace" title="target namespace">Definition</a>: The <b>target namespace</b> of a module is the namespace of the objects (such as elements or functions) that it defines. ] </p><p>The second part of the Prolog consists of declarations of variables, functions, and options. These declarations appear at the end of the Prolog because they may be affected by declarations and imports in the first part of the Prolog.</p><p> [<a id="dt-queryBody" title="query body">Definition</a>: The <b>Query Body</b>, if present, consists of an expression that defines the result of the query.] Evaluation of expressions is described in <a href="#id-expressions"><b>4 Expressions</b></a>. A module can be evaluated only if it has a Query Body.</p><div class="div2"><h3><a id="id-version-declaration"></a>5.1 Version Declaration</h3><a id="d3e30917"></a><a id="d3e27714"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-VersionDecl"></a>[2]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-VersionDecl">VersionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"xquery" (("encoding" <a href="#doc-xquery40-StringLiteral">StringLiteral</a>) | ("version" <a href="#doc-xquery40-StringLiteral">StringLiteral</a> ("encoding" <a href="#doc-xquery40-StringLiteral">StringLiteral</a>)?)) <a href="#doc-xquery40-Separator">Separator</a></code></td><td></td></tr></tbody></table><p><span class="deltaxml-old"> [</span><a id="dt-version-declaration" title="version declaration"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">version declaration</span></b><span class="deltaxml-old"> can identify the applicable XQuery syntax and semantics for a </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-old">module</span></a><span class="deltaxml-old">, as well as its encoding.] </span></p><p><span class="deltaxml-old"> [</span><a id="dt-version-number" title="XQuery version number"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: An </span><b><span class="deltaxml-old">XQuery version number</span></b><span class="deltaxml-old"> consists of two integers separated by a dot. The first integer is referred to as the </span><b><span class="deltaxml-old">major version number</span></b><span class="deltaxml-old">; the second as the </span><b><span class="deltaxml-old">minor version number</span></b><span class="deltaxml-old">.] </span><span><span class="deltaxml-old">An </span><b><span class="deltaxml-old">integer</span></b><span class="deltaxml-old"> here means a sequence of decimal digits with no sign or other punctuation.</span></span></p><p><span style="display: none;" class="delete_version">Any XQuery processor that implements any version of XQuery with a given major number must accept any query with the same major version number. The processor may reject queries labeled with a different major version number. The processor may reject queries with the same major version number and a greater minor version number than the processor recognizes.</span><span style="display: none;" class="add_version"> [<a id="dt-version-declaration" title="version declaration">Definition</a>: A <b>version declaration</b> can identify the applicable XQuery syntax and semantics for a <a title="module" class="termref" href="#dt-module">module</a>, as well as its encoding.] [<a id="dt-version-number" title="XQuery version number">Definition</a>: An <b>XQuery version number</b> consists of two integers separated by a dot. The first integer is referred to as the <b>major version number</b>; the second as the <b>minor version number</b>.] Any XQuery processor that implements any version of XQuery with a given major number must accept any query with the same major version number. The processor may reject queries labeled with a different major version number. The processor may reject queries with the same major version number and a greater minor version number than the processor recognizes. If a query is rejected because of a version mismatch with the processor, a static error [<a href="#ERRXQST0031" title="err:XQST0031">err:XQST0031</a>] must be raised. </span><span class="modify_version"><span class="deltaxml-new"> [</span><a id="dt-version-declaration" title="version declaration"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: A </span><b><span class="deltaxml-new">version declaration</span></b><span class="deltaxml-new"> can identify the applicable XQuery syntax and semantics for a </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new">module</span></a><span class="deltaxml-new">, as well as its encoding.] [</span><a id="dt-version-number" title="XQuery version number"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: An </span><b><span class="deltaxml-new">XQuery version number</span></b><span class="deltaxml-new"> consists of two integers separated by a dot. The first integer is referred to as the </span><b><span class="deltaxml-new">major version number</span></b><span class="deltaxml-new">; the second as the </span><b><span class="deltaxml-new">minor version number</span></b><span class="deltaxml-new">.] </span>Any XQuery processor that implements any version of XQuery with a given major number must accept any query with the same major version number. The processor may reject queries labeled with a different major version number. The processor may reject queries with the same major version number and a greater minor version number than the processor recognizes.<span class="deltaxml-new"> If a query is rejected because of a version mismatch with the processor, a static error [</span><a href="#ERRXQST0031" title="err:XQST0031"><span class="deltaxml-new">err:XQST0031</span></a><span class="deltaxml-new">] must be raised. </span></span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The version numbers </span><code><span class="deltaxml-old">“4.01”</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">“4.1”</span></code><span class="deltaxml-old"> are equivalent: both have a major number of 4 and a minor number of 1. Version </span><code><span class="deltaxml-old">“4.10”</span></code><span class="deltaxml-old"> by the same reasoning has a higher minor number than version </span><code><span class="deltaxml-old">“4.2”</span></code><span class="deltaxml-old">.</span></p></div><p><span class="deltaxml-old">If a query is rejected because of a version mismatch with the processor, a static error [</span><a href="#ERRXQST0031" title="err:XQST0031"><span class="deltaxml-old">err:XQST0031</span></a><span class="deltaxml-old">] must be raised.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The processor is allowed to provide an option to require that minor versions also match, or that the minor number of the version in the query is not larger than the largest minor version understood by the processor in this major release of XQuery, or to allow more permissive version matching, perhaps with warnings, but the <span class="deltaxml-old">behavior</span><span class="deltaxml-new">behaviour</span> is then outside the scope of this specification.</p></div><p><span class="deltaxml-old">The version number “4.0” indicates the intent that the module be processed by an </span><a title="XQuery 4.0 Processor" class="termref" href="#dt-xquery-40-processor"><span class="deltaxml-old">XQuery 4.0 processor</span></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">Similarly, the version number “1.0” indicates the intent that the module be processed by an </span><a title="XQuery 1.0 Processor" class="termref" href="#dt-xquery-10-processor"><span class="deltaxml-old">XQuery 1.0 processor</span></a><span class="deltaxml-old">, “3.0” an </span><a title="XQuery 3.0 Processor" class="termref" href="#dt-xquery-30-processor"><span class="deltaxml-old">XQuery 3.0 processor</span></a><span class="deltaxml-old">, and “3.1” an </span><a title="XQuery 3.1 Processor" class="termref" href="#dt-xquery-31-processor"><span class="deltaxml-old">XQuery 3.1 processor</span></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-new">The version number "1.0" indicates the intent that the module be processed by an </span><a title="XQuery 1.0 Processor" class="termref" href="#dt-xquery-10-processor"><span class="deltaxml-new">XQuery 1.0 processor</span></a><span class="deltaxml-new">, the version number "3.0" indicates the intent that the module be processed by an </span><a title="XQuery 3.0 Processor" class="termref" href="#dt-xquery-30-processor"><span class="deltaxml-new">XQuery 3.0 processor</span></a><span class="deltaxml-new">, the version number "3.1" indicates the intent that the module be processed by an </span><a title="XQuery 3.1 Processor" class="termref" href="#dt-xquery-31-processor"><span class="deltaxml-new">XQuery 3.1 processor</span></a><span class="deltaxml-new">. </span>If the version declaration is not present or the version is not included in the declaration, an XQuery <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span> processor assumes a version of <span class="deltaxml-old">“4.0”</span><span class="deltaxml-new">"3.1"</span>.</p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">This does not preclude the use of an external API or other configuration mechanism that instructs a piece of software to behave as an XQuery 4.0 processor.</span></p></div><p><span style="display: none;" class="delete_version"> [<a id="dt-encoding-declaration" title="encoding declaration">Definition</a>: If present, a version declaration may optionally include an <b>encoding declaration</b>. The value of the string literal following the keyword <code>encoding</code> is an encoding name, and must conform to the definition of <code>EncName</code> specified in <a href="#XML">[XML 1.0]</a> [<a href="#ERRXQST0087" title="err:XQST0087">err:XQST0087</a>]. The purpose of an encoding declaration is to allow the writer of a query to provide a string that indicates how the query is encoded, such as <code>"UTF-8"</code>, <code>"UTF-16"</code>, or <code>"US-ASCII"</code>.] Since the encoding of a query may change as the query moves from one environment to another, there can be no guarantee that the encoding declaration is correct.</span><span style="display: none;" class="add_version"> [<a id="dt-encoding-declaration" title="encoding declaration">Definition</a>: If present, a version declaration may optionally include an <b>encoding declaration</b>. The value of the string literal following the keyword <code>encoding</code> is an encoding name, and must conform to the definition of <code>EncName</code> specified in <a href="#XML">[XML 1.0]</a> [<a href="#ERRXQST0087" title="err:XQST0087">err:XQST0087</a>]. The purpose of an encoding declaration is to allow the writer of a query to provide a string that indicates how the query is encoded, such as "<code>UTF-8</code>", "<code>UTF-16</code>", or "<code>US-ASCII</code>".] Since the encoding of a query may change as the query moves from one environment to another, there can be no guarantee that the encoding declaration is correct.</span><span class="modify_version"> [<a id="dt-encoding-declaration" title="encoding declaration">Definition</a>: If present, a version declaration may optionally include an <b>encoding declaration</b>. The value of the string literal following the keyword <code>encoding</code> is an encoding name, and must conform to the definition of <code>EncName</code> specified in <a href="#XML">[XML 1.0]</a> [<a href="#ERRXQST0087" title="err:XQST0087">err:XQST0087</a>]. The purpose of an encoding declaration is to allow the writer of a query to provide a string that indicates how the query is encoded, such as "<code>UTF-8<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>, "<code>UTF-16<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>, or "<code>US-ASCII<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.] Since the encoding of a query may change as the query moves from one environment to another, there can be no guarantee that the encoding declaration is correct.</span></p><p>The handling of an encoding declaration is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. If an implementation has <em>a priori</em> knowledge of the encoding of a query, it may use this knowledge and disregard the encoding declaration. The semantics of a query are not affected by the presence or absence of an encoding declaration.</p><p>If a version declaration is present, no <a href="#doc-xquery40-Comment">Comment</a> may occur before the end of the version declaration. If such a <a href="#doc-xquery40-Comment">Comment</a> is present, the result is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>; an implementation may raise an implementation-dependent static error, or ignore the comment. </p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">The effect of a <code>Comment</code> before the end of a version declaration is implementation-dependent because it may suppress query processing by interfering with detection of the encoding declaration.</span><span style="display: none;" class="add_version">The effect of a Comment before the end of a version declaration is implementation-dependent because it may suppress query processing by interfering with detection of the encoding declaration.</span><span class="modify_version">The effect of a Comment before the end of a version declaration is implementation-dependent because it may suppress query processing by interfering with detection of the encoding declaration.</span></p></div><p>The following examples illustrate version declarations:</p><div class="exampleInner"><pre><span class="deltaxml-old">xquery version "3.1";</span></pre><pre><span class="deltaxml-new">xquery version "1.0";</span></pre></div><div class="exampleInner"><pre><span class="deltaxml-old">xquery version "4.0" encoding "utf-8";</span></pre><pre><span class="deltaxml-new">xquery version "3.0" encoding "utf-8";</span></pre></div></div><div class="div2"><h3><a id="id-module-declaration"></a>5.2 Module Declaration</h3><a id="d3e31053"></a><a id="d3e27818"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ModuleDecl"></a>[5]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ModuleDecl">ModuleDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"module" "namespace" <a href="#prod-xquery40-NCName">NCName</a> "=" <a href="#doc-xquery40-URILiteral">URILiteral</a><a href="#doc-xquery40-Separator">Separator</a></code></td><td></td></tr></tbody></table><p> [<a id="dt-module-declaration" title="module declaration">Definition</a>: A <b>module declaration</b> serves to identify a <a title="module" class="termref" href="#dt-module">module</a> as a <a title="library module" class="termref" href="#dt-library-module">library module</a>. A module declaration begins with the keyword <code>module</code> and contains a namespace prefix and a <a href="#doc-xquery40-URILiteral">URILiteral</a>.] The URILiteral must be of nonzero length [<a href="#ERRXQST0088" title="err:XQST0088">err:XQST0088</a>]. The URILiteral identifies the <a title="target namespace" class="termref" href="#dt-target-namespace">target namespace</a> of the library module, which is the namespace for all variables and functions exported by the library module. The name of every variable and function declared in a library module must have a namespace URI that is the same as the target namespace of the module; otherwise a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0048" title="err:XQST0048">err:XQST0048</a>]. The (prefix,URI) pair is added to the set of <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>. </p><p>The namespace prefix specified in a module declaration must not be <code>xml</code> or <code>xmlns</code> [<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>], and must not be the same as any namespace prefix bound in the same module by a <a title="schema import" class="termref" href="#dt-schema-import">schema import</a>, by a <a title="namespace declaration" class="termref" href="#dt-namespace-declaration">namespace declaration</a>, or by a <a title="module import" class="termref" href="#dt-module-import">module import</a> with a different target namespace [<a href="#ERRXQST0033" title="err:XQST0033">err:XQST0033</a>].</p><p>Any <a title="module" class="termref" href="#dt-module">module</a> may import one or more library modules by means of a <a title="module import" class="termref" href="#dt-module-import">module import</a> that specifies the target namespace of the library modules to be imported. When a module imports one or more library modules, the variables and functions declared in the imported modules are added to the <a title="static context" class="termref" href="#dt-static-context">static context</a> and (where applicable) to the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> of the importing module.</p><p>The following is an example of a module declaration:</p><div class="exampleInner"><pre>module namespace gis = "http://example.org/gis-functions";</pre></div></div><div class="div2"><h3><a id="id-boundary-space-decls"></a>5.3 Boundary-space Declaration</h3><a id="d3e31139"></a><a id="d3e27904"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-BoundarySpaceDecl"></a>[9]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-BoundarySpaceDecl">BoundarySpaceDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "boundary-space" ("preserve" | "strip")</code></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version"> [<a id="dt-boundary-space-decl" title="boundary-space declaration">Definition</a>: A <b>boundary-space declaration</b> sets the <a title="boundary-space policy" class="termref" href="#dt-boundary-space-policy">boundary-space policy</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default. Boundary-space policy controls whether <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> is preserved by element constructors during processing of the query.] If boundary-space policy is <code>preserve</code>, boundary whitespace is preserved. If boundary-space policy is <code>strip</code>, boundary whitespace is stripped (deleted). A further discussion of whitespace in constructed elements can be found in <a href="#id-whitespace"><span class="delete_version"><b>4.13.1.4 Boundary Whitespace</b></span><span class="modify_version"><b>4.13.1.4 Boundary Whitespace</b></span></a>.</span><span style="display: none;" class="add_version"> [<a id="dt-boundary-space-decl" title="boundary-space declaration">Definition</a>: A <b>boundary-space declaration</b> sets the <a title="boundary-space policy" class="termref" href="#dt-boundary-space-policy">boundary-space policy</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default. Boundary-space policy controls whether <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> is preserved by element constructors during processing of the query.] If boundary-space policy is <code>preserve</code>, boundary whitespace is preserved. If boundary-space policy is <code>strip</code>, boundary whitespace is stripped (deleted). A further discussion of whitespace in constructed elements can be found in <a href="#id-whitespace"><span class="add_version"><b>4.12.1.4 Boundary Whitespace</b></span><span class="modify_version"><b>4.12.1.4 Boundary Whitespace</b></span></a>.</span><span class="modify_version"> [<a id="dt-boundary-space-decl" title="boundary-space declaration">Definition</a>: A <b>boundary-space declaration</b> sets the <a title="boundary-space policy" class="termref" href="#dt-boundary-space-policy">boundary-space policy</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default. Boundary-space policy controls whether <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> is preserved by element constructors during processing of the query.] If boundary-space policy is <code>preserve</code>, boundary whitespace is preserved. If boundary-space policy is <code>strip</code>, boundary whitespace is stripped (deleted). A further discussion of whitespace in constructed elements can be found in <a href="#id-whitespace"><span style="display: none;" class="delete_version"><b>4.13.1.4 Boundary Whitespace</b></span><span style="display: none;" class="add_version"><b>4.12.1.4 Boundary Whitespace</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1.4</span><span class="deltaxml-new">4.12.1.4</span> Boundary Whitespace</b></span></a>.</span></p><p>The following example illustrates a boundary-space declaration:</p><div class="exampleInner"><pre>declare boundary-space preserve;</pre></div><p>If a Prolog contains more than one boundary-space declaration, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0068" title="err:XQST0068">err:XQST0068</a>].</p></div><div class="div2"><h3><a id="id-default-collation-declaration"></a>5.4 Default Collation Declaration</h3><a id="d3e31178"></a><a id="d3e27943"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DefaultCollationDecl"></a>[10]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DefaultCollationDecl">DefaultCollationDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "default" "collation" <a href="#doc-xquery40-URILiteral">URILiteral</a></code></td><td></td></tr></tbody></table><p> [<a id="dt-default-collation-decl" title="default collation declaration">Definition</a>: A <b>default collation declaration</b> sets the value of the <a title="default collation" class="termref" href="#dt-def-collation">default collation</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default.] The default collation is the collation that is used by functions and operators that require a collation if no other collation is specified. For example, the <code>gt</code> operator on strings is defined by a call to the <code>fn:compare</code> function, which takes an optional collation parameter. Since the <code>gt</code> operator does not specify a collation, the <code>fn:compare</code> function implements <code>gt</code> by using the default collation.</p><p>If neither the implementation nor the Prolog specifies a default collation, the Unicode codepoint collation (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>) is used. </p><p>The following example illustrates a default collation declaration:</p><div class="exampleInner"><pre>declare default collation "http://example.org/languages/Icelandic";</pre></div><p>If a default collation declaration specifies a collation by a relative URI, that relative URI is <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved to an absolute URI</a> using the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a>. If a Prolog contains more than one default collation declaration, or the value specified by a default collation declaration (after resolution of a relative URI, if necessary) is not present in <a title="statically known collations" class="termref" href="#dt-static-collations">statically known collations</a>, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0038" title="err:XQST0038">err:XQST0038</a>].</p></div><div class="div2"><h3><a id="id-base-uri-decl"></a>5.5 Base URI Declaration</h3><a id="d3e31236"></a><a id="d3e28001"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-BaseURIDecl"></a>[11]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-BaseURIDecl">BaseURIDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "base-uri" <a href="#doc-xquery40-URILiteral">URILiteral</a></code></td><td></td></tr></tbody></table><p> [<a id="dt-base-uri-decl" title="base URI declaration">Definition</a>: A <b>base URI declaration</b> specifies the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property. The <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is used when resolving relative URI references.] For example, the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is used when resolving relative references for <a title="module import" class="termref" href="#dt-module-import">module import</a> and for the <code>fn:doc</code> function.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>As discussed in the definition of <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a>, if there is no base URI declaration, or if the value of the declaration is a relative URI reference, then the value of the Static Base URI may depend on the location of the query, and it is permissible for this to vary between the static analysis phase and the dynamic evaluation phase.</p></div><p>The following is an example of a base URI declaration:</p><div class="exampleInner"><pre>declare base-uri "http://example.org";</pre></div><p>If a Prolog contains more than one base URI declaration, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0032" title="err:XQST0032">err:XQST0032</a>].</p><p><span style="display: none;" class="delete_version">In the terminology of <a href="#RFC3986">[RFC3986]</a> Section 5.1, the URILiteral of the base URI declaration is considered to be a “base URI embedded in content”. If no base URI declaration is present, <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is established according to the principles outlined in <a href="#RFC3986">[RFC3986]</a> Section 5.1—that is, it defaults first to the base URI of the encapsulating entity, then to the URI used to retrieve the entity, and finally to an implementation-defined default. If the URILiteral in the base URI declaration is a relative URI, then it is made absolute by resolving it with respect to this same hierarchy. For example, if the URILiteral in the base URI declaration is <code>../data/</code>, and the query is contained in a file whose URI is <code>file:///C:/temp/queries/query.xq</code>, then the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is <code>file:///C:/temp/data/</code>.</span><span style="display: none;" class="add_version">In the terminology of <a href="#RFC3986">[RFC3986]</a> Section 5.1, the URILiteral of the base URI declaration is considered to be a "base URI embedded in content". If no base URI declaration is present, <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is established according to the principles outlined in <a href="#RFC3986">[RFC3986]</a> Section 5.1—that is, it defaults first to the base URI of the encapsulating entity, then to the URI used to retrieve the entity, and finally to an implementation-defined default. If the URILiteral in the base URI declaration is a relative URI, then it is made absolute by resolving it with respect to this same hierarchy. For example, if the URILiteral in the base URI declaration is <code>../data/</code>, and the query is contained in a file whose URI is <code>file:///C:/temp/queries/query.xq</code>, then the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is <code>file:///C:/temp/data/</code>.</span><span class="modify_version">In the terminology of <a href="#RFC3986">[RFC3986]</a> Section 5.1, the URILiteral of the base URI declaration is considered to be a <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>base URI embedded in content<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span>. If no base URI declaration is present, <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is established according to the principles outlined in <a href="#RFC3986">[RFC3986]</a> Section 5.1—that is, it defaults first to the base URI of the encapsulating entity, then to the URI used to retrieve the entity, and finally to an implementation-defined default. If the URILiteral in the base URI declaration is a relative URI, then it is made absolute by resolving it with respect to this same hierarchy. For example, if the URILiteral in the base URI declaration is <code>../data/</code>, and the query is contained in a file whose URI is <code>file:///C:/temp/queries/query.xq</code>, then the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is <code>file:///C:/temp/data/</code>.</span></p><p><span style="display: none;" class="delete_version">It is not intrinsically an error if this process fails to establish an absolute base URI; however, the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is then <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup> [<a href="#ERRXPST0001" title="err:XPST0001">err:XPST0001</a>]. When the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>, any attempt to use its value to <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolve a relative URI reference</a> will result in an error [<a href="#ERRXPST0001" title="err:XPST0001">err:XPST0001</a>]. </span><span style="display: none;" class="add_version">It is not intrinsically an error if this process fails to establish an absolute base URI; however, the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is then <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup> [<a href="#ERRXPST0001" title="err:XPST0001">err:XPST0001</a>]. When the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>, any attempt to use its value to <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolve a relative URI reference</a> will result in an error [<a href="#ERRXPST0001" title="err:XPST0001">err:XPST0001</a>]. </span><span class="modify_version">It is not intrinsically an error if this process fails to establish an absolute base URI; however, the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is then <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup> [<a href="#ERRXPST0001" title="err:XPST0001">err:XPST0001</a>]. When the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>, any attempt to use its value to <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolve a relative URI reference</a> will result in an error [<a href="#ERRXPST0001" title="err:XPST0001">err:XPST0001</a>]. </span></p></div><div class="div2"><h3><a id="id-construction-declaration"></a>5.6 Construction Declaration</h3><a id="d3e31323"></a><a id="d3e28088"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ConstructionDecl"></a>[12]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ConstructionDecl">ConstructionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "construction" ("strip" | "preserve")</code></td><td></td></tr></tbody></table><p> [<a id="dt-construction-decl" title="construction declaration">Definition</a>: A <b>construction declaration</b> sets the <a title="construction mode" class="termref" href="#dt-construction-mode">construction mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default.] The construction mode governs the behavior of element and document node constructors. If construction mode is <code>preserve</code>, the type of a constructed element node is <code>xs:anyType</code>, and all attribute and element nodes copied during node construction retain their original types. If construction mode is <code>strip</code>, the type of a constructed element node is <code>xs:untyped</code>; all element nodes copied during node construction receive the type <code>xs:untyped</code>, and all attribute nodes copied during node construction receive the type <code>xs:untypedAtomic</code>.</p><p>The following example illustrates a construction declaration:</p><div class="exampleInner"><pre>declare construction strip;</pre></div><p>If a Prolog specifies more than one construction declaration, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0067" title="err:XQST0067">err:XQST0067</a>].</p></div><div class="div2"><h3><a id="id-default-ordering-decl"></a>5.7 Ordering Mode Declaration</h3><a id="d3e31366"></a><a id="d3e28131"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-OrderingModeDecl"></a>[13]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-OrderingModeDecl">OrderingModeDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "ordering" ("ordered" | "unordered")</code></td><td></td></tr></tbody></table><p> [<a id="dt-ordering-mode-decl" title="ordering mode declaration">Definition</a>: An <b>ordering mode declaration</b> sets the <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default.] This ordering mode applies to all expressions in a <a title="module" class="termref" href="#dt-module">module</a> (including both the <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> and the <a title="query body" class="termref" href="#dt-queryBody">Query Body</a>, if any), unless overridden by an <code>ordered</code> or <code>unordered</code> expression.</p><p>The following example illustrates an ordering mode declaration:</p><div class="exampleInner"><pre>declare ordering unordered;</pre></div><p>If a Prolog contains more than one ordering mode declaration, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0065" title="err:XQST0065">err:XQST0065</a>].</p></div><div class="div2"><h3><a id="id-empty-order-decl"></a>5.8 Empty Order Declaration</h3><a id="d3e31410"></a><a id="d3e28175"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-EmptyOrderDecl"></a>[14]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EmptyOrderDecl">EmptyOrderDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "default" "order" "empty" ("greatest" | "least")</code></td><td></td></tr></tbody></table><p> [<a id="dt-empty-order-decl" title="empty order declaration">Definition</a>: An <b>empty order declaration</b> sets the <a title="default order for empty sequences" class="termref" href="#dt-default-empty-order">default order for empty sequences</a> in the <a title="static context" class="termref" href="#dt-static-context">static context,</a> overriding any implementation-defined default. This declaration controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression.] An individual <code>order by</code> clause may override the default order for empty sequences by specifying <code>empty greatest</code> or <code>empty least</code>.</p><p>The following example illustrates an empty order declaration:</p><div class="exampleInner"><pre>declare default order empty least;</pre></div><p>If a Prolog contains more than one empty order declaration, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0069" title="err:XQST0069">err:XQST0069</a>].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is important to distinguish an <a title="empty order declaration" class="termref" href="#dt-empty-order-decl">empty order declaration</a> from an <a title="ordering mode declaration" class="termref" href="#dt-ordering-mode-decl">ordering mode declaration</a>. An <a title="empty order declaration" class="termref" href="#dt-empty-order-decl">empty order declaration</a> applies only when an <code>order by</code> clause is present, and specifies how empty sequences are treated by the <code>order by</code> clause (unless overridden). An <a title="ordering mode declaration" class="termref" href="#dt-ordering-mode-decl">ordering mode declaration</a>, on the other hand, applies only in the absence of an <code>order by</code> clause.</p></div></div><div class="div2"><h3><a id="id-copy-namespaces-decl"></a>5.9 Copy-Namespaces Declaration</h3><a id="d3e31472"></a><a id="d3e28237"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CopyNamespacesDecl"></a>[15]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "copy-namespaces" <a href="#doc-xquery40-PreserveMode">PreserveMode</a> "," <a href="#doc-xquery40-InheritMode">InheritMode</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PreserveMode"></a>[16]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-PreserveMode">PreserveMode</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"preserve" | "no-preserve"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-InheritMode"></a>[17]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-InheritMode">InheritMode</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"inherit" | "no-inherit"</code></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version"> [<a id="dt-copy-namespaces-decl" title="copy-namespaces declaration">Definition</a>: A <b>copy-namespaces declaration</b> sets the value of <a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default. Copy-namespaces mode controls the namespace bindings that are assigned when an existing element node is copied by an element constructor or document constructor.] Handling of namespace bindings by element constructors is described in <a href="#id-element-constructor"><span class="delete_version"><b>4.13.1 Direct Element Constructors</b></span><span class="modify_version"><b>4.13.1 Direct Element Constructors</b></span></a>.</span><span style="display: none;" class="add_version"> [<a id="dt-copy-namespaces-decl" title="copy-namespaces declaration">Definition</a>: A <b>copy-namespaces declaration</b> sets the value of <a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default. Copy-namespaces mode controls the namespace bindings that are assigned when an existing element node is copied by an element constructor or document constructor.] Handling of namespace bindings by element constructors is described in <a href="#id-element-constructor"><span class="add_version"><b>4.12.1 Direct Element Constructors</b></span><span class="modify_version"><b>4.12.1 Direct Element Constructors</b></span></a>.</span><span class="modify_version"> [<a id="dt-copy-namespaces-decl" title="copy-namespaces declaration">Definition</a>: A <b>copy-namespaces declaration</b> sets the value of <a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default. Copy-namespaces mode controls the namespace bindings that are assigned when an existing element node is copied by an element constructor or document constructor.] Handling of namespace bindings by element constructors is described in <a href="#id-element-constructor"><span style="display: none;" class="delete_version"><b>4.13.1 Direct Element Constructors</b></span><span style="display: none;" class="add_version"><b>4.12.1 Direct Element Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1</span><span class="deltaxml-new">4.12.1</span> Direct Element Constructors</b></span></a>.</span></p><p>The following example illustrates a copy-namespaces declaration:</p><div class="exampleInner"><pre>declare copy-namespaces preserve, no-inherit;</pre></div><p>If a Prolog contains more than one copy-namespaces declaration, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0055" title="err:XQST0055">err:XQST0055</a>].</p></div><div class="div2"><h3><a id="id-decimal-format-decl"></a>5.10 Decimal Format Declaration</h3><a id="d3e31517"></a><a id="d3e28282"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DecimalFormatDecl"></a>[18]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DecimalFormatDecl">DecimalFormatDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" (("decimal-format" <a href="#doc-xquery40-EQName">EQName</a>) | ("default" "decimal-format")) (<a href="#doc-xquery40-DFPropertyName">DFPropertyName</a> "=" <a href="#doc-xquery40-StringLiteral">StringLiteral</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DFPropertyName"></a>[19]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DFPropertyName">DFPropertyName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"decimal-separator" | "grouping-separator" | "infinity" | "minus-sign" | "NaN" | "percent" | "per-mille" | "zero-digit" | "digit" | "pattern-separator" | "exponent-separator"</code></td><td></td></tr></tbody></table><p> [<a id="dt-decimal-format-decl" title="decimal-format         declaration">Definition</a>: A <b>decimal format declaration</b> adds a decimal format to the <a title="statically known decimal formats" class="termref" href="#dt-static-decimal-formats">statically known decimal formats</a>, which define the properties used to format numbers using the <code>fn:format-number()</code> function], as described in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>. If the form <code>decimal-format EQName</code> is used, then the declaration defines the properties of the decimal format whose name is <code>EQName</code>, while the form <code>default decimal-format</code> defines the properties of the unnamed decimal format. The declaration contains a set of (<code>DFPropertyName</code>, <code>StringLiteral</code>) pairs, where the <code>DFPropertyName</code> is the name of the property and the <code>StringLiteral</code> is its value. The valid values and default values for each property are defined in <a title="statically known decimal formats" class="termref" href="#dt-static-decimal-formats">statically known decimal formats</a>. </p><p>If a format declares no properties, default values are used for all properties.</p><p>Error conditions are defined as follows:</p><ul><li><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a query prolog to contain two decimal format declarations with the same name, or to contain two default decimal format declarations [<a href="#ERRXQST0111" title="err:XQST0111">err:XQST0111</a>].</p></li><li><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a decimal format declaration to define the same property more than once [<a href="#ERRXQST0114" title="err:XQST0114">err:XQST0114</a>].</p></li><li><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a decimal format declaration to specify a value that is not valid for a given property, as described in <a title="statically known decimal formats" class="termref" href="#dt-static-decimal-formats">statically known decimal formats</a> [<a href="#ERRXQST0097" title="err:XQST0097">err:XQST0097</a>].</p></li><li><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if, for any named or unnamed decimal format, the properties representing characters used in a picture string do not have distinct values [<a href="#ERRXQST0098" title="err:XQST0098">err:XQST0098</a>].</p><p>The following properties represent characters used in a picture string: <a title="decimal-separator" class="termref" href="#id-static-decimal-format-decimal-separator">decimal-separator</a>, <a title="exponent-separator" class="termref" href="#id-static-decimal-format-exponent-separator">exponent-separator</a>, <a title="grouping-separator" class="termref" href="#id-static-decimal-format-grouping-separator">grouping-separator</a>, <a title="percent" class="termref" href="#id-static-decimal-format-percent">percent</a>, <a title="per-mille" class="termref" href="#id-static-decimal-format-per-mille">per-mille</a>, the family of ten decimal digits starting with <a title="zero-digit" class="termref" href="#id-static-decimal-format-zero-digit">zero-digit</a>, <a title="digit" class="termref" href="#id-static-decimal-format-digit">digit</a>, and <a title="pattern-separator" class="termref" href="#id-static-decimal-format-pattern-separator">pattern-separator</a>.</p></li></ul><div class="example"><p>The following query formats numbers using two different decimal format declarations:</p><div class="exampleInner"><pre>declare decimal-format local:de decimal-separator = "," grouping-separator = "."; declare decimal-format local:en decimal-separator = "." grouping-separator = ","; let $numbers := (1234.567, 789, 1234567.765) for $i in $numbers return ( format-number($i, "#.###,##", "local:de"), format-number($i, "#,###.##", "local:en") )</pre></div><p>The output of this query is:</p><div class="exampleInner"><pre>1.234,57 1,234.57 789 789 1.234.567,76 1,234,567.76</pre></div></div></div><div class="div2"><h3><a id="id-schema-import"></a>5.11 Schema Import</h3><a id="d3e31641"></a><a id="d3e28406"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SchemaImport"></a>[21]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SchemaImport">SchemaImport</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"import" "schema" <a href="#doc-xquery40-SchemaPrefix">SchemaPrefix</a>? <a href="#doc-xquery40-URILiteral">URILiteral</a> ("at" <a href="#doc-xquery40-URILiteral">URILiteral</a> ("," <a href="#doc-xquery40-URILiteral">URILiteral</a>)*)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SchemaPrefix"></a>[22]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SchemaPrefix">SchemaPrefix</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>("namespace" <a href="#prod-xquery40-NCName">NCName</a> "=") | ("fixed"? "default" "element" "namespace")</code></span><span style="display: none;" class="add_version"><code>("namespace" <a href="#prod-xquery40-NCName">NCName</a> "=") | ("default" "element" "namespace")</code></span><span class="modify_version"><code>("namespace" <a href="#prod-xquery40-NCName">NCName</a> "=") | ("<span class="deltaxml-old">fixed"? "</span>default" "element" "namespace")</code></span></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version"> [<a id="dt-schema-import" title="schema import">Definition</a>: A <b>schema import</b> imports the element declarations, attribute declarations, and type definitions from a schema into the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>. For each named user-defined simple type in the schema, schema import also adds a corresponding <a title="constructor function" class="termref" href="#dt-constructor-function">constructor function</a>. ] The schema to be imported is identified by its <a title="target namespace" class="termref" href="#dt-target-namespace">target namespace</a>. The schema import may bind a namespace prefix to the target namespace of the imported schema, adding the (prefix, URI) pair to the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>, or it may declare that target namespace to be the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>. The schema import may also provide optional hints for locating the schema.</span><span style="display: none;" class="add_version"> [<a id="dt-schema-import" title="schema import">Definition</a>: A <b>schema import</b> imports the element declarations, attribute declarations, and type definitions from a schema into the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>. For each named user-defined simple type in the schema, schema import also adds a corresponding <a title="constructor function" class="termref" href="#dt-constructor-function">constructor function</a>. ] The schema to be imported is identified by its <a title="target namespace" class="termref" href="#dt-target-namespace">target namespace</a>. The schema import may bind a namespace prefix to the target namespace of the imported schema, adding the (prefix, URI) pair to the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>, or it may declare that target namespace to be the <a class="termref" title="default element namespace" href="#dt-def-elem-ns">default element namespace</a><span>and the <a title="default type namespace" class="termref" href="#dt-def-type-ns">default type namespace</a></span>. The schema import may also provide optional hints for locating the schema.</span><span class="modify_version"> [<a id="dt-schema-import" title="schema import">Definition</a>: A <b>schema import</b> imports the element declarations, attribute declarations, and type definitions from a schema into the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>. For each named user-defined simple type in the schema, schema import also adds a corresponding <a title="constructor function" class="termref" href="#dt-constructor-function">constructor function</a>. ] The schema to be imported is identified by its <a title="target namespace" class="termref" href="#dt-target-namespace">target namespace</a>. The schema import may bind a namespace prefix to the target namespace of the imported schema, adding the (prefix, URI) pair to the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>, or it may declare that target namespace to be the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><a class="termref" title="default element namespace" href="#dt-def-elem-ns"><span class="deltaxml-new">default element namespace</span></a><span><span class="deltaxml-new">and the </span><a title="default type namespace" class="termref" href="#dt-def-type-ns"><span class="deltaxml-new">default type namespace</span></a></span>. The schema import may also provide optional hints for locating the schema.</span></p><p>The namespace prefix specified in a schema import must not be <code>xml</code> or <code>xmlns</code> [<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>], and must not be the same as any namespace prefix bound in the same module by another schema import, a <a title="module import" class="termref" href="#dt-module-import">module import</a>, a <a title="namespace declaration" class="termref" href="#dt-namespace-declaration">namespace declaration</a>, or a <a title="module import" class="termref" href="#dt-module-import">module declaration</a> [<a href="#ERRXQST0033" title="err:XQST0033">err:XQST0033</a>]. </p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">If schema definitions from the </span><code><span class="deltaxml-old">xml</span></code><span class="deltaxml-old"> namespace are to be used (for example, </span><code><span class="deltaxml-old">schema-attribute(xml:space)</span></code><span class="deltaxml-old">, then the prolog should include a declaration in the form </span><code><span class="deltaxml-old">import schema "http://www.w3.org/XML/1998/namespace"</span></code><span class="deltaxml-old">. No prefix should be supplied (the </span><code><span class="deltaxml-old">xml</span></code><span class="deltaxml-old"> prefix is predeclared), and no location hint should be provided (the schema definitions for the namespace are built in, and cannot be varied).</span></p></div><p>If the schema import declaration specifies <code>default element namespace</code> then the prolog must not contain a <a title="namespace declaration" class="termref" href="#dt-namespace-declaration">namespace declaration</a> that specifies <code>default element namespace</code> or <code>default type namespace</code>.</p><p><span class="deltaxml-old">If the keyword </span><code><span class="deltaxml-old">"fixed"</span></code><span class="deltaxml-old">, is present, the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old"> is fixed throughout the module, and is not affected by default namespace declarations (</span><code><span class="deltaxml-old">xmlns=""</span></code><span class="deltaxml-old">) appearing on direct element constructors.</span></p><p> The first <a href="#doc-xquery40-URILiteral">URILiteral</a> in a schema import specifies the target namespace of the schema to be imported. The URILiterals that follow the <code>at</code> keyword are optional location hints, and can be interpreted or disregarded in an implementation-dependent way. Multiple location hints might be used to indicate more than one possible place to look for the schema or multiple physical resources to be assembled to form the schema. </p><p><span style="display: none;" class="delete_version"> If the target namespace is <code>http://www.w3.org/2005/xpath-functions</code> then the schema described in <a href="https://qt4cg.org/specifications/xpath-functions-40/#schemata">Section C Schemas</a><sup><small>FO40</small></sup> is imported; any location hints are ignored. </span><span style="display: none;" class="add_version"> If the target namespace is <code>http://www.w3.org/2005/xpath-functions</code> then the schema described in <a href="https://www.w3.org/TR/xpath-functions-31/#schemata">Section C Schemas </a><sup><small>FO31</small></sup> is imported; any location hints are ignored. </span><span class="modify_version"> If the target namespace is <code>http://www.w3.org/2005/xpath-functions</code> then the schema described in <a href="https://www.w3.org/TR/xpath-functions-31/#schemata">Section C Schemas<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup> is imported; any location hints are ignored. </span></p><p><span style="display: none;" class="delete_version">A schema import that specifies a zero-length string as target namespace is considered to import a schema that has no target namespace. Such a schema import must not bind a namespace prefix [<a href="#ERRXQST0057" title="err:XQST0057">err:XQST0057</a>], but it may set the default element and/or type namespace to a zero-length string (representing “no namespace”), thus enabling the definitions in the imported namespace to be referenced. If the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> is not set to "no namespace", <span>the only way to reference the definitions in an imported schema that has no target namespace is using the EQName syntax <code>Q{}local-name</code></span>.</span><span style="display: none;" class="add_version">A schema import that specifies a zero-length string as target namespace is considered to import a schema that has no target namespace. Such a schema import must not bind a namespace prefix [<a href="#ERRXQST0057" title="err:XQST0057">err:XQST0057</a>], but it may set the default element and/or type namespace to a zero-length string (representing "no namespace"), thus enabling the definitions in the imported namespace to be referenced. If the default element and/or type namespace is not set to "no namespace", <span>the only way to reference the definitions in an imported schema that has no target namespace is using the EQName syntax <code>Q{}local-name</code></span>.</span><span class="modify_version">A schema import that specifies a zero-length string as target namespace is considered to import a schema that has no target namespace. Such a schema import must not bind a namespace prefix [<a href="#ERRXQST0057" title="err:XQST0057">err:XQST0057</a>], but it may set the default element and/or type namespace to a zero-length string (representing <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>no namespace<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span>), thus enabling the definitions in the imported namespace to be referenced. If the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-new">default element and/or type namespace</span> is not set to "no namespace", <span>the only way to reference the definitions in an imported schema that has no target namespace is using the EQName syntax <code>Q{}local-name</code></span>.</span></p><p><span class="deltaxml-old">The </span><a href="#doc-xquery40-URILiteral"><span class="deltaxml-old">URILiterals</span></a><span class="deltaxml-old"> that follow the </span><code><span class="deltaxml-old">at</span></code><span class="deltaxml-old"> keyword are optional location hints, intended to allow a processor to locate schema documents containing definitions of the required schema components in the target namespace. Processors </span><strong><span class="deltaxml-old">may</span></strong><span class="deltaxml-old"> interpret or disregard these hints in an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-old">implementation-defined</span></a><span class="deltaxml-old"> way. The preferred strategy, which </span><strong><span class="deltaxml-old">should</span></strong><span class="deltaxml-old"> be used by default unless the user indicates otherwise, is as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-old">If the target namespace is one for which the processor has built-in knowledge, for example the schema for a </span><a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces"><span class="deltaxml-old">reserved namespace</span></a><span class="deltaxml-old">, the location hints </span><strong><span class="deltaxml-old">should</span></strong><span class="deltaxml-old"> be ignored, and the built-in schema used in preference.</span></p></li><li><p><span class="deltaxml-old">In other cases, the location hints are taken in order, treating them as URI references relative to the static base URI of the query module.</span></p></li><li><p><span class="deltaxml-old">If the first location hint cannot be successfully dereferenced, then that location hint is disregarded (optionally with a warning), and the process continues with the next location hint, until one is found that can be successfully dereferenced; if none of the location hints can be dereferenced, then a static error is reported.</span></p></li><li><p><span class="deltaxml-old">The dereferencing of a location hint </span><strong><span class="deltaxml-old">may</span></strong><span class="deltaxml-old"> make use of implementation-defined indirection mechanisms such as resolver callbacks and catalog files.</span></p></li><li><p><span class="deltaxml-old">If a location hint is successfully dereferenced, but yields a resource that cannot be parsed as a valid XSD schema document with the correct target namespace, then a static error is reported.</span></p></li><li><p><span class="deltaxml-old">If a valid schema document is located, then it is combined with the schema documents obtained from other import schema declarations, in the same way as a schema is assembled from multiple schema documents referenced using </span><code><span class="deltaxml-old">xs:import</span></code><span class="deltaxml-old"> declarations. This implies that the several schema documents must together comprise a valid schema, for example there cannot be two different type definitions with the same name.</span></p></li><li><p><span class="deltaxml-old">Once one location hint has been successfully processed, subsequent location hints are ignored.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Processors that adopted a different strategy in earlier releases </span><strong><span class="deltaxml-old">may</span></strong><span class="deltaxml-old"> continue to use that strategy by default, in order to retain compatibility; however such processors </span><strong><span class="deltaxml-old">should</span></strong><span class="deltaxml-old"> offer the above strategy as an option. </span></p><p><span class="deltaxml-old">The process described above is not intended to be totally prescriptive, or to guarantee complete interoperability. Processors are likely to exhibit variations, depending both on design decisions made by the product vendor, and on decisions made when configuring the platform and network infrastructure on which it runs. For example, when retrieving HTTP resources, the details of the HTTP request are likely to vary, and the criteria used to decide whether a request was successful may also vary. In addition, the XSD specification itself describes some aspects of the process incompletely, including for example the criteria used to decide whether two components (such as type definitions) should be considered identical.</span></p></div><p><span class="deltaxml-old">Different query modules may import different schemas, but there is a requirement that all the schemas used by a query </span><strong><span class="deltaxml-old">must</span></strong><span class="deltaxml-old"> be compatible. The rules for compatibility are defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#schema-consistency"><span class="deltaxml-old">Section 2.8.1 Schema Consistency</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">. This means, for example:</span></p><ul><li><p><span class="deltaxml-old">If any schema component (such as an element declaration or complex type definition) is imported into more than one query module, the definitions of these components must effectively be the same.</span></p></li><li><p><span class="deltaxml-old">This leaves room, however, for some differences between modules. For example, the substitution group membership of an element declaration may vary between one module and another, depending on what other element declarations are present in the schema. This means that an element can be validated in one module and passed as a function parameter to another module in which the element would be considered invalid. Any static type inferencing that is performed must take such possibilities into account; this is particularly important if query modules are compiled independently from one another.</span></p></li></ul><p><span class="deltaxml-old"> If the target namespace is </span><code><span class="deltaxml-old">http://www.w3.org/2005/xpath-functions</span></code><span class="deltaxml-old"> then the schema described in </span><a href="https://www.w3.org/TR/xpath-functions-31/#schemata"><span class="deltaxml-old">Section C Schemas </span></a><sup><small><span class="deltaxml-old">FO31</span></small></sup><span class="deltaxml-old"> is imported; any location hints are ignored. </span></p><p><span style="display: none;" class="delete_version">It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0058" title="err:XQST0058">err:XQST0058</a>] if more than one schema import in the same <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> specifies the same target namespace. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0059" title="err:XQST0059">err:XQST0059</a>] if the implementation is not able to process a schema import by finding a valid schema with the specified target namespace. </span><span style="display: none;" class="add_version">It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0058" title="err:XQST0058">err:XQST0058</a>] if more than one schema import in the same <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> specifies the same target namespace. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0059" title="err:XQST0059">err:XQST0059</a>] if the implementation is not able to process a schema import by finding a valid schema with the specified target namespace. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0035" title="err:XQST0035">err:XQST0035</a>] if multiple imported schemas, or multiple physical resources within one schema, contain definitions for the same name in the same symbol space (for example, two definitions for the same element name, even if the definitions are consistent). However, it is not an error to import the schema with target namespace <code>http://www.w3.org/2001/XMLSchema </code>(predeclared prefix <code>xs</code>), even though the built-in types defined in this schema are implicitly included in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types.</a></span><span class="modify_version">It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0058" title="err:XQST0058">err:XQST0058</a>] if more than one schema import in the same <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> specifies the same target namespace. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0059" title="err:XQST0059">err:XQST0059</a>] if the implementation is not able to process a schema import by finding a valid schema with the specified target namespace. <span class="deltaxml-new">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new">static error</span></a><span class="deltaxml-new"> [</span><a href="#ERRXQST0035" title="err:XQST0035"><span class="deltaxml-new">err:XQST0035</span></a><span class="deltaxml-new">] if multiple imported schemas, or multiple physical resources within one schema, contain definitions for the same name in the same symbol space (for example, two definitions for the same element name, even if the definitions are consistent). However, it is not an error to import the schema with target namespace </span><code><span class="deltaxml-new">http://www.w3.org/2001/XMLSchema </span></code><span class="deltaxml-new">(predeclared prefix </span><code><span class="deltaxml-new">xs</span></code><span class="deltaxml-new">), even though the built-in types defined in this schema are implicitly included in the </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-new">in-scope schema types.</span></a></span></p><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0012" title="err:XQST0012">err:XQST0012</a>] if the set of definitions contained in all schemas imported by a Prolog do not satisfy the conditions for schema validity specified in Sections 3 and 5 of <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> Part 1<span class="deltaxml-old">: in particular</span><span class="deltaxml-new">--i.e.</span>, each definition must be valid, complete, and unique.</p><p><span class="deltaxml-old"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-old">static error</span></a><span class="deltaxml-old"> [</span><a href="#ERRXQST0149" title="err:XQST0149"><span class="deltaxml-old">err:XQST0149</span></a><span class="deltaxml-old">] if the schemas imported by different modules of a query are not compatible as defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#schema-consistency"><span class="deltaxml-old">Section 2.8.1 Schema Consistency</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">.</span></p><p>The following example imports a schema, specifying both its target namespace and its location, and binding the prefix <code>soap</code> to the target namespace:</p><div class="exampleInner"><pre>import schema namespace soap="http://www.w3.org/2003/05/soap-envelope" at "http://www.w3.org/2003/05/soap-envelope/";</pre></div><p>The following example imports a schema by specifying only its target namespace, and makes it the <span>default namespace for elements and types</span>:</p><div class="exampleInner"><pre>import schema default element namespace "http://example.org/abc";</pre></div><p><span style="display: none;" class="delete_version">The following example imports a schema that has no target namespace, providing a location hint, and sets the <span>default namespace for elements and types</span> to “no namespace” so that the definitions in the imported schema can be referenced:</span><span style="display: none;" class="add_version">The following example imports a schema that has no target namespace, providing a location hint, and sets the <span>default namespace for elements and types</span> to "no namespace" so that the definitions in the imported schema can be referenced:</span><span class="modify_version">The following example imports a schema that has no target namespace, providing a location hint, and sets the <span>default namespace for elements and types</span> to <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>no namespace<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> so that the definitions in the imported schema can be referenced:</span></p><div class="exampleInner"><pre>import schema default element namespace "" at "http://example.org/xyz.xsd";</pre></div><p><span style="display: none;" class="delete_version">The following example imports a schema that has no target namespace and sets the <span>default namespace for elements and types</span> to “no namespace”. Since no location hint is provided, it is up to the implementation to find the schema to be imported.</span><span style="display: none;" class="add_version">The following example imports a schema that has no target namespace and sets the <span>default namespace for elements and types</span> to "no namespace". Since no location hint is provided, it is up to the implementation to find the schema to be imported.</span><span class="modify_version">The following example imports a schema that has no target namespace and sets the <span>default namespace for elements and types</span> to <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>no namespace<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span>. Since no location hint is provided, it is up to the implementation to find the schema to be imported.</span></p><div class="exampleInner"><pre>import schema default element namespace "";</pre></div></div><div class="div2"><h3><a id="id-module-import"></a>5.12 Module Import</h3><a id="d3e31909"></a><a id="d3e28581"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ModuleImport"></a>[23]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ModuleImport">ModuleImport</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"import" "module" ("namespace" <a href="#prod-xquery40-NCName">NCName</a> "=")? <a href="#doc-xquery40-URILiteral">URILiteral</a> ("at" <a href="#doc-xquery40-URILiteral">URILiteral</a> ("," <a href="#doc-xquery40-URILiteral">URILiteral</a>)*)?</code></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version"> [<a id="dt-module-import" title="module import">Definition</a>: A <b>module import</b> imports the public variable declarations, public function declarations<span>, and public item type declarations</span> from one or more <a title="library module" class="termref" href="#dt-library-module">library modules</a> into the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>, <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a><span>, or <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types">in-scope named item types</a></span> of the importing <a title="module" class="termref" href="#dt-module">module</a>.] Each module import names a <a title="target namespace" class="termref" href="#dt-target-namespace">target namespace</a> and imports an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> set of modules that share this target namespace. The module import may bind a namespace prefix to the target namespace, adding the (prefix, URI) pair to the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>, and it may provide optional hints for locating the modules to be imported.</span><span style="display: none;" class="add_version"> [<a id="dt-module-import" title="module import">Definition</a>: A <b>module import</b> imports the public variable declarations, public function declarations<span>, and public item type declarations</span> from one or more <a title="library module" class="termref" href="#dt-library-module">library modules</a> into the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>, <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a><span>, or <a class="termref" title="item type aliases" href="#dt-item-type-aliases">item type aliases</a></span> of the importing <a title="module" class="termref" href="#dt-module">module</a>.] Each module import names a <a title="target namespace" class="termref" href="#dt-target-namespace">target namespace</a> and imports an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> set of modules that share this target namespace. The module import may bind a namespace prefix to the target namespace, adding the (prefix, URI) pair to the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>, and it may provide optional hints for locating the modules to be imported.</span><span class="modify_version"> [<a id="dt-module-import" title="module import">Definition</a>: A <b>module import</b> imports the public variable declarations, public function declarations<span>, and public item type declarations</span> from one or more <a title="library module" class="termref" href="#dt-library-module">library modules</a> into the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>, <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a><span>, or <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types"><span class="deltaxml-old">in-scope named item types</span></a><a class="termref" title="item type aliases" href="#dt-item-type-aliases"><span class="deltaxml-new">item type aliases</span></a></span> of the importing <a title="module" class="termref" href="#dt-module">module</a>.] Each module import names a <a title="target namespace" class="termref" href="#dt-target-namespace">target namespace</a> and imports an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> set of modules that share this target namespace. The module import may bind a namespace prefix to the target namespace, adding the (prefix, URI) pair to the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>, and it may provide optional hints for locating the modules to be imported.</span></p><p><span style="display: none;" class="delete_version">If a module <var>A</var> imports module <var>B</var>, the static context of module <var>A</var> will contain the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>, <a class="termref" title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a><span>, or <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types">in-scope named item types</a></span> of module <var>B</var>, and the dynamic context of module <var>A</var> will contain the public <a title="variable values" class="termref" href="#dt-variable-values">variable values</a> and <a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions">dynamically known function definitions</a> of module <var>B</var>. It will not contain:</span><span style="display: none;" class="add_version">If a module <code>A</code> imports module <code>B</code>, the static context of module <code>A</code> will contain the <a class="termref" title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> and <a class="termref" title="statically known function definitions" href="#dt-statically-known-function-definitions">statically known function definitions</a> of module <code>B</code>, and the dynamic context of module <code>A</code> will contain the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a> and <a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions">dynamically known function definitions</a> of module <code>B</code>, with the exception of non-public functions and variables, and of the functions and variables not declared directly in <code>B</code>.</span><span class="modify_version">If a module <code>A</code> imports module <code>B</code>, the static context of module <code>A</code> will contain the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-old">statically known function definitions</span></a><span class="deltaxml-old">, </span><a class="termref" title="in-scope schema definitions" href="#dt-issd">in-scope <span class="deltaxml-old">variables</span><span class="deltaxml-new">schema definitions</span></a><span class="deltaxml-old">, or</span><span class="deltaxml-new"> and</span> <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types"><span class="deltaxml-old">in-scope named item types</span></a><a class="termref" title="statically known function definitions" href="#dt-statically-known-function-definitions"><span class="deltaxml-new">statically known function definitions</span></a> of module <code>B</code>, and the dynamic context of module <code>A</code> will contain the <span class="deltaxml-old">public </span><a title="variable values" class="termref" href="#dt-variable-values">variable values</a> and <a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions">dynamically known function definitions</a> of module <code>B</code><span class="deltaxml-old">. It will not contain</span><span class="deltaxml-new">, with the exception of non-public functions and variables, and of the functions and variables not declared directly in </span><code><span class="deltaxml-new">B</span></code><span class="deltaxml-old">:</span><span class="deltaxml-new">.</span></span></p><ul><li><p><span class="deltaxml-old">Private functions, variables, and item types declared in </span><var><span class="deltaxml-old">B</span></var><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">Functions, variables, and item types not declared directly in </span><var><span class="deltaxml-old">B</span></var><span class="deltaxml-old">, but imported from some other library module.</span></p></li><li><p><span class="deltaxml-old">Other components such as </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-old">in-scope schema definitions</span></a><span class="deltaxml-old"> or </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-old">statically known namespaces</span></a><span class="deltaxml-old"> declared in </span><var><span class="deltaxml-old">B</span></var><span class="deltaxml-old">.</span></p></li></ul><p>The following example illustrates a module import:</p><div class="exampleInner"><pre>import module namespace gis="http://example.org/gis-functions";</pre></div><p>If a query imports the same module via multiple paths, only one instance of the module is imported. Because only one instance of a module is imported, there is only one instance of each variable declared in a module's prolog.</p><p>A module may import its own target namespace (this is interpreted as importing an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> set of other modules that share its target namespace.)</p><p>The namespace prefix specified in a module import must not be <code>xml</code> or <code>xmlns</code> [<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>], and must not be the same as any namespace prefix bound in the same module by another module import, a <a title="schema import" class="termref" href="#dt-schema-import">schema import</a>, a <a title="namespace declaration" class="termref" href="#dt-namespace-declaration">namespace declaration</a>, or a <a title="module declaration" class="termref" href="#dt-module-declaration">module declaration</a> with a different target namespace [<a href="#ERRXQST0033" title="err:XQST0033">err:XQST0033</a>].</p><p><span style="display: none;" class="delete_version">The first <a href="#doc-xquery40-URILiteral">URILiteral</a> in a module import must be of nonzero length [<a href="#ERRXQST0088" title="err:XQST0088">err:XQST0088</a>], and specifies the target namespace of the modules to be imported. The <a href="#doc-xquery40-URILiteral">URILiterals</a> that follow the <code>at</code> keyword are optional location hints, and can be interpreted or disregarded in an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way.</span><span style="display: none;" class="add_version">The first <a href="#doc-xquery40-URILiteral">URILiteral</a> in a module import must be of nonzero length [<a href="#ERRXQST0088" title="err:XQST0088">err:XQST0088</a>], and specifies the target namespace of the modules to be imported. The URILiterals that follow the <code>at</code> keyword are optional location hints, and can be interpreted or disregarded in an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way.</span><span class="modify_version">The first <a href="#doc-xquery40-URILiteral">URILiteral</a> in a module import must be of nonzero length [<a href="#ERRXQST0088" title="err:XQST0088">err:XQST0088</a>], and specifies the target namespace of the modules to be imported. The <a href="#doc-xquery40-URILiteral"><span class="deltaxml-old">URILiterals</span></a><span class="deltaxml-new">URILiterals</span> that follow the <code>at</code> keyword are optional location hints, and can be interpreted or disregarded in an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way.</span></p><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0047" title="err:XQST0047">err:XQST0047</a>] if more than one module import in a <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> specifies the same target namespace. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0059" title="err:XQST0059">err:XQST0059</a>] if the implementation is not able to process a module import by finding a valid module definition with the specified target namespace. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two or more variables declared or imported by a <a title="module" class="termref" href="#dt-module">module</a> have equal <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> (as defined by the <code>eq</code> operator) [<a href="#ERRXQST0049" title="err:XQST0049">err:XQST0049</a>].</p><p><span style="display: none;" class="delete_version">Module imports are not transitive. Importing a module provides access only to declarations contained directly in the imported module. For example, if module <var>A</var> imports module <var>B</var>, and module <var>B</var> imports module <var>C</var>, module <var>A</var> does not have access to the functions and variables declared in module <var>C</var>. </span><span style="display: none;" class="add_version">Each <a title="module" class="termref" href="#dt-module">module</a> has its own <a title="static context" class="termref" href="#dt-static-context">static context</a>. A <a title="module import" class="termref" href="#dt-module-import">module import</a> imports only functions, variable declarations<span>, and item type declaratons</span>; it does not import other objects from the imported modules, such as <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> or <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>. Module imports are not transitive—that is, importing a module provides access only to declarations contained directly in the imported module. For example, if module A imports module B, and module B imports module C, module A does not have access to the functions and variables declared in module C. </span><span class="modify_version"><span class="deltaxml-new">Each </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new">module</span></a><span class="deltaxml-new"> has its own </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new">static context</span></a><span class="deltaxml-new">. A </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new">module import</span></a><span class="deltaxml-new"> imports only functions, variable declarations</span><span><span class="deltaxml-new">, and item type declaratons</span></span><span class="deltaxml-new">; it does not import other objects from the imported modules, such as </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new">in-scope schema definitions</span></a><span class="deltaxml-new"> or </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new">statically known namespaces</span></a><span class="deltaxml-new">. </span>Module imports are not transitive<span class="deltaxml-old">. Importing</span><span class="deltaxml-new">—that is, importing</span> a module provides access only to declarations contained directly in the imported module. For example, if module A imports module B, and module B imports module C, module A does not have access to the functions and variables declared in module C. </span></p><div class="example"><div class="exampleHeader"><a id="d3e32104"></a><a id="d3e28759"></a>Example: Schema Information and Module Import</div><p><span style="display: none;" class="delete_version">A module import does not import schema definitions from the imported module. In the following query, the type <code>geometry:triangle</code> is not defined, even if it is known in the imported module, so the variable declaration raises an error [<a href="#ERRXPST0051" title="err:XPST0051">err:XPST0051</a>]:</span><span style="display: none;" class="add_version">A module import does not import schema definitions from the imported module. In the following query, the type geometry:triangle is not defined, even if it is known in the imported module, so the variable declaration raises an error [<a href="#ERRXPST0051" title="err:XPST0051">err:XPST0051</a>]:</span><span class="modify_version">A module import does not import schema definitions from the imported module. In the following query, the type geometry:triangle is not defined, even if it is known in the imported module, so the variable declaration raises an error [<a href="#ERRXPST0051" title="err:XPST0051">err:XPST0051</a>]:</span></p><div class="exampleInner"><pre>(: Error - geometry:triangle is not defined :) import module namespace geo = "http://example.org/geo-functions"; declare variable $t as geometry:triangle := geo:make-triangle(); $t</pre></div><p>Without the type declaration for the variable, the variable declaration succeeds:</p><div class="exampleInner"><pre>import module namespace geo = "http://example.org/geo-functions"; declare variable $t := geo:make-triangle(); $t</pre></div><p>Importing the schema that defines the type of the variable, the variable declaration succeeds:</p><div class="exampleInner"><pre>import schema namespace geometry = "http://example.org/geo-schema-declarations"; import module namespace geo = "http://example.org/geo-functions"; declare variable $t as geometry:triangle := geo:make-triangle(); $t</pre></div></div><div class="div3"><h4><a id="id-module-handling-module-uris"></a>5.12.1 The Target Namespace of a Module</h4><p>The target namespace of a module should be treated in the same way as other namespace URIs.</p><p>To maximize interoperability, query authors should use a string that is a valid absolute IRI.</p><p>Implementions must accept any string of Unicode characters. Target namespace URIs are compared using the Unicode codepoint collation rather than any concept of semantic equivalence.</p><p>Implementations may provide mechanisms allowing the target namespace URI to be used as input to a process that delivers the module as a resource, for example a catalog, module repository, or URI resolver. For interoperability, such mechanisms should not prevent the user from choosing an arbitrary URI for naming a module.</p><p>Similarly, implementations may perform syntactic transformations on the target namespace URI to obtain the names of related resources, for example to implement a convention relating the name or location of compiled code to the target namespace URI; but again, such mechanisms should not prevent the user from choosing an arbitrary target namespace URI.</p><p><span style="display: none;" class="delete_version">As with other namespace URIs, it is common practice to use target namespace URIs whose scheme is <code>http</code> and whose authority part uses a DNS domain name under the control of the user.</span><span style="display: none;" class="add_version">As with other namespace URIs, it is common practice to use target namespace URIs whose scheme is "http" and whose authority part uses a DNS domain name under the control of the user.</span><span class="modify_version">As with other namespace URIs, it is common practice to use target namespace URIs whose scheme is <span class="deltaxml-new">"</span>http<span class="deltaxml-new">"</span> and whose authority part uses a DNS domain name under the control of the user.</span></p><p>The specifications allow, and some users might consider it good practice, for the target namespace URI of a function library to be the same as the namespace URI of the XML vocabulary manipulated by the functions in that library.</p></div><div class="div3"><h4><a id="id-module-handling-multiple-same"></a>5.12.2 Multiple Modules with the same Namespace</h4><p>Several different modules with the same target namespace can be used in the same query. The names of public variables and public functions must be unique within the <a title="module context" class="termref" href="#dt-module-context">module contexts</a> of a query: that is, if two modules with the same target namespace URI are used in the same query, the names of the public variables and functions in their module contexts must not overlap.</p><p><span style="display: none;" class="delete_version">If one module contains an <code>import module</code> declaration with the target namespace <code>M</code>, then all public variables and public functions in the contexts of modules whose target namespace is <code>M</code> must be accessible in the importing module, regardless whether the participation of the imported module was directly due to this "import module" declaration.</span><span style="display: none;" class="add_version">If one module contains an "import module" declaration with the target namespace <code>M</code>, then all public variables and public functions in the contexts of modules whose target namespace is <code>M</code> must be accessible in the importing module, regardless whether the participation of the imported module was directly due to this "import module" declaration.</span><span class="modify_version">If one module contains an <span class="deltaxml-new">"</span>import module<span class="deltaxml-new">"</span> declaration with the target namespace <code>M</code>, then all public variables and public functions in the contexts of modules whose target namespace is <code>M</code> must be accessible in the importing module, regardless whether the participation of the imported module was directly due to this "import module" declaration.</span></p></div><div class="div3"><h4><a id="id-module-handling-location-uris"></a>5.12.3 Location URIs</h4><p><span style="display: none;" class="delete_version">The term “location URIs” refers to the URIs in the <code>at</code> clause of an <code>import module</code> declaration.</span><span style="display: none;" class="add_version">The term "location URIs" refers to the URIs in the "at" clause of an "import module" declaration.</span><span class="modify_version">The term <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>location URIs<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> refers to the URIs in the <span class="deltaxml-new">"</span>at<span class="deltaxml-new">"</span> clause of an <span class="deltaxml-new">"</span>import module<span class="deltaxml-new">"</span> declaration.</span></p><p><span style="display: none;" class="delete_version">Products should (by default or at user option) take account of all the location URIs in an <code>import module</code> declaration, treating each location URI as a reference to a module with the specified target namespace URI. Location URIs should be made absolute with respect to the static base URI of the module containing the <code>import module</code> declaration where they appear. The mapping from location URIs to module source code or compiled code MAY be done in any way convenient to the implementation. If possible given the product’s architecture, security requirements, etc, the product should allow this to fetch the source code of the module to use the standard web mechanisms for dereferencing URIs in standard schemes such as the <code>http</code> URI scheme.</span><span style="display: none;" class="add_version">Products should (by default or at user option) take account of all the location URIs in an "import module" declaration, treating each location URI as a reference to a module with the specified target namespace URI. Location URIs should be made absolute with respect to the static base URI of the module containing the "import module" declaration where they appear. The mapping from location URIs to module source code or compiled code MAY be done in any way convenient to the implementation. If possible given the product's architecture, security requirements, etc, the product should allow this to fetch the source code of the module to use the standard web mechanisms for dereferencing URIs in standard schemes such as the "http" URI scheme.</span><span class="modify_version">Products should (by default or at user option) take account of all the location URIs in an <span class="deltaxml-new">"</span>import module<span class="deltaxml-new">"</span> declaration, treating each location URI as a reference to a module with the specified target namespace URI. Location URIs should be made absolute with respect to the static base URI of the module containing the <span class="deltaxml-new">"</span>import module<span class="deltaxml-new">"</span> declaration where they appear. The mapping from location URIs to module source code or compiled code MAY be done in any way convenient to the implementation. If possible given the <span class="deltaxml-old">product’s</span><span class="deltaxml-new">product's</span> architecture, security requirements, etc, the product should allow this to fetch the source code of the module to use the standard web mechanisms for dereferencing URIs in standard schemes such as the <span class="deltaxml-new">"</span>http<span class="deltaxml-new">"</span> URI scheme.</span></p><p><span style="display: none;" class="delete_version">When the same absolutized location URI is used more than once, either in the same <code>import module</code> declaration or in different <code>import module</code> declarations within the same query, a single copy of the resource containing the module is loaded. When different absolutized location URIs are used, each results in a single module being loaded, unless the implementation is able to determine that the different URIs are references to the same resource. No error due to duplicate variable or functions names should arise from the same module being imported more than once, so long as the absolute location URI is the same in each case.</span><span style="display: none;" class="add_version">When the same absolutized location URI is used more than once, either in the same "import module" declaration or in different "import module" declarations within the same query, a single copy of the resource containing the module is loaded. When different absolutized location URIs are used, each results in a single module being loaded, unless the implementation is able to determine that the different URIs are references to the same resource. No error due to duplicate variable or functions names should arise from the same module being imported more than once, so long as the absolute location URI is the same in each case.</span><span class="modify_version">When the same absolutized location URI is used more than once, either in the same <span class="deltaxml-new">"</span>import module<span class="deltaxml-new">"</span> declaration or in different <span class="deltaxml-new">"</span>import module<span class="deltaxml-new">"</span> declarations within the same query, a single copy of the resource containing the module is loaded. When different absolutized location URIs are used, each results in a single module being loaded, unless the implementation is able to determine that the different URIs are references to the same resource. No error due to duplicate variable or functions names should arise from the same module being imported more than once, so long as the absolute location URI is the same in each case.</span></p><p>Implementations must report a static error if a location URI cannot be resolved after all available recovery strategies have been exhausted.</p></div><div class="div3"><h4><a id="id-module-handling-cycles"></a>5.12.4 Cycles</h4><p>Implementations must resolve cycles in the import graph, either at the level of target namespace URIs or at the level of location URIs, and ensure that each module is imported only once. </p></div></div><div class="div2"><h3><a id="id-namespace-declaration"></a>5.13 Namespace Declaration</h3><a id="d3e32176"></a><a id="d3e28807"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NamespaceDecl"></a>[24]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NamespaceDecl">NamespaceDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "namespace" <a href="#prod-xquery40-NCName">NCName</a> "=" <a href="#doc-xquery40-URILiteral">URILiteral</a></code></td><td></td></tr></tbody></table><p> [<a id="dt-namespace-declaration" title="namespace declaration">Definition</a>: A <b>namespace declaration</b> declares a namespace prefix and associates it with a namespace URI, adding the (prefix, URI) pair to the set of <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>.] The namespace declaration is in scope throughout the query in which it is declared, unless it is overridden by a <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attribute</a> in a <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a>.</p><p>If the URILiteral part of a namespace declaration is a zero-length string, any existing namespace binding for the given prefix is removed from the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>. This feature provides a way to remove predeclared namespace prefixes such as <code>local</code>.</p><p>The following query illustrates a namespace declaration:</p><div class="exampleInner"><pre><span class="deltaxml-old">declare namespace foo = "http://example.org"; &lt;foo:bar&gt; Lentils &lt;/foo:bar&gt;</span></pre><pre><span class="deltaxml-new">declare namespace foo = "http://example.org"; &lt;foo:bar&gt; Lentils &lt;/foo:bar&gt; </span></pre></div><p>In the query result, the newly created node is in the namespace associated with the namespace URI <code>http://example.org</code>.</p><p>The namespace prefix specified in a namespace declaration must not be <code>xml</code> or <code>xmlns</code> [<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>]. The namespace URI specified in a namespace declaration must not be <code>http://www.w3.org/XML/1998/namespace</code> or <code>http://www.w3.org/2000/xmlns/</code> [<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>]. The namespace prefix specified in a namespace declaration must not be the same as any namespace prefix bound in the same module by a <a title="module import" class="termref" href="#dt-module-import">module import</a>, <a title="schema import" class="termref" href="#dt-schema-import">schema import</a>, <a title="module import" class="termref" href="#dt-module-import">module declaration</a>, or another namespace declaration [<a href="#ERRXQST0033" title="err:XQST0033">err:XQST0033</a>]. </p><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>] if an expression contains a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> with a namespace prefix that is not in the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>.</p><p><span style="display: none;" class="delete_version">XQuery has several predeclared namespace prefixes, which are listed in <a href="#id-namespaces-and-qnames"><b>2.1.2 Namespaces and QNames</b></a>. These prefixes may be used without an explicit declaration; they are present in the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> before each query is processed. They may be overridden by <a title="namespace declaration" class="termref" href="#dt-namespace-declaration">namespace declarations</a> in a <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> or by <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> on constructed elements (however, the prefix <code>xml</code> must not be redeclared, and no other prefix may be bound to the namespace URI associated with the prefix <code>xml</code> [<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>]). </span><span style="display: none;" class="add_version">XQuery has several predeclared namespace prefixes that are present in the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> before each query is processed. These prefixes may be used without an explicit declaration. They may be overridden by <a title="namespace declaration" class="termref" href="#dt-namespace-declaration">namespace declarations</a> in a <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> or by <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> on constructed elements (however, the prefix <code>xml</code> must not be redeclared, and no other prefix may be bound to the namespace URI associated with the prefix <code>xml</code> [<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>]). The predeclared namespace prefixes are as follows:</span><span class="modify_version">XQuery has several predeclared namespace prefixes<span class="deltaxml-old">, which are listed in</span><span class="deltaxml-new"> that are</span> <a href="#id-namespaces-and-qnames"><b><span class="deltaxml-old">2.1.2 Namespaces and QNames</span></b></a><span class="deltaxml-old">. These prefixes may be used without an explicit declaration; they are </span>present in the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> before each query is processed. <span class="deltaxml-new">These prefixes may be used without an explicit declaration. </span>They may be overridden by <a title="namespace declaration" class="termref" href="#dt-namespace-declaration">namespace declarations</a> in a <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> or by <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> on constructed elements (however, the prefix <code>xml</code> must not be redeclared, and no other prefix may be bound to the namespace URI associated with the prefix <code>xml</code> [<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>]). <span class="deltaxml-new">The predeclared namespace prefixes are as follows:</span></span></p><ul><li><p><code><span class="deltaxml-new">xml = http://www.w3.org/XML/1998/namespace</span></code></p></li><li><p><code><span class="deltaxml-new">xs = http://www.w3.org/2001/XMLSchema</span></code></p></li><li><p><code><span class="deltaxml-new">xsi = http://www.w3.org/2001/XMLSchema-instance</span></code></p></li><li><p><code><span class="deltaxml-new">fn = http://www.w3.org/2005/xpath-functions</span></code></p></li><li><p><code><span class="deltaxml-new">local = http://www.w3.org/2005/xquery-local-functions</span></code><span class="deltaxml-new"> (see </span><a href="#FunctionDeclns"><b><span class="deltaxml-new">5.18 Function Declaration</span></b></a><span class="deltaxml-new">.)</span></p></li></ul><p>Additional predeclared namespace prefixes may be added to the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> by an implementation.</p><p>When element or attribute names are compared, they are considered identical if the local parts and namespace URIs match on a codepoint basis. Namespace prefixes need not be identical for two names to match, as illustrated by the following example:</p><div class="exampleInner"><pre><span class="deltaxml-old">declare namespace xx = "http://example.org"; let $i := &lt;foo:bar xmlns:foo = "http://example.org"&gt; &lt;foo:bing&gt; Lentils &lt;/foo:bing&gt; &lt;/foo:bar&gt; return $i/xx:bing</span></pre><pre><span class="deltaxml-new">declare namespace xx = "http://example.org"; let $i := &lt;foo:bar xmlns:foo = "http://example.org"&gt; &lt;foo:bing&gt; Lentils &lt;/foo:bing&gt; &lt;/foo:bar&gt; return $i/xx:bing </span></pre></div><p>Although the namespace prefixes <code>xx</code> and <code>foo</code> differ, both are bound to the namespace URI <code>http://example.org</code>. Since <code>xx:bing</code> and <code>foo:bing</code> have the same local name and the same namespace URI, they match. The output of the above query is as follows.</p><div class="exampleInner"><pre><span class="deltaxml-old">&lt;foo:bing xmlns:foo = "http://example.org"&gt; Lentils &lt;/foo:bing&gt;</span></pre><pre><span class="deltaxml-new">&lt;foo:bing xmlns:foo = "http://example.org"&gt; Lentils &lt;/foo:bing&gt; </span></pre></div></div><div class="div2"><h3><a id="id-default-namespace"></a>5.14 Default Namespace Declaration</h3><a id="d3e32305"></a><a id="d3e28962"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DefaultNamespaceDecl"></a>[25]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DefaultNamespaceDecl">DefaultNamespaceDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"declare" "fixed"? "default" ("element" | "function") "namespace" <a href="#doc-xquery40-URILiteral">URILiteral</a></code></span><span style="display: none;" class="add_version"><code>"declare" "default" ("element" | "type" | "function") "namespace" <a href="#doc-xquery40-URILiteral">URILiteral</a></code></span><span class="modify_version"><code>"declare" "<span class="deltaxml-old">fixed"? "</span>default" ("element" | "<span class="deltaxml-new">type" | "</span>function") "namespace" <a href="#doc-xquery40-URILiteral">URILiteral</a></code></span></td><td></td></tr></tbody></table><p><b>Default namespace declarations</b> can be used in a <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> to facilitate the use of unprefixed QNames.</p><p>The namespace URI specified in a default namespace declaration must not be <code>http://www.w3.org/XML/1998/namespace</code> or <code>http://www.w3.org/2000/xmlns/</code> [<a href="#ERRXQST0070" title="err:XQST0070">err:XQST0070</a>].</p><p>The following kinds of default namespace declarations are supported:</p><ul><li><p><span class="deltaxml-new"> [</span><a id="dt-def-elem-ns" title="default element namespace"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: PLACEHOLDER] </span></p><p><span style="display: none;" class="delete_version">A <b>default element namespace declaration</b> declares how unprefixed element and type names are to be interpreted. The relevant value is recorded as the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> for the query module. A <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> may contain at most one default element namespace declaration <span>and it must not contain both a default element namespace declaration and an <code>import schema</code> declaration that specifies a default element namespace</span> [<a href="#ERRXQST0066" title="err:XQST0066">err:XQST0066</a>].</span><span style="display: none;" class="add_version">A <b>default element namespace declaration</b> declares a namespace URI that is associated with unprefixed names of elements . This declaration is recorded as the <a class="termref" title="default element namespace" href="#dt-def-elem-ns">default element namespace</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>. A <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> may contain at most one default element namespace declaration <span>and it must not contain both a default element namespace declaration and an <code>import schema</code> declaration that specifies a default element namespace</span> [<a href="#ERRXQST0066" title="err:XQST0066">err:XQST0066</a>] . If the <a href="#doc-xquery40-URILiteral">URILiteral</a> in a default <span>element</span> namespace declaration is a zero-length string, the <a title="default element namespace" class="termref" href="#dt-def-elem-ns">default element namespace</a> is undeclared (set to <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>), and unprefixed names of elements are considered to be in no namespace. The following example illustrates the declaration of a default namespace for elements:</span><span class="modify_version">A <b>default element namespace declaration</b> declares <span class="deltaxml-old">how unprefixed element and type names are to be interpreted. The relevant value</span><span class="deltaxml-new">a namespace URI that is associated with unprefixed names of elements . This declaration</span> is recorded as the <a class="termref" title="default namespace for elements and types" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><a class="termref" title="default element namespace" href="#dt-def-elem-ns"><span class="deltaxml-new">default element namespace</span></a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a><span class="deltaxml-old"> for the query module</span>. A <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> may contain at most one default element namespace declaration <span>and it must not contain both a default element namespace declaration and an <code>import schema</code> declaration that specifies a default element namespace</span> [<a href="#ERRXQST0066" title="err:XQST0066">err:XQST0066</a>]<span class="deltaxml-new"> </span>.<span class="deltaxml-new"> If the </span><a href="#doc-xquery40-URILiteral"><span class="deltaxml-new">URILiteral</span></a><span class="deltaxml-new"> in a default </span><span><span class="deltaxml-new">element</span></span><span class="deltaxml-new"> namespace declaration is a zero-length string, the </span><a title="default element namespace" class="termref" href="#dt-def-elem-ns"><span class="deltaxml-new">default element namespace</span></a><span class="deltaxml-new"> is undeclared (set to </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent"><span class="deltaxml-new">absent</span></a><sup><small><span class="deltaxml-new">DM31</span></small></sup><span class="deltaxml-new">), and unprefixed names of elements are considered to be in no namespace. The following example illustrates the declaration of a default namespace for elements:</span></span></p><p><span class="deltaxml-old">The </span><code><span class="deltaxml-old">URILiteral</span></code><span class="deltaxml-old"> may take one of the following forms:</span></p><ul><li><p><span class="deltaxml-old">A namespace URI. This namespace will be used for all unprefixed names appearing where an element or type name is expected.</span></p></li><li><p><span class="deltaxml-old">The empty string </span><code><span class="deltaxml-old">""</span></code><span class="deltaxml-old">. In this case unprefixed names appearing where an element or type name is expected are treated as being in no namespace: the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old"> is set to </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-old">absent</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">.</span></p></li></ul><p><span class="deltaxml-old">The following example illustrates the declaration of a default namespace for elements and types:</span></p><div class="exampleInner"><pre>declare default element namespace "http://example.org/names";</pre></div><p><span style="display: none;" class="delete_version">If no default element namespace declaration is present, unprefixed element and type names are in no namespace (however, an implementation may define a different default as specified in <a href="#id-xq-static-context-components"><b>C.1 Static Context Components</b></a>.)</span><span style="display: none;" class="add_version">If no default <span>element</span> namespace declaration is present, unprefixed element names are in no namespace (however, an implementation may define a different default as specified in <a href="#id-xq-static-context-components"><b>C.1 Static Context Components</b></a>.)</span><span class="modify_version">If no default <span>element</span> namespace declaration is present, unprefixed element <span class="deltaxml-old">and type </span>names are in no namespace (however, an implementation may define a different default as specified in <a href="#id-xq-static-context-components"><b>C.1 Static Context Components</b></a>.)</span></p><p><span class="deltaxml-old">If the keyword </span><code><span class="deltaxml-old">"fixed"</span></code><span class="deltaxml-old">, is present, the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old"> is fixed throughout the module, and is not affected by default namespace declarations (</span><code><span class="deltaxml-old">xmlns=""</span></code><span class="deltaxml-old">) appearing on direct element constructors.</span></p><p><span class="deltaxml-new">A default element namespace declaration also establishes a binding for the zero-length prefix in the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new">statically known namespaces</span></a><span class="deltaxml-new">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">The default element namespace is used primarily for resolving unprefixed element names appearing in path expressions such as </span><code><span class="deltaxml-new">/orders/order/price</span></code><span class="deltaxml-new">. The binding for the zero-length prefix in the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new">statically known namespaces</span></a><span class="deltaxml-new"> is used primarily for resolving unprefixed element names in </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-new">direct element constructors</span></a><span class="deltaxml-new"> such as </span><code><span class="deltaxml-new">&lt;orders&gt;{$x}&lt;/orders&gt;</span></code><span class="deltaxml-new">. Although the default element namespace declaration sets both to the same namespace, they can be different within the query: the binding for the zero-length prefix is affected by the presence of a a </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new">namespace declaration attribute</span></a><span class="deltaxml-new"> (such as </span><code><span class="deltaxml-new">xmlns=""</span></code><span class="deltaxml-new">)in a </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-new">direct element constructor</span></a></p><p><span class="deltaxml-new">In the absence of a default type namespace declaration, such a </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new">namespace declaration attribute</span></a><span class="deltaxml-new"> also overrides the default element namespace.</span></p></div><p><span class="deltaxml-new">For backwards compatibility reasons, if the prolog contains a default element namespace declaration and no default type namespace declaration, then the default namespace for types is set to be the same as the default namespace for elements.</span></p></li><li class="add_version" style="display: none;"><p>A <b>default type namespace declaration</b> declares a namespace URI that is associated with unprefixed names of types. This declaration is recorded as the <a title="default type namespace" class="termref" href="#dt-def-type-ns">default type namespace</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>. A <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> may contain at most one default type namespace declaration <span>and it must not contain both a default type namespace declaration and an <code>import schema</code> declaration that specifies a default element namespace</span> [<a href="#ERRXQST0066" title="err:XQST0066">err:XQST0066</a>] . If the <a href="#doc-xquery40-URILiteral">URILiteral</a> in a default type namespace declaration is a zero-length string, the <a title="default type namespace" class="termref" href="#dt-def-type-ns">default type namespace</a> is undeclared (set to <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>), and unprefixed names of types are considered to be in no namespace. The following example illustrates the declaration of a default namespace for types:</p><div class="exampleInner"><pre>declare default type namespace "http://www.w3.org/2001/XMLSchema";</pre></div><p>This declaration allows names of built-in types to be used without a prefix, for example a function parameter can be declared as <code>$arg as integer</code> rather than <code>$arg as xs:integer</code>. Note however that it does not apply to the names of constructor functions, which use the default namespace for functions.</p><p>A default type namespace declaration applies throughout the query module and cannot be overridden.</p><p>For backwards compatibility reasons, if the prolog contains no explicit default type namespace declaration, then:</p><ol class="enumar"><li><p>A <code>default element namespace declaration</code> in the prolog also sets the default namespace for types; and</p></li><li><p>A <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attribute</a><code>xmlns="uuuu"</code> in a <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a> overrides both the default element namespace and the default type namespace declared in the query prolog.</p></li></ol><p>If no default <span>element</span> namespace declaration is present, unprefixed element names are in no namespace (however, an implementation may define a different default as specified in <a href="#id-xq-static-context-components"><b>C.1 Static Context Components</b></a>.)</p><p>For backwards compatibility reasons, if the prolog contains a default element namespace declaration and no default type namespace declaration, then the default namespace for types is set to be the same as the default namespace for elements.</p></li><li class="modify_version"><p><span class="deltaxml-new">A </span><b><span class="deltaxml-new">default type namespace declaration</span></b><span class="deltaxml-new"> declares a namespace URI that is associated with unprefixed names of types. This declaration is recorded as the </span><a title="default type namespace" class="termref" href="#dt-def-type-ns"><span class="deltaxml-new">default type namespace</span></a><span class="deltaxml-new"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new">static context</span></a><span class="deltaxml-new">. A </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new">Prolog</span></a><span class="deltaxml-new"> may contain at most one default type namespace declaration </span><span><span class="deltaxml-new">and it must not contain both a default type namespace declaration and an </span><code><span class="deltaxml-new">import schema</span></code><span class="deltaxml-new"> declaration that specifies a default element namespace</span></span><span class="deltaxml-new"> [</span><a href="#ERRXQST0066" title="err:XQST0066"><span class="deltaxml-new">err:XQST0066</span></a><span class="deltaxml-new">] . If the </span><a href="#doc-xquery40-URILiteral"><span class="deltaxml-new">URILiteral</span></a><span class="deltaxml-new"> in a default type namespace declaration is a zero-length string, the </span><a title="default type namespace" class="termref" href="#dt-def-type-ns"><span class="deltaxml-new">default type namespace</span></a><span class="deltaxml-new"> is undeclared (set to </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent"><span class="deltaxml-new">absent</span></a><sup><small><span class="deltaxml-new">DM31</span></small></sup><span class="deltaxml-new">), and unprefixed names of types are considered to be in no namespace. The following example illustrates the declaration of a default namespace for types:</span></p><div class="exampleInner"><pre><span class="deltaxml-new">declare default type namespace "http://www.w3.org/2001/XMLSchema";</span></pre></div><p><span class="deltaxml-new">This declaration allows names of built-in types to be used without a prefix, for example a function parameter can be declared as </span><code><span class="deltaxml-new">$arg as integer</span></code><span class="deltaxml-new"> rather than </span><code><span class="deltaxml-new">$arg as xs:integer</span></code><span class="deltaxml-new">. Note however that it does not apply to the names of constructor functions, which use the default namespace for functions.</span></p><p><span class="deltaxml-new">A default type namespace declaration applies throughout the query module and cannot be overridden.</span></p><p><span class="deltaxml-new">For backwards compatibility reasons, if the prolog contains no explicit default type namespace declaration, then:</span></p><ol class="enumar"><li><p><span class="deltaxml-new">A </span><code><span class="deltaxml-new">default element namespace declaration</span></code><span class="deltaxml-new"> in the prolog also sets the default namespace for types; and</span></p></li><li><p><span class="deltaxml-new">A </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new">namespace declaration attribute</span></a><code><span class="deltaxml-new">xmlns="uuuu"</span></code><span class="deltaxml-new"> in a </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-new">direct element constructor</span></a><span class="deltaxml-new"> overrides both the default element namespace and the default type namespace declared in the query prolog.</span></p></li></ol><p><span class="deltaxml-new">If no default </span><span><span class="deltaxml-new">element</span></span><span class="deltaxml-new"> namespace declaration is present, unprefixed element names are in no namespace (however, an implementation may define a different default as specified in </span><a href="#id-xq-static-context-components"><b><span class="deltaxml-new">C.1 Static Context Components</span></b></a><span class="deltaxml-new">.)</span></p><p><span class="deltaxml-new">For backwards compatibility reasons, if the prolog contains a default element namespace declaration and no default type namespace declaration, then the default namespace for types is set to be the same as the default namespace for elements.</span></p></li><li><p>A <b>default function namespace declaration</b> declares a namespace URI that is associated with unprefixed function names in static function calls and function declarations.</p><p><span style="display: none;" class="delete_version">A <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> may contain at most one default function namespace declaration [<a href="#ERRXQST0066" title="err:XQST0066">err:XQST0066</a>]. If the <code>StringLiteral</code> in a default function namespace declaration is a zero-length string, the default function namespace is undeclared (set to <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>). In that case, any functions that are associated with a namespace can be called only by using an explicit namespace prefix.</span><span style="display: none;" class="add_version">A <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> may contain at most one default function namespace declaration [<a href="#ERRXQST0066" title="err:XQST0066">err:XQST0066</a>]. If the <code>StringLiteral</code> in a default function namespace declaration is a zero-length string, the default function namespace is undeclared (set to <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>). In that case, any functions that are associated with a namespace can be called only by using an explicit namespace prefix.</span><span class="modify_version">A <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> may contain at most one default function namespace declaration [<a href="#ERRXQST0066" title="err:XQST0066">err:XQST0066</a>]. If the <code>StringLiteral</code> in a default function namespace declaration is a zero-length string, the default function namespace is undeclared (set to <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>). In that case, any functions that are associated with a namespace can be called only by using an explicit namespace prefix.</span></p><p>If no default function namespace declaration is present, the default function namespace is the namespace of XPath/XQuery functions, <code>http://www.w3.org/2005/xpath-functions</code> (however, an implementation may define a different default as specified in <a href="#id-xq-static-context-components"><b>C.1 Static Context Components</b></a>.)</p><p>The following example illustrates the declaration of a default function namespace:</p><div class="exampleInner"><pre>declare default function namespace "http://www.w3.org/2005/xpath-functions/math";</pre></div><p>The effect of declaring a default function namespace is that all functions in the default function namespace, including implicitly declared <a title="constructor function" class="termref" href="#dt-constructor-function">constructor functions</a>, can be invoked without specifying a namespace prefix. When a static function call uses a function name with no prefix, the local name of the function must match a function (including implicitly declared <a title="constructor function" class="termref" href="#dt-constructor-function">constructor functions</a>) in the default function namespace [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Only <a title="constructor function" class="termref" href="#dt-constructor-function">constructor functions</a> can be in no namespace.</p></div><p><span class="deltaxml-old">The keyword </span><code><span class="deltaxml-old">"fixed"</span></code><span class="deltaxml-old"> has no effect when declaring a default function namespace, since there is no mechanism to change the default function namespace within a query module.</span></p></li></ul><p> Unprefixed attribute names and variable names are in no namespace.</p></div><div class="div2"><h3><a id="id-annotations"></a>5.15 Annotations</h3><a id="d3e32432"></a><a id="d3e29193"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AnnotatedDecl"></a>[26]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AnnotatedDecl">AnnotatedDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" <a href="#doc-xquery40-Annotation">Annotation</a>* (<a href="#doc-xquery40-VarDecl">VarDecl</a> | <a href="#doc-xquery40-FunctionDecl">FunctionDecl</a> | <a href="#doc-xquery40-ItemTypeDecl">ItemTypeDecl</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e28620.doc-xquery40-InlineFunctionExpr"></a><a id="noid_d4e25659.doc-xquery40-InlineFunctionExpr"></a>[<span class="deltaxml-old">207</span><span class="deltaxml-new">194</span>]&nbsp;&nbsp;&nbsp;</td><td><code>InlineFunctionExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-Annotation">Annotation</a>* ("function" | "fn") <a href="#doc-xquery40-FunctionSignature">FunctionSignature</a>? <a href="#doc-xquery40-FunctionBody">FunctionBody</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-Annotation">Annotation</a>* (("function" <a href="#doc-xquery40-FunctionSignature">FunctionSignature</a>) | ("-&gt;" <a href="#doc-xquery40-FunctionSignature">FunctionSignature</a>?)) <a href="#doc-xquery40-FunctionBody">FunctionBody</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-Annotation">Annotation</a>* (<span class="deltaxml-new">(</span>"function" <a href="#doc-xquery40-FunctionSignature"><span class="deltaxml-new">FunctionSignature</span></a><span class="deltaxml-new">) </span>| <span class="deltaxml-old">"fn")</span><span class="deltaxml-new">("-&gt;"</span> <a href="#doc-xquery40-FunctionSignature">FunctionSignature</a>?<span class="deltaxml-new">))</span> <a href="#doc-xquery40-FunctionBody">FunctionBody</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Annotation"></a>[27]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Annotation">Annotation</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-AnnotationValue">AnnotationValue</a> ("," <a href="#doc-xquery40-AnnotationValue">AnnotationValue</a>)* ")")?</code></span><span style="display: none;" class="add_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-Literal">Literal</a> ("," <a href="#doc-xquery40-Literal">Literal</a>)* ")")?</code></span><span class="modify_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a><a href="#doc-xquery40-Literal"><span class="deltaxml-new">Literal</span></a> ("," <a href="#doc-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a><a href="#doc-xquery40-Literal"><span class="deltaxml-new">Literal</span></a>)* ")")?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AnnotationValue"></a><span class="deltaxml-old">[28]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a><span class="deltaxml-old"> | ("-"? </span><a href="#doc-xquery40-NumericLiteral"><span class="deltaxml-old">NumericLiteral</span></a><span class="deltaxml-old">) | ("true" "(" ")") | ("false" "(" ")")</span></code></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version">XQuery uses annotations to declare properties associated with functions (inline or declared in the prolog) and variables. For instance, a function may be declared <code>%public</code> or <code>%private</code>. The semantics associated with these properties are described in <a href="#FunctionDeclns"><span class="delete_version"><b>5.18 Function Declarations</b></span><span class="modify_version"><b>5.18 Function Declarations</b></span></a>.</span><span style="display: none;" class="add_version">XQuery uses annotations to declare properties associated with functions (inline or declared in the prolog) and variables. For instance, a function may be declared <code>%public</code> or <code>%private</code>. The semantics associated with these properties are described in <a href="#FunctionDeclns"><span class="add_version"><b>5.18 Function Declaration</b></span><span class="modify_version"><b>5.18 Function Declaration</b></span></a>.</span><span class="modify_version">XQuery uses annotations to declare properties associated with functions (inline or declared in the prolog) and variables. For instance, a function may be declared <code>%public</code> or <code>%private</code>. The semantics associated with these properties are described in <a href="#FunctionDeclns"><span style="display: none;" class="delete_version"><b>5.18 Function Declarations</b></span><span style="display: none;" class="add_version"><b>5.18 Function Declaration</b></span><span class="modify_version"><b>5.18 Function <span class="deltaxml-old">Declarations</span><span class="deltaxml-new">Declaration</span></b></span></a>.</span></p><p>Annotations are <code>(QName, value)</code> pairs. If the EQName of the annotation is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, the prefix of the QName is resolved using the statically known namespaces; if no prefix is present, the name is in the <code>http://www.w3.org/2012/xquery</code> namespace. </p><p class="xquery"> Implementations may define further annotations, whose behaviour is implementation-defined. For instance, if the <code>eg</code> prefix is bound to a namespace associated with a particular implementation, it could define an annotation like <code>eg:sequential</code>. If the namespace URI of an annotation is not recognized by the implementation, then the annotation is ignored. Implementations may also provide a way for users to define their own annotations. Implementations must not define annotations in <a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces">reserved namespaces</a>; it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0045" title="err:XQST0045">err:XQST0045</a>] for a user to define an annotation in a <a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces">reserved namespace</a>. </p><p><span class="deltaxml-old"> An annotation can provide values explicitly using a parenthesized list of constant values. These values may take any of the following forms:</span></p><ul><li><p><span class="deltaxml-old">A string literal, for example </span><code><span class="deltaxml-old">"Paris"</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">'London'</span></code><span class="deltaxml-old">, denoting a value of type </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">A numeric literal, for example </span><code><span class="deltaxml-old">0</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">0.1</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">0x7FFF</span></code><span class="deltaxml-old">, or </span><code><span class="deltaxml-old">1e-6</span></code><span class="deltaxml-old">, denoting a value of type </span><code><span class="deltaxml-old">xs:decimal</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old">, or </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old">. The literal may be preceded by a minus sign to represent a negative number.</span></p></li><li><p><span class="deltaxml-old">One of the constructs </span><code><span class="deltaxml-old">true()</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">false()</span></code><span class="deltaxml-old">, denoting the </span><code><span class="deltaxml-old">xs:boolean</span></code><span class="deltaxml-old"> values </span><code><span class="deltaxml-old">true</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">false</span></code><span class="deltaxml-old"> respectively.</span></p></li></ul><p><span style="display: none;" class="delete_version">For example, the annotation <code>%java:method("java.lang.Math.sin")</code> sets the value of the <code>java:method</code> annotation to the string value <code>java.lang.Math.sin</code>. </span><span style="display: none;" class="add_version"> An annotation can provide values explicitly using a parenthesized list of <a title="" class="termref" href="#id-literals">literals</a>. For instance, the annotation <code>%java:method("java.lang.Math.sin")</code> sets the value of the <code>java:method</code> annotation to the string value <code>java.lang.Math.sin</code>.</span><span class="modify_version"><span class="deltaxml-new"> An annotation can provide values explicitly using a parenthesized list of </span><a title="" class="termref" href="#id-literals"><span class="deltaxml-new">literals</span></a><span class="deltaxml-new">. </span>For <span class="deltaxml-old">example</span><span class="deltaxml-new">instance</span>, the annotation <code>%java:method("java.lang.Math.sin")</code> sets the value of the <code>java:method</code> annotation to the string value <code>java.lang.Math.sin</code>.<span class="deltaxml-old"> </span></span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The constructs </span><code><span class="deltaxml-old">true()</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">false()</span></code><span class="deltaxml-old"> must be written as prescribed by the grammar. No namespace prefix is allowed; although the values resemble calls to functions in the default function namespace, they are unaffected by the namespace context.</span></p></div></div><div class="div2"><h3><a id="id-variable-declarations"></a>5.16 Variable Declaration</h3><a id="d3e32581"></a><a id="d3e29288"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e28720.doc-xquery40-AnnotatedDecl"></a><a id="noid_d4e25711.doc-xquery40-AnnotatedDecl"></a>[26]&nbsp;&nbsp;&nbsp;</td><td><code>AnnotatedDecl</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" <a href="#doc-xquery40-Annotation">Annotation</a>* (<a href="#doc-xquery40-VarDecl">VarDecl</a> | <a href="#doc-xquery40-FunctionDecl">FunctionDecl</a> | <a href="#doc-xquery40-ItemTypeDecl">ItemTypeDecl</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e28721.doc-xquery40-Annotation"></a><a id="noid_d4e25712.doc-xquery40-Annotation"></a>[27]&nbsp;&nbsp;&nbsp;</td><td><code>Annotation</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-AnnotationValue">AnnotationValue</a> ("," <a href="#doc-xquery40-AnnotationValue">AnnotationValue</a>)* ")")?</code></span><span style="display: none;" class="add_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-Literal">Literal</a> ("," <a href="#doc-xquery40-Literal">Literal</a>)* ")")?</code></span><span class="modify_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a><a href="#doc-xquery40-Literal"><span class="deltaxml-new">Literal</span></a> ("," <a href="#doc-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a><a href="#doc-xquery40-Literal"><span class="deltaxml-new">Literal</span></a>)* ")")?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-VarDecl"></a>[<span class="deltaxml-old">29</span><span class="deltaxml-new">28</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-VarDecl">VarDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"variable" "$" <a href="#doc-xquery40-VarName">VarName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? ((":=" <a href="#doc-xquery40-VarValue">VarValue</a>) | ("external" (":=" <a href="#doc-xquery40-VarDefaultValue">VarDefaultValue</a>)?))</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e28723.doc-xquery40-VarName"></a><a id="noid_d4e25714.doc-xquery40-VarName"></a>[<span class="deltaxml-old">170</span><span class="deltaxml-new">157</span>]&nbsp;&nbsp;&nbsp;</td><td><code>VarName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e28724.doc-xquery40-TypeDeclaration"></a><a id="noid_d4e25715.doc-xquery40-TypeDeclaration"></a>[<span class="deltaxml-old">224</span><span class="deltaxml-new">211</span>]&nbsp;&nbsp;&nbsp;</td><td><code>TypeDeclaration</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"as" <a href="#doc-xquery40-SequenceType">SequenceType</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-VarValue"></a>[<span class="deltaxml-old">30</span><span class="deltaxml-new">29</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-VarValue">VarValue</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-VarDefaultValue"></a>[<span class="deltaxml-old">31</span><span class="deltaxml-new">30</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-VarDefaultValue">VarDefaultValue</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody></table><p><span style="display: none;" class="delete_version"> [<a id="dt-variable-declartion" title="variable declaration">Definition</a>: A <b>variable declaration</b> in the XQuery prolog defines the name and <a title="static type" class="termref" href="#dt-static-type">static type</a> of a variable, and optionally a value for the variable. It adds to the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, and may also add to the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a> in the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a>.] </span><span style="display: none;" class="add_version">A <b>variable declaration</b> adds the <a title="static type" class="termref" href="#dt-static-type">static type</a> of a variable to the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a>, and may also add a value for the variable to the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a>. </span><span class="modify_version"><span class="deltaxml-old"> [</span><a id="dt-variable-declartion" title="variable declaration"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: </span>A <b>variable declaration</b> <span class="deltaxml-old">in the XQuery prolog defines the name and</span><span class="deltaxml-new">adds the</span> <a title="static type" class="termref" href="#dt-static-type">static type</a> of a variable<span class="deltaxml-old">, and optionally a value for the variable. It adds</span> to the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a><span class="deltaxml-old"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-old">static context</span></a>, and may also add <span class="deltaxml-new">a value for the variable </span>to the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a><span class="deltaxml-old"> in the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-old">dynamic context</span></a>.<span class="deltaxml-old">]</span> </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">The term <b>variable declaration</b> always refers to a declaration of a variable in a Prolog. The binding of a variable to a value in a query expression, such as a FLWOR expression, is known as a <b>variable binding</b>, and does not make the variable visible to an importing module.</span><span style="display: none;" class="add_version">A <b>variable declaration</b> always refers to a declaration of a variable in a Prolog. The binding of a variable to a value in a query expression, such as a FLWOR expression, is known as a <b>variable binding</b>, and does not make the variable visible to an importing module.</span><span class="modify_version"><span class="deltaxml-old">The term</span><span class="deltaxml-new">A</span> <b>variable declaration</b> always refers to a declaration of a variable in a Prolog. The binding of a variable to a value in a query expression, such as a FLWOR expression, is known as a <b>variable binding</b>, and does not make the variable visible to an importing module.</span></p></div><p>During static analysis, a variable declaration causes a pair <code>(expanded QName N, type T)</code> to be added to the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a>. The expanded QName N is the <code>VarName</code>. If N is equal (as defined by the eq operator) to the expanded QName of another variable in in-scope variables, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0049" title="err:XQST0049">err:XQST0049</a>]. The type T of the declared variable is as follows: </p><ul><li><p>If <code>TypeDeclaration</code> is present, then the <code>SequenceType</code> in the <code>TypeDeclaration</code>; otherwise</p></li><li><p>If the Static Typing Feature is in effect and <code>VarValue</code> is present, then the static type inferred from static analysis of the expression <code>VarValue</code>;</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Type inference might not be computable until after the check for circular dependencies, described below, is complete.</p></div></li><li><p> Otherwise, <code>item()*</code>.</p></li></ul><p>All variable names declared in a library module must (when expanded) be in the target namespace of the library module [<a href="#ERRXQST0048" title="err:XQST0048">err:XQST0048</a>]. A variable declaration may use annotations to specify that the variable is <code>%private</code> or <code>%public</code> (which is the default). [<a id="dt-private-variable" title="private   variable">Definition</a>: A <b>private variable</b> is a variable with a <code>%private</code> annotation. A private variable is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> of another module.] [<a id="dt-public-variable" title="public variable">Definition</a>: A <b>public variable</b> is a variable without a <code>%private</code> annotation. A public variable is accessible to <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can import it into the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> of another module. Using <code>%public</code> and <code>%private</code> annotations in a main module is not an error, but it does not affect module imports, since a main module cannot be imported. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0116" title="err:XQST0116">err:XQST0116</a>] if a variable declaration contains both a <code>%private</code> and a <code>%public</code> annotation, more than one <code>%private</code> annotation, or more than one <code>%public</code> annotation.] </p><p>Variable names that have no namespace prefix are in no namespace. Variable declarations that have no namespace prefix may appear only in a main module.</p><p>Here are some examples of variable declarations:</p><ul><li><p>The following declaration specifies both the type and the value of a variable. This declaration causes the type <code>xs:integer</code> to be associated with variable <code>$x</code> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, and the value <code>7</code> to be associated with variable <code>$x</code> in the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a>.</p><div class="exampleInner"><pre>declare variable $x as xs:integer := 7;</pre></div></li><li><p>The following declaration specifies a value but not a type. The <a title="static type" class="termref" href="#dt-static-type">static type</a> of the variable is inferred from the static type of its value. In this case, the variable <code>$x</code> has a static type of <code>xs:decimal</code>, inferred from its value which is 7.5.</p><div class="exampleInner"><pre>declare variable $x := 7.5;</pre></div></li><li><p>The following declaration specifies a type but not a value. The keyword <code>external</code> indicates that the value of the variable will be provided by the external environment. At evaluation time, if the variable <code>$x</code> in the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> does not have a value of type <code>xs:integer</code>, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised.</p><div class="exampleInner"><pre>declare variable $x as xs:integer external;</pre></div></li><li><p>The following declaration specifies neither a type nor a value. It simply declares that the query depends on the existence of a variable named <code>$x</code>, whose type and value will be provided by the external environment. During query analysis, the type of <code>$x</code> is considered to be <code>item()*</code>. During query evaluation, the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> must include a type and a value for <code>$x</code>, and its value must be compatible with its type.</p><div class="exampleInner"><pre>declare variable $x external;</pre></div></li><li><p>The following declaration, which might appear in a library module, declares a variable whose name includes a namespace prefix:</p><div class="exampleInner"><pre>declare variable $sasl:username as xs:string := "jonathan@example.com";</pre></div></li><li><p>This is an example of an external variable declaration that provides a <code>VarDefaultValue</code>:</p><div class="exampleInner"><pre>declare variable $x as xs:integer external := 47;</pre></div></li></ul><p> An implementation can provide annotations it needs. For instance, an implementation that supports volatile external variables might allow them to be declared using an annotation:</p><div class="exampleInner"><pre>declare %eg:volatile variable $time as xs:time external;</pre></div><p> [<a id="dt-initializing-expression" title="initializing expression">Definition</a>: If a variable declaration includes an expression (<code>VarValue</code> or <code>VarDefaultValue</code>), the expression is called an <b>initializing expression.</b> The static context for an initializing expression includes all functions, variables, and namespaces that are declared or imported anywhere in the Prolog, other than the variable being declared.] </p><p>If a required type is defined, then the value obtained by evaluating the initializing expression is converted to the required type by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. A type error occurs if this is not possible. In invoking the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, <a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> does not apply.</p><p><span style="display: none;" class="delete_version">In a module's dynamic context, a variable value (or the context value) may <a title="depends on" class="termref" href="#dt-depends-on">depend on</a> another variable value (or the context value). [<a id="dt-depends-on" title="depends on">Definition</a>: A variable value (or the context value) <b>depends on</b> another variable value (or the context value) if, during the evaluation of the initializing expression of the former, the latter is accessed through the module context.] </span><span style="display: none;" class="add_version">In a module's dynamic context, a variable value (or the context item) may <a title="depends on" class="termref" href="#dt-depends-on">depend on</a> another variable value (or the context item). [<a id="dt-depends-on" title="depends on">Definition</a>: A variable value (or the context item) <b>depends on</b> another variable value (or the context item) if, during the evaluation of the initializing expression of the former, the latter is accessed through the module context.] </span><span class="modify_version">In a module's dynamic context, a variable value (or the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>) may <a title="depends on" class="termref" href="#dt-depends-on">depend on</a> another variable value (or the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>). [<a id="dt-depends-on" title="depends on">Definition</a>: A variable value (or the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>) <b>depends on</b> another variable value (or the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>) if, during the evaluation of the initializing expression of the former, the latter is accessed through the module context.] </span></p><p>In the following example, the value of variable <code>$a</code><a title="depends on" class="termref" href="#dt-depends-on">depends on</a> the value of variable <code>$b</code> because the evaluation of $a's initializing expression accesses the value of $b during the evaluation of <code>local:f()</code>.</p><div class="exampleInner"><pre><span class="deltaxml-old">declare variable $a := local:f(); declare variable $b := 1; declare function local:f() { $b };</span></pre><pre><span class="deltaxml-new">declare variable $a := local:f(); declare variable $b := 1; declare function local:f() { $b }; </span></pre></div><p>A directed graph can be built with all variable values and the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> as nodes, and with the <a title="depends on" class="termref" href="#dt-depends-on">depend on</a> relation as edges. This graph must not contain cycles, as it makes the population of the dynamic context impossible. If it is discovered, during static analysis or during dynamic evaluation, that such a cycle exists, error [<a href="#ERRXQDY0054" title="err:XQDY0054">err:XQDY0054</a>] must be raised.</p><p><span style="display: none;" class="delete_version">During query evaluation, each variable declaration causes a pair <code>(expanded QName <var>N</var>, value <var>V</var>)</code> to be added to the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a>. The expanded QName <var>N</var> is the <code>VarName</code>. The value <var>V</var> is as follows:</span><span style="display: none;" class="add_version">During query evaluation, each variable declaration causes a pair <code>(expanded QName N, value V)</code> to be added to the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a>. The expanded QName N is the <code>VarName</code>. The value V is as follows:</span><span class="modify_version">During query evaluation, each variable declaration causes a pair <code>(expanded QName N, value V)</code> to be added to the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a>. The expanded QName N is the <code>VarName</code>. The value V is as follows:</span></p><ul><li><p><span style="display: none;" class="delete_version">If <code>VarValue</code> is specified, then <var>V</var> is the result of evaluating <code>VarValue</code>.</span><span style="display: none;" class="add_version">If <code>VarValue</code> is specified, then V is the result of evaluating <code>VarValue</code>.</span><span class="modify_version">If <code>VarValue</code> is specified, then V is the result of evaluating <code>VarValue</code>.</span></p></li><li><p> If <code>external</code> is specified, then:</p><ul><li><p><span style="display: none;" class="delete_version"> if a value is provided for the variable by the external environment, then <var>V</var> is that value. The means by which typed values of external variables are provided by the external environment is implementation-defined.</span><span style="display: none;" class="add_version"> if a value is provided for the variable by the external environment, then V is that value. The means by which typed values of external variables are provided by the external environment is implementation-defined.</span><span class="modify_version"> if a value is provided for the variable by the external environment, then V is that value. The means by which typed values of external variables are provided by the external environment is implementation-defined.</span></p></li><li><p><span style="display: none;" class="delete_version"> if no value is provided for the variable by the external environment, and <code>VarDefaultValue</code> is specified, then <var>V</var> is the result of evaluating <code>VarDefaultValue</code>.</span><span style="display: none;" class="add_version"> if no value is provided for the variable by the external environment, and <code>VarDefaultValue</code> is specified, then V is the result of evaluating <code>VarDefaultValue</code>.</span><span class="modify_version"> if no value is provided for the variable by the external environment, and <code>VarDefaultValue</code> is specified, then V is the result of evaluating <code>VarDefaultValue</code>.</span></p></li><li><p>If no value is provided for the variable by the external environment, and <code>VarDefaultValue</code> is not specified, then a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>]. </p><p>It is implementation-dependent whether this error is raised if the evaluation of the query does not reference the value of the variable.</p></li></ul></li></ul><p><span style="display: none;" class="delete_version">In all cases the value <var>V</var> must match the type <var>T</var> according to the rules for SequenceType matching; otherwise a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</span><span style="display: none;" class="add_version">In all cases the value V must match the type T according to the rules for SequenceType matching; otherwise a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</span><span class="modify_version">In all cases the value V must match the type T according to the rules for SequenceType matching; otherwise a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</span></p></div><div class="div2"><h3><a id="id-context-value-declarations"></a><a id="id-context-item-declarations"></a>5.17 Context <span class="deltaxml-old">Value</span><span class="deltaxml-new">Item</span> Declaration</h3><a id="d3e32980"></a><a id="d3e29659"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ContextValueDecl"></a><a id="doc-xquery40-ContextItemDecl"></a>[<span class="deltaxml-old">32</span><span class="deltaxml-new">31</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-ContextValueDecl">ContextValueDecl</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-ContextItemDecl">ContextItemDecl</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-ContextValueDecl"><span class="deltaxml-old">ContextValueDecl</span></a><a href="#prod-xquery40-ContextItemDecl"><span class="deltaxml-new">ContextItemDecl</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"declare" "context" (("value" ("as" <a href="#doc-xquery40-SequenceType">SequenceType</a>)?) | ("item" ("as" <a href="#doc-xquery40-ItemType">ItemType</a>)?)) ((":=" <a href="#doc-xquery40-VarValue">VarValue</a>) | ("external" (":=" <a href="#doc-xquery40-VarDefaultValue">VarDefaultValue</a>)?))</code></span><span style="display: none;" class="add_version"><code>"declare" "context" "item" ("as" <a href="#doc-xquery40-ItemType">ItemType</a>)? ((":=" <a href="#doc-xquery40-VarValue">VarValue</a>) | ("external" (":=" <a href="#doc-xquery40-VarDefaultValue">VarDefaultValue</a>)?))</code></span><span class="modify_version"><code>"declare" "context" <span class="deltaxml-old">(("value" ("as" </span><span class="deltaxml-new">"</span><a href="#doc-xquery40-SequenceType"><span class="deltaxml-old">SequenceType</span></a><span class="deltaxml-old">)?) | ("</span>item" ("as" <a href="#doc-xquery40-ItemType">ItemType</a>)?<span class="deltaxml-old">))</span> ((":=" <a href="#doc-xquery40-VarValue">VarValue</a>) | ("external" (":=" <a href="#doc-xquery40-VarDefaultValue">VarDefaultValue</a>)?))</code></span></td><td></td></tr></tbody></table><p>A context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> declaration allows a query to specify the <a title="static type" class="termref" href="#dt-static-type">static type</a>, value, or default value for the <a class="termref" title="initial context item" href="#dt-initial-context-item">initial context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span></a>.</p><p>Only the main module can set the <span class="deltaxml-new">value of the </span><a class="termref" title="initial context item" href="#dt-initial-context-item">initial context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span></a>. In a library module, a context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> declaration must be external, and specifies only the static type. Specifying a <a href="#doc-xquery40-VarValue">VarValue</a> or <a href="#doc-xquery40-VarDefaultValue">VarDefaultValue</a> for a context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> declaration in a library module is a static error [<a href="#ERRXQST0113" title="err:XQST0113">err:XQST0113</a>].</p><p><span class="deltaxml-old">The form </span><code><span class="deltaxml-old">declare context value</span></code><span class="deltaxml-old"> allows the </span><a title="initial context value" class="termref" href="#dt-initial-context-value"><span class="deltaxml-old">initial context value</span></a><span class="deltaxml-old"> to set to any value, with any sequence type. The alternative form </span><code><span class="deltaxml-old">declare context item</span></code><span class="deltaxml-old"> is retained for compatibility with earlier versions of XQuery, and requires the value to be a single item, and the type (if specified) to be an item type.</span></p><p>In every module that does not contain a context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> declaration, the effect is as if the declaration</p><div class="exampleInner"><pre><span class="deltaxml-old">declare context value as item()* external;</span></pre><pre><span class="deltaxml-new">declare context item as item() external;</span></pre></div><p>appeared in that module.</p><p><span style="display: none;" class="delete_version">The context value declaration has the effect of setting the context value static type <code>T</code> in the static context. When the form <code>declare context value</code> is used, the default type is <code>item()*</code>. When the alternative form <code>declare context item</code> is used, the default type is <code>item()</code>.</span><span style="display: none;" class="add_version">During static analysis, the context item declaration has the effect of setting the context item static type <code>T</code> in the static context. The context item static type is set to <code>ItemType</code> if specified, or to <code>item()</code> otherwise.</span><span class="modify_version"><span class="deltaxml-old">The context value</span><span class="deltaxml-new">During static analysis, the context item</span> declaration has the effect of setting the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> static type <code>T</code> in the static context. <span class="deltaxml-old">When the form</span><span class="deltaxml-new">The</span> <span class="deltaxml-old">declare </span>context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> <span class="deltaxml-old">is used, the default</span><span class="deltaxml-new">static</span> type is <span class="deltaxml-old">item()*</span><span class="deltaxml-new">set</span><span class="deltaxml-old">. When the alternative form</span><span class="deltaxml-new"> to</span> <code><span class="deltaxml-old">declare context item</span><span class="deltaxml-new">ItemType</span></code> <span class="deltaxml-old">is used, the default type is</span><span class="deltaxml-new">if specified, or to</span> <code>item()</code><span class="deltaxml-new"> otherwise</span>.</span></p><p>If a module contains more than one context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> declaration, a static error is raised [<a href="#ERRXQST0099" title="err:XQST0099">err:XQST0099</a>].</p><p>The static context for an initializing expression includes all functions, variables, and namespaces that are declared or imported anywhere in the Prolog.</p><p><span style="display: none;" class="delete_version">During query evaluation, a <a class="termref" title="fixed focus" href="#dt-fixed-focus">fixed focus</a> is created in the dynamic context for the evaluation of the <code>QueryBody</code> in the main module, and for the initializing expression of every variable declaration in every module. The context value of this fixed focus is called the <a class="termref" title="initial context value" href="#dt-initial-context-value">initial context value</a>, which is selected as follows: </span><span style="display: none;" class="add_version">During query evaluation, a <a class="termref" title="singleton focus" href="#dt-singleton-focus">singleton focus</a> is created in the dynamic context for the evaluation of the <code>QueryBody</code> in the main module, and for the initializing expression of every variable declaration in every module. The context item of this singleton focus is called the <a class="termref" title="initial context item" href="#dt-initial-context-item">initial context item</a>, which is selected as follows: </span><span class="modify_version">During query evaluation, a <a class="termref" title="singleton focus" href="#dt-singleton-focus"><span class="deltaxml-old">fixed</span><span class="deltaxml-new">singleton</span> focus</a> is created in the dynamic context for the evaluation of the <code>QueryBody</code> in the main module, and for the initializing expression of every variable declaration in every module. The context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> of this <span class="deltaxml-old">fixed</span><span class="deltaxml-new">singleton</span> focus is called the <a class="termref" title="initial context item" href="#dt-initial-context-item">initial context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span></a>, which is selected as follows: </span></p><ul><li><p><span style="display: none;" class="delete_version">If <code>VarValue</code> is specified, then the initial context value is the result of evaluating <code>VarValue</code>.</span><span style="display: none;" class="add_version">If <code>VarValue</code> is specified, then the initial context item is the result of evaluating <code>VarValue</code>.</span><span class="modify_version">If <code>VarValue</code> is specified, then the initial context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> is the result of evaluating <code>VarValue</code>.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p> In such a case, the initial context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> does not obtain its value from the external environment. If the external environment attempts to provide a value for the initial context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>, it is outside the scope of this specification whether that is ignored, or results in an error. </p></div></li><li><p>If <code>external</code> is specified, then:</p><ul><li><p>If the declaration occurs in a main module and a value is provided for the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> by the external environment, then the initial context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> is that value. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>If the declaration occurs in a library module, then it does not set the value of the initial context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>, the value is set by the main module.</p></div><p>The means by which an external value is provided by the external environment is implementation-defined.</p></li><li><p><span style="display: none;" class="delete_version">If no value is provided for the context value by the external environment, and <code>VarDefaultValue</code> is specified, then the initial context value is the result of evaluating <code>VarDefaultValue</code> as described below. </span><span style="display: none;" class="add_version">If no value is provided for the context item by the external environment, and <code>VarDefaultValue</code> is specified, then the initial context item is the result of evaluating <code>VarDefaultValue</code> as described below. </span><span class="modify_version">If no value is provided for the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> by the external environment, and <code>VarDefaultValue</code> is specified, then the initial context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> is the result of evaluating <code>VarDefaultValue</code> as described below. </span></p></li></ul></li></ul><p><span style="display: none;" class="delete_version">In all cases where the context value has a value, that value must match the type <code>T</code> according to the rules for SequenceType matching; otherwise a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. If more than one module contains a context value declaration, the context value must match the type declared in each one.</span><span style="display: none;" class="add_version">In all cases where the context item has a value, that value must match the type <code>T</code> according to the rules for SequenceType matching; otherwise a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. If more than one module contains a context item declaration, the context item must match the type declared in each one.</span><span class="modify_version">In all cases where the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> has a value, that value must match the type <code>T</code> according to the rules for SequenceType matching; otherwise a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. If more than one module contains a context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> declaration, the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> must match the type declared in each one.</span></p><p>If <code>VarValue</code> or <code>VarDefaultValue</code> is evaluated, the static and dynamic contexts for the evaluation are the current module's static and dynamic context.</p><p>If a required type is defined, then the value obtained by evaluating <code>VarValue</code> or <code>VarDefaultValue</code> is converted to the required type by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. A type error occurs if this is not possible. In invoking the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, <a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> does not apply.</p><p>Here are some examples of context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> declarations.</p><ul><li><p>Declare the type of the context <span class="deltaxml-old">value as a single element item with a required element name</span><span class="deltaxml-new">item</span>:</p><div class="exampleInner"><pre>declare namespace env="http://www.w3.org/2003/05/soap-envelope"; declare context item as element(env:Envelope) external;</pre></div></li><li><p>Declare a default context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>, which is a system log in a default location. If the system log is in a different location, it can be specified in the external environment:</p><div class="exampleInner"><pre><span class="deltaxml-old">declare context value as element(sys:log) external := doc("/var/xlogs/sysevent.xml")/sys:log;</span></pre><pre><span class="deltaxml-new">declare context item as element(sys:log) external := doc("/var/xlogs/sysevent.xml")/sys:log; </span></pre></div></li><li class="delete_version" style="display: none;"><p>Declare a context value, which is collection whose collection URI is supplied as an external parameter to the query. If the system log is in a different location, it can be specified in the external environment:</p><div class="exampleInner"><pre>declare variable $uri as xs:string external; declare context value as document-node()* := collection($uri);</pre></div><p>With this declaration, a query body such as <code>//person[name="Mandela"]</code> returns all matching <code>person</code> elements appearing in any document in the collection.</p></li><li class="modify_version"><p><span class="deltaxml-old">Declare a context value, which is collection whose collection URI is supplied as an external parameter to the query. If the system log is in a different location, it can be specified in the external environment:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">declare variable $uri as xs:string external; declare context value as document-node()* := collection($uri);</span></pre></div><p><span class="deltaxml-old">With this declaration, a query body such as </span><code><span class="deltaxml-old">//person[name="Mandela"]</span></code><span class="deltaxml-old"> returns all matching </span><code><span class="deltaxml-old">person</span></code><span class="deltaxml-old"> elements appearing in any document in the collection.</span></p></li></ul></div><div class="div2"><h3><a id="FunctionDeclns"></a>5.18 Function <span class="deltaxml-old">Declarations</span><span class="deltaxml-new">Declaration</span></h3><p>In addition to the <a class="termref" title="built-in function" href="#dt-built-in-function"><span class="deltaxml-old">system</span><span class="deltaxml-new">built-in</span> functions</a>, XQuery allows users to declare functions of their own. A function declaration declares a family of functions having the same name and similar parameters. The declaration specifies the name of the function, the names and datatypes of the parameters, and the datatype of the result. All datatypes are specified using the syntax described in <a href="#id-types"><b>3 Types</b></a>.</p><p>Including a function declaration in the query causes a corresponding <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> to be added to the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a> of the <a title="static context" class="termref" href="#dt-static-context">static context</a>. The associated functions also become available in the <a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions">dynamically known function definitions</a> of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a>.</p><a id="d3e33156"></a><a id="d3e29810"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e29214.doc-xquery40-AnnotatedDecl"></a><a id="noid_d4e26155.doc-xquery40-AnnotatedDecl"></a>[26]&nbsp;&nbsp;&nbsp;</td><td><code>AnnotatedDecl</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" <a href="#doc-xquery40-Annotation">Annotation</a>* (<a href="#doc-xquery40-VarDecl">VarDecl</a> | <a href="#doc-xquery40-FunctionDecl">FunctionDecl</a> | <a href="#doc-xquery40-ItemTypeDecl">ItemTypeDecl</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e29215.doc-xquery40-Annotation"></a><a id="noid_d4e26156.doc-xquery40-Annotation"></a>[27]&nbsp;&nbsp;&nbsp;</td><td><code>Annotation</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-AnnotationValue">AnnotationValue</a> ("," <a href="#doc-xquery40-AnnotationValue">AnnotationValue</a>)* ")")?</code></span><span style="display: none;" class="add_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-Literal">Literal</a> ("," <a href="#doc-xquery40-Literal">Literal</a>)* ")")?</code></span><span class="modify_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a><a href="#doc-xquery40-Literal"><span class="deltaxml-new">Literal</span></a> ("," <a href="#doc-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a><a href="#doc-xquery40-Literal"><span class="deltaxml-new">Literal</span></a>)* ")")?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionDecl"></a>[<span class="deltaxml-old">33</span><span class="deltaxml-new">32</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-FunctionDecl">FunctionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"function" <a href="#doc-xquery40-EQName">EQName</a><a href="#doc-xquery40-FunctionSignatureWithDefaults">FunctionSignatureWithDefaults</a> (<a href="#doc-xquery40-FunctionBody">FunctionBody</a> | "external")</code></td><td><i>/* <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionSignatureWithDefaults"></a>[<span class="deltaxml-old">34</span><span class="deltaxml-new">33</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-FunctionSignatureWithDefaults">FunctionSignatureWithDefaults</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" <a href="#doc-xquery40-ParamListWithDefaults">ParamListWithDefaults</a>? ")" <a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ParamListWithDefaults"></a>[<span class="deltaxml-old">36</span><span class="deltaxml-new">35</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ParamListWithDefaults">ParamListWithDefaults</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ParamWithDefault">ParamWithDefault</a> ("," <a href="#doc-xquery40-ParamWithDefault">ParamWithDefault</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ParamWithDefault"></a>[<span class="deltaxml-old">37</span><span class="deltaxml-new">36</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ParamWithDefault">ParamWithDefault</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#doc-xquery40-EQName">EQName</a><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a>? (":=" <a href="#doc-xquery40-ExprSingle">ExprSingle</a>)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionBody"></a>[<span class="deltaxml-old">40</span><span class="deltaxml-new">39</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-FunctionBody">FunctionBody</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e29221.doc-xquery40-TypeDeclaration"></a><a id="noid_d4e26162.doc-xquery40-TypeDeclaration"></a>[<span class="deltaxml-old">224</span><span class="deltaxml-new">211</span>]&nbsp;&nbsp;&nbsp;</td><td><code>TypeDeclaration</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"as" <a href="#doc-xquery40-SequenceType">SequenceType</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e29222.doc-xquery40-EnclosedExpr"></a><a id="noid_d4e26163.doc-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code>EnclosedExpr</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody></table><p> A function declaration specifies whether the implementation of the function is <a title="user-defined function" class="termref" href="#dt-udf">user-defined</a> or <a title="external function" class="termref" href="#dt-external-function">external</a>.</p><p><span class="deltaxml-old">In addition to </span><a title="user-defined function" class="termref" href="#dt-udf"><span class="deltaxml-old">user-defined functions</span></a><span class="deltaxml-old"> and </span><a class="termref" title="external function" href="#dt-external-function"><span class="deltaxml-old">external functions</span></a><span class="deltaxml-old">, XQuery 4.0 allows anonymous functions to be declared in the body of a query using </span><a title="inline function expression" href="#dt-inline-func" class="termref"><span class="deltaxml-old">inline function expressions</span></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">The following example illustrates the declaration and use of a local function that accepts a sequence of </span><code><span class="deltaxml-old">employee</span></code><span class="deltaxml-old"> elements, summarizes them by department, and returns a sequence of </span><code><span class="deltaxml-old">dept</span></code><span class="deltaxml-old"> elements.</span></p><div class="example"><div class="exampleHeader"><a id="d3e33284"></a><span class="deltaxml-old">Example: Using a function, prepare a summary of employees that are located in Denver.</span></div><div class="exampleInner"><pre><span class="deltaxml-old">declare function local:summary($emps as element(employee)*) as element(dept)* { for $d in fn:distinct-values($emps/deptno) let $e := $emps[deptno = $d] return &lt;dept&gt; &lt;deptno&gt;{$d}&lt;/deptno&gt; &lt;headcount&gt; {fn:count($e)} &lt;/headcount&gt; &lt;payroll&gt; {fn:sum($e/salary)} &lt;/payroll&gt; &lt;/dept&gt; }; local:summary(fn:doc("acme_corp.xml")//employee[location = "Denver"])</span></pre></div></div><p><span class="deltaxml-new"> [</span><a id="dt-udf" title="user-defined function"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: </span><b><span class="deltaxml-new">User defined functions</span></b><span class="deltaxml-new"> are functions that contain a </span><b><span class="deltaxml-new">function body</span></b><span class="deltaxml-new">, which provides the implementation of the function as a </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new">content expression</span></a><span class="deltaxml-new">.] The </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new">static context</span></a><span class="deltaxml-new"> for a function body includes all functions, variables, and namespaces that are declared or imported anywhere in the </span><a class="termref" title="Prolog" href="#dt-prolog"><span class="deltaxml-new">Prolog</span></a><span class="deltaxml-new">, including the function being declared. Its </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new">in-scope variables</span></a><span class="deltaxml-new"> component also includes the parameters of the function being declared. However, its </span><a title="context item static type" class="termref" href="#dt-context-item-static-type"><span class="deltaxml-new">context item static type</span></a><span class="deltaxml-new"> component is </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent"><span class="deltaxml-new">absent</span></a><sup><small><span class="deltaxml-new">DM31</span></small></sup><span class="deltaxml-new">, and an implementation should raise a static error [</span><a title="err:XPST0008" href="#ERRXPST0008"><span class="deltaxml-new">err:XPST0008</span></a><span class="deltaxml-new">] if an expression depends on the context item. </span></p><p><span class="deltaxml-new">The function declaration includes a list of zero or more function parameters. A parameter is optional if a default value is supplied using the construct </span><code><span class="deltaxml-new">:= ExprSingle</span></code><span class="deltaxml-new">; otherwise it is required. If a parameter is optional, then all subsequent parameters in the list must also be optional. In other words, the parameter list includes zero or more required parameters followed by zero or more optional parameters.</span></p><p><span class="deltaxml-new">The number of arguments that may be supplied in a call to this family of functions is this in the range </span><var><span class="deltaxml-new">M</span></var><span class="deltaxml-new"> to </span><var><span class="deltaxml-new">N</span></var><span class="deltaxml-new">, where </span><var><span class="deltaxml-new">M</span></var><span class="deltaxml-new"> is the number of required parameters, and </span><var><span class="deltaxml-new">N</span></var><span class="deltaxml-new"> is the total number of parameters (whether required or optional). This is refered to as the </span><a title="arity range" class="termref" href="#dt-arity-range"><span class="deltaxml-new">arity range</span></a><span class="deltaxml-new"> of the </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new">function definition</span></a><span class="deltaxml-new">.</span></p><p><span class="deltaxml-new">The properties of the </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new">function definition</span></a><var><span class="deltaxml-new">F</span></var><span class="deltaxml-new"> are derived from the syntax of the function declaration as follows:</span></p><ul><li><p><span class="deltaxml-new">The name of </span><var><span class="deltaxml-new">F</span></var><span class="deltaxml-new"> is the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new">expanded QName</span></a><span class="deltaxml-new"> obtained by expanding the </span><code><span class="deltaxml-new">EQName</span></code><span class="deltaxml-new"> that follows the keyword </span><code><span class="deltaxml-new">function</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">The parameters of </span><var><span class="deltaxml-new">F</span></var><span class="deltaxml-new"> are derived from the </span><code><span class="deltaxml-new">ParamWithDefault</span></code><span class="deltaxml-new"> entries in the </span><code><span class="deltaxml-new">ParamListWithDefaults</span></code><span class="deltaxml-new">:</span></p><ul><li><p><span class="deltaxml-new">The parameter name is the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new">expanded QName</span></a><span class="deltaxml-new"> obtained by expanding the </span><code><span class="deltaxml-new">EQName</span></code><span class="deltaxml-new"> that follows the </span><code><span class="deltaxml-new">$</span></code><span class="deltaxml-new"> symbol.</span></p></li><li><p><span class="deltaxml-new">The required type of the parameter is given by the </span><code><span class="deltaxml-new">TypeDeclaration</span></code><span class="deltaxml-new">, defaulting to </span><code><span class="deltaxml-new">item()*</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">The default value of the parameter is given by the expression that follows the </span><code><span class="deltaxml-new">:=</span></code><span class="deltaxml-new"> symbol; if there is no default value, then the parameter is a required parameter.</span></p></li></ul></li><li><p><span class="deltaxml-new">The return type of the function is given by the final </span><code><span class="deltaxml-new">TypeDeclaration</span></code><span class="deltaxml-new"> that follows the </span><code><span class="deltaxml-new">ParamListWithDefaults</span></code><span class="deltaxml-new"> if present, defaulting to </span><code><span class="deltaxml-new">item()*</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">The function annotations are derived from the annotations that follow the </span><code><span class="deltaxml-new">%</span></code><span class="deltaxml-new"> symbol, if present.</span></p></li><li><p><span class="deltaxml-new">The implementation of the function is given by the enclosed expression.</span></p></li></ul><p><span class="deltaxml-new">The static context may include more than one declared function with the same name, but their arity ranges must not overlap [</span><a href="#ERRXQST0034" title="err:XQST0034"><span class="deltaxml-new">err:XQST0034</span></a><span class="deltaxml-new">].</span></p><div class="note"><h4><a id="id-user-defined-functions"></a><span class="deltaxml-old">5.18.1 User-Defined Functions</span></h4><p><span class="deltaxml-old"> [</span><a id="dt-udf" title="user-defined function"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: </span><b><span class="deltaxml-old">User defined functions</span></b><span class="deltaxml-old"> are functions that contain a </span><b><span class="deltaxml-old">function body</span></b><span class="deltaxml-old">, which provides the implementation of the function as a </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-old">content expression</span></a><span class="deltaxml-old">.] The </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-old">static context</span></a><span class="deltaxml-old"> for a function body includes all functions, variables, and namespaces that are declared or imported anywhere in the </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-old">Prolog</span></a><span class="deltaxml-old">, including the function being declared. Its </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-old">in-scope variables</span></a><span class="deltaxml-old"> component also includes the parameters of the function being declared. However, its </span><a title="context value static type" class="termref" href="#dt-context-value-static-type"><span class="deltaxml-old">context value static type</span></a><span class="deltaxml-old"> component is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-old">absent</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">, and an implementation should raise a static error [</span><a href="#ERRXPST0008" title="err:XPST0008"><span class="deltaxml-old">err:XPST0008</span></a><span class="deltaxml-old">] if an expression depends on the context value. </span></p><p><span class="deltaxml-old">The properties of the </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-old">function definition</span></a><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old"> are derived from the syntax of the function declaration as follows:</span></p><ul><li><p><span class="deltaxml-old">The name of </span><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old"> is the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-old">expanded QName</span></a><span class="deltaxml-old"> obtained by expanding the </span><code><span class="deltaxml-old">EQName</span></code><span class="deltaxml-old"> that follows the keyword </span><code><span class="deltaxml-old">function</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The parameters of </span><var><span class="deltaxml-old">F</span></var><span class="deltaxml-old"> are derived from the </span><code><span class="deltaxml-old">ParamWithDefault</span></code><span class="deltaxml-old"> entries in the </span><code><span class="deltaxml-old">ParamListWithDefaults</span></code><span class="deltaxml-old">:</span></p><ul><li><p><span class="deltaxml-old">The parameter name is the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-old">expanded QName</span></a><span class="deltaxml-old"> obtained by expanding the </span><code><span class="deltaxml-old">EQName</span></code><span class="deltaxml-old"> that follows the </span><code><span class="deltaxml-old">$</span></code><span class="deltaxml-old"> symbol.</span></p></li><li><p><span class="deltaxml-old">The required type of the parameter is given by the </span><code><span class="deltaxml-old">TypeDeclaration</span></code><span class="deltaxml-old">, defaulting to </span><code><span class="deltaxml-old">item()*</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The default value of the parameter is given by the expression that follows the </span><code><span class="deltaxml-old">:=</span></code><span class="deltaxml-old"> symbol; if there is no default value, then the parameter is a required parameter.</span></p></li></ul></li><li><p><span class="deltaxml-old">The return type of the function is given by the final </span><code><span class="deltaxml-old">TypeDeclaration</span></code><span class="deltaxml-old"> that follows the </span><code><span class="deltaxml-old">ParamListWithDefaults</span></code><span class="deltaxml-old"> if present, defaulting to </span><code><span class="deltaxml-old">item()*</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The function annotations are derived from the annotations that follow the </span><code><span class="deltaxml-old">%</span></code><span class="deltaxml-old"> symbol, if present.</span></p></li><li><p><span class="deltaxml-old">The implementation of the function is given by the enclosed expression.</span></p></li></ul><p><span class="deltaxml-old">The static context may include more than one declared function with the same name, but their arity ranges must not overlap [</span><a href="#ERRXQST0034" title="err:XQST0034"><span class="deltaxml-old">err:XQST0034</span></a><span class="deltaxml-old">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">A consequence of this rule is that a function declaration must not declare a function that has arity 1 (one) if its name is the same as the name of an imported atomic type, since the name would then clash with the constructor function for that type.</span></p></div><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">A consequence of this rule is that a function declaration must not declare a function that has arity 1 (one) if its name is the same as the name of an imported atomic type, since the name would then clash with the constructor function for that type.</span></p></div><div class="div3"><h4><a id="id-function-names"></a><span class="deltaxml-old">5.18.2 Function Names</span></h4><p><span class="deltaxml-old">Every declared function must be in a namespace; that is, every declared function name must (when expanded) have a non-null namespace URI [</span><a href="#ERRXQST0060" title="err:XQST0060"><span class="deltaxml-old">err:XQST0060</span></a><span class="deltaxml-old">]. If the function name in a function declaration has no namespace prefix, it is considered to be in the </span><b><span class="deltaxml-old">default function namespace</span></b><span class="deltaxml-old">. Every function name declared in a </span><a title="library module" class="termref" href="#dt-library-module"><span class="deltaxml-old">library module</span></a><span class="deltaxml-old"> must (when expanded) be in the </span><a title="target namespace" class="termref" href="#dt-target-namespace"><span class="deltaxml-old">target namespace</span></a><span class="deltaxml-old"> of the library module [</span><a href="#ERRXQST0048" title="err:XQST0048"><span class="deltaxml-old">err:XQST0048</span></a><span class="deltaxml-old">]. </span></p><p><span class="deltaxml-old"> [</span><a id="dt-reserved-namespaces" title="reserved namespaces"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">reserved namespace</span></b><span class="deltaxml-old"> is a namespace that must not be used in the name of a function declaration.] It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-old">static error</span></a><span class="deltaxml-old"> [</span><a href="#ERRXQST0045" title="err:XQST0045"><span class="deltaxml-old">err:XQST0045</span></a><span class="deltaxml-old">] if the function name in a function declaration (when expanded) is in a </span><a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces"><span class="deltaxml-old">reserved namespace</span></a><span class="deltaxml-old">. The following namespaces are reserved namespaces: </span></p><ul><li><p><code><span class="deltaxml-old">http://www.w3.org/XML/1998/namespace</span></code></p></li><li><p><code><span class="deltaxml-old">http://www.w3.org/2001/XMLSchema</span></code></p></li><li><p><code><span class="deltaxml-old">http://www.w3.org/2001/XMLSchema-instance</span></code></p></li><li><p><code><span class="deltaxml-old">http://www.w3.org/2005/xpath-functions</span></code></p></li><li><p><code><span class="deltaxml-old">http://www.w3.org/2005/xpath-functions/array</span></code></p></li><li><p><code><span class="deltaxml-old">http://www.w3.org/2005/xpath-functions/map</span></code></p></li><li><p><code><span class="deltaxml-old">http://www.w3.org/2005/xpath-functions/math</span></code></p></li><li><p><code><span class="deltaxml-old">http://www.w3.org/2012/xquery</span></code></p></li></ul><p><span class="deltaxml-old">In order to allow main modules to declare functions for local use within the module without defining a new namespace, XQuery predefines the namespace prefix </span><code><span class="deltaxml-old">local</span></code><span class="deltaxml-old"> to the namespace </span><code><span class="deltaxml-old">http://www.w3.org/2005/xquery-local-functions</span></code><span class="deltaxml-old">. It is suggested (but not required) that this namespace be used for defining local functions.</span></p></div><div class="div3"><h4><a id="id-function-parameters"></a><span class="deltaxml-old">5.18.3 Function Parameters</span></h4><p><span class="deltaxml-old">The function declaration includes a list of zero or more function parameters.</span></p><p><span class="deltaxml-old">The parameters of a function declaration are considered to be variables whose scope is the function body. It is an </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-old">static error</span></a><span class="deltaxml-old"> [</span><a href="#ERRXQST0039" title="err:XQST0039"><span class="deltaxml-old">err:XQST0039</span></a><span class="deltaxml-old">] for a function declaration to have more than one parameter with the same name. The type of a function parameter can be any type that can be expressed as a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-old">sequence type</span></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">If a function parameter is declared using a name but no type, its default type is </span><code><span class="deltaxml-old">item()*</span></code><span class="deltaxml-old">. If the result type is omitted from a function declaration, its default result type is </span><code><span class="deltaxml-old">item()*</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">The function body defines the implementation of the </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-old">function definition</span></a><span class="deltaxml-old">. The rules for static function calls (see </span><a href="#id-eval-static-function-call"><b><span class="deltaxml-old">4.6.1.2 Evaluating Static Function Calls</span></b></a><span class="deltaxml-old">) ensure that a value is available for each parameter, whether required or optional, and that the value will always be an instance of the declared type. </span></p><p><span class="deltaxml-old">A parameter is optional if a default value is supplied using the construct </span><code><span class="deltaxml-old">:= ExprSingle</span></code><span class="deltaxml-old">; otherwise it is required. If a parameter is optional, then all subsequent parameters in the list must also be optional; otherwise, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-old">static error</span></a><span class="deltaxml-old"> is raised [</span><a href="#ERRXQST0148" title="err:XQST0148"><span class="deltaxml-old">err:XQST0148</span></a><span class="deltaxml-old">]. In other words, the parameter list includes zero or more required parameters followed by zero or more optional parameters.</span></p><p><span class="deltaxml-old">The number of arguments that may be supplied in a call to this family of functions is thus in the range </span><var><span class="deltaxml-old">M</span></var><span class="deltaxml-old"> to </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old">, where </span><var><span class="deltaxml-old">M</span></var><span class="deltaxml-old"> is the number of required parameters, and </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> is the total number of parameters (whether required or optional). This is refered to as the </span><a title="arity range" class="termref" href="#dt-arity-range"><span class="deltaxml-old">arity range</span></a><span class="deltaxml-old"> of the </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-old">function definition</span></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">The default value for an optional parameter will often be supplied using a simple literal or constant expression, for example </span><code><span class="deltaxml-old">$married as xs:boolean := false()</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">$options as map(*) := map{}</span></code><span class="deltaxml-old">. However, to allow greater flexibility, the initial value can also be context-dependent. For example, </span><code><span class="deltaxml-old">$node as node() := .</span></code><span class="deltaxml-old"> declares a parameter whose default value is the context value from the dynamic context of the caller, while </span><code><span class="deltaxml-old">$collation as xs:string := default-collation()</span></code><span class="deltaxml-old"> declares a parameter whose default value is the default collation from the dynamic context of the caller. The detailed rules are as follows. In these rules, the term </span><b><span class="deltaxml-old">caller</span></b><span class="deltaxml-old"> means the function call or function reference that invokes the function being defined.</span></p><p><span class="deltaxml-old">The </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-old">static context</span></a><span class="deltaxml-old"> for the initializing expression of an optional parameter is the same as the static context for the </span><a title="initializing expression" class="termref" href="#dt-initializing-expression"><span class="deltaxml-old">initializing expression</span></a><span class="deltaxml-old"> of a variable declaration (see </span><a href="#id-variable-declarations"><b><span class="deltaxml-old">5.16 Variable Declaration</span></b></a><span class="deltaxml-old">), with the following exceptions:</span></p><ul><li><p><span class="deltaxml-old">The </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-old">in-scope variables</span></a><span class="deltaxml-old"> component is empty. This means that the initializing expression cannot refer to any variables, other than local variables declared within the expression itself. Note in particular that it cannot refer to other parameters of the function.</span></p></li><li><p><span class="deltaxml-old">The </span><a title="context value static type" class="termref" href="#dt-context-value-static-type"><span class="deltaxml-old">context value static type</span></a><span class="deltaxml-old"> is </span><code><span class="deltaxml-old">item()*</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-old">statically known function definitions</span></a><span class="deltaxml-old"> excludes all user-defined functions.</span></p></li></ul><p><span class="deltaxml-old">The </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-old">dynamic context</span></a><span class="deltaxml-old"> for the initializing expression of an optional parameter is the same as the dynamic context of the </span><b><span class="deltaxml-old">caller</span></b><span class="deltaxml-old">, with the following exceptions:</span></p><ul><li><p><span class="deltaxml-old">The </span><a title="variable values" class="termref" href="#dt-variable-values"><span class="deltaxml-old">variable values</span></a><span class="deltaxml-old"> component is empty.</span></p></li><li><p><span class="deltaxml-old">The </span><a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions"><span class="deltaxml-old">dynamically known function definitions</span></a><span class="deltaxml-old"> excludes all user-defined functions.</span></p></li></ul></div><p><span class="deltaxml-new"> In function declarations, </span><a title="external function" class="termref" href="#dt-external-function"><span class="deltaxml-new">external functions</span></a><span class="deltaxml-new"> are identified by the keyword </span><code><span class="deltaxml-new">external</span></code><span class="deltaxml-new">. The purpose of a function declaration for an external function is to declare the datatypes of the function parameters and result, for use in type checking of the query that contains or imports the function declaration.</span></p><p><span class="deltaxml-new">In addition to </span><a title="user-defined function" class="termref" href="#dt-udf"><span class="deltaxml-new">user-defined functions</span></a><span class="deltaxml-new"> and </span><a title="external function" class="termref" href="#dt-external-function"><span class="deltaxml-new">external functions</span></a><span class="deltaxml-new">, XQuery 4.0 allows anonymous functions to be declared in the body of a query using </span><a title="inline function expression" class="termref" href="#dt-inline-func"><span class="deltaxml-new">inline function expressions</span></a><span class="deltaxml-new">.</span></p><p><span class="deltaxml-new">A function declaration may use the </span><code><span class="deltaxml-new">%private</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">%public</span></code><span class="deltaxml-new"> annotations to specify that a function is public or private; if neither of these annotations is used, the function is public. [</span><a id="dt-private-function" title="private function"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: A </span><b><span class="deltaxml-new">private function</span></b><span class="deltaxml-new"> is a function with a </span><code><span class="deltaxml-new">%private</span></code><span class="deltaxml-new"> annotation. A private function is hidden from </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new">module import</span></a><span class="deltaxml-new">, which can not import it into the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new">statically known function definitions</span></a><span class="deltaxml-new"> of another module. ] [</span><a id="dt-public-function" title="public function"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: A </span><b><span class="deltaxml-new">public function</span></b><span class="deltaxml-new"> is a function without a </span><code><span class="deltaxml-new">%private</span></code><span class="deltaxml-new"> annotation. A public function is accessible to </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new">module import</span></a><span class="deltaxml-new">, which can import it into the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new">statically known function definitions</span></a><span class="deltaxml-new"> of another module. ] Using </span><code><span class="deltaxml-new">%public</span></code><span class="deltaxml-new"> and </span><code><span class="deltaxml-new">%private</span></code><span class="deltaxml-new"> annotations in a main module is not an error, but it does not affect module imports, since a main module cannot be imported. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new">static error</span></a><span class="deltaxml-new"> [</span><a href="#ERRXQST0106" title="err:XQST0106"><span class="deltaxml-new">err:XQST0106</span></a><span class="deltaxml-new">] if a function declaration contains both a </span><code><span class="deltaxml-new">%private</span></code><span class="deltaxml-new"> and a </span><code><span class="deltaxml-new">%public</span></code><span class="deltaxml-new"> annotation, more than one </span><code><span class="deltaxml-new">%private</span></code><span class="deltaxml-new"> annotation, or more than one </span><code><span class="deltaxml-new">%public</span></code><span class="deltaxml-new"> annotation. </span></p><p><span class="deltaxml-new">An XQuery implementation may provide a facility whereby external functions can be implemented, but it is not required to do so. If such a facility is provided, the protocols by which parameters are passed to an external function, and the result of the function is returned to the invoking query, are </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new">implementation-defined</span></a><span class="deltaxml-new">. An XQuery implementation may augment the type system of </span><a href="#xpath-datamodel-31"><span class="deltaxml-new">[XQuery and XPath Data Model (XDM) 3.1]</span></a><span class="deltaxml-new"> with additional types that are designed to facilitate exchange of data, or it may provide mechanism for the user to define such types. For example, a type might be provided that encapsulates an object returned by an external function, such as an SQL database connection. These additional types, if defined, are considered to be derived by restriction from </span><code><span class="deltaxml-new">xs:anyAtomicType</span></code><span class="deltaxml-new">.</span></p><p><span class="deltaxml-new">An implementation can define annotations, in its own namespace, to support functionality beyond the scope of this specification. For instance, an implementation that supports external Java functions might use an annotation to associate a Java function with an XQuery external function:</span></p><div class="exampleInner"><h4><a id="id-function-annotations"></a><span class="deltaxml-old">5.18.4 Function Annotations</span></h4><p><span class="deltaxml-old">A function declaration may use the </span><code><span class="deltaxml-old">%private</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">%public</span></code><span class="deltaxml-old"> annotations to specify that a function is public or private; if neither of these annotations is used, the function is public. [</span><a id="dt-private-function" title="private function"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">private function</span></b><span class="deltaxml-old"> is a function with a </span><code><span class="deltaxml-old">%private</span></code><span class="deltaxml-old"> annotation. A private function is hidden from </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-old">module import</span></a><span class="deltaxml-old">, which can not import it into the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-old">statically known function definitions</span></a><span class="deltaxml-old"> of another module. ] [</span><a id="dt-public-function" title="public function"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">public function</span></b><span class="deltaxml-old"> is a function without a </span><code><span class="deltaxml-old">%private</span></code><span class="deltaxml-old"> annotation. A public function is accessible to </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-old">module import</span></a><span class="deltaxml-old">, which can import it into the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-old">statically known function definitions</span></a><span class="deltaxml-old"> of another module. ] Using </span><code><span class="deltaxml-old">%public</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">%private</span></code><span class="deltaxml-old"> annotations in a main module is not an error, but it does not affect module imports, since a main module cannot be imported. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-old">static error</span></a><span class="deltaxml-old"> [</span><a href="#ERRXQST0106" title="err:XQST0106"><span class="deltaxml-old">err:XQST0106</span></a><span class="deltaxml-old">] if a function declaration contains both a </span><code><span class="deltaxml-old">%private</span></code><span class="deltaxml-old"> and a </span><code><span class="deltaxml-old">%public</span></code><span class="deltaxml-old"> annotation, more than one </span><code><span class="deltaxml-old">%private</span></code><span class="deltaxml-old"> annotation, or more than one </span><code><span class="deltaxml-old">%public</span></code><span class="deltaxml-old"> annotation. </span></p><p><span class="deltaxml-old">An implementation can define annotations, in its own namespace, to support functionality beyond the scope of this specification. For instance, an implementation that supports external Java functions might use an annotation to associate a Java function with an XQuery external function:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">declare %java:method("java.lang.StrictMath.copySign") function smath:copySign($magnitude, $sign) external;</span></pre></div><pre><span class="deltaxml-new">declare %java:method("java.lang.StrictMath.copySign") function smath:copySign($magnitude, $sign) external;</span></pre></div><div class="div3"><h4><a id="id-external-functions"></a><span class="deltaxml-old">5.18.5 External Functions</span></h4><p><span class="deltaxml-old"> In function declarations, </span><a title="external function" class="termref" href="#dt-external-function"><span class="deltaxml-old">external functions</span></a><span class="deltaxml-old"> are identified by the keyword </span><code><span class="deltaxml-old">external</span></code><span class="deltaxml-old">. The purpose of a function declaration for an external function is to declare the datatypes of the function parameters and result, for use in type checking of the query that contains or imports the function declaration.</span></p><p><span class="deltaxml-old">An XQuery implementation may provide a facility whereby external functions can be implemented, but it is not required to do so. If such a facility is provided, the protocols by which parameters are passed to an external function, and the result of the function is returned to the invoking query, are </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-old">implementation-defined</span></a><span class="deltaxml-old">. An XQuery implementation may augment the type system of </span><a href="#xpath-datamodel-40"><span class="deltaxml-old">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-old"> with additional types that are designed to facilitate exchange of data, or it may provide mechanism for the user to define such types. For example, a type might be provided that encapsulates an object returned by an external function, such as an SQL database connection. These additional types, if defined, are considered to be derived by restriction from </span><code><span class="deltaxml-old">xs:anyAtomicType</span></code><span class="deltaxml-old">.</span></p></div><div class="div3"><h4><a id="id-recursion"></a><span class="deltaxml-old">5.18.6 Recursion</span></h4><p><span class="deltaxml-old">A function declaration may be recursive—that is, it may reference itself. Mutually recursive functions, whose bodies reference each other, are also allowed.</span></p><div class="example"><div class="exampleHeader"><a id="d3e33652"></a><span class="deltaxml-old">Example: A recursive function to compute the maximum depth of a document</span></div><p><span class="deltaxml-old">The following example declares a recursive function that computes the maximum depth of a node hierarchy, and calls the function to find the maximum depth of a particular document. The function </span><code><span class="deltaxml-old">local:depth</span></code><span class="deltaxml-old"> calls the built-in functions </span><code><span class="deltaxml-old">empty</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">max</span></code><span class="deltaxml-old">, which are in the default function namespace.</span></p><div class="exampleInner"><pre><span class="deltaxml-old">declare function local:depth($e as node()) as xs:integer { (: A node with no children has depth 1 :) (: Otherwise, add 1 to max depth of children :) if (fn:empty($e/*)) then 1 else fn:max(for $c in $e/* return local:depth($c)) + 1 }; local:depth(doc("partlist.xml"))</span></pre></div><p><span class="deltaxml-old">[TODO: add an example of a function with an optional parameter.]</span></p></div></div><p><span class="deltaxml-new">Every declared function must be in a namespace; that is, every declared function name must (when expanded) have a non-null namespace URI [</span><a href="#ERRXQST0060" title="err:XQST0060"><span class="deltaxml-new">err:XQST0060</span></a><span class="deltaxml-new">]. If the function name in a function declaration has no namespace prefix, it is considered to be in the </span><b><span class="deltaxml-new">default function namespace</span></b><span class="deltaxml-new">. Every function name declared in a </span><a title="library module" class="termref" href="#dt-library-module"><span class="deltaxml-new">library module</span></a><span class="deltaxml-new"> must (when expanded) be in the </span><a title="target namespace" class="termref" href="#dt-target-namespace"><span class="deltaxml-new">target namespace</span></a><span class="deltaxml-new"> of the library module [</span><a href="#ERRXQST0048" title="err:XQST0048"><span class="deltaxml-new">err:XQST0048</span></a><span class="deltaxml-new">]. </span></p><p><span class="deltaxml-new"> [</span><a id="dt-reserved-namespaces" title="reserved namespaces"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: A </span><b><span class="deltaxml-new">reserved namespace</span></b><span class="deltaxml-new"> is a namespace that must not be used in the name of a function declaration.] It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new">static error</span></a><span class="deltaxml-new"> [</span><a href="#ERRXQST0045" title="err:XQST0045"><span class="deltaxml-new">err:XQST0045</span></a><span class="deltaxml-new">] if the function name in a function declaration (when expanded) is in a </span><a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces"><span class="deltaxml-new">reserved namespace</span></a><span class="deltaxml-new">. The following namespaces are reserved namespaces: </span></p><ul><li><p><code><span class="deltaxml-new">http://www.w3.org/XML/1998/namespace</span></code></p></li><li><p><code><span class="deltaxml-new">http://www.w3.org/2001/XMLSchema</span></code></p></li><li><p><code><span class="deltaxml-new">http://www.w3.org/2001/XMLSchema-instance</span></code></p></li><li><p><code><span class="deltaxml-new">http://www.w3.org/2005/xpath-functions</span></code></p></li><li><p><code><span class="deltaxml-new">http://www.w3.org/2005/xpath-functions/math</span></code></p></li><li><p><code><span class="deltaxml-new">http://www.w3.org/2012/xquery</span></code></p></li><li><p><code><span class="deltaxml-new">http://www.w3.org/2005/xpath-functions/array</span></code></p></li><li><p><code><span class="deltaxml-new">http://www.w3.org/2005/xpath-functions/map</span></code></p></li></ul><p><span class="deltaxml-new">In order to allow main modules to declare functions for local use within the module without defining a new namespace, XQuery predefines the namespace prefix </span><code><span class="deltaxml-new">local</span></code><span class="deltaxml-new"> to the namespace </span><code><span class="deltaxml-new">http://www.w3.org/2005/xquery-local-functions</span></code><span class="deltaxml-new">. It is suggested (but not required) that this namespace be used for defining local functions.</span></p><p><span class="deltaxml-new">If a function parameter is declared using a name but no type, its default type is </span><code><span class="deltaxml-new">item()*</span></code><span class="deltaxml-new">. If the result type is omitted from a function declaration, its default result type is </span><code><span class="deltaxml-new">item()*</span></code><span class="deltaxml-new">.</span></p><p><span class="deltaxml-new">The function body defines the implementation of the </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new">function definition</span></a><span class="deltaxml-new">. The rules for static function calls (see </span><a href="#id-eval-static-function-call"><b><span class="deltaxml-new">4.4.1.2 Evaluating Static Function Calls</span></b></a><span class="deltaxml-new">) ensure that a value is available for each parameter, whether required or optional. </span></p><p><span class="deltaxml-new">The parameters of a function declaration are considered to be variables whose scope is the function body. It is an </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new">static error</span></a><span class="deltaxml-new"> [</span><a href="#ERRXQST0039" title="err:XQST0039"><span class="deltaxml-new">err:XQST0039</span></a><span class="deltaxml-new">] for a function declaration to have more than one parameter with the same name. The type of a function parameter can be any type that can be expressed as a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new">sequence type</span></a><span class="deltaxml-new">.</span></p><p><span class="deltaxml-new">The following example illustrates the declaration and use of a local function that accepts a sequence of </span><code><span class="deltaxml-new">employee</span></code><span class="deltaxml-new"> elements, summarizes them by department, and returns a sequence of </span><code><span class="deltaxml-new">dept</span></code><span class="deltaxml-new"> elements.</span></p><ul><li><p><span class="deltaxml-new">Using a function, prepare a summary of employees that are located in Denver.</span></p><div class="exampleInner"><pre><span class="deltaxml-new">declare function local:summary($emps as element(employee)*) as element(dept)* { for $d in fn:distinct-values($emps/deptno) let $e := $emps[deptno = $d] return &lt;dept&gt; &lt;deptno&gt;{$d}&lt;/deptno&gt; &lt;headcount&gt; {fn:count($e)} &lt;/headcount&gt; &lt;payroll&gt; {fn:sum($e/salary)} &lt;/payroll&gt; &lt;/dept&gt; }; local:summary(fn:doc("acme_corp.xml")//employee[location = "Denver"])</span></pre></div></li></ul><p><span class="deltaxml-new">A function declaration may be recursive—that is, it may reference itself. Mutually recursive functions, whose bodies reference each other, are also allowed. The following example declares a recursive function that computes the maximum depth of a node hierarchy, and calls the function to find the maximum depth of a particular document. The function </span><code><span class="deltaxml-new">local:depth</span></code><span class="deltaxml-new"> calls the built-in functions </span><code><span class="deltaxml-new">empty</span></code><span class="deltaxml-new"> and </span><code><span class="deltaxml-new">max</span></code><span class="deltaxml-new">, which are in the default function namespace.</span></p><ul><li><p><span class="deltaxml-new">Find the maximum depth of the document named </span><code><span class="deltaxml-new">partlist.xml</span></code><span class="deltaxml-new">.</span></p><div class="exampleInner"><pre><span class="deltaxml-new">declare function local:depth($e as node()) as xs:integer { (: A node with no children has depth 1 :) (: Otherwise, add 1 to max depth of children :) if (fn:empty($e/*)) then 1 else fn:max(for $c in $e/* return local:depth($c)) + 1 }; local:depth(fn:doc("partlist.xml")) </span></pre></div></li></ul><p><span class="deltaxml-new">[TODO: add an example of a function with an optional parameter.]</span></p></div><div class="div2"><h3><a id="id-item-type-declaration"></a>5.19 Item Type Declarations</h3><p><span style="display: none;" class="delete_version">An item type declaration defines a name for an item type. Defining a name for an item type allows it to be referenced <span>by name</span> rather than repeating the item type definition in full. It also allows recursive types to be defined.</span><span style="display: none;" class="add_version">An item type declaration defines a name for an item type. Defining a name for an item type allows it to be referenced (using the syntax <code>item-type(name)</code> rather than repeating the item type definition in full.</span><span class="modify_version">An item type declaration defines a name for an item type. Defining a name for an item type allows it to be referenced <span class="deltaxml-old">by</span><span class="deltaxml-new">(using the syntax</span> <code><span class="deltaxml-old">name</span><span class="deltaxml-new">item-type(name)</span></code> rather than repeating the item type definition in full.<span class="deltaxml-old"> It also allows recursive types to be defined.</span></span></p><a id="d3e33675"></a><a id="d3e30260"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e29641.doc-xquery40-AnnotatedDecl"></a><a id="noid_d4e26513.doc-xquery40-AnnotatedDecl"></a>[26]&nbsp;&nbsp;&nbsp;</td><td><code>AnnotatedDecl</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" <a href="#doc-xquery40-Annotation">Annotation</a>* (<a href="#doc-xquery40-VarDecl">VarDecl</a> | <a href="#doc-xquery40-FunctionDecl">FunctionDecl</a> | <a href="#doc-xquery40-ItemTypeDecl">ItemTypeDecl</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e29642.doc-xquery40-Annotation"></a><a id="noid_d4e26514.doc-xquery40-Annotation"></a>[27]&nbsp;&nbsp;&nbsp;</td><td><code>Annotation</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-AnnotationValue">AnnotationValue</a> ("," <a href="#doc-xquery40-AnnotationValue">AnnotationValue</a>)* ")")?</code></span><span style="display: none;" class="add_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-Literal">Literal</a> ("," <a href="#doc-xquery40-Literal">Literal</a>)* ")")?</code></span><span class="modify_version"><code>"%" <a href="#doc-xquery40-EQName">EQName</a> ("(" <a href="#doc-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a><a href="#doc-xquery40-Literal"><span class="deltaxml-new">Literal</span></a> ("," <a href="#doc-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a><a href="#doc-xquery40-Literal"><span class="deltaxml-new">Literal</span></a>)* ")")?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemTypeDecl"></a>[<span class="deltaxml-old">42</span><span class="deltaxml-new">41</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ItemTypeDecl">ItemTypeDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"item-type" <a href="#doc-xquery40-EQName">EQName</a> "as" <a href="#doc-xquery40-ItemType">ItemType</a></code></td><td></td></tr></tbody></table><p>An item-type declaration adds a named item type to the <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types"><span class="deltaxml-old">in-scope named item types</span></a><a class="termref" title="item type aliases" href="#dt-item-type-aliases"><span class="deltaxml-new">item type aliases</span></a> of the containing module. This enables the item type to be referred to using a simple name.</p><div class="example"><p>For example, given the declaration:</p><div class="exampleInner"><pre>declare item-type app:invoice as map("xs:string", element(inv:paid-invoice))</pre></div><p>It becomes possible to declare a variable containing a sequence of such items as:</p><div class="exampleInner"><pre>declare variable $invoices as app:invoice*</pre></div><p>The definition can also be used within another item-type declaration:</p><div class="exampleInner"><pre>declare item-type app:overdue-invoices as map("xs:date", app:invoice*)</pre></div></div><p>If the name of the item type <span class="deltaxml-old">being declared </span>is written as an (unprefixed) NCName, then it is interpreted as being in <span class="deltaxml-old">the</span><span class="deltaxml-new">no</span> <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-new">namespace</span>.</p><p>All item type names declared in a library module must (when expanded) be in the target namespace of the library module [<a href="#ERRXQST0048" title="err:XQST0048">err:XQST0048</a>]. </p><p><span style="display: none;" class="delete_version">An item type declaration may use the <code>%private</code> or <code>%public</code> annotations to specify that an item type name is public or private; if neither of these annotations is used, the declaration is public. [<a id="dt-private-item-type" title="private item type">Definition</a>: A <b>private item type</b> is a named item type with a <code>%private</code> annotation. A private item type is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types">in-scope named item types</a> of another module. ] [<a id="dt-public-item-type" title="public item type">Definition</a>: A <b>public item type</b> is an item type declaration without a <code>%private</code> annotation. A public item type is accessible to <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can import it into the <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types">in-scope named item types</a> of another module. ] Using <code>%public</code> and <code>%private</code> annotations in a main module is not an error, but it does not affect module imports, since a main module cannot be imported. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0106" title="err:XQST0106">err:XQST0106</a>] if an item type declaration contains both a <code>%private</code> and a <code>%public</code> annotation, more than one <code>%private</code> annotation, or more than one <code>%public</code> annotation. </span><span style="display: none;" class="add_version">An item type declaration may use the <code>%private</code> or <code>%public</code> annotations to specify that an item type name is public or private; if neither of these annotations is used, the declaration is public. [<a id="dt-private-item-type" title="private item type">Definition</a>: A <b>private item type</b> is a named item type with a <code>%private</code> annotation. A private item type is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a class="termref" title="item type aliases" href="#dt-item-type-aliases">item type aliases</a> of another module. ] [<a id="dt-public-item-type" title="public item type">Definition</a>: A <b>public item type</b> is an item type declaration without a <code>%private</code> annotation. A public item type is accessible to <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can import it into the <a class="termref" title="item type aliases" href="#dt-item-type-aliases">item type aliases</a> of another module. ] Using <code>%public</code> and <code>%private</code> annotations in a main module is not an error, but it does not affect module imports, since a main module cannot be imported. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0106" title="err:XQST0106">err:XQST0106</a>] if an item type declaration contains both a <code>%private</code> and a <code>%public</code> annotation, more than one <code>%private</code> annotation, or more than one <code>%public</code> annotation. </span><span class="modify_version">An item type declaration may use the <code>%private</code> or <code>%public</code> annotations to specify that an item type name is public or private; if neither of these annotations is used, the declaration is public. [<a id="dt-private-item-type" title="private item type">Definition</a>: A <b>private item type</b> is a named item type with a <code>%private</code> annotation. A private item type is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types"><span class="deltaxml-old">in-scope named item types</span></a><a class="termref" title="item type aliases" href="#dt-item-type-aliases"><span class="deltaxml-new">item type aliases</span></a> of another module. ] [<a id="dt-public-item-type" title="public item type">Definition</a>: A <b>public item type</b> is an item type declaration without a <code>%private</code> annotation. A public item type is accessible to <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can import it into the <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types"><span class="deltaxml-old">in-scope named item types</span></a><a class="termref" title="item type aliases" href="#dt-item-type-aliases"><span class="deltaxml-new">item type aliases</span></a> of another module. ] Using <code>%public</code> and <code>%private</code> annotations in a main module is not an error, but it does not affect module imports, since a main module cannot be imported. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0106" title="err:XQST0106">err:XQST0106</a>] if an item type declaration contains both a <code>%private</code> and a <code>%public</code> annotation, more than one <code>%private</code> annotation, or more than one <code>%public</code> annotation. </span></p><p><span class="deltaxml-old">The declaration of an item type (whether locally declared in a module or imported from a public declaration in an imported module) must precede any use of the item type name: that is, the name only becomes available in the static context of constructs that lexically follow the relevant item type declaration or module import. A consequence of this rule is that cyclic and self-referential definitions are not allowed.</span></p><p><span class="deltaxml-old">The name of an item type must be unique among the names of all declared item types and </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-old">generalized atomic types</span></a><span class="deltaxml-old"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-old">static context</span></a><span class="deltaxml-old"> of the query module. [</span><a href="#ERRXQST0146" title="err:XQST0146"><span class="deltaxml-old">err:XQST0146</span></a><span class="deltaxml-old">] </span></p><p><span class="deltaxml-old">A recursive named item type is one whose expansion refers directly or indirectly to itself. A named item type is allowed to be recursive only if it satisfies the conditions defined in </span><a href="#id-recursive-record-tests"><b><span class="deltaxml-old">3.6.4.4 Recursive Record Tests</span></b></a><span class="deltaxml-old"> [</span><a href="#ERRXQST0140" title="err:XQST0140"><span class="deltaxml-old">err:XQST0140</span></a><span class="deltaxml-old">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">It is possible to import a public variable or function into a different module even if its declaration refers to named item types that are not themselves imported (because they are declared as </span><code><span class="deltaxml-old">%private</span></code><span class="deltaxml-old">). This is because it is entirely possible to use and create instances of an item type even when the name of the item type is not known. This is true even for recursive item types. However, it is generally more convenient if any named item types used in public function and variable declarations are themselves public. This is likely to be especially true in the case of higher-order functions.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Declaring a named item type will in many cases implicitly create a constructor function, having the same name as the type, for use when creating instances of the type. For details see </span><a href="#id-constructor-functions"><b><span class="deltaxml-old">4.22.5 Constructor Functions</span></b></a><span class="deltaxml-old">.</span></p></div><p><span class="deltaxml-new">A static error must be reported if the definition of item types is cyclic: that is, if the definition of an item type depends directly or indirectly on itself. [TODO: ERROR CODE]</span></p></div><div class="div2"><h3><a id="id-option-declaration"></a>5.20 Option Declaration</h3><p> [<a id="dt-option-declaration" title="option declaration">Definition</a>: An <b>option declaration</b> declares an option that affects the behavior of a particular implementation. Each option consists of an identifying EQName and a StringLiteral.] </p><a id="d3e33823"></a><a id="d3e30379"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-OptionDecl"></a>[<span class="deltaxml-old">43</span><span class="deltaxml-new">42</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-OptionDecl">OptionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "option" <a href="#doc-xquery40-EQName">EQName</a><a href="#doc-xquery40-StringLiteral">StringLiteral</a></code></td><td></td></tr></tbody></table><p>Typically, a particular option will be recognized by some implementations and not by others. The syntax is designed so that option declarations can be successfully parsed by all implementations.</p><p>If the EQName of an option is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> with a prefix, it must resolve to a namespace URI and local name, using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>].</p><p>If the EQName of an option <span>is a <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> that</span> does not have a prefix, the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is in the <code>http://www.w3.org/2012/xquery</code> namespace, which is reserved for option declarations defined by the XQuery family of specifications. XQuery does not currently define declaration options in this namespace.</p><p>Each implementation recognizes the <code>http://www.w3.org/2012/xquery</code> namespace URI and and all options defined in this namespace in this specification. In addition, each implementation recognizes an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> set of namespace URIs and an implementation-defined set of option names defined in those namespaces. If the namespace part of an option declaration's name is not recognized, the option declaration is ignored.</p><p>Otherwise, the effect of the option declaration, including its error behavior, is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. For example, if the local part of the QName is not recognized, or if the StringLiteral does not conform to the rules defined by the implementation for the particular option declaration, the implementation may choose whether to raise an error, ignore the option declaration, or take some other action.</p><p>Implementations may impose rules on where particular option declarations may appear relative to variable declarations and function declarations, and the interpretation of an option declaration may depend on its position.</p><p>An option declaration must not be used to change the syntax accepted by the processor, or to suppress the detection of <a title="static error" class="termref" href="#dt-static-error">static errors</a>. However, it may be used without restriction to modify the semantics of the query. The scope of the option declaration is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>—for example, an option declaration might apply to the whole query, to the current module, or to the immediately following function declaration.</p><p>The following examples illustrate several possible uses for option declarations:</p><ul><li><p>This option declaration might be used to specify how comments in source documents returned by the <code>fn:doc()</code> function should be handled:</p><div class="exampleInner"><pre><span class="deltaxml-old">declare option exq:strip-comments "true";</span></pre><pre><span class="deltaxml-new">declare option exq:strip-comments "true"; </span></pre></div></li><li><p>This option declaration might be used to associate a namespace used in function names with a Java class: </p><div class="exampleInner"><pre><span class="deltaxml-old">declare namespace smath = "http://example.org/MathLibrary"; declare option exq:java-class "smath = java.lang.StrictMath";</span></pre><pre><span class="deltaxml-new">declare namespace smath = "http://example.org/MathLibrary"; declare option exq:java-class "smath = java.lang.StrictMath"; </span></pre></div></li></ul></div></div><div class="div1"><h2><a id="id-conformance"></a>6 Conformance</h2><p>This section defines the conformance criteria for an XQuery 4.0 processor. In this section, the following terms are used to indicate the requirement levels defined in <a href="#RFC2119">[RFC2119]</a>. [<a id="must" title="must">Definition</a>: <b>MUST</b> means that the item is an absolute requirement of the specification.] [<a id="mustnot" title="must not">Definition</a>: <b>MUST NOT</b> means that the item is an absolute prohibition of the specification.] [<a id="may" title="may">Definition</a>: <b>MAY</b> means that an item is truly optional.] [<a id="should" title="should">Definition</a>: <b>SHOULD</b> means that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.] </p><p class="xquery">An XQuery processor that claims to conform to this specification <a title="must" class="termref" href="#must">MUST</a> include a claim of Minimal Conformance as defined in <a href="#id-minimal-conformance"><b>6.1 Minimal Conformance</b></a>. In addition to a claim of Minimal Conformance, it <a title="may" class="termref" href="#may">MAY</a> claim conformance to one or more optional features defined in <a href="#id-conform-optional-features"><b>6.2 Optional Features</b></a>.</p><div class="div2"><h3><a id="id-minimal-conformance"></a>6.1 Minimal Conformance</h3><p>An implementation that claims <b>Minimal Conformance</b> to this specification <a title="must" class="termref" href="#must">MUST</a> provide all of the following items:</p><ol class="enumar"><li><p>An implementation of everything specified in this document except those features specified in <a href="#id-conform-optional-features"><b>6.2 Optional Features</b></a> to be optional. If an implementation does not provide a given optional feature, it <a title="must" class="termref" href="#must">MUST</a> implement any requirements specified in <a href="#id-conform-optional-features"><b>6.2 Optional Features</b></a> for implementations that do not provide that feature.</p></li><li><p>A definition of every item specified to be <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, unless that item is part of an optional feature that is not provided by the implementation. A list of <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> items can be found in <a href="#id-impl-defined-items"><b>D Implementation-Defined Items</b></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations are not required to define items specified to be <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p></div></li><li><p>An implementation of <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a>, as specified in <a href="#id-data-model-conformance"><b>6.3 Data Model Conformance</b></a>, and a definition of every item specified to be <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, unless that item is part of an optional feature that is not provided by the implementation.</p></li><li><p>An implementation of all functions defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>, and a definition of every item specified to be <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, unless that function or item is part of an optional feature that is not provided by the implementation.</p></li></ol></div><div class="div2"><h3><a id="id-conform-optional-features"></a>6.2 Optional Features</h3><p>The features discussed in this section are optional. An implementation <a title="may" class="termref" href="#may">MAY</a> claim conformance to one or more of these features.</p><p>The description of each feature mentions any errors that occur if a query relies on a feature that is not present.</p><div class="div3"><h4><a id="id-schema-aware-feature"></a>6.2.1 Schema Aware Feature</h4><p><span style="display: none;" class="delete_version"> [<a id="dt-schema-aware-feature" title="schema aware feature">Definition</a>: The <b>Schema Aware Feature</b> permits the query Prolog to contain a <a title="schema import" class="termref" href="#dt-schema-import">schema import</a>, and permits a query to contain a <code>validate</code> expression (see <a href="#id-validate"><span class="delete_version"><b>4.25 Validate Expressions</b></span><span class="modify_version"><b>4.25 Validate Expressions</b></span></a>). ] </span><span style="display: none;" class="add_version"> [<a id="dt-schema-aware-feature" title="schema aware feature">Definition</a>: The <b>Schema Aware Feature</b> permits the query Prolog to contain a <a title="schema import" class="termref" href="#dt-schema-import">schema import</a>, and permits a query to contain a <code>validate</code> expression (see <a href="#id-validate"><span class="add_version"><b>4.24 Validate Expressions</b></span><span class="modify_version"><b>4.24 Validate Expressions</b></span></a>). ] </span><span class="modify_version"> [<a id="dt-schema-aware-feature" title="schema aware feature">Definition</a>: The <b>Schema Aware Feature</b> permits the query Prolog to contain a <a title="schema import" class="termref" href="#dt-schema-import">schema import</a>, and permits a query to contain a <code>validate</code> expression (see <a href="#id-validate"><span style="display: none;" class="delete_version"><b>4.25 Validate Expressions</b></span><span style="display: none;" class="add_version"><b>4.24 Validate Expressions</b></span><span class="modify_version"><b><span class="deltaxml-old">4.25</span><span class="deltaxml-new">4.24</span> Validate Expressions</b></span></a>). ] </span></p><p>If an XQuery implementation does not provide the Schema Aware Feature, it <a title="must" class="termref" href="#must">MUST</a> raise a static error [<a href="#ERRXQST0009" title="err:XQST0009">err:XQST0009</a>] if it encounters a schema import, and it <a title="must" class="termref" href="#must">MUST</a> raise a static error [<a href="#ERRXQST0075" title="err:XQST0075">err:XQST0075</a>] if it encounters a <code>validate</code> expression.</p><p>If an implementation provides the Schema Aware Feature, it <a title="must" class="termref" href="#must">MUST</a> also provide the <a href="#id-typed-data-feature"><b>6.2.2 Typed Data Feature</b></a>.</p></div><div class="div3"><h4><a id="id-typed-data-feature"></a>6.2.2 Typed Data Feature</h4><p> [<a id="dt-typed-data-feature" title="typed data feature">Definition</a>: The <b>Typed Data Feature</b> permits an XDM instance to contain element node types other than <code>xs:untyped</code> and attributes node types other than <code>xs:untypedAtomic</code>.] </p><p>If an XQuery implementation does not provide the Typed Data Feature, it <a title="must" class="termref" href="#must">MUST</a> guarantee that:</p><ol class="enumar"><li><p>The XDM has the type <code>xs:untyped</code> for every element node and <code>xs:untypedAtomic</code> for every attribute node, including nodes created by the query.</p></li><li><p>Elements constructed by the query always have the type <code>xs:untyped</code>; attributes constructed by the query always have the type <code>xs:untypedAtomic</code>. (This is equivalent to using <code>construction mode = strip</code>.)</p></li></ol></div><div class="div3"><h4><a id="id-static-typing-feature"></a><span class="deltaxml-new">6.2.3 Static Typing Feature</span></h4><p><span class="deltaxml-new"> [</span><a id="dt-static-typing-feature" title="static     typing feature"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: The </span><b><span class="deltaxml-new">Static Typing Feature</span></b><span class="deltaxml-new"> requires implementations to report all </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new">type errors</span></a><span class="deltaxml-new"> during the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new">static analysis phase</span></a><span class="deltaxml-new">.] </span></p><p><span class="deltaxml-new">If an implementation provides the </span><a title="static     typing feature" class="termref" href="#dt-static-typing-feature"><span class="deltaxml-new">Static Typing Feature</span></a><span class="deltaxml-new">, then it </span><a title="must" class="termref" href="#must"><span class="deltaxml-new">MUST</span></a><span class="deltaxml-new"> raise an error during static analysis whenever the inferred static type of an expression is not subsumed by the required type for the context in which it appears.</span></p><p><span class="deltaxml-new">If an implementation does not provide the </span><a title="static     typing feature" class="termref" href="#dt-static-typing-feature"><span class="deltaxml-new">Static Typing Feature</span></a><span class="deltaxml-new">, then it </span><a title="must not" class="termref" href="#mustnot"><span class="deltaxml-new">MUST NOT</span></a><span class="deltaxml-new"> report type errors during the static analysis phase except in cases where the inferred static type and the required type have an empty intersection (that is, where evaluation of the expression is guaranteed to fail). It </span><a title="may" class="termref" href="#may"><span class="deltaxml-new">MAY</span></a><span class="deltaxml-new"> defer some or all type checking until the dynamic evaluation phase.</span></p></div><div class="div3"><h4><a id="id-module-feature"></a>6.2.4 Module Feature</h4><p> [<a id="dt-module-feature" title="module feature">Definition</a>: The <b>Module Feature</b> allows a query Prolog to contain a <b>Module Import</b> and allows <b>library modules</b> to be created.] </p><p>An implementation that does not provide the Module Feature <a title="must" class="termref" href="#must">MUST</a> raise a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0016" title="err:XQST0016">err:XQST0016</a>] if it encounters a <a title="module declaration" class="termref" href="#dt-module-declaration">module declaration</a> or a <a title="module import" class="termref" href="#dt-module-import">module import</a>. Since a <a title="module declaration" class="termref" href="#dt-module-declaration">module declaration</a> is required in a <a title="library module" class="termref" href="#dt-library-module">library module</a>, the Module Feature is required in order to create a <a title="library module" class="termref" href="#dt-library-module">library module</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>In the absence of the Module Feature, each query consists of a single <a title="main module" class="termref" href="#dt-main-module">main module</a>.</p></div></div><div class="div3"><h4><a id="id-serialization-feature"></a>6.2.5 Serialization Feature</h4><p> [<a id="dt-serialization-feature" title="serialization feature">Definition</a>: The <b>Serialization Feature</b> provides means for serializing the result of a query as specified in <a href="#id-serialization"><b>2.3.4 Serialization</b></a>.] A conforming XQuery implementation that provides the Serialization Feature <a title="must" class="termref" href="#must">MUST</a> conform to <a href="#id-serialization"><b>2.3.4 Serialization</b></a>. An implementation <a title="may" class="termref" href="#may">MAY</a> provide other forms of serialization, which do not conform to the Serialization Feature, and are beyond the scope of this specification. </p><p>The means by which serialization is invoked is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>If an error is raised during the serialization process as specified in <a href="#xslt-xquery-serialization-31">[XSLT and XQuery Serialization <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a>, an implementation <a title="must" class="termref" href="#must">MUST</a> report the error to the calling environment.</p><p><span style="display: none;" class="delete_version">An implementation that does not provide the Serialization Feature <a title="must" class="termref" href="#must">MUST NOT</a> raise errors when reading an <a title="output declaration" class="termref" href="#dt-output-declaration">output declaration</a>, and <a title="must" class="termref" href="#must">MUST</a> implement <code>fn:serialize</code>; it <a title="may" class="termref" href="#may">MAY</a>, however, raise an error when <code>fn:serialize</code> is invoked, as specified in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-serialize">Section 15.1.3 fn:serialize</a><sup><small>FO40</small></sup>. An implementation that does not provide the Serialization Feature <a title="may" class="termref" href="#may">MAY</a> provide results of a query using a vendor-defined serialization.</span><span style="display: none;" class="add_version">An implementation that does not provide the Serialization Feature <a title="must" class="termref" href="#must">MUST NOT</a> raise errors when reading an <a title="output declaration" class="termref" href="#dt-output-declaration">output declaration</a>, and <a title="must" class="termref" href="#must">MUST</a> implement <code>fn:serialize</code>; it <a title="may" class="termref" href="#may">MAY</a>, however, raise an error when <code>fn:serialize</code> is invoked, as specified in <a href="https://www.w3.org/TR/xpath-functions-31/#func-serialize">Section 14.7.3 fn:serialize </a><sup><small>FO31</small></sup>. An implementation that does not provide the Serialization Feature <a title="may" class="termref" href="#may">MAY</a> provide results of a query using a vendor-defined serialization.</span><span class="modify_version">An implementation that does not provide the Serialization Feature <a title="must" class="termref" href="#must">MUST NOT</a> raise errors when reading an <a title="output declaration" class="termref" href="#dt-output-declaration">output declaration</a>, and <a title="must" class="termref" href="#must">MUST</a> implement <code>fn:serialize</code>; it <a title="may" class="termref" href="#may">MAY</a>, however, raise an error when <code>fn:serialize</code> is invoked, as specified in <a href="https://www.w3.org/TR/xpath-functions-31/#func-serialize">Section <span class="deltaxml-old">15.1.3</span><span class="deltaxml-new">14.7.3</span> fn:serialize<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>. An implementation that does not provide the Serialization Feature <a title="may" class="termref" href="#may">MAY</a> provide results of a query using a vendor-defined serialization.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Some implementations return query results without serialization. For instance, an implementation might provide results via an XML API or a binary representation such as a persistent DOM.</p></div></div></div><div class="div2"><h3><a id="id-data-model-conformance"></a>6.3 Data Model Conformance</h3><p>All XQuery implementations process data represented in the <a title="data model" class="termref" href="#dt-datamodel">data model</a> as specified in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a>. The data model specification relies on languages such as XQuery to specify conformance criteria for the data model in their respective environments, and suggests that the following issues should be considered:</p><ol class="enumar"><li><p><span style="display: none;" class="delete_version"><em>Support for normative construction from an infoset.</em> An implementation <a title="may" class="termref" href="#may">MAY</a> choose to claim conformance to <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#const-infoset">Section 3.2 Construction from an Infoset</a><sup><small>DM40</small></sup>, which defines a normative way to construct an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> from an XML document that is merely well-formed or is governed by a DTD.</span><span style="display: none;" class="add_version"><em>Support for normative construction from an infoset.</em> An implementation <a title="may" class="termref" href="#may">MAY</a> choose to claim conformance to <a href="https://www.w3.org/TR/xpath-datamodel-31/#const-infoset">Section 3.2 Construction from an Infoset </a><sup><small>DM31</small></sup>, which defines a normative way to construct an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> from an XML document that is merely well-formed or is governed by a DTD.</span><span class="modify_version"><em>Support for normative construction from an infoset.</em> An implementation <a title="may" class="termref" href="#may">MAY</a> choose to claim conformance to <a href="https://www.w3.org/TR/xpath-datamodel-31/#const-infoset">Section 3.2 Construction from an Infoset<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>, which defines a normative way to construct an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> from an XML document that is merely well-formed or is governed by a DTD.</span></p></li><li><p><span style="display: none;" class="delete_version"><em>Support for normative construction from a PSVI.</em> An implementation <a title="may" class="termref" href="#may">MAY</a> choose to claim conformance to <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#const-psvi">Section 3.3 Construction from a PSVI</a><sup><small>DM40</small></sup>, which defines a normative way to construct an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> from an XML document that is governed by a W3C XML Schema.</span><span style="display: none;" class="add_version"><em>Support for normative construction from a PSVI.</em> An implementation <a title="may" class="termref" href="#may">MAY</a> choose to claim conformance to <a href="https://www.w3.org/TR/xpath-datamodel-31/#const-psvi">Section 3.3 Construction from a PSVI </a><sup><small>DM31</small></sup>, which defines a normative way to construct an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> from an XML document that is governed by a W3C XML Schema.</span><span class="modify_version"><em>Support for normative construction from a PSVI.</em> An implementation <a title="may" class="termref" href="#may">MAY</a> choose to claim conformance to <a href="https://www.w3.org/TR/xpath-datamodel-31/#const-psvi">Section 3.3 Construction from a PSVI<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>, which defines a normative way to construct an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> from an XML document that is governed by a W3C XML Schema.</span></p></li><li><p><span style="display: none;" class="delete_version"><em>Support for versions of XML and XSD.</em> As stated in <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>, the definitions of primitives such as strings, characters, and names <a title="should" class="termref" href="#should">SHOULD</a> be taken from the latest applicable version of the base specifications in which they are defined; it is implementation-defined which definitions are used in cases where these differ. </span><span style="display: none;" class="add_version"><em>Support for versions of XML and XSD.</em> As stated in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>, the definitions of primitives such as strings, characters, and names <a title="should" class="termref" href="#should">SHOULD</a> be taken from the latest applicable version of the base specifications in which they are defined; it is implementation-defined which definitions are used in cases where these differ. </span><span class="modify_version"><em>Support for versions of XML and XSD.</em> As stated in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a>, the definitions of primitives such as strings, characters, and names <a title="should" class="termref" href="#should">SHOULD</a> be taken from the latest applicable version of the base specifications in which they are defined; it is implementation-defined which definitions are used in cases where these differ. </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>For suggestions on processing XML 1.1 documents with XSD 1.0, see <a href="#xml11schema10">[XML 1.1 and Schema 1.0]</a>.</p></div></li><li><p><em>Ranges of data values.</em> In XQuery, the following limits are <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>:</p><ol class="enumla"><li><p>For the <code>xs:decimal</code> type, the maximum number of decimal digits (<code>totalDigits</code> facet) <a title="must" class="termref" href="#must">MUST</a> be at least 18. This limit <a title="should" class="termref" href="#should">SHOULD</a> be at least 20 digits in order to accommodate the full range of values of built-in subtypes of <code>xs:integer</code>, such as <code>xs:long</code> and <code>xs:unsignedLong</code>. </p></li><li><p>For the types <code>xs:date</code>, <code>xs:dateTime</code>, <code>xs:gYear</code>, and <code>xs:gYearMonth</code>: the minimum and maximum value of the year component (must be at least 1 to 9999).</p><p>For the types <code>xs:time</code> and <code>xs:dateTime</code>: the maximum number of fractional second digits (must be at least 3).</p></li><li><p>For the <code>xs:duration type</code>: the maximum absolute values of the years, months, days, hours, minutes, and seconds components.</p></li><li><p>For the <code>xs:yearMonthDuration</code> type: the maximum absolute value, expressed as an integer number of months.</p></li><li><p>For the <code>xs:dayTimeDuration</code> type: the maximum absolute value, expressed as a decimal number of seconds.</p></li><li><p>For the types <code>xs:string</code>, <code>xs:hexBinary</code>, <code>xs:base64Binary</code>, <code>xs:QName</code>, <code>xs:anyURI</code>, <code>xs:NOTATION</code>, and types derived from them: limitations (if any) imposed by the implementation on lengths of values.</p></li></ol><p>The limits listed above need not be fixed, but <a title="may" class="termref" href="#may">MAY</a> depend on environmental factors such as system resources. For example, the length of a value of type <code>xs:string</code> might be limited by available memory.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For discussion of errors due to <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> limits, see <a href="#id-kinds-of-errors"><b>2.4.1 Kinds of Errors</b></a>.</p></div></li></ol></div><div class="div2"><h3><a id="id-syntax-extensions"></a>6.4 Syntax Extensions</h3><p>Any syntactic extensions to XQuery are <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The effect of syntactic extensions, including their error behavior, is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. Syntactic extensions <a title="may" class="termref" href="#may">MAY</a> be used without restriction to modify the semantics of a XQuery expression.</p></div></div></div><div class="back"><div class="div1"><h2><a id="nt-bnf"></a>A XQuery 4.0 Grammar</h2><div class="div2"><h3><a id="id-grammar"></a>A.1 EBNF</h3><p>The grammar of XQuery 4.0 uses the same simple Extended Backus-Naur Form (EBNF) notation as <a href="#XML">[XML 1.0]</a> with the following minor differences.</p><ul><li><p>All named symbols have a name that begins with an uppercase letter.</p></li><li><p>It adds a notation for referring to productions in external specifications.</p></li><li><p>Comments or extra-grammatical constraints on grammar productions are between '/*' and '*/' symbols.</p><ul><li><p>A 'xgc:' prefix is an extra-grammatical constraint, the details of which are explained in <a href="#extra-grammatical-constraints"><b>A.1.2 Extra-grammatical Constraints</b></a></p></li><li><p>A 'ws:' prefix explains the whitespace rules for the production, the details of which are explained in <a href="#whitespace-rules"><span style="display: none;" class="delete_version"><b>A.3.5 Whitespace Rules</b></span><span style="display: none;" class="add_version"><b>A.2.4 Whitespace Rules</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">3.5</span><span class="deltaxml-new">2.4</span> Whitespace Rules</b></span></a></p></li><li><p>A 'gn:' prefix means a 'Grammar Note', and is meant as a clarification for parsing rules, and is explained in <a href="#notes-on-parsing"><b>A.1.3 Grammar Notes</b></a>. These notes are not normative.</p></li></ul></li></ul><p><span style="display: none;" class="delete_version">The terminal symbols for this grammar include the quoted strings used in the production rules below, and the terminal symbols defined in section <a href="#terminal-symbols"><span class="delete_version"><b>A.3.1 Terminal Symbols</b></span><span class="modify_version"><b>A.3.1 Terminal Symbols</b></span></a>. <span>The grammar is a little unusual in that parsing and tokenization are somewhat intertwined: for more details see <a href="#lexical-structure"><b>A.3 Lexical structure</b></a>.</span></span><span style="display: none;" class="add_version">The terminal symbols for this grammar include the quoted strings used in the production rules below, and the terminal symbols defined in section <a href="#terminal-symbols"><span class="add_version"><b>A.2.1 Terminal Symbols</b></span><span class="modify_version"><b>A.2.1 Terminal Symbols</b></span></a>.</span><span class="modify_version">The terminal symbols for this grammar include the quoted strings used in the production rules below, and the terminal symbols defined in section <a href="#terminal-symbols"><span style="display: none;" class="delete_version"><b>A.3.1 Terminal Symbols</b></span><span style="display: none;" class="add_version"><b>A.2.1 Terminal Symbols</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">3.1</span><span class="deltaxml-new">2.1</span> Terminal Symbols</b></span></a>.<span class="deltaxml-old"> </span><span class="deltaxml-old">The grammar is a little unusual in that parsing and tokenization are somewhat intertwined: for more details see </span><a href="#lexical-structure"><b><span class="deltaxml-old">A.3 Lexical structure</span></b></a><span class="deltaxml-old">.</span></span></p><p>The EBNF notation is described in more detail in <a href="#EBNFNotation"><b>A.1.1 Notation</b></a>.</p><a id="BNF-Grammar"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Module"></a>[1]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Module">Module</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-VersionDecl">VersionDecl</a>? (<a href="#prod-xquery40-LibraryModule">LibraryModule</a> | <a href="#prod-xquery40-MainModule">MainModule</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-VersionDecl"></a>[2]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-VersionDecl">VersionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"xquery" (("encoding" <a href="#prod-xquery40-StringLiteral">StringLiteral</a>) | ("version" <a href="#prod-xquery40-StringLiteral">StringLiteral</a> ("encoding" <a href="#prod-xquery40-StringLiteral">StringLiteral</a>)?)) <a href="#prod-xquery40-Separator">Separator</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-MainModule"></a>[3]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-MainModule">MainModule</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Prolog">Prolog</a><a href="#prod-xquery40-QueryBody">QueryBody</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-LibraryModule"></a>[4]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-LibraryModule">LibraryModule</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ModuleDecl">ModuleDecl</a><a href="#prod-xquery40-Prolog">Prolog</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ModuleDecl"></a>[5]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ModuleDecl">ModuleDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"module" "namespace" <a href="#prod-xquery40-NCName">NCName</a> "=" <a href="#prod-xquery40-URILiteral">URILiteral</a><a href="#prod-xquery40-Separator">Separator</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Prolog"></a>[6]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Prolog">Prolog</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>((<a href="#prod-xquery40-DefaultNamespaceDecl">DefaultNamespaceDecl</a> | <a href="#prod-xquery40-Setter">Setter</a> | <a href="#prod-xquery40-NamespaceDecl">NamespaceDecl</a> | <a href="#prod-xquery40-Import">Import</a>) <a href="#prod-xquery40-Separator">Separator</a>)* ((<a href="#prod-xquery40-ContextValueDecl">ContextValueDecl</a> | <a href="#prod-xquery40-AnnotatedDecl">AnnotatedDecl</a> | <a href="#prod-xquery40-OptionDecl">OptionDecl</a>) <a href="#prod-xquery40-Separator">Separator</a>)*</code></span><span style="display: none;" class="add_version"><code>((<a href="#prod-xquery40-DefaultNamespaceDecl">DefaultNamespaceDecl</a> | <a href="#prod-xquery40-Setter">Setter</a> | <a href="#prod-xquery40-NamespaceDecl">NamespaceDecl</a> | <a href="#prod-xquery40-Import">Import</a>) <a href="#prod-xquery40-Separator">Separator</a>)* ((<a href="#prod-xquery40-ContextItemDecl">ContextItemDecl</a> | <a href="#prod-xquery40-AnnotatedDecl">AnnotatedDecl</a> | <a href="#prod-xquery40-OptionDecl">OptionDecl</a>) <a href="#prod-xquery40-Separator">Separator</a>)*</code></span><span class="modify_version"><code>((<a href="#prod-xquery40-DefaultNamespaceDecl">DefaultNamespaceDecl</a> | <a href="#prod-xquery40-Setter">Setter</a> | <a href="#prod-xquery40-NamespaceDecl">NamespaceDecl</a> | <a href="#prod-xquery40-Import">Import</a>) <a href="#prod-xquery40-Separator">Separator</a>)* ((<a href="#prod-xquery40-ContextValueDecl"><span class="deltaxml-old">ContextValueDecl</span></a><a href="#prod-xquery40-ContextItemDecl"><span class="deltaxml-new">ContextItemDecl</span></a> | <a href="#prod-xquery40-AnnotatedDecl">AnnotatedDecl</a> | <a href="#prod-xquery40-OptionDecl">OptionDecl</a>) <a href="#prod-xquery40-Separator">Separator</a>)*</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Separator"></a>[7]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Separator">Separator</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>";"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Setter"></a>[8]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Setter">Setter</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-BoundarySpaceDecl">BoundarySpaceDecl</a> | <a href="#prod-xquery40-DefaultCollationDecl">DefaultCollationDecl</a> | <a href="#prod-xquery40-BaseURIDecl">BaseURIDecl</a> | <a href="#prod-xquery40-ConstructionDecl">ConstructionDecl</a> | <a href="#prod-xquery40-OrderingModeDecl">OrderingModeDecl</a> | <a href="#prod-xquery40-EmptyOrderDecl">EmptyOrderDecl</a> | <a href="#prod-xquery40-CopyNamespacesDecl">CopyNamespacesDecl</a> | <a href="#prod-xquery40-DecimalFormatDecl">DecimalFormatDecl</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-BoundarySpaceDecl"></a>[9]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-BoundarySpaceDecl">BoundarySpaceDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "boundary-space" ("preserve" | "strip")</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DefaultCollationDecl"></a>[10]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DefaultCollationDecl">DefaultCollationDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "default" "collation" <a href="#prod-xquery40-URILiteral">URILiteral</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-BaseURIDecl"></a>[11]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-BaseURIDecl">BaseURIDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "base-uri" <a href="#prod-xquery40-URILiteral">URILiteral</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ConstructionDecl"></a>[12]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ConstructionDecl">ConstructionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "construction" ("strip" | "preserve")</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-OrderingModeDecl"></a>[13]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-OrderingModeDecl">OrderingModeDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "ordering" ("ordered" | "unordered")</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-EmptyOrderDecl"></a>[14]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EmptyOrderDecl">EmptyOrderDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "default" "order" "empty" ("greatest" | "least")</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CopyNamespacesDecl"></a>[15]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "copy-namespaces" <a href="#prod-xquery40-PreserveMode">PreserveMode</a> "," <a href="#prod-xquery40-InheritMode">InheritMode</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-PreserveMode"></a>[16]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PreserveMode">PreserveMode</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"preserve" | "no-preserve"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-InheritMode"></a>[17]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-InheritMode">InheritMode</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"inherit" | "no-inherit"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DecimalFormatDecl"></a>[18]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DecimalFormatDecl">DecimalFormatDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" (("decimal-format" <a href="#prod-xquery40-EQName">EQName</a>) | ("default" "decimal-format")) (<a href="#prod-xquery40-DFPropertyName">DFPropertyName</a> "=" <a href="#prod-xquery40-StringLiteral">StringLiteral</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DFPropertyName"></a>[19]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DFPropertyName">DFPropertyName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"decimal-separator" | "grouping-separator" | "infinity" | "minus-sign" | "NaN" | "percent" | "per-mille" | "zero-digit" | "digit" | "pattern-separator" | "exponent-separator"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Import"></a>[20]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Import">Import</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SchemaImport">SchemaImport</a> | <a href="#prod-xquery40-ModuleImport">ModuleImport</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SchemaImport"></a>[21]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SchemaImport">SchemaImport</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"import" "schema" <a href="#prod-xquery40-SchemaPrefix">SchemaPrefix</a>? <a href="#prod-xquery40-URILiteral">URILiteral</a> ("at" <a href="#prod-xquery40-URILiteral">URILiteral</a> ("," <a href="#prod-xquery40-URILiteral">URILiteral</a>)*)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SchemaPrefix"></a>[22]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SchemaPrefix">SchemaPrefix</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>("namespace" <a href="#prod-xquery40-NCName">NCName</a> "=") | ("fixed"? "default" "element" "namespace")</code></span><span style="display: none;" class="add_version"><code>("namespace" <a href="#prod-xquery40-NCName">NCName</a> "=") | ("default" "element" "namespace")</code></span><span class="modify_version"><code>("namespace" <a href="#prod-xquery40-NCName">NCName</a> "=") | ("<span class="deltaxml-old">fixed"? "</span>default" "element" "namespace")</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ModuleImport"></a>[23]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ModuleImport">ModuleImport</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"import" "module" ("namespace" <a href="#prod-xquery40-NCName">NCName</a> "=")? <a href="#prod-xquery40-URILiteral">URILiteral</a> ("at" <a href="#prod-xquery40-URILiteral">URILiteral</a> ("," <a href="#prod-xquery40-URILiteral">URILiteral</a>)*)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-NamespaceDecl"></a>[24]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-NamespaceDecl">NamespaceDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "namespace" <a href="#prod-xquery40-NCName">NCName</a> "=" <a href="#prod-xquery40-URILiteral">URILiteral</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DefaultNamespaceDecl"></a>[25]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DefaultNamespaceDecl">DefaultNamespaceDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"declare" "fixed"? "default" ("element" | "function") "namespace" <a href="#prod-xquery40-URILiteral">URILiteral</a></code></span><span style="display: none;" class="add_version"><code>"declare" "default" ("element" | "type" | "function") "namespace" <a href="#prod-xquery40-URILiteral">URILiteral</a></code></span><span class="modify_version"><code>"declare" "<span class="deltaxml-old">fixed"? "</span>default" ("element" | "<span class="deltaxml-new">type" | "</span>function") "namespace" <a href="#prod-xquery40-URILiteral">URILiteral</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AnnotatedDecl"></a>[26]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AnnotatedDecl">AnnotatedDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" <a href="#prod-xquery40-Annotation">Annotation</a>* (<a href="#prod-xquery40-VarDecl">VarDecl</a> | <a href="#prod-xquery40-FunctionDecl">FunctionDecl</a> | <a href="#prod-xquery40-ItemTypeDecl">ItemTypeDecl</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Annotation"></a>[27]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Annotation">Annotation</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"%" <a href="#prod-xquery40-EQName">EQName</a> ("(" <a href="#prod-xquery40-AnnotationValue">AnnotationValue</a> ("," <a href="#prod-xquery40-AnnotationValue">AnnotationValue</a>)* ")")?</code></span><span style="display: none;" class="add_version"><code>"%" <a href="#prod-xquery40-EQName">EQName</a> ("(" <a href="#prod-xquery40-Literal">Literal</a> ("," <a href="#prod-xquery40-Literal">Literal</a>)* ")")?</code></span><span class="modify_version"><code>"%" <a href="#prod-xquery40-EQName">EQName</a> ("(" <a href="#prod-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a><a href="#prod-xquery40-Literal"><span class="deltaxml-new">Literal</span></a> ("," <a href="#prod-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a><a href="#prod-xquery40-Literal"><span class="deltaxml-new">Literal</span></a>)* ")")?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AnnotationValue"></a><span class="deltaxml-old">[28]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-AnnotationValue"><span class="deltaxml-old">AnnotationValue</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a><span class="deltaxml-old"> | ("-"? </span><a href="#prod-xquery40-NumericLiteral"><span class="deltaxml-old">NumericLiteral</span></a><span class="deltaxml-old">) | ("true" "(" ")") | ("false" "(" ")")</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-VarDecl"></a>[<span class="deltaxml-old">29</span><span class="deltaxml-new">28</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-VarDecl">VarDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"variable" "$" <a href="#prod-xquery40-VarName">VarName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? ((":=" <a href="#prod-xquery40-VarValue">VarValue</a>) | ("external" (":=" <a href="#prod-xquery40-VarDefaultValue">VarDefaultValue</a>)?))</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-VarValue"></a>[<span class="deltaxml-old">30</span><span class="deltaxml-new">29</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-VarValue">VarValue</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-VarDefaultValue"></a>[<span class="deltaxml-old">31</span><span class="deltaxml-new">30</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-VarDefaultValue">VarDefaultValue</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ContextValueDecl"></a><a id="prod-xquery40-ContextItemDecl"></a>[<span class="deltaxml-old">32</span><span class="deltaxml-new">31</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-ContextValueDecl">ContextValueDecl</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-ContextItemDecl">ContextItemDecl</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-ContextValueDecl"><span class="deltaxml-old">ContextValueDecl</span></a><a href="#doc-xquery40-ContextItemDecl"><span class="deltaxml-new">ContextItemDecl</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"declare" "context" (("value" ("as" <a href="#prod-xquery40-SequenceType">SequenceType</a>)?) | ("item" ("as" <a href="#prod-xquery40-ItemType">ItemType</a>)?)) ((":=" <a href="#prod-xquery40-VarValue">VarValue</a>) | ("external" (":=" <a href="#prod-xquery40-VarDefaultValue">VarDefaultValue</a>)?))</code></span><span style="display: none;" class="add_version"><code>"declare" "context" "item" ("as" <a href="#prod-xquery40-ItemType">ItemType</a>)? ((":=" <a href="#prod-xquery40-VarValue">VarValue</a>) | ("external" (":=" <a href="#prod-xquery40-VarDefaultValue">VarDefaultValue</a>)?))</code></span><span class="modify_version"><code>"declare" "context" <span class="deltaxml-old">(("value" ("as" </span><span class="deltaxml-new">"</span><a href="#prod-xquery40-SequenceType"><span class="deltaxml-old">SequenceType</span></a><span class="deltaxml-old">)?) | ("</span>item" ("as" <a href="#prod-xquery40-ItemType">ItemType</a>)?<span class="deltaxml-old">))</span> ((":=" <a href="#prod-xquery40-VarValue">VarValue</a>) | ("external" (":=" <a href="#prod-xquery40-VarDefaultValue">VarDefaultValue</a>)?))</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-FunctionDecl"></a>[<span class="deltaxml-old">33</span><span class="deltaxml-new">32</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-FunctionDecl">FunctionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"function" <a href="#prod-xquery40-EQName">EQName</a><a href="#prod-xquery40-FunctionSignatureWithDefaults">FunctionSignatureWithDefaults</a> (<a href="#prod-xquery40-FunctionBody">FunctionBody</a> | "external")</code></td><td><i>/* <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-FunctionSignatureWithDefaults"></a>[<span class="deltaxml-old">34</span><span class="deltaxml-new">33</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-FunctionSignatureWithDefaults">FunctionSignatureWithDefaults</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" <a href="#prod-xquery40-ParamListWithDefaults">ParamListWithDefaults</a>? ")" <a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-FunctionSignature"></a>[<span class="deltaxml-old">35</span><span class="deltaxml-new">34</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-FunctionSignature">FunctionSignature</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" <a href="#prod-xquery40-ParamList">ParamList</a>? ")" <a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ParamListWithDefaults"></a>[<span class="deltaxml-old">36</span><span class="deltaxml-new">35</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ParamListWithDefaults">ParamListWithDefaults</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ParamWithDefault">ParamWithDefault</a> ("," <a href="#prod-xquery40-ParamWithDefault">ParamWithDefault</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ParamWithDefault"></a>[<span class="deltaxml-old">37</span><span class="deltaxml-new">36</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ParamWithDefault">ParamWithDefault</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#prod-xquery40-EQName">EQName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? (":=" <a href="#prod-xquery40-ExprSingle">ExprSingle</a>)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ParamList"></a>[<span class="deltaxml-old">38</span><span class="deltaxml-new">37</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ParamList">ParamList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Param">Param</a> ("," <a href="#prod-xquery40-Param">Param</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Param"></a>[<span class="deltaxml-old">39</span><span class="deltaxml-new">38</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Param">Param</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#prod-xquery40-EQName">EQName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-FunctionBody"></a>[<span class="deltaxml-old">40</span><span class="deltaxml-new">39</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-FunctionBody">FunctionBody</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-EnclosedExpr"></a>[<span class="deltaxml-old">41</span><span class="deltaxml-new">40</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"{" <a href="#prod-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ItemTypeDecl"></a>[<span class="deltaxml-old">42</span><span class="deltaxml-new">41</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ItemTypeDecl">ItemTypeDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"item-type" <a href="#prod-xquery40-EQName">EQName</a> "as" <a href="#prod-xquery40-ItemType">ItemType</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-OptionDecl"></a>[<span class="deltaxml-old">43</span><span class="deltaxml-new">42</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-OptionDecl">OptionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"declare" "option" <a href="#prod-xquery40-EQName">EQName</a><a href="#prod-xquery40-StringLiteral">StringLiteral</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-QueryBody"></a>[<span class="deltaxml-old">44</span><span class="deltaxml-new">43</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-QueryBody">QueryBody</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Expr">Expr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Expr"></a>[<span class="deltaxml-old">45</span><span class="deltaxml-new">44</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Expr">Expr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a> ("," <a href="#prod-xquery40-ExprSingle">ExprSingle</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ExprSingle"></a>[<span class="deltaxml-old">46</span><span class="deltaxml-new">45</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-WithExpr">WithExpr</a><br>| <a href="#prod-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#prod-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#prod-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#prod-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#prod-xquery40-IfExpr">IfExpr</a><br>| <a href="#prod-xquery40-TryCatchExpr">TryCatchExpr</a><br>| <a href="#prod-xquery40-OrExpr">OrExpr</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-WithExpr">WithExpr</a><br>| <a href="#prod-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#prod-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#prod-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#prod-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#prod-xquery40-IfExpr">IfExpr</a><br>| <a href="#prod-xquery40-TryCatchExpr">TryCatchExpr</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-WithExpr">WithExpr</a><br>| <a href="#prod-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#prod-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#prod-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#prod-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#prod-xquery40-IfExpr">IfExpr</a><br>| <a href="#prod-xquery40-TryCatchExpr">TryCatchExpr</a><span class="deltaxml-old">| </span><a href="#prod-xquery40-OrExpr"><span class="deltaxml-old">OrExpr</span></a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-WithExpr"></a>[<span class="deltaxml-old">47</span><span class="deltaxml-new">46</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-WithExpr">WithExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"with" <a href="#prod-xquery40-NamespaceDeclaration">NamespaceDeclaration</a> ("," <a href="#prod-xquery40-NamespaceDeclaration">NamespaceDeclaration</a>)* <a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-NamespaceDeclaration"></a>[<span class="deltaxml-old">48</span><span class="deltaxml-new">47</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-NamespaceDeclaration">NamespaceDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-QName">QName</a> "=" <a href="#prod-xquery40-URILiteral">URILiteral</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-FLWORExpr"></a>[<span class="deltaxml-old">49</span><span class="deltaxml-new">48</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-FLWORExpr">FLWORExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-InitialClause">InitialClause</a><a href="#prod-xquery40-IntermediateClause">IntermediateClause</a>* <a href="#prod-xquery40-ReturnClause">ReturnClause</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-InitialClause"></a>[<span class="deltaxml-old">50</span><span class="deltaxml-new">49</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-InitialClause">InitialClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-ForClause">ForClause</a> | <a href="#prod-xquery40-LetClause">LetClause</a> | <a href="#prod-xquery40-WindowClause">WindowClause</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-ForClause">ForClause</a> | <a href="#prod-xquery40-ForMemberClause">ForMemberClause</a> | <a href="#prod-xquery40-LetClause">LetClause</a> | <a href="#prod-xquery40-WindowClause">WindowClause</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-ForClause">ForClause</a> | <a href="#prod-xquery40-ForMemberClause"><span class="deltaxml-new">ForMemberClause</span></a><span class="deltaxml-new"> | </span><a href="#prod-xquery40-LetClause">LetClause</a> | <a href="#prod-xquery40-WindowClause">WindowClause</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-IntermediateClause"></a>[<span class="deltaxml-old">51</span><span class="deltaxml-new">50</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-IntermediateClause">IntermediateClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-InitialClause">InitialClause</a> | <a href="#prod-xquery40-WhereClause">WhereClause</a> | <a href="#prod-xquery40-WhileClause">WhileClause</a> | <a href="#prod-xquery40-GroupByClause">GroupByClause</a> | <a href="#prod-xquery40-OrderByClause">OrderByClause</a> | <a href="#prod-xquery40-CountClause">CountClause</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-InitialClause">InitialClause</a> | <a href="#prod-xquery40-WhereClause">WhereClause</a> | <a href="#prod-xquery40-GroupByClause">GroupByClause</a> | <a href="#prod-xquery40-OrderByClause">OrderByClause</a> | <a href="#prod-xquery40-CountClause">CountClause</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-InitialClause">InitialClause</a> | <a href="#prod-xquery40-WhereClause">WhereClause</a> | <a href="#prod-xquery40-WhileClause"><span class="deltaxml-old">WhileClause</span></a><span class="deltaxml-old"> | </span><a href="#prod-xquery40-GroupByClause">GroupByClause</a> | <a href="#prod-xquery40-OrderByClause">OrderByClause</a> | <a href="#prod-xquery40-CountClause">CountClause</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ForClause"></a>[<span class="deltaxml-old">52</span><span class="deltaxml-new">51</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ForClause">ForClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"for" <a href="#prod-xquery40-ForBinding">ForBinding</a> ("," <a href="#prod-xquery40-ForBinding">ForBinding</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ForBinding"></a><span class="deltaxml-old">[53]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-ForBinding"><span class="deltaxml-old">ForBinding</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-ForItemBinding"><span class="deltaxml-old">ForItemBinding</span></a><span class="deltaxml-old"> | </span><a href="#prod-xquery40-ForMemberBinding"><span class="deltaxml-old">ForMemberBinding</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ForItemBinding"></a><a id="prod-xquery40-ForBinding"></a>[<span class="deltaxml-old">54</span><span class="deltaxml-new">52</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-ForItemBinding">ForItemBinding</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-ForBinding">ForBinding</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-ForItemBinding"><span class="deltaxml-old">ForItemBinding</span></a><a href="#doc-xquery40-ForBinding"><span class="deltaxml-new">ForBinding</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#prod-xquery40-VarName">VarName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? <a href="#prod-xquery40-AllowingEmpty">AllowingEmpty</a>? <a href="#prod-xquery40-PositionalVar">PositionalVar</a>? "in" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ForMemberBinding"></a><a id="prod-xquery40-AllowingEmpty"></a>[<span class="deltaxml-old">55</span><span class="deltaxml-new">53</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-ForMemberBinding">ForMemberBinding</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-AllowingEmpty">AllowingEmpty</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-ForMemberBinding"><span class="deltaxml-old">ForMemberBinding</span></a><a href="#doc-xquery40-AllowingEmpty"><span class="deltaxml-new">AllowingEmpty</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"member" "$" <a href="#prod-xquery40-VarName">VarName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? <a href="#prod-xquery40-PositionalVar">PositionalVar</a>? "in" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></span><span style="display: none;" class="add_version"><code>"allowing" "empty"</code></span><span class="modify_version"><code>"<span class="deltaxml-old">member</span><span class="deltaxml-new">allowing</span>" "<span class="deltaxml-old">$</span><span class="deltaxml-new">empty</span>"<span class="deltaxml-old"> </span><a href="#prod-xquery40-VarName"><span class="deltaxml-old">VarName</span></a><a href="#prod-xquery40-TypeDeclaration"><span class="deltaxml-old">TypeDeclaration</span></a><span class="deltaxml-old">? </span><a href="#prod-xquery40-PositionalVar"><span class="deltaxml-old">PositionalVar</span></a><span class="deltaxml-old">? "in" </span><a href="#prod-xquery40-ExprSingle"><span class="deltaxml-old">ExprSingle</span></a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ForMemberClause"></a><span class="deltaxml-new">[54]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-ForMemberClause"><span class="deltaxml-new">ForMemberClause</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">"for" "member" </span><a href="#prod-xquery40-ForMemberBinding"><span class="deltaxml-new">ForMemberBinding</span></a><span class="deltaxml-new"> ("," </span><a href="#prod-xquery40-ForMemberBinding"><span class="deltaxml-new">ForMemberBinding</span></a><span class="deltaxml-new">)*</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AllowingEmpty"></a><a id="prod-xquery40-ForMemberBinding"></a>[<span class="deltaxml-old">56</span><span class="deltaxml-new">55</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-AllowingEmpty">AllowingEmpty</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-ForMemberBinding">ForMemberBinding</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-AllowingEmpty"><span class="deltaxml-old">AllowingEmpty</span></a><a href="#doc-xquery40-ForMemberBinding"><span class="deltaxml-new">ForMemberBinding</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"allowing" "empty"</code></span><span style="display: none;" class="add_version"><code>"$" <a href="#prod-xquery40-VarName">VarName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? <a href="#prod-xquery40-PositionalVar">PositionalVar</a>? "in" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></span><span class="modify_version"><code>"<span class="deltaxml-old">allowing</span><span class="deltaxml-new">$</span>" <a href="#prod-xquery40-VarName"><span class="deltaxml-new">VarName</span></a><a href="#prod-xquery40-TypeDeclaration"><span class="deltaxml-new">TypeDeclaration</span></a><span class="deltaxml-new">? </span><a href="#prod-xquery40-PositionalVar"><span class="deltaxml-new">PositionalVar</span></a><span class="deltaxml-new">? </span>"<span class="deltaxml-old">empty</span><span class="deltaxml-new">in</span>"<span class="deltaxml-new"> </span><a href="#prod-xquery40-ExprSingle"><span class="deltaxml-new">ExprSingle</span></a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-PositionalVar"></a>[<span class="deltaxml-old">57</span><span class="deltaxml-new">56</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PositionalVar">PositionalVar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"at" "$" <a href="#prod-xquery40-VarName">VarName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-LetClause"></a>[<span class="deltaxml-old">58</span><span class="deltaxml-new">57</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-LetClause">LetClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"let" <a href="#prod-xquery40-LetBinding">LetBinding</a> ("," <a href="#prod-xquery40-LetBinding">LetBinding</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-LetBinding"></a>[<span class="deltaxml-old">59</span><span class="deltaxml-new">58</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-LetBinding">LetBinding</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#prod-xquery40-VarName">VarName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? ":=" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-WindowClause"></a>[<span class="deltaxml-old">60</span><span class="deltaxml-new">59</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-WindowClause">WindowClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"for" (<a href="#prod-xquery40-TumblingWindowClause">TumblingWindowClause</a> | <a href="#prod-xquery40-SlidingWindowClause">SlidingWindowClause</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-TumblingWindowClause"></a>[<span class="deltaxml-old">61</span><span class="deltaxml-new">60</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-TumblingWindowClause">TumblingWindowClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"tumbling" "window" "$" <a href="#prod-xquery40-VarName">VarName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#prod-xquery40-ExprSingle">ExprSingle</a><a href="#prod-xquery40-WindowStartCondition">WindowStartCondition</a>? <a href="#prod-xquery40-WindowEndCondition">WindowEndCondition</a>?</code></span><span style="display: none;" class="add_version"><code>"tumbling" "window" "$" <a href="#prod-xquery40-VarName">VarName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#prod-xquery40-ExprSingle">ExprSingle</a><a href="#prod-xquery40-WindowStartCondition">WindowStartCondition</a><a href="#prod-xquery40-WindowEndCondition">WindowEndCondition</a>?</code></span><span class="modify_version"><code>"tumbling" "window" "$" <a href="#prod-xquery40-VarName">VarName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#prod-xquery40-ExprSingle">ExprSingle</a><a href="#prod-xquery40-WindowStartCondition">WindowStartCondition</a><span class="deltaxml-old">? </span><a href="#prod-xquery40-WindowEndCondition">WindowEndCondition</a>?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SlidingWindowClause"></a>[<span class="deltaxml-old">62</span><span class="deltaxml-new">61</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SlidingWindowClause">SlidingWindowClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"sliding" "window" "$" <a href="#prod-xquery40-VarName">VarName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#prod-xquery40-ExprSingle">ExprSingle</a><a href="#prod-xquery40-WindowStartCondition">WindowStartCondition</a>? <a href="#prod-xquery40-WindowEndCondition">WindowEndCondition</a></code></span><span style="display: none;" class="add_version"><code>"sliding" "window" "$" <a href="#prod-xquery40-VarName">VarName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#prod-xquery40-ExprSingle">ExprSingle</a><a href="#prod-xquery40-WindowStartCondition">WindowStartCondition</a><a href="#prod-xquery40-WindowEndCondition">WindowEndCondition</a></code></span><span class="modify_version"><code>"sliding" "window" "$" <a href="#prod-xquery40-VarName">VarName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#prod-xquery40-ExprSingle">ExprSingle</a><a href="#prod-xquery40-WindowStartCondition">WindowStartCondition</a><span class="deltaxml-old">? </span><a href="#prod-xquery40-WindowEndCondition">WindowEndCondition</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-WindowStartCondition"></a>[<span class="deltaxml-old">63</span><span class="deltaxml-new">62</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-WindowStartCondition">WindowStartCondition</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"start" <a href="#prod-xquery40-WindowVars">WindowVars</a> ("when" <a href="#prod-xquery40-ExprSingle">ExprSingle</a>)?</code></span><span style="display: none;" class="add_version"><code>"start" <a href="#prod-xquery40-WindowVars">WindowVars</a> "when" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></span><span class="modify_version"><code>"start" <a href="#prod-xquery40-WindowVars">WindowVars</a> <span class="deltaxml-old">(</span>"when" <a href="#prod-xquery40-ExprSingle">ExprSingle</a><span class="deltaxml-old">)?</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-WindowEndCondition"></a>[<span class="deltaxml-old">64</span><span class="deltaxml-new">63</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-WindowEndCondition">WindowEndCondition</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"only"? "end" <a href="#prod-xquery40-WindowVars">WindowVars</a> ("when" <a href="#prod-xquery40-ExprSingle">ExprSingle</a>)?</code></span><span style="display: none;" class="add_version"><code>"only"? "end" <a href="#prod-xquery40-WindowVars">WindowVars</a> "when" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></span><span class="modify_version"><code>"only"? "end" <a href="#prod-xquery40-WindowVars">WindowVars</a> <span class="deltaxml-old">(</span>"when" <a href="#prod-xquery40-ExprSingle">ExprSingle</a><span class="deltaxml-old">)?</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-WindowVars"></a>[<span class="deltaxml-old">65</span><span class="deltaxml-new">64</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-WindowVars">WindowVars</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("$" <a href="#prod-xquery40-CurrentItem">CurrentItem</a>)? <a href="#prod-xquery40-PositionalVar">PositionalVar</a>? ("previous" "$" <a href="#prod-xquery40-PreviousItem">PreviousItem</a>)? ("next" "$" <a href="#prod-xquery40-NextItem">NextItem</a>)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CurrentItem"></a>[<span class="deltaxml-old">66</span><span class="deltaxml-new">65</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CurrentItem">CurrentItem</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-PreviousItem"></a>[<span class="deltaxml-old">67</span><span class="deltaxml-new">66</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PreviousItem">PreviousItem</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-NextItem"></a>[<span class="deltaxml-old">68</span><span class="deltaxml-new">67</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-NextItem">NextItem</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CountClause"></a>[<span class="deltaxml-old">69</span><span class="deltaxml-new">68</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CountClause">CountClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"count" "$" <a href="#prod-xquery40-VarName">VarName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-WhereClause"></a>[<span class="deltaxml-old">70</span><span class="deltaxml-new">69</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-WhereClause">WhereClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"where" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-WhileClause"></a><span class="deltaxml-old">[71]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-WhileClause"><span class="deltaxml-old">WhileClause</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"while" </span><a href="#prod-xquery40-ExprSingle"><span class="deltaxml-old">ExprSingle</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-GroupByClause"></a>[<span class="deltaxml-old">72</span><span class="deltaxml-new">70</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-GroupByClause">GroupByClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"group" "by" <a href="#prod-xquery40-GroupingSpecList">GroupingSpecList</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-GroupingSpecList"></a>[<span class="deltaxml-old">73</span><span class="deltaxml-new">71</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-GroupingSpecList">GroupingSpecList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-GroupingSpec">GroupingSpec</a> ("," <a href="#prod-xquery40-GroupingSpec">GroupingSpec</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-GroupingSpec"></a>[<span class="deltaxml-old">74</span><span class="deltaxml-new">72</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-GroupingSpec">GroupingSpec</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-GroupingVariable">GroupingVariable</a> (<a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? ":=" <a href="#prod-xquery40-ExprSingle">ExprSingle</a>)? ("collation" <a href="#prod-xquery40-URILiteral">URILiteral</a>)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-GroupingVariable"></a>[<span class="deltaxml-old">75</span><span class="deltaxml-new">73</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-GroupingVariable">GroupingVariable</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#prod-xquery40-VarName">VarName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-OrderByClause"></a>[<span class="deltaxml-old">76</span><span class="deltaxml-new">74</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-OrderByClause">OrderByClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(("order" "by") | ("stable" "order" "by")) <a href="#prod-xquery40-OrderSpecList">OrderSpecList</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-OrderSpecList"></a>[<span class="deltaxml-old">77</span><span class="deltaxml-new">75</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-OrderSpecList">OrderSpecList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-OrderSpec">OrderSpec</a> ("," <a href="#prod-xquery40-OrderSpec">OrderSpec</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-OrderSpec"></a>[<span class="deltaxml-old">78</span><span class="deltaxml-new">76</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-OrderSpec">OrderSpec</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a><a href="#prod-xquery40-OrderModifier">OrderModifier</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-OrderModifier"></a>[<span class="deltaxml-old">79</span><span class="deltaxml-new">77</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-OrderModifier">OrderModifier</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("ascending" | "descending")? ("empty" ("greatest" | "least"))? ("collation" <a href="#prod-xquery40-URILiteral">URILiteral</a>)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ReturnClause"></a>[<span class="deltaxml-old">80</span><span class="deltaxml-new">78</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ReturnClause">ReturnClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"return" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-QuantifiedExpr"></a>[<span class="deltaxml-old">81</span><span class="deltaxml-new">79</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("some" | "every") <a href="#prod-xquery40-QuantifierBinding">QuantifierBinding</a> ("," <a href="#prod-xquery40-QuantifierBinding">QuantifierBinding</a>)* "satisfies" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-QuantifierBinding"></a>[<span class="deltaxml-old">82</span><span class="deltaxml-new">80</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-QuantifierBinding">QuantifierBinding</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#prod-xquery40-VarName">VarName</a><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a>? "in" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SwitchExpr"></a>[<span class="deltaxml-old">83</span><span class="deltaxml-new">81</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SwitchExpr">SwitchExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"switch" <a href="#prod-xquery40-SwitchComparand">SwitchComparand</a>? (<a href="#prod-xquery40-SwitchCases">SwitchCases</a> | <a href="#prod-xquery40-BracedSwitchCases">BracedSwitchCases</a>)</code></span><span style="display: none;" class="add_version"><code>"switch" "(" <a href="#prod-xquery40-Expr">Expr</a> ")" <a href="#prod-xquery40-SwitchCaseClause">SwitchCaseClause</a>+ "default" "return" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></span><span class="modify_version"><code>"switch" <a href="#prod-xquery40-SwitchComparand"><span class="deltaxml-old">SwitchComparand</span></a><span class="deltaxml-old">? (</span><span class="deltaxml-new">"(" </span><a href="#prod-xquery40-SwitchCases"><span class="deltaxml-old">SwitchCases</span></a><a href="#prod-xquery40-Expr"><span class="deltaxml-new">Expr</span></a> <span class="deltaxml-old">|</span><span class="deltaxml-new">")"</span> <a href="#prod-xquery40-BracedSwitchCases"><span class="deltaxml-old">BracedSwitchCases</span></a><a href="#prod-xquery40-SwitchCaseClause"><span class="deltaxml-new">SwitchCaseClause</span></a><span class="deltaxml-old">)</span><span class="deltaxml-new">+ "default" "return" </span><a href="#prod-xquery40-ExprSingle"><span class="deltaxml-new">ExprSingle</span></a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SwitchComparand"></a><span class="deltaxml-old">[84]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-SwitchComparand"><span class="deltaxml-old">SwitchComparand</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"(" </span><a href="#prod-xquery40-Expr"><span class="deltaxml-old">Expr</span></a><span class="deltaxml-old"> ")"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SwitchCases"></a><span class="deltaxml-old">[85]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-SwitchCases"><span class="deltaxml-old">SwitchCases</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-SwitchCaseClause"><span class="deltaxml-old">SwitchCaseClause</span></a><span class="deltaxml-old">+ "default" "return" </span><a href="#prod-xquery40-ExprSingle"><span class="deltaxml-old">ExprSingle</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-BracedSwitchCases"></a><span class="deltaxml-old">[86]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-BracedSwitchCases"><span class="deltaxml-old">BracedSwitchCases</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"{" </span><a href="#prod-xquery40-SwitchCases"><span class="deltaxml-old">SwitchCases</span></a><span class="deltaxml-old"> "}"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SwitchCaseClause"></a>[<span class="deltaxml-old">87</span><span class="deltaxml-new">82</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SwitchCaseClause">SwitchCaseClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("case" <a href="#prod-xquery40-SwitchCaseOperand">SwitchCaseOperand</a>)+ "return" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SwitchCaseOperand"></a>[<span class="deltaxml-old">88</span><span class="deltaxml-new">83</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SwitchCaseOperand">SwitchCaseOperand</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Expr">Expr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-TypeswitchExpr"></a>[<span class="deltaxml-old">89</span><span class="deltaxml-new">84</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"typeswitch" "(" <a href="#prod-xquery40-Expr">Expr</a> ")" (<a href="#prod-xquery40-TypeswitchCases">TypeswitchCases</a> | <a href="#prod-xquery40-BracedTypeswitchCases">BracedTypeswitchCases</a>)</code></span><span style="display: none;" class="add_version"><code>"typeswitch" "(" <a href="#prod-xquery40-Expr">Expr</a> ")" <a href="#prod-xquery40-CaseClause">CaseClause</a>+ "default" ("$" <a href="#prod-xquery40-VarName">VarName</a>)? "return" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></span><span class="modify_version"><code>"typeswitch" "(" <a href="#prod-xquery40-Expr">Expr</a> ")" <span class="deltaxml-old">(</span><a href="#prod-xquery40-TypeswitchCases"><span class="deltaxml-old">TypeswitchCases</span></a><a href="#prod-xquery40-CaseClause"><span class="deltaxml-new">CaseClause</span></a><span class="deltaxml-old"> |</span><span class="deltaxml-new">+ "default" ("$"</span> <a href="#prod-xquery40-BracedTypeswitchCases"><span class="deltaxml-old">BracedTypeswitchCases</span></a><a href="#prod-xquery40-VarName"><span class="deltaxml-new">VarName</span></a>)<span class="deltaxml-new">? "return" </span><a href="#prod-xquery40-ExprSingle"><span class="deltaxml-new">ExprSingle</span></a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-TypeswitchCases"></a><span class="deltaxml-old">[90]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-TypeswitchCases"><span class="deltaxml-old">TypeswitchCases</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-CaseClause"><span class="deltaxml-old">CaseClause</span></a><span class="deltaxml-old">+ "default" ("$" </span><a href="#prod-xquery40-VarName"><span class="deltaxml-old">VarName</span></a><span class="deltaxml-old">)? "return" </span><a href="#prod-xquery40-ExprSingle"><span class="deltaxml-old">ExprSingle</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-BracedTypeswitchCases"></a><span class="deltaxml-old">[91]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-BracedTypeswitchCases"><span class="deltaxml-old">BracedTypeswitchCases</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"{" </span><a href="#prod-xquery40-TypeswitchCases"><span class="deltaxml-old">TypeswitchCases</span></a><span class="deltaxml-old"> "}"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CaseClause"></a>[<span class="deltaxml-old">92</span><span class="deltaxml-new">85</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CaseClause">CaseClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"case" ("$" <a href="#prod-xquery40-VarName">VarName</a> "as")? <a href="#prod-xquery40-SequenceTypeUnion">SequenceTypeUnion</a> "return" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SequenceTypeUnion"></a>[<span class="deltaxml-old">93</span><span class="deltaxml-new">86</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SequenceTypeUnion">SequenceTypeUnion</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SequenceType">SequenceType</a> ("|" <a href="#prod-xquery40-SequenceType">SequenceType</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-IfExpr"></a>[<span class="deltaxml-old">94</span><span class="deltaxml-new">87</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-IfExpr">IfExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"if" "(" <a href="#prod-xquery40-Expr">Expr</a> ")" (<a href="#prod-xquery40-UnbracedActions">UnbracedActions</a> | <a href="#prod-xquery40-BracedActions">BracedActions</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-UnbracedActions"></a>[<span class="deltaxml-old">95</span><span class="deltaxml-new">88</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-UnbracedActions">UnbracedActions</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"then" <a href="#prod-xquery40-ExprSingle">ExprSingle</a> "else" <a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-BracedActions"></a>[<span class="deltaxml-old">96</span><span class="deltaxml-new">89</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-BracedActions">BracedActions</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ThenAction">ThenAction</a><a href="#prod-xquery40-ElseIfAction">ElseIfAction</a>* <a href="#prod-xquery40-ElseAction">ElseAction</a>?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ThenAction"></a>[<span class="deltaxml-old">97</span><span class="deltaxml-new">90</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ThenAction">ThenAction</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ElseIfAction"></a>[<span class="deltaxml-old">98</span><span class="deltaxml-new">91</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ElseIfAction">ElseIfAction</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"else" "if" "(" <a href="#prod-xquery40-Expr">Expr</a> ")" <a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ElseAction"></a>[<span class="deltaxml-old">99</span><span class="deltaxml-new">92</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ElseAction">ElseAction</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"else" <a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-TryCatchExpr"></a>[<span class="deltaxml-old">100</span><span class="deltaxml-new">93</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-TryClause">TryClause</a><a href="#prod-xquery40-CatchClause">CatchClause</a>+</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-TryClause"></a>[<span class="deltaxml-old">101</span><span class="deltaxml-new">94</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-TryClause">TryClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"try" <a href="#prod-xquery40-EnclosedTryTargetExpr">EnclosedTryTargetExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-EnclosedTryTargetExpr"></a>[<span class="deltaxml-old">102</span><span class="deltaxml-new">95</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EnclosedTryTargetExpr">EnclosedTryTargetExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CatchClause"></a>[<span class="deltaxml-old">103</span><span class="deltaxml-new">96</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CatchClause">CatchClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"catch" <a href="#prod-xquery40-NameTestUnion">NameTestUnion</a><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></span><span style="display: none;" class="add_version"><code>"catch" <a href="#prod-xquery40-CatchErrorList">CatchErrorList</a><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></span><span class="modify_version"><code>"catch" <a href="#prod-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a><a href="#prod-xquery40-CatchErrorList"><span class="deltaxml-new">CatchErrorList</span></a><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-NameTestUnion"></a><a id="prod-xquery40-CatchErrorList"></a>[<span class="deltaxml-old">104</span><span class="deltaxml-new">97</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-NameTestUnion">NameTestUnion</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-CatchErrorList">CatchErrorList</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a><a href="#doc-xquery40-CatchErrorList"><span class="deltaxml-new">CatchErrorList</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NameTest">NameTest</a> ("|" <a href="#prod-xquery40-NameTest">NameTest</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-OrExpr"></a>[<span class="deltaxml-old">105</span><span class="deltaxml-new">98</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-OrExpr">OrExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AndExpr">AndExpr</a> ( "or" <a href="#prod-xquery40-AndExpr">AndExpr</a> )*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AndExpr"></a>[<span class="deltaxml-old">106</span><span class="deltaxml-new">99</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AndExpr">AndExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ComparisonExpr">ComparisonExpr</a> ( "and" <a href="#prod-xquery40-ComparisonExpr">ComparisonExpr</a> )*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ComparisonExpr"></a>[<span class="deltaxml-old">107</span><span class="deltaxml-new">100</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ComparisonExpr">ComparisonExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-OtherwiseExpr">OtherwiseExpr</a> ( (<a href="#prod-xquery40-ValueComp">ValueComp</a><br>| <a href="#prod-xquery40-GeneralComp">GeneralComp</a><br>| <a href="#prod-xquery40-NodeComp">NodeComp</a>) <a href="#prod-xquery40-OtherwiseExpr">OtherwiseExpr</a> )?</code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-StringConcatExpr">StringConcatExpr</a> ( (<a href="#prod-xquery40-ValueComp">ValueComp</a><br>| <a href="#prod-xquery40-GeneralComp">GeneralComp</a><br>| <a href="#prod-xquery40-NodeComp">NodeComp</a>) <a href="#prod-xquery40-StringConcatExpr">StringConcatExpr</a> )?</code></span><span class="modify_version"><code><a href="#prod-xquery40-OtherwiseExpr"><span class="deltaxml-old">OtherwiseExpr</span></a><a href="#prod-xquery40-StringConcatExpr"><span class="deltaxml-new">StringConcatExpr</span></a> ( (<a href="#prod-xquery40-ValueComp">ValueComp</a><br>| <a href="#prod-xquery40-GeneralComp">GeneralComp</a><br>| <a href="#prod-xquery40-NodeComp">NodeComp</a>) <a href="#prod-xquery40-OtherwiseExpr"><span class="deltaxml-old">OtherwiseExpr</span></a><a href="#prod-xquery40-StringConcatExpr"><span class="deltaxml-new">StringConcatExpr</span></a> )?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-OtherwiseExpr"></a><span class="deltaxml-old">[108]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-OtherwiseExpr"><span class="deltaxml-old">OtherwiseExpr</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-StringConcatExpr"><span class="deltaxml-old">StringConcatExpr</span></a><span class="deltaxml-old"> ( "otherwise" </span><a href="#prod-xquery40-StringConcatExpr"><span class="deltaxml-old">StringConcatExpr</span></a><span class="deltaxml-old"> )*</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-StringConcatExpr"></a>[<span class="deltaxml-old">109</span><span class="deltaxml-new">101</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-StringConcatExpr">StringConcatExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-RangeExpr">RangeExpr</a> ( "||" <a href="#prod-xquery40-RangeExpr">RangeExpr</a> )*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-RangeExpr"></a>[<span class="deltaxml-old">110</span><span class="deltaxml-new">102</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-RangeExpr">RangeExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AdditiveExpr">AdditiveExpr</a> ( "to" <a href="#prod-xquery40-AdditiveExpr">AdditiveExpr</a> )?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AdditiveExpr"></a>[<span class="deltaxml-old">111</span><span class="deltaxml-new">103</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AdditiveExpr">AdditiveExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" | "-") <a href="#prod-xquery40-MultiplicativeExpr">MultiplicativeExpr</a> )*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-MultiplicativeExpr"></a>[<span class="deltaxml-old">112</span><span class="deltaxml-new">104</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-MultiplicativeExpr">MultiplicativeExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-UnionExpr">UnionExpr</a> ( ("*" | "×" | "div" | "÷" | "idiv" | "mod") <a href="#prod-xquery40-UnionExpr">UnionExpr</a> )*</code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-OtherwiseExpr">OtherwiseExpr</a> ( ("*" | "div" | "idiv" | "mod") <a href="#prod-xquery40-OtherwiseExpr">OtherwiseExpr</a> )*</code></span><span class="modify_version"><code><a href="#prod-xquery40-UnionExpr"><span class="deltaxml-old">UnionExpr</span></a><a href="#prod-xquery40-OtherwiseExpr"><span class="deltaxml-new">OtherwiseExpr</span></a> ( ("*" | "<span class="deltaxml-old">×" | "</span>div" | "<span class="deltaxml-old">÷" | "</span>idiv" | "mod") <a href="#prod-xquery40-UnionExpr"><span class="deltaxml-old">UnionExpr</span></a><a href="#prod-xquery40-OtherwiseExpr"><span class="deltaxml-new">OtherwiseExpr</span></a> )*</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-OtherwiseExpr"></a><span class="deltaxml-new">[105]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-OtherwiseExpr"><span class="deltaxml-new">OtherwiseExpr</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-UnionExpr"><span class="deltaxml-new">UnionExpr</span></a><span class="deltaxml-new"> ( "otherwise" </span><a href="#prod-xquery40-UnionExpr"><span class="deltaxml-new">UnionExpr</span></a><span class="deltaxml-new"> )*</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-UnionExpr"></a>[<span class="deltaxml-old">113</span><span class="deltaxml-new">106</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-UnionExpr">UnionExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union" | "|") <a href="#prod-xquery40-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-IntersectExceptExpr"></a>[<span class="deltaxml-old">114</span><span class="deltaxml-new">107</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-IntersectExceptExpr">IntersectExceptExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-InstanceofExpr">InstanceofExpr</a> ( ("intersect" | "except") <a href="#prod-xquery40-InstanceofExpr">InstanceofExpr</a> )*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-InstanceofExpr"></a>[<span class="deltaxml-old">115</span><span class="deltaxml-new">108</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-InstanceofExpr">InstanceofExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-TreatExpr">TreatExpr</a> ( "instance" "of" <a href="#prod-xquery40-SequenceType">SequenceType</a> )?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-TreatExpr"></a>[<span class="deltaxml-old">116</span><span class="deltaxml-new">109</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-TreatExpr">TreatExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CastableExpr">CastableExpr</a> ( "treat" "as" <a href="#prod-xquery40-SequenceType">SequenceType</a> )?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CastableExpr"></a>[<span class="deltaxml-old">117</span><span class="deltaxml-new">110</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CastableExpr">CastableExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CastExpr">CastExpr</a> ( "castable" "as" <a href="#prod-xquery40-SingleType">SingleType</a> )?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CastExpr"></a>[<span class="deltaxml-old">118</span><span class="deltaxml-new">111</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CastExpr">CastExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ArrowExpr">ArrowExpr</a> ( "cast" "as" <a href="#prod-xquery40-SingleType">SingleType</a> )?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ArrowExpr"></a>[<span class="deltaxml-old">119</span><span class="deltaxml-new">112</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ArrowExpr">ArrowExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-UnaryExpr">UnaryExpr</a> ( (<a href="#prod-xquery40-SequenceArrowTarget">SequenceArrowTarget</a> | <a href="#prod-xquery40-MappingArrowTarget">MappingArrowTarget</a> | <a href="#prod-xquery40-LookupArrowTarget">LookupArrowTarget</a>) )*</code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-UnaryExpr">UnaryExpr</a> ( (<a href="#prod-xquery40-FatArrowTarget">FatArrowTarget</a> | <a href="#prod-xquery40-ThinArrowTarget">ThinArrowTarget</a>) )*</code></span><span class="modify_version"><code><a href="#prod-xquery40-UnaryExpr">UnaryExpr</a> ( (<a href="#prod-xquery40-SequenceArrowTarget"><span class="deltaxml-old">SequenceArrowTarget</span></a><a href="#prod-xquery40-FatArrowTarget"><span class="deltaxml-new">FatArrowTarget</span></a> | <a href="#prod-xquery40-MappingArrowTarget"><span class="deltaxml-old">MappingArrowTarget</span></a><span class="deltaxml-old"> | </span><a href="#prod-xquery40-LookupArrowTarget"><span class="deltaxml-old">LookupArrowTarget</span></a><a href="#prod-xquery40-ThinArrowTarget"><span class="deltaxml-new">ThinArrowTarget</span></a>) )*</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-UnaryExpr"></a>[<span class="deltaxml-old">120</span><span class="deltaxml-new">113</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-UnaryExpr">UnaryExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("-" | "+")* <a href="#prod-xquery40-ValueExpr">ValueExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ValueExpr"></a>[<span class="deltaxml-old">121</span><span class="deltaxml-new">114</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ValueExpr">ValueExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ValidateExpr">ValidateExpr</a> | <a href="#prod-xquery40-ExtensionExpr">ExtensionExpr</a> | <a href="#prod-xquery40-SimpleMapExpr">SimpleMapExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SequenceArrowTarget"></a><a id="prod-xquery40-FatArrowTarget"></a>[<span class="deltaxml-old">122</span><span class="deltaxml-new">115</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-SequenceArrowTarget">SequenceArrowTarget</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-FatArrowTarget">FatArrowTarget</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-SequenceArrowTarget"><span class="deltaxml-old">SequenceArrowTarget</span></a><a href="#doc-xquery40-FatArrowTarget"><span class="deltaxml-new">FatArrowTarget</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"=&gt;" <a href="#prod-xquery40-ArrowTarget">ArrowTarget</a></code></span><span style="display: none;" class="add_version"><code>"=&gt;" ((<a href="#prod-xquery40-ArrowStaticFunction">ArrowStaticFunction</a><a href="#prod-xquery40-ArgumentList">ArgumentList</a>) | (<a href="#prod-xquery40-ArrowDynamicFunction">ArrowDynamicFunction</a><a href="#prod-xquery40-PositionalArgumentList">PositionalArgumentList</a>))</code></span><span class="modify_version"><code>"=&gt;" <a href="#prod-xquery40-ArrowTarget"><span class="deltaxml-old">ArrowTarget</span></a><span class="deltaxml-new">((</span><a href="#prod-xquery40-ArrowStaticFunction"><span class="deltaxml-new">ArrowStaticFunction</span></a><a href="#prod-xquery40-ArgumentList"><span class="deltaxml-new">ArgumentList</span></a><span class="deltaxml-new">) | (</span><a href="#prod-xquery40-ArrowDynamicFunction"><span class="deltaxml-new">ArrowDynamicFunction</span></a><a href="#prod-xquery40-PositionalArgumentList"><span class="deltaxml-new">PositionalArgumentList</span></a><span class="deltaxml-new">))</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-MappingArrowTarget"></a><span class="deltaxml-old">[123]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-MappingArrowTarget"><span class="deltaxml-old">MappingArrowTarget</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"=!&gt;" </span><a href="#prod-xquery40-ArrowTarget"><span class="deltaxml-old">ArrowTarget</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ArrowTarget"></a><span class="deltaxml-old">[124]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-ArrowTarget"><span class="deltaxml-old">ArrowTarget</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">(</span><a href="#prod-xquery40-ArrowStaticFunction"><span class="deltaxml-old">ArrowStaticFunction</span></a><a href="#prod-xquery40-ArgumentList"><span class="deltaxml-old">ArgumentList</span></a><span class="deltaxml-old">) | (</span><a href="#prod-xquery40-ArrowDynamicFunction"><span class="deltaxml-old">ArrowDynamicFunction</span></a><a href="#prod-xquery40-PositionalArgumentList"><span class="deltaxml-old">PositionalArgumentList</span></a><span class="deltaxml-old">)</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-LookupArrowTarget"></a><a id="prod-xquery40-ThinArrowTarget"></a>[<span class="deltaxml-old">125</span><span class="deltaxml-new">116</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-LookupArrowTarget">LookupArrowTarget</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-ThinArrowTarget">ThinArrowTarget</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-LookupArrowTarget"><span class="deltaxml-old">LookupArrowTarget</span></a><a href="#doc-xquery40-ThinArrowTarget"><span class="deltaxml-new">ThinArrowTarget</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"=?&gt;" <a href="#prod-xquery40-NCName">NCName</a><a href="#prod-xquery40-PositionalArgumentList">PositionalArgumentList</a></code></span><span style="display: none;" class="add_version"><code>"-&gt;" ((<a href="#prod-xquery40-ArrowStaticFunction">ArrowStaticFunction</a><a href="#prod-xquery40-ArgumentList">ArgumentList</a>) | (<a href="#prod-xquery40-ArrowDynamicFunction">ArrowDynamicFunction</a><a href="#prod-xquery40-PositionalArgumentList">PositionalArgumentList</a>) | <a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a>)</code></span><span class="modify_version"><code>"<span class="deltaxml-old">=?</span><span class="deltaxml-new">-</span>&gt;" <a href="#prod-xquery40-NCName"><span class="deltaxml-old">NCName</span></a><span class="deltaxml-new">((</span><a href="#prod-xquery40-ArrowStaticFunction"><span class="deltaxml-new">ArrowStaticFunction</span></a><a href="#prod-xquery40-ArgumentList"><span class="deltaxml-new">ArgumentList</span></a><span class="deltaxml-new">) | (</span><a href="#prod-xquery40-ArrowDynamicFunction"><span class="deltaxml-new">ArrowDynamicFunction</span></a><a href="#prod-xquery40-PositionalArgumentList">PositionalArgumentList</a><span class="deltaxml-new">) | </span><a href="#prod-xquery40-EnclosedExpr"><span class="deltaxml-new">EnclosedExpr</span></a><span class="deltaxml-new">)</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-GeneralComp"></a>[<span class="deltaxml-old">126</span><span class="deltaxml-new">117</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-GeneralComp">GeneralComp</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;="</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ValueComp"></a>[<span class="deltaxml-old">127</span><span class="deltaxml-new">118</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ValueComp">ValueComp</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-NodeComp"></a>[<span class="deltaxml-old">128</span><span class="deltaxml-new">119</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-NodeComp">NodeComp</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ValidateExpr"></a>[<span class="deltaxml-old">129</span><span class="deltaxml-new">120</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ValidateExpr">ValidateExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"validate" (<a href="#prod-xquery40-ValidationMode">ValidationMode</a> | ("type" <a href="#prod-xquery40-TypeName">TypeName</a>))? "{" <a href="#prod-xquery40-Expr">Expr</a> "}"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ValidationMode"></a>[<span class="deltaxml-old">130</span><span class="deltaxml-new">121</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ValidationMode">ValidationMode</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"lax" | "strict"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ExtensionExpr"></a>[<span class="deltaxml-old">131</span><span class="deltaxml-new">122</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ExtensionExpr">ExtensionExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Pragma">Pragma</a>+ "{" <a href="#prod-xquery40-Expr">Expr</a>? "}"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Pragma"></a>[<span class="deltaxml-old">132</span><span class="deltaxml-new">123</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Pragma">Pragma</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(#" <a href="#prod-xquery40-S">S</a>? <a href="#prod-xquery40-EQName">EQName</a> (<a href="#prod-xquery40-S">S</a><a href="#prod-xquery40-PragmaContents">PragmaContents</a>)? "#)"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-PragmaContents"></a>[<span class="deltaxml-old">133</span><span class="deltaxml-new">124</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PragmaContents">PragmaContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a>* - (Char* '#)' Char*))</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SimpleMapExpr"></a>[<span class="deltaxml-old">134</span><span class="deltaxml-new">125</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SimpleMapExpr">SimpleMapExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-PathExpr">PathExpr</a> ("!" <a href="#prod-xquery40-PathExpr">PathExpr</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-PathExpr"></a>[<span class="deltaxml-old">135</span><span class="deltaxml-new">126</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PathExpr">PathExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("/" <a href="#prod-xquery40-RelativePathExpr">RelativePathExpr</a>?)<br>| ("//" <a href="#prod-xquery40-RelativePathExpr">RelativePathExpr</a>)<br>| <a href="#prod-xquery40-RelativePathExpr">RelativePathExpr</a></code></td><td><i>/* <a href="#parse-note-leading-lone-slash">xgc: leading-lone-slash</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-RelativePathExpr"></a>[<span class="deltaxml-old">136</span><span class="deltaxml-new">127</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-RelativePathExpr">RelativePathExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-StepExpr">StepExpr</a> (("/" | "//") <a href="#prod-xquery40-StepExpr">StepExpr</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-StepExpr"></a>[<span class="deltaxml-old">137</span><span class="deltaxml-new">128</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-StepExpr">StepExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-PostfixExpr">PostfixExpr</a> | <a href="#prod-xquery40-AxisStep">AxisStep</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AxisStep"></a>[<span class="deltaxml-old">138</span><span class="deltaxml-new">129</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AxisStep">AxisStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-ReverseStep">ReverseStep</a> | <a href="#prod-xquery40-ForwardStep">ForwardStep</a>) <a href="#prod-xquery40-PredicateList">PredicateList</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ForwardStep"></a>[<span class="deltaxml-old">139</span><span class="deltaxml-new">130</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ForwardStep">ForwardStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-ForwardAxis">ForwardAxis</a><a href="#prod-xquery40-NodeTest">NodeTest</a>) | <a href="#prod-xquery40-AbbrevForwardStep">AbbrevForwardStep</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ForwardAxis"></a>[<span class="deltaxml-old">140</span><span class="deltaxml-new">131</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ForwardAxis">ForwardAxis</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("child" "::")<br>| ("descendant" "::")<br>| ("attribute" "::")<br>| ("self" "::")<br>| ("descendant-or-self" "::")<br>| ("following-sibling" "::")<br>| ("following" "::")</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AbbrevForwardStep"></a>[<span class="deltaxml-old">141</span><span class="deltaxml-new">132</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AbbrevForwardStep">AbbrevForwardStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("@" <a href="#prod-xquery40-NodeTest">NodeTest</a>) | <a href="#prod-xquery40-SimpleNodeTest">SimpleNodeTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ReverseStep"></a>[<span class="deltaxml-old">142</span><span class="deltaxml-new">133</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ReverseStep">ReverseStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-ReverseAxis">ReverseAxis</a><a href="#prod-xquery40-NodeTest">NodeTest</a>) | <a href="#prod-xquery40-AbbrevReverseStep">AbbrevReverseStep</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ReverseAxis"></a>[<span class="deltaxml-old">143</span><span class="deltaxml-new">134</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ReverseAxis">ReverseAxis</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("parent" "::")<br>| ("ancestor" "::")<br>| ("preceding-sibling" "::")<br>| ("preceding" "::")<br>| ("ancestor-or-self" "::")</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AbbrevReverseStep"></a>[<span class="deltaxml-old">144</span><span class="deltaxml-new">135</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AbbrevReverseStep">AbbrevReverseStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>".."</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-NodeTest"></a>[<span class="deltaxml-old">145</span><span class="deltaxml-new">136</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-NodeTest">NodeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-UnionNodeTest">UnionNodeTest</a> | <a href="#prod-xquery40-SimpleNodeTest">SimpleNodeTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-UnionNodeTest"></a>[<span class="deltaxml-old">146</span><span class="deltaxml-new">137</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-UnionNodeTest">UnionNodeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" <a href="#prod-xquery40-SimpleNodeTest">SimpleNodeTest</a> ("|" <a href="#prod-xquery40-SimpleNodeTest">SimpleNodeTest</a>)* ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SimpleNodeTest"></a>[<span class="deltaxml-old">147</span><span class="deltaxml-new">138</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SimpleNodeTest">SimpleNodeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-KindTest">KindTest</a> | <a href="#prod-xquery40-NameTest">NameTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-NameTest"></a>[<span class="deltaxml-old">148</span><span class="deltaxml-new">139</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-NameTest">NameTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a> | <a href="#prod-xquery40-Wildcard">Wildcard</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Wildcard"></a>[<span class="deltaxml-old">149</span><span class="deltaxml-new">140</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Wildcard">Wildcard</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"*"<br>| (<a href="#prod-xquery40-NCName">NCName</a> ":*")<br>| ("*:" <a href="#prod-xquery40-NCName">NCName</a>)<br>| (<a href="#prod-xquery40-BracedURILiteral">BracedURILiteral</a> "*")</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-FilterExpr"></a><span class="deltaxml-old">[150]&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">FilterExpr</span></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-PostfixExpr"><span class="deltaxml-old">PostfixExpr</span></a><a href="#prod-xquery40-Predicate"><span class="deltaxml-old">Predicate</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-PostfixExpr"></a>[<span class="deltaxml-old">151</span><span class="deltaxml-new">141</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PostfixExpr">PostfixExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-PrimaryExpr">PrimaryExpr</a> | <a href="#prod-xquery40-FilterExpr">FilterExpr</a> | <a href="#prod-xquery40-DynamicFunctionCall">DynamicFunctionCall</a> | <a href="#prod-xquery40-LookupExpr">LookupExpr</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-PrimaryExpr">PrimaryExpr</a> (<a href="#prod-xquery40-Predicate">Predicate</a> | <a href="#prod-xquery40-PositionalArgumentList">PositionalArgumentList</a> | <a href="#prod-xquery40-Lookup">Lookup</a>)*</code></span><span class="modify_version"><code><a href="#prod-xquery40-PrimaryExpr">PrimaryExpr</a> <span class="deltaxml-old">|</span><span class="deltaxml-new">(</span><a href="#prod-xquery40-Predicate"><span class="deltaxml-new">Predicate</span></a> <a href="#prod-xquery40-FilterExpr"><span class="deltaxml-old">FilterExpr</span></a><span class="deltaxml-old"> </span>| <a href="#prod-xquery40-DynamicFunctionCall"><span class="deltaxml-old">DynamicFunctionCall</span></a><a href="#prod-xquery40-PositionalArgumentList"><span class="deltaxml-new">PositionalArgumentList</span></a> | <a href="#prod-xquery40-LookupExpr"><span class="deltaxml-old">LookupExpr</span></a><a href="#prod-xquery40-Lookup"><span class="deltaxml-new">Lookup</span></a><span class="deltaxml-new">)*</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DynamicFunctionCall"></a><span class="deltaxml-old">[152]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-DynamicFunctionCall"><span class="deltaxml-old">DynamicFunctionCall</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-PostfixExpr"><span class="deltaxml-old">PostfixExpr</span></a><a href="#prod-xquery40-PositionalArgumentList"><span class="deltaxml-old">PositionalArgumentList</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ArgumentList"></a>[<span class="deltaxml-old">153</span><span class="deltaxml-new">142</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ArgumentList">ArgumentList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" ((<a href="#prod-xquery40-PositionalArguments">PositionalArguments</a> ("," <a href="#prod-xquery40-KeywordArguments">KeywordArguments</a>)?) | <a href="#prod-xquery40-KeywordArguments">KeywordArguments</a>)? ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-PositionalArgumentList"></a>[<span class="deltaxml-old">154</span><span class="deltaxml-new">143</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PositionalArgumentList">PositionalArgumentList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" <a href="#prod-xquery40-PositionalArguments">PositionalArguments</a>? ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-PositionalArguments"></a>[<span class="deltaxml-old">155</span><span class="deltaxml-new">144</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PositionalArguments">PositionalArguments</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Argument">Argument</a> ("," <a href="#prod-xquery40-Argument">Argument</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-KeywordArguments"></a>[<span class="deltaxml-old">156</span><span class="deltaxml-new">145</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>KeywordArguments</code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-KeywordArguments">KeywordArguments</a></code></span><span class="modify_version"><code><span class="deltaxml-old">KeywordArguments</span><a href="#doc-xquery40-KeywordArguments"><span class="deltaxml-new">KeywordArguments</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-KeywordArgument">KeywordArgument</a> ("," <a href="#prod-xquery40-KeywordArgument">KeywordArgument</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-KeywordArgument"></a>[<span class="deltaxml-old">157</span><span class="deltaxml-new">146</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-KeywordArgument">KeywordArgument</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a> ":=" <a href="#prod-xquery40-Argument">Argument</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-PredicateList"></a>[<span class="deltaxml-old">158</span><span class="deltaxml-new">147</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PredicateList">PredicateList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Predicate">Predicate</a>*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Predicate"></a>[<span class="deltaxml-old">159</span><span class="deltaxml-new">148</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Predicate">Predicate</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"[" <a href="#prod-xquery40-Expr">Expr</a> "]"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-LookupExpr"></a><a id="prod-xquery40-Lookup"></a>[<span class="deltaxml-old">160</span><span class="deltaxml-new">149</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-LookupExpr">LookupExpr</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-Lookup">Lookup</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-LookupExpr"><span class="deltaxml-old">LookupExpr</span></a><a href="#doc-xquery40-Lookup"><span class="deltaxml-new">Lookup</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-PostfixExpr">PostfixExpr</a><a href="#prod-xquery40-Lookup">Lookup</a></code></span><span style="display: none;" class="add_version"><code>"?" <a href="#prod-xquery40-KeySpecifier">KeySpecifier</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-PostfixExpr"><span class="deltaxml-old">PostfixExpr</span></a><a href="#prod-xquery40-Lookup"><span class="deltaxml-old">Lookup</span></a><span class="deltaxml-new">"?" </span><a href="#prod-xquery40-KeySpecifier"><span class="deltaxml-new">KeySpecifier</span></a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Lookup"></a><span class="deltaxml-old">[161]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-Lookup"><span class="deltaxml-old">Lookup</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">("?" | "??") </span><a href="#prod-xquery40-KeySpecifier"><span class="deltaxml-old">KeySpecifier</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-KeySpecifier"></a>[<span class="deltaxml-old">162</span><span class="deltaxml-new">150</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-KeySpecifier">KeySpecifier</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-NCName">NCName</a> | <a href="#prod-xquery40-IntegerLiteral">IntegerLiteral</a> | <a href="#prod-xquery40-StringLiteral">StringLiteral</a> | <a href="#prod-xquery40-VarRef">VarRef</a> | <a href="#prod-xquery40-ParenthesizedExpr">ParenthesizedExpr</a> | <a href="#prod-xquery40-LookupWildcard">LookupWildcard</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-NCName">NCName</a> | <a href="#prod-xquery40-IntegerLiteral">IntegerLiteral</a> | <a href="#prod-xquery40-StringLiteral">StringLiteral</a> | <a href="#prod-xquery40-VarRef">VarRef</a> | <a href="#prod-xquery40-ParenthesizedExpr">ParenthesizedExpr</a> | "*"</code></span><span class="modify_version"><code><a href="#prod-xquery40-NCName">NCName</a> | <a href="#prod-xquery40-IntegerLiteral">IntegerLiteral</a> | <a href="#prod-xquery40-StringLiteral">StringLiteral</a> | <a href="#prod-xquery40-VarRef">VarRef</a> | <a href="#prod-xquery40-ParenthesizedExpr">ParenthesizedExpr</a> | <a href="#prod-xquery40-LookupWildcard"><span class="deltaxml-old">LookupWildcard</span></a><span class="deltaxml-new">"*"</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-LookupWildcard"></a><span class="deltaxml-old">[163]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-LookupWildcard"><span class="deltaxml-old">LookupWildcard</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"*" ("::" </span><a href="#prod-xquery40-SequenceType"><span class="deltaxml-old">SequenceType</span></a><span class="deltaxml-old">)?</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ArrowStaticFunction"></a>[<span class="deltaxml-old">164</span><span class="deltaxml-new">151</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ArrowStaticFunction">ArrowStaticFunction</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ArrowDynamicFunction"></a>[<span class="deltaxml-old">165</span><span class="deltaxml-new">152</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ArrowDynamicFunction">ArrowDynamicFunction</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-VarRef">VarRef</a> | <a href="#prod-xquery40-InlineFunctionExpr">InlineFunctionExpr</a> | <a href="#prod-xquery40-ParenthesizedExpr">ParenthesizedExpr</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-VarRef">VarRef</a> | <a href="#prod-xquery40-ParenthesizedExpr">ParenthesizedExpr</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-VarRef">VarRef</a> | <a href="#prod-xquery40-InlineFunctionExpr"><span class="deltaxml-old">InlineFunctionExpr</span></a><span class="deltaxml-old"> | </span><a href="#prod-xquery40-ParenthesizedExpr">ParenthesizedExpr</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-PrimaryExpr"></a>[<span class="deltaxml-old">166</span><span class="deltaxml-new">153</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PrimaryExpr">PrimaryExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-Literal">Literal</a><br>| <a href="#prod-xquery40-VarRef">VarRef</a><br>| <a href="#prod-xquery40-ParenthesizedExpr">ParenthesizedExpr</a><br>| <a href="#prod-xquery40-ContextValueRef">ContextValueRef</a><br>| <a href="#prod-xquery40-FunctionCall">FunctionCall</a><br>| <a href="#prod-xquery40-OrderedExpr">OrderedExpr</a><br>| <a href="#prod-xquery40-UnorderedExpr">UnorderedExpr</a><br>| <a href="#prod-xquery40-NodeConstructor">NodeConstructor</a><br>| <a href="#prod-xquery40-FunctionItemExpr">FunctionItemExpr</a><br>| <a href="#prod-xquery40-MapConstructor">MapConstructor</a><br>| <a href="#prod-xquery40-ArrayConstructor">ArrayConstructor</a><br>| <a href="#prod-xquery40-StringTemplate">StringTemplate</a><br>| <a href="#prod-xquery40-StringConstructor">StringConstructor</a><br>| <a href="#prod-xquery40-UnaryLookup">UnaryLookup</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-Literal">Literal</a><br>| <a href="#prod-xquery40-VarRef">VarRef</a><br>| <a href="#prod-xquery40-ParenthesizedExpr">ParenthesizedExpr</a><br>| <a href="#prod-xquery40-ContextItemExpr">ContextItemExpr</a><br>| <a href="#prod-xquery40-FunctionCall">FunctionCall</a><br>| <a href="#prod-xquery40-OrderedExpr">OrderedExpr</a><br>| <a href="#prod-xquery40-UnorderedExpr">UnorderedExpr</a><br>| <a href="#prod-xquery40-NodeConstructor">NodeConstructor</a><br>| <a href="#prod-xquery40-FunctionItemExpr">FunctionItemExpr</a><br>| <a href="#prod-xquery40-MapConstructor">MapConstructor</a><br>| <a href="#prod-xquery40-ArrayConstructor">ArrayConstructor</a><br>| <a href="#prod-xquery40-StringTemplate">StringTemplate</a><br>| <a href="#prod-xquery40-StringConstructor">StringConstructor</a><br>| <a href="#prod-xquery40-UnaryLookup">UnaryLookup</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-Literal">Literal</a><br>| <a href="#prod-xquery40-VarRef">VarRef</a><br>| <a href="#prod-xquery40-ParenthesizedExpr">ParenthesizedExpr</a><br>| <a href="#prod-xquery40-ContextValueRef"><span class="deltaxml-old">ContextValueRef</span></a><a href="#prod-xquery40-ContextItemExpr"><span class="deltaxml-new">ContextItemExpr</span></a><br>| <a href="#prod-xquery40-FunctionCall">FunctionCall</a><br>| <a href="#prod-xquery40-OrderedExpr">OrderedExpr</a><br>| <a href="#prod-xquery40-UnorderedExpr">UnorderedExpr</a><br>| <a href="#prod-xquery40-NodeConstructor">NodeConstructor</a><br>| <a href="#prod-xquery40-FunctionItemExpr">FunctionItemExpr</a><br>| <a href="#prod-xquery40-MapConstructor">MapConstructor</a><br>| <a href="#prod-xquery40-ArrayConstructor">ArrayConstructor</a><br>| <a href="#prod-xquery40-StringTemplate">StringTemplate</a><br>| <a href="#prod-xquery40-StringConstructor">StringConstructor</a><br>| <a href="#prod-xquery40-UnaryLookup">UnaryLookup</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Literal"></a>[<span class="deltaxml-old">167</span><span class="deltaxml-new">154</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Literal">Literal</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NumericLiteral">NumericLiteral</a> | <a href="#prod-xquery40-StringLiteral">StringLiteral</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-NumericLiteral"></a>[<span class="deltaxml-old">168</span><span class="deltaxml-new">155</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-NumericLiteral">NumericLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-IntegerLiteral">IntegerLiteral</a> | <a href="#prod-xquery40-HexIntegerLiteral">HexIntegerLiteral</a> | <a href="#prod-xquery40-BinaryIntegerLiteral">BinaryIntegerLiteral</a> | <a href="#prod-xquery40-DecimalLiteral">DecimalLiteral</a> | <a href="#prod-xquery40-DoubleLiteral">DoubleLiteral</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-VarRef"></a>[<span class="deltaxml-old">169</span><span class="deltaxml-new">156</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-VarRef">VarRef</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$" <a href="#prod-xquery40-VarName">VarName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-VarName"></a>[<span class="deltaxml-old">170</span><span class="deltaxml-new">157</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-VarName">VarName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ParenthesizedExpr"></a>[<span class="deltaxml-old">171</span><span class="deltaxml-new">158</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ParenthesizedExpr">ParenthesizedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" <a href="#prod-xquery40-Expr">Expr</a>? ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ContextValueRef"></a><a id="prod-xquery40-ContextItemExpr"></a>[<span class="deltaxml-old">172</span><span class="deltaxml-new">159</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-ContextValueRef">ContextValueRef</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-ContextItemExpr">ContextItemExpr</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-ContextValueRef"><span class="deltaxml-old">ContextValueRef</span></a><a href="#doc-xquery40-ContextItemExpr"><span class="deltaxml-new">ContextItemExpr</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"."</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-OrderedExpr"></a>[<span class="deltaxml-old">173</span><span class="deltaxml-new">160</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-OrderedExpr">OrderedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"ordered" <a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-UnorderedExpr"></a>[<span class="deltaxml-old">174</span><span class="deltaxml-new">161</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-UnorderedExpr">UnorderedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"unordered" <a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-FunctionCall"></a>[<span class="deltaxml-old">175</span><span class="deltaxml-new">162</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-FunctionCall">FunctionCall</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a><a href="#prod-xquery40-ArgumentList">ArgumentList</a></code></td><td><i>/* <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a> */</i></td></tr><tr style="vertical-align:baseline;"><td></td><td></td><td></td><td></td><td><i>/* <a href="#parse-note-parens">gn: parens</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Argument"></a>[<span class="deltaxml-old">176</span><span class="deltaxml-new">163</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Argument">Argument</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a> | <a href="#prod-xquery40-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ArgumentPlaceholder"></a>[<span class="deltaxml-old">177</span><span class="deltaxml-new">164</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"?"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-NodeConstructor"></a>[<span class="deltaxml-old">178</span><span class="deltaxml-new">165</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-NodeConstructor">NodeConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DirectConstructor">DirectConstructor</a><br>| <a href="#prod-xquery40-ComputedConstructor">ComputedConstructor</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DirectConstructor"></a>[<span class="deltaxml-old">179</span><span class="deltaxml-new">166</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DirectConstructor">DirectConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DirElemConstructor">DirElemConstructor</a><br>| <a href="#prod-xquery40-DirCommentConstructor">DirCommentConstructor</a><br>| <a href="#prod-xquery40-DirPIConstructor">DirPIConstructor</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DirElemConstructor"></a>[<span class="deltaxml-old">180</span><span class="deltaxml-new">167</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DirElemConstructor">DirElemConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"&lt;" <a href="#prod-xquery40-QName">QName</a><a href="#prod-xquery40-DirAttributeList">DirAttributeList</a> ("/&gt;" | ("&gt;" <a href="#prod-xquery40-DirElemContent">DirElemContent</a>* "&lt;/" <a href="#prod-xquery40-QName">QName</a><a href="#prod-xquery40-S">S</a>? "&gt;"))</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DirAttributeList"></a>[<span class="deltaxml-old">181</span><span class="deltaxml-new">168</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DirAttributeList">DirAttributeList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-S">S</a> (<a href="#prod-xquery40-QName">QName</a><a href="#prod-xquery40-S">S</a>? "=" <a href="#prod-xquery40-S">S</a>? <a href="#prod-xquery40-DirAttributeValue">DirAttributeValue</a>)?)*</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DirAttributeValue"></a>[<span class="deltaxml-old">182</span><span class="deltaxml-new">169</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DirAttributeValue">DirAttributeValue</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>('"' (<a href="#prod-xquery40-EscapeQuot">EscapeQuot</a> | <a href="#prod-xquery40-QuotAttrValueContent">QuotAttrValueContent</a>)* '"')<br>| ("'" (<a href="#prod-xquery40-EscapeApos">EscapeApos</a> | <a href="#prod-xquery40-AposAttrValueContent">AposAttrValueContent</a>)* "'")</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-QuotAttrValueContent"></a>[<span class="deltaxml-old">183</span><span class="deltaxml-new">170</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-QuotAttrValueContent">QuotAttrValueContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-QuotAttrContentChar">QuotAttrContentChar</a><br>| <a href="#prod-xquery40-CommonContent">CommonContent</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AposAttrValueContent"></a>[<span class="deltaxml-old">184</span><span class="deltaxml-new">171</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AposAttrValueContent">AposAttrValueContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AposAttrContentChar">AposAttrContentChar</a><br>| <a href="#prod-xquery40-CommonContent">CommonContent</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DirElemContent"></a>[<span class="deltaxml-old">185</span><span class="deltaxml-new">172</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DirElemContent">DirElemContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DirectConstructor">DirectConstructor</a><br>| <a href="#prod-xquery40-CDataSection">CDataSection</a><br>| <a href="#prod-xquery40-CommonContent">CommonContent</a><br>| <a href="#prod-xquery40-ElementContentChar">ElementContentChar</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CommonContent"></a>[<span class="deltaxml-old">186</span><span class="deltaxml-new">173</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CommonContent">CommonContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-PredefinedEntityRef">PredefinedEntityRef</a> | <a href="#prod-xquery40-CharRef">CharRef</a> | "{{" | "}}" | <a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DirCommentConstructor"></a>[<span class="deltaxml-old">187</span><span class="deltaxml-new">174</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DirCommentConstructor">DirCommentConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"&lt;!--" <a href="#prod-xquery40-DirCommentContents">DirCommentContents</a> "--&gt;"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DirCommentContents"></a>[<span class="deltaxml-old">188</span><span class="deltaxml-new">175</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DirCommentContents">DirCommentContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>((<a href="#prod-xquery40-Char">Char</a> - '-') | ('-' (<a href="#prod-xquery40-Char">Char</a> - '-')))*</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DirPIConstructor"></a>[<span class="deltaxml-old">189</span><span class="deltaxml-new">176</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DirPIConstructor">DirPIConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"&lt;?" <a href="#prod-xquery40-PITarget">PITarget</a> (<a href="#prod-xquery40-S">S</a><a href="#prod-xquery40-DirPIContents">DirPIContents</a>)? "?&gt;"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DirPIContents"></a>[<span class="deltaxml-old">190</span><span class="deltaxml-new">177</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DirPIContents">DirPIContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a>* - (Char* '?&gt;' Char*))</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CDataSection"></a>[<span class="deltaxml-old">191</span><span class="deltaxml-new">178</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CDataSection">CDataSection</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"&lt;![CDATA[" <a href="#prod-xquery40-CDataSectionContents">CDataSectionContents</a> "]]&gt;"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CDataSectionContents"></a>[<span class="deltaxml-old">192</span><span class="deltaxml-new">179</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CDataSectionContents">CDataSectionContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a>* - (Char* ']]&gt;' Char*))</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ComputedConstructor"></a>[<span class="deltaxml-old">193</span><span class="deltaxml-new">180</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ComputedConstructor">ComputedConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-CompDocConstructor">CompDocConstructor</a><br>| <a href="#prod-xquery40-CompElemConstructor">CompElemConstructor</a><br>| <a href="#prod-xquery40-CompAttrConstructor">CompAttrConstructor</a><br>| <a href="#prod-xquery40-CompNamespaceConstructor">CompNamespaceConstructor</a><br>| <a href="#prod-xquery40-CompTextConstructor">CompTextConstructor</a><br>| <a href="#prod-xquery40-CompCommentConstructor">CompCommentConstructor</a><br>| <a href="#prod-xquery40-CompPIConstructor">CompPIConstructor</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CompDocConstructor"></a>[<span class="deltaxml-old">194</span><span class="deltaxml-new">181</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CompDocConstructor">CompDocConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"document" <a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CompElemConstructor"></a>[<span class="deltaxml-old">195</span><span class="deltaxml-new">182</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CompElemConstructor">CompElemConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"element" (<a href="#prod-xquery40-EQName">EQName</a> | ("{" <a href="#prod-xquery40-Expr">Expr</a> "}")) <a href="#prod-xquery40-EnclosedContentExpr">EnclosedContentExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-EnclosedContentExpr"></a>[<span class="deltaxml-old">196</span><span class="deltaxml-new">183</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EnclosedContentExpr">EnclosedContentExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CompAttrConstructor"></a>[<span class="deltaxml-old">197</span><span class="deltaxml-new">184</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CompAttrConstructor">CompAttrConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"attribute" (<a href="#prod-xquery40-EQName">EQName</a> | ("{" <a href="#prod-xquery40-Expr">Expr</a> "}")) <a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CompNamespaceConstructor"></a>[<span class="deltaxml-old">198</span><span class="deltaxml-new">185</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CompNamespaceConstructor">CompNamespaceConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"namespace" (<a href="#prod-xquery40-Prefix">Prefix</a> | <a href="#prod-xquery40-EnclosedPrefixExpr">EnclosedPrefixExpr</a>) <a href="#prod-xquery40-EnclosedURIExpr">EnclosedURIExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Prefix"></a>[<span class="deltaxml-old">199</span><span class="deltaxml-new">186</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Prefix">Prefix</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NCName">NCName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-EnclosedPrefixExpr"></a>[<span class="deltaxml-old">200</span><span class="deltaxml-new">187</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EnclosedPrefixExpr">EnclosedPrefixExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-EnclosedURIExpr"></a>[<span class="deltaxml-old">201</span><span class="deltaxml-new">188</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EnclosedURIExpr">EnclosedURIExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CompTextConstructor"></a>[<span class="deltaxml-old">202</span><span class="deltaxml-new">189</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CompTextConstructor">CompTextConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"text" <a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CompCommentConstructor"></a>[<span class="deltaxml-old">203</span><span class="deltaxml-new">190</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CompCommentConstructor">CompCommentConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"comment" <a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CompPIConstructor"></a>[<span class="deltaxml-old">204</span><span class="deltaxml-new">191</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CompPIConstructor">CompPIConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"processing-instruction" (<a href="#prod-xquery40-NCName">NCName</a> | ("{" <a href="#prod-xquery40-Expr">Expr</a> "}")) <a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-FunctionItemExpr"></a>[<span class="deltaxml-old">205</span><span class="deltaxml-new">192</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-FunctionItemExpr">FunctionItemExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NamedFunctionRef">NamedFunctionRef</a> | <a href="#prod-xquery40-InlineFunctionExpr">InlineFunctionExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-NamedFunctionRef"></a>[<span class="deltaxml-old">206</span><span class="deltaxml-new">193</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-NamedFunctionRef">NamedFunctionRef</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a> "#" <a href="#prod-xquery40-IntegerLiteral">IntegerLiteral</a></code></td><td><i>/* <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-InlineFunctionExpr"></a>[<span class="deltaxml-old">207</span><span class="deltaxml-new">194</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-InlineFunctionExpr">InlineFunctionExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-Annotation">Annotation</a>* ("function" | "fn") <a href="#prod-xquery40-FunctionSignature">FunctionSignature</a>? <a href="#prod-xquery40-FunctionBody">FunctionBody</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-Annotation">Annotation</a>* (("function" <a href="#prod-xquery40-FunctionSignature">FunctionSignature</a>) | ("-&gt;" <a href="#prod-xquery40-FunctionSignature">FunctionSignature</a>?)) <a href="#prod-xquery40-FunctionBody">FunctionBody</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-Annotation">Annotation</a>* (<span class="deltaxml-new">(</span>"function" <a href="#prod-xquery40-FunctionSignature"><span class="deltaxml-new">FunctionSignature</span></a><span class="deltaxml-new">) </span>| <span class="deltaxml-old">"fn")</span><span class="deltaxml-new">("-&gt;"</span> <a href="#prod-xquery40-FunctionSignature">FunctionSignature</a>?<span class="deltaxml-new">))</span> <a href="#prod-xquery40-FunctionBody">FunctionBody</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-MapConstructor"></a>[<span class="deltaxml-old">208</span><span class="deltaxml-new">195</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-MapConstructor">MapConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"map" "{" (<a href="#prod-xquery40-MapConstructorEntry">MapConstructorEntry</a> ("," <a href="#prod-xquery40-MapConstructorEntry">MapConstructorEntry</a>)*)? "}"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-MapConstructorEntry"></a>[<span class="deltaxml-old">209</span><span class="deltaxml-new">196</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-MapConstructorEntry">MapConstructorEntry</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-MapKeyExpr">MapKeyExpr</a> ":" <a href="#prod-xquery40-MapValueExpr">MapValueExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-MapKeyExpr"></a>[<span class="deltaxml-old">210</span><span class="deltaxml-new">197</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-MapKeyExpr">MapKeyExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-MapValueExpr"></a>[<span class="deltaxml-old">211</span><span class="deltaxml-new">198</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-MapValueExpr">MapValueExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ArrayConstructor"></a>[<span class="deltaxml-old">212</span><span class="deltaxml-new">199</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ArrayConstructor">ArrayConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-SquareArrayConstructor">SquareArrayConstructor</a> | <a href="#prod-xquery40-CurlyArrayConstructor">CurlyArrayConstructor</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SquareArrayConstructor"></a>[<span class="deltaxml-old">213</span><span class="deltaxml-new">200</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SquareArrayConstructor">SquareArrayConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"[" (<a href="#prod-xquery40-ExprSingle">ExprSingle</a> ("," <a href="#prod-xquery40-ExprSingle">ExprSingle</a>)*)? "]"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CurlyArrayConstructor"></a>[<span class="deltaxml-old">214</span><span class="deltaxml-new">201</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CurlyArrayConstructor">CurlyArrayConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"array" <a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-StringTemplate"></a>[<span class="deltaxml-old">215</span><span class="deltaxml-new">202</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-StringTemplate">StringTemplate</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"`" (<a href="#prod-xquery40-StringTemplateFixedPart">StringTemplateFixedPart</a> | <a href="#prod-xquery40-StringTemplateVariablePart">StringTemplateVariablePart</a>)* "`"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-StringTemplateFixedPart"></a>[<span class="deltaxml-old">216</span><span class="deltaxml-new">203</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-StringTemplateFixedPart">StringTemplateFixedPart</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>((<a href="#prod-xquery40-Char">Char</a> - ('{' | '}' | '`')) | "{{" | "}}" | "``")*</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-StringTemplateVariablePart"></a>[<span class="deltaxml-old">217</span><span class="deltaxml-new">204</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-StringTemplateVariablePart">StringTemplateVariablePart</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-StringConstructor"></a>[<span class="deltaxml-old">218</span><span class="deltaxml-new">205</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-StringConstructor">StringConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"``[" <a href="#prod-xquery40-StringConstructorContent">StringConstructorContent</a> "]``"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-StringConstructorContent"></a>[<span class="deltaxml-old">219</span><span class="deltaxml-new">206</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-StringConstructorContent">StringConstructorContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-StringConstructorChars">StringConstructorChars</a> (<a href="#prod-xquery40-StringInterpolation">StringInterpolation</a><a href="#prod-xquery40-StringConstructorChars">StringConstructorChars</a>)*</code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-StringConstructorChars">StringConstructorChars</a> (<a href="#prod-xquery40-StringConstructorInterpolation">StringConstructorInterpolation</a><a href="#prod-xquery40-StringConstructorChars">StringConstructorChars</a>)*</code></span><span class="modify_version"><code><a href="#prod-xquery40-StringConstructorChars">StringConstructorChars</a> (<a href="#prod-xquery40-StringInterpolation"><span class="deltaxml-old">StringInterpolation</span></a><a href="#prod-xquery40-StringConstructorInterpolation"><span class="deltaxml-new">StringConstructorInterpolation</span></a><a href="#prod-xquery40-StringConstructorChars">StringConstructorChars</a>)*</code></span></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-StringConstructorChars"></a>[<span class="deltaxml-old">220</span><span class="deltaxml-new">207</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-StringConstructorChars">StringConstructorChars</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a>* - (Char* ('`{' | ']``') Char*))</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-StringInterpolation"></a><a id="prod-xquery40-StringConstructorInterpolation"></a>[<span class="deltaxml-old">221</span><span class="deltaxml-new">208</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-StringInterpolation">StringInterpolation</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-StringConstructorInterpolation">StringConstructorInterpolation</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-StringInterpolation"><span class="deltaxml-old">StringInterpolation</span></a><a href="#doc-xquery40-StringConstructorInterpolation"><span class="deltaxml-new">StringConstructorInterpolation</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"`{" <a href="#prod-xquery40-Expr">Expr</a>? "}`"</code></td><td><span style="display: none;" class="delete_version"><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></span><span style="display: none;" class="add_version"></span><span class="modify_version"><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></span></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-UnaryLookup"></a>[<span class="deltaxml-old">222</span><span class="deltaxml-new">209</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-UnaryLookup">UnaryLookup</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>("?" | "??") <a href="#prod-xquery40-KeySpecifier">KeySpecifier</a></code></span><span style="display: none;" class="add_version"><code>"?" <a href="#prod-xquery40-KeySpecifier">KeySpecifier</a></code></span><span class="modify_version"><code><span class="deltaxml-old">(</span>"?" <span class="deltaxml-old">| "??") </span><a href="#prod-xquery40-KeySpecifier">KeySpecifier</a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SingleType"></a>[<span class="deltaxml-old">223</span><span class="deltaxml-new">210</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SingleType">SingleType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-CastTarget">CastTarget</a> "?"?</code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-SimpleTypeName">SimpleTypeName</a> "?"?</code></span><span class="modify_version"><code><a href="#prod-xquery40-CastTarget"><span class="deltaxml-old">CastTarget</span></a><a href="#prod-xquery40-SimpleTypeName"><span class="deltaxml-new">SimpleTypeName</span></a> "?"?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-TypeDeclaration"></a>[<span class="deltaxml-old">224</span><span class="deltaxml-new">211</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-TypeDeclaration">TypeDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"as" <a href="#prod-xquery40-SequenceType">SequenceType</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SequenceType"></a>[<span class="deltaxml-old">225</span><span class="deltaxml-new">212</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SequenceType">SequenceType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#prod-xquery40-ItemType">ItemType</a><a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-OccurrenceIndicator"></a>[<span class="deltaxml-old">226</span><span class="deltaxml-new">213</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-OccurrenceIndicator">OccurrenceIndicator</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"?" | "*" | "+"</code></td><td><i>/* <a href="#parse-note-occurrence-indicators">xgc: occurrence-indicators</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ItemType"></a>[<span class="deltaxml-old">227</span><span class="deltaxml-new">214</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ItemType">ItemType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AnyItemTest">AnyItemTest</a> | <a href="#prod-xquery40-TypeName">TypeName</a> | <a href="#prod-xquery40-KindTest">KindTest</a> | <a href="#prod-xquery40-FunctionTest">FunctionTest</a> | <a href="#prod-xquery40-MapTest">MapTest</a> | <a href="#prod-xquery40-ArrayTest">ArrayTest</a> | <a href="#prod-xquery40-AtomicOrUnionType">AtomicOrUnionType</a> | <a href="#prod-xquery40-RecordTest">RecordTest</a> | <a href="#prod-xquery40-LocalUnionType">LocalUnionType</a> | <a href="#prod-xquery40-EnumerationType">EnumerationType</a> | <a href="#prod-xquery40-ParenthesizedItemType">ParenthesizedItemType</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AnyItemTest"></a>[<span class="deltaxml-old">228</span><span class="deltaxml-new">215</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AnyItemTest">AnyItemTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"item" "(" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AtomicOrUnionType"></a>[<span class="deltaxml-old">229</span><span class="deltaxml-new">216</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AtomicOrUnionType">AtomicOrUnionType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-KindTest"></a>[<span class="deltaxml-old">230</span><span class="deltaxml-new">217</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-KindTest">KindTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-DocumentTest">DocumentTest</a><br>| <a href="#prod-xquery40-ElementTest">ElementTest</a><br>| <a href="#prod-xquery40-AttributeTest">AttributeTest</a><br>| <a href="#prod-xquery40-SchemaElementTest">SchemaElementTest</a><br>| <a href="#prod-xquery40-SchemaAttributeTest">SchemaAttributeTest</a><br>| <a href="#prod-xquery40-PITest">PITest</a><br>| <a href="#prod-xquery40-CommentTest">CommentTest</a><br>| <a href="#prod-xquery40-TextTest">TextTest</a><br>| <a href="#prod-xquery40-NamespaceNodeTest">NamespaceNodeTest</a><br>| <a href="#prod-xquery40-AnyKindTest">AnyKindTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AnyKindTest"></a>[<span class="deltaxml-old">231</span><span class="deltaxml-new">218</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AnyKindTest">AnyKindTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"node" "(" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DocumentTest"></a>[<span class="deltaxml-old">232</span><span class="deltaxml-new">219</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DocumentTest">DocumentTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"document-node" "(" (<a href="#prod-xquery40-ElementTest">ElementTest</a> | <a href="#prod-xquery40-SchemaElementTest">SchemaElementTest</a>)? ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-TextTest"></a>[<span class="deltaxml-old">233</span><span class="deltaxml-new">220</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-TextTest">TextTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"text" "(" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CommentTest"></a>[<span class="deltaxml-old">234</span><span class="deltaxml-new">221</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-CommentTest">CommentTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"comment" "(" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-NamespaceNodeTest"></a>[<span class="deltaxml-old">235</span><span class="deltaxml-new">222</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-NamespaceNodeTest">NamespaceNodeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"namespace-node" "(" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-PITest"></a>[<span class="deltaxml-old">236</span><span class="deltaxml-new">223</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PITest">PITest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"processing-instruction" "(" (<a href="#prod-xquery40-NCName">NCName</a> | <a href="#prod-xquery40-StringLiteral">StringLiteral</a>)? ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AttributeTest"></a>[<span class="deltaxml-old">237</span><span class="deltaxml-new">224</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AttributeTest">AttributeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"attribute" "(" (<a href="#prod-xquery40-NameTestUnion">NameTestUnion</a> ("," <a href="#prod-xquery40-TypeName">TypeName</a>)?)? ")"</code></span><span style="display: none;" class="add_version"><code>"attribute" "(" (<a href="#prod-xquery40-NameTest">NameTest</a> ("," <a href="#prod-xquery40-TypeName">TypeName</a>)?)? ")"</code></span><span class="modify_version"><code>"attribute" "(" (<a href="#prod-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a><a href="#prod-xquery40-NameTest"><span class="deltaxml-new">NameTest</span></a> ("," <a href="#prod-xquery40-TypeName">TypeName</a>)?)? ")"</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SchemaAttributeTest"></a>[<span class="deltaxml-old">238</span><span class="deltaxml-new">225</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SchemaAttributeTest">SchemaAttributeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"schema-attribute" "(" <a href="#prod-xquery40-AttributeDeclaration">AttributeDeclaration</a> ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AttributeDeclaration"></a>[<span class="deltaxml-old">239</span><span class="deltaxml-new">226</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AttributeDeclaration">AttributeDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AttributeName">AttributeName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ElementTest"></a>[<span class="deltaxml-old">240</span><span class="deltaxml-new">227</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ElementTest">ElementTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>"element" "(" (<a href="#prod-xquery40-NameTestUnion">NameTestUnion</a> ("," <a href="#prod-xquery40-TypeName">TypeName</a> "?"?)?)? ")"</code></span><span style="display: none;" class="add_version"><code>"element" "(" (<a href="#prod-xquery40-NameTest">NameTest</a> ("," <a href="#prod-xquery40-TypeName">TypeName</a> "?"?)?)? ")"</code></span><span class="modify_version"><code>"element" "(" (<a href="#prod-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnion</span></a><a href="#prod-xquery40-NameTest"><span class="deltaxml-new">NameTest</span></a> ("," <a href="#prod-xquery40-TypeName">TypeName</a> "?"?)?)? ")"</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SchemaElementTest"></a>[<span class="deltaxml-old">241</span><span class="deltaxml-new">228</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-SchemaElementTest">SchemaElementTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"schema-element" "(" <a href="#prod-xquery40-ElementDeclaration">ElementDeclaration</a> ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ElementDeclaration"></a>[<span class="deltaxml-old">242</span><span class="deltaxml-new">229</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ElementDeclaration">ElementDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-ElementName">ElementName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AttributeName"></a>[<span class="deltaxml-old">243</span><span class="deltaxml-new">230</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AttributeName">AttributeName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ElementName"></a>[<span class="deltaxml-old">244</span><span class="deltaxml-new">231</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ElementName">ElementName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CastTarget"></a><a id="prod-xquery40-SimpleTypeName"></a>[<span class="deltaxml-old">245</span><span class="deltaxml-new">232</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>CastTarget</code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-SimpleTypeName">SimpleTypeName</a></code></span><span class="modify_version"><code><span class="deltaxml-old">CastTarget</span><a href="#doc-xquery40-SimpleTypeName"><span class="deltaxml-new">SimpleTypeName</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-TypeName">TypeName</a> | <a href="#prod-xquery40-LocalUnionType">LocalUnionType</a> | <a href="#prod-xquery40-EnumerationType">EnumerationType</a></code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-TypeName">TypeName</a> | <a href="#prod-xquery40-LocalUnionType">LocalUnionType</a></code></span><span class="modify_version"><code><a href="#prod-xquery40-TypeName">TypeName</a> | <a href="#prod-xquery40-LocalUnionType">LocalUnionType</a><span class="deltaxml-old"> | </span><a href="#prod-xquery40-EnumerationType"><span class="deltaxml-old">EnumerationType</span></a></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-TypeName"></a>[<span class="deltaxml-old">246</span><span class="deltaxml-new">233</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-TypeName">TypeName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-FunctionTest"></a>[<span class="deltaxml-old">247</span><span class="deltaxml-new">234</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-FunctionTest">FunctionTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Annotation">Annotation</a>* (<a href="#prod-xquery40-AnyFunctionTest">AnyFunctionTest</a><br>| <a href="#prod-xquery40-TypedFunctionTest">TypedFunctionTest</a>)</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AnyFunctionTest"></a>[<span class="deltaxml-old">248</span><span class="deltaxml-new">235</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AnyFunctionTest">AnyFunctionTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"function" "(" "*" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-TypedFunctionTest"></a>[<span class="deltaxml-old">249</span><span class="deltaxml-new">236</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-TypedFunctionTest">TypedFunctionTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"function" "(" (<a href="#prod-xquery40-SequenceType">SequenceType</a> ("," <a href="#prod-xquery40-SequenceType">SequenceType</a>)*)? ")" "as" <a href="#prod-xquery40-SequenceType">SequenceType</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-MapTest"></a>[<span class="deltaxml-old">250</span><span class="deltaxml-new">237</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-MapTest">MapTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AnyMapTest">AnyMapTest</a> | <a href="#prod-xquery40-TypedMapTest">TypedMapTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AnyMapTest"></a>[<span class="deltaxml-old">251</span><span class="deltaxml-new">238</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AnyMapTest">AnyMapTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"map" "(" "*" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-TypedMapTest"></a>[<span class="deltaxml-old">252</span><span class="deltaxml-new">239</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-TypedMapTest">TypedMapTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"map" "(" <a href="#prod-xquery40-ItemType">ItemType</a> "," <a href="#prod-xquery40-SequenceType">SequenceType</a> ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-RecordTest"></a><span class="deltaxml-old">[253]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-RecordTest"><span class="deltaxml-old">RecordTest</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-AnyRecordTest"><span class="deltaxml-old">AnyRecordTest</span></a><span class="deltaxml-old"> | </span><a href="#prod-xquery40-TypedRecordTest"><span class="deltaxml-old">TypedRecordTest</span></a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AnyRecordTest"></a><span class="deltaxml-old">[254]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-AnyRecordTest"><span class="deltaxml-old">AnyRecordTest</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"record" "(" "*" ")"</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-TypedRecordTest"></a><a id="prod-xquery40-RecordTest"></a>[<span class="deltaxml-old">255</span><span class="deltaxml-new">240</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-TypedRecordTest">TypedRecordTest</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-RecordTest">RecordTest</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-TypedRecordTest"><span class="deltaxml-old">TypedRecordTest</span></a><a href="#doc-xquery40-RecordTest"><span class="deltaxml-new">RecordTest</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"record" "(" <a href="#prod-xquery40-FieldDeclaration">FieldDeclaration</a> ("," <a href="#prod-xquery40-FieldDeclaration">FieldDeclaration</a>)* <a href="#prod-xquery40-ExtensibleFlag">ExtensibleFlag</a>? ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-FieldDeclaration"></a>[<span class="deltaxml-old">256</span><span class="deltaxml-new">241</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-FieldDeclaration">FieldDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-FieldName">FieldName</a> "?"? ("as" <a href="#prod-xquery40-SequenceType">SequenceType</a>)?</code></span><span style="display: none;" class="add_version"><code><a href="#prod-xquery40-FieldName">FieldName</a> "?"? ("as" (<a href="#prod-xquery40-SequenceType">SequenceType</a> | <a href="#prod-xquery40-SelfReference">SelfReference</a>))?</code></span><span class="modify_version"><code><a href="#prod-xquery40-FieldName">FieldName</a> "?"? ("as" <span class="deltaxml-new">(</span><a href="#prod-xquery40-SequenceType">SequenceType</a><span class="deltaxml-new"> | </span><a href="#prod-xquery40-SelfReference"><span class="deltaxml-new">SelfReference</span></a>)<span class="deltaxml-new">)</span>?</code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-FieldName"></a>[<span class="deltaxml-old">257</span><span class="deltaxml-new">242</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-FieldName">FieldName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-NCName">NCName</a> | <a href="#prod-xquery40-StringLiteral">StringLiteral</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-SelfReference"></a><span class="deltaxml-new">[243]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-SelfReference"><span class="deltaxml-new">SelfReference</span></a></code></td><td><span class="deltaxml-new">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new">".." </span><a href="#prod-xquery40-OccurrenceIndicator"><span class="deltaxml-new">OccurrenceIndicator</span></a><span class="deltaxml-new">?</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ExtensibleFlag"></a>[<span class="deltaxml-old">258</span><span class="deltaxml-new">244</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ExtensibleFlag">ExtensibleFlag</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"," "*"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-LocalUnionType"></a>[<span class="deltaxml-old">259</span><span class="deltaxml-new">245</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-LocalUnionType">LocalUnionType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"union" "(" <a href="#prod-xquery40-ItemType">ItemType</a> ("," <a href="#prod-xquery40-ItemType">ItemType</a>)* ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-EnumerationType"></a>[<span class="deltaxml-old">260</span><span class="deltaxml-new">246</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EnumerationType">EnumerationType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"enum" "(" <a href="#prod-xquery40-StringLiteral">StringLiteral</a> ("," <a href="#prod-xquery40-StringLiteral">StringLiteral</a>)* ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ArrayTest"></a>[<span class="deltaxml-old">261</span><span class="deltaxml-new">247</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ArrayTest">ArrayTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-AnyArrayTest">AnyArrayTest</a> | <a href="#prod-xquery40-TypedArrayTest">TypedArrayTest</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AnyArrayTest"></a>[<span class="deltaxml-old">262</span><span class="deltaxml-new">248</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AnyArrayTest">AnyArrayTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"array" "(" "*" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-TypedArrayTest"></a>[<span class="deltaxml-old">263</span><span class="deltaxml-new">249</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-TypedArrayTest">TypedArrayTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"array" "(" <a href="#prod-xquery40-SequenceType">SequenceType</a> ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ParenthesizedItemType"></a>[<span class="deltaxml-old">264</span><span class="deltaxml-new">250</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ParenthesizedItemType">ParenthesizedItemType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" <a href="#prod-xquery40-ItemType">ItemType</a> ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-URILiteral"></a>[<span class="deltaxml-old">265</span><span class="deltaxml-new">251</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-URILiteral">URILiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-StringLiteral">StringLiteral</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-EQName"></a>[<span class="deltaxml-old">266</span><span class="deltaxml-new">252</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EQName">EQName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td><td></td></tr></tbody></table><div class="div3"><h4><a id="EBNFNotation"></a>A.1.1 Notation</h4><p> [<a id="symbol" title="symbol">Definition</a>: Each rule in the grammar defines one <b>symbol</b>, using the following format: </p><div class="exampleInner"><pre>symbol ::= expression</pre></div><p> ] </p><p> [<a id="terminal" title="terminal">Definition</a>: A <b>terminal</b> is a symbol or string or pattern that can appear in the right-hand side of a rule, but never appears on the left-hand side in the main grammar, although it may appear on the left-hand side of a rule in the grammar for terminals.] The following constructs are used to match strings of one or more characters in a terminal:</p><dl><dt class="label">[a-zA-Z]</dt><dd><p>matches any <a href="#prod-xquery40-Char">Char</a> with a value in the range(s) indicated (inclusive).</p></dd><dt class="label">[abc]</dt><dd><p>matches any <a href="#prod-xquery40-Char">Char</a> with a value among the characters enumerated. </p></dd><dt class="label">[^abc]</dt><dd><p>matches any <a href="#prod-xquery40-Char">Char</a> with a value not among the characters given.</p></dd><dt class="label">"string"</dt><dd><p>matches the sequence of characters that appear inside the double quotes.</p></dd><dt class="label">'string'</dt><dd><p>matches the sequence of characters that appear inside the single quotes.</p></dd><dt class="label"> [http://www.w3.org/TR/REC-example/#NT-Example]</dt><dd><p>matches any string matched by the production defined in the external specification as per the provided reference.</p></dd></dl><p>Patterns (including the above constructs) can be combined with grammatical operators to form more complex patterns, matching more complex sets of character strings. In the examples that follow, A and B represent (sub-)patterns.</p><dl><dt class="label">(A)</dt><dd><p><code>A</code> is treated as a unit and may be combined as described in this list.</p></dd><dt class="label">A?</dt><dd><p>matches <code>A</code> or nothing; optional <code>A</code>.</p></dd><dt class="label">A B</dt><dd><p>matches <code>A</code> followed by <code>B</code>. This operator has higher precedence than alternation; thus <code>A B | C D</code> is identical to <code>(A B) | (C D)</code>.</p></dd><dt class="label">A | B</dt><dd><p>matches <code>A</code> or <code>B</code> but not both.</p></dd><dt class="label">A - B</dt><dd><p>matches any string that matches <code>A</code> but does not match <code>B</code>.</p></dd><dt class="label">A+</dt><dd><p>matches one or more occurrences of <code>A</code>. Concatenation has higher precedence than alternation; thus <code>A+ | B+</code> is identical to <code>(A+) | (B+)</code>.</p></dd></dl><dl><dt class="label">A*</dt><dd><p>matches zero or more occurrences of <code>A</code>. Concatenation has higher precedence than alternation; thus <code>A* | B*</code> is identical to <code>(A*) | (B*)</code></p></dd></dl></div><div class="div3"><h4><a id="extra-grammatical-constraints"></a>A.1.2 Extra-grammatical Constraints</h4><p>This section contains constraints on the EBNF productions, which are required to parse syntactically valid sentences. The notes below are referenced from the right side of the production, with the notation: <em>/* xgc: &lt;id&gt; */</em>.</p><div class="constraint"><p class="prefix"><a id="parse-note-leading-lone-slash"></a><b>Constraint: leading-lone-slash</b></p><p>A single slash may appear either as a complete path expression or as the first part of a path expression in which it is followed by a <a href="#doc-xquery40-RelativePathExpr">RelativePathExpr</a>. In some cases, the next token after the slash is insufficient to allow a parser to distinguish these two possibilities: the <code>*</code> token and keywords like <code>union</code> could be either an operator or a <a href="#doc-xquery40-NameTest">NameTest</a><span class="xquery">, and the <code>&lt;</code> token could be either an operator or the start of a <a href="#doc-xquery40-DirectConstructor"> DirectConstructor</a></span>. For example, without lookahead the first part of the expression <code>/ * 5</code> is easily taken to be a complete expression, <code>/ *</code>, which has a very different interpretation (the child nodes of <code>/</code>).</p><p>If the token immediately following a slash can form the start of a <a href="#doc-xquery40-RelativePathExpr">RelativePathExpr</a>, then the slash must be the beginning of a <a href="#doc-xquery40-PathExpr">PathExpr</a>, not the entirety of it.</p><p>A single slash may be used as the left-hand argument of an operator by parenthesizing it: <code>(/) * 5</code>. The expression <code>5 * /</code>, on the other hand, is syntactically valid without parentheses.</p></div><div class="constraint"><p class="prefix"><a id="parse-note-xml-version"></a><b>Constraint: xml-version</b></p><p><span style="display: none;" class="delete_version">The version of XML and XML Names (e.g. <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a>, or <a href="#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a>) is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. It is recommended that the latest applicable version be used (even if it is published later than this specification). The EBNF in this specification links only to the 1.0 versions. Note also that these external productions follow the whitespace rules of their respective specifications, and not the rules of this specification, in particular <a href="#DefaultWhitespaceHandling"><span class="delete_version"><b>A.3.5.1 Default Whitespace Handling</b></span><span class="modify_version"><b>A.3.5.1 Default Whitespace Handling</b></span></a>. Thus <code>prefix : localname</code> is not a syntactically valid <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> for purposes of this specification, just as it is not permitted in a XML document. Also, comments are not permissible on either side of the colon. Also extra-grammatical constraints such as well-formedness constraints must be taken into account.</span><span style="display: none;" class="add_version">The version of XML and XML Names (e.g. <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a>, or <a href="#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a>) is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. It is recommended that the latest applicable version be used (even if it is published later than this specification). The EBNF in this specification links only to the 1.0 versions. Note also that these external productions follow the whitespace rules of their respective specifications, and not the rules of this specification, in particular <a href="#DefaultWhitespaceHandling"><span class="add_version"><b>A.2.4.1 Default Whitespace Handling</b></span><span class="modify_version"><b>A.2.4.1 Default Whitespace Handling</b></span></a>. Thus <code>prefix : localname</code> is not a syntactically valid <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> for purposes of this specification, just as it is not permitted in a XML document. Also, comments are not permissible on either side of the colon. Also extra-grammatical constraints such as well-formedness constraints must be taken into account.</span><span class="modify_version">The version of XML and XML Names (e.g. <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a>, or <a href="#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a>) is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. It is recommended that the latest applicable version be used (even if it is published later than this specification). The EBNF in this specification links only to the 1.0 versions. Note also that these external productions follow the whitespace rules of their respective specifications, and not the rules of this specification, in particular <a href="#DefaultWhitespaceHandling"><span style="display: none;" class="delete_version"><b>A.3.5.1 Default Whitespace Handling</b></span><span style="display: none;" class="add_version"><b>A.2.4.1 Default Whitespace Handling</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">3.5.1</span><span class="deltaxml-new">2.4.1</span> Default Whitespace Handling</b></span></a>. Thus <code>prefix : localname</code> is not a syntactically valid <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> for purposes of this specification, just as it is not permitted in a XML document. Also, comments are not permissible on either side of the colon. Also extra-grammatical constraints such as well-formedness constraints must be taken into account.</span></p><p class="xquery">XML 1.0 and XML 1.1 differ in their handling of C0 control characters (specifically #x1 through #x1F, excluding #x9, #xA, and #xD) and C1 control characters (#x7F through #x9F). In XML 1.0, these C0 characters are prohibited, and the C1 characters are permitted. In XML 1.1, both sets of control characters are permitted, but only if written as character references. It is RECOMMENDED that implementations should follow the XML 1.1 rules in this respect; however, for backwards compatibility with <span class="xquery">XQuery 1.0</span> , implementations MAY allow C1 control characters to be used directly. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Direct use of C1 control characters often suggests a character encoding error, such as using encoding CP-1252 and mislabeling it as iso-8859-1.</p></div></div><div class="constraint"><p class="prefix"><a id="parse-note-reserved-function-names"></a><b>Constraint: reserved-function-names</b></p><p><span style="display: none;" class="delete_version">Unprefixed function names spelled the same way as language keywords could make the language impossible to parse. For instance, <code>element(foo)</code> could be taken either as a <a href="#doc-xquery40-FunctionCall">FunctionCall</a> or as an <a href="#doc-xquery40-ElementTest">ElementTest</a>. Therefore, an unprefixed function name must not be any of the names in <a href="#id-reserved-fn-names"><span class="delete_version"><b>A.4 Reserved Function Names</b></span><span class="modify_version"><b>A.4 Reserved Function Names</b></span></a>.</span><span style="display: none;" class="add_version">Unprefixed function names spelled the same way as language keywords could make the language impossible to parse. For instance, <code>element(foo)</code> could be taken either as a <a href="#doc-xquery40-FunctionCall">FunctionCall</a> or as an <a href="#doc-xquery40-ElementTest">ElementTest</a>. Therefore, an unprefixed function name must not be any of the names in <a href="#id-reserved-fn-names"><span class="add_version"><b>A.3 Reserved Function Names</b></span><span class="modify_version"><b>A.3 Reserved Function Names</b></span></a>.</span><span class="modify_version">Unprefixed function names spelled the same way as language keywords could make the language impossible to parse. For instance, <code>element(foo)</code> could be taken either as a <a href="#doc-xquery40-FunctionCall">FunctionCall</a> or as an <a href="#doc-xquery40-ElementTest">ElementTest</a>. Therefore, an unprefixed function name must not be any of the names in <a href="#id-reserved-fn-names"><span style="display: none;" class="delete_version"><b>A.4 Reserved Function Names</b></span><span style="display: none;" class="add_version"><b>A.3 Reserved Function Names</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">4</span><span class="deltaxml-new">3</span> Reserved Function Names</b></span></a>.</span></p><p><span style="display: none;" class="delete_version">A function named <code>if</code> can be called by binding its namespace to a prefix and using the prefixed form: <code>library:if(foo)</code> instead of <code>if(foo)</code>.</span><span style="display: none;" class="add_version">A function named "if" can be called by binding its namespace to a prefix and using the prefixed form: "library:if(foo)" instead of "if(foo)".</span><span class="modify_version">A function named <span class="deltaxml-new">"</span>if<span class="deltaxml-new">"</span> can be called by binding its namespace to a prefix and using the prefixed form: <span class="deltaxml-new">"</span>library:if(foo)<span class="deltaxml-new">"</span> instead of <span class="deltaxml-new">"</span>if(foo)<span class="deltaxml-new">"</span>.</span></p></div><div class="constraint"><p class="prefix"><a id="parse-note-occurrence-indicators"></a><b>Constraint: occurrence-indicators</b></p><p><span style="display: none;" class="delete_version">As written, the grammar in <a href="#nt-bnf"><b>A XQuery 4.0 Grammar</b></a> is ambiguous for some forms using the <code>"+"</code>, <code>"?"</code> and <code>"*"</code><a href="#doc-xquery40-OccurrenceIndicator">OccurrenceIndicators</a>. The ambiguity is resolved as follows: these operators are tightly bound to the <a href="#doc-xquery40-SequenceType">SequenceType</a> expression, and have higher precedence than other uses of these symbols. Any occurrence of <code>"+"</code>, <code>"?"</code> or <code>"*"</code>, that follows a sequence type is assumed to be an occurrence indicator, which binds to the last <a href="#doc-xquery40-ItemType">ItemType</a> in the <a href="#doc-xquery40-SequenceType">SequenceType</a>.</span><span style="display: none;" class="add_version">As written, the grammar in <a href="#nt-bnf"><b>A XQuery 4.0 Grammar</b></a> is ambiguous for some forms using the '+' and '*' occurrence indicators. The ambiguity is resolved as follows: these operators are tightly bound to the <a href="#doc-xquery40-SequenceType">SequenceType</a> expression, and have higher precedence than other uses of these symbols. Any occurrence of '+' and '*', as well as '?', following a sequence type is assumed to be an occurrence indicator, which binds to the last <a href="#doc-xquery40-ItemType">ItemType</a> in the <a href="#doc-xquery40-SequenceType">SequenceType</a>.</span><span class="modify_version">As written, the grammar in <a href="#nt-bnf"><b>A XQuery 4.0 Grammar</b></a> is ambiguous for some forms using the <span class="deltaxml-old">"+"</span><span class="deltaxml-new">'+'</span><span class="deltaxml-old">,</span> <span class="deltaxml-old">"?"</span><span class="deltaxml-old"> </span>and <span class="deltaxml-old">"*"</span><span class="deltaxml-new">'*'</span><a href="#doc-xquery40-OccurrenceIndicator"><span class="deltaxml-old">OccurrenceIndicators</span></a><span class="deltaxml-new"> </span><span class="deltaxml-new">occurrence indicators</span>. The ambiguity is resolved as follows: these operators are tightly bound to the <a href="#doc-xquery40-SequenceType">SequenceType</a> expression, and have higher precedence than other uses of these symbols. Any occurrence of <span class="deltaxml-old">"+"</span><span class="deltaxml-new">'+'</span><span class="deltaxml-new"> and '*'</span>, <span class="deltaxml-old">"?"</span><span class="deltaxml-new">as</span> <span class="deltaxml-old">or</span><span class="deltaxml-new">well</span> <span class="deltaxml-old">"*"</span><span class="deltaxml-new">as '?'</span>, <span class="deltaxml-old">that follows</span><span class="deltaxml-new">following</span> a sequence type is assumed to be an occurrence indicator, which binds to the last <a href="#doc-xquery40-ItemType">ItemType</a> in the <a href="#doc-xquery40-SequenceType">SequenceType</a>.</span></p><p><span style="display: none;" class="delete_version">Thus, <code>4 treat as item() + - 5</code> must be interpreted as <code>(4 treat as item()+) - 5</code>, taking the '+' as an occurrence indicator and the '-' as a subtraction operator. To force the interpretation of "+" as an addition operator (and the corresponding interpretation of the "-" as a unary minus), parentheses may be used: the form <code>(4 treat as item()) + -5</code> surrounds the <a href="#doc-xquery40-SequenceType">SequenceType</a> expression with parentheses and leads to the desired interpretation.</span><span style="display: none;" class="add_version">Thus, <code>4 treat as item() + - 5</code> must be interpreted as <code>(4 treat as item()+) - 5</code>, taking the '+' as an OccurrenceIndicator and the '-' as a subtraction operator. To force the interpretation of "+" as an addition operator (and the corresponding interpretation of the "-" as a unary minus), parentheses may be used: the form <code>(4 treat as item()) + -5</code> surrounds the <a href="#doc-xquery40-SequenceType">SequenceType</a> expression with parentheses and leads to the desired interpretation.</span><span class="modify_version">Thus, <code>4 treat as item() + - 5</code> must be interpreted as <code>(4 treat as item()+) - 5</code>, taking the '+' as an <span class="deltaxml-old">occurrence indicator</span><span class="deltaxml-new">OccurrenceIndicator</span> and the '-' as a subtraction operator. To force the interpretation of "+" as an addition operator (and the corresponding interpretation of the "-" as a unary minus), parentheses may be used: the form <code>(4 treat as item()) + -5</code> surrounds the <a href="#doc-xquery40-SequenceType">SequenceType</a> expression with parentheses and leads to the desired interpretation.</span></p><p><code>function () as xs:string *</code> is interpreted as <code>function () as (xs:string *)</code>, not as <code>(function () as xs:string) *</code>. Parentheses can be used as shown to force the latter interpretation.</p><p><span style="display: none;" class="delete_version">This rule has as a consequence that certain forms which would otherwise be syntactically valid and unambiguous are not recognized: in <code>4 treat as item() + 5</code>, the <code>"+"</code> is taken as an <a href="#doc-xquery40-OccurrenceIndicator">OccurrenceIndicator</a>, and not as an operator, which means this is not a syntactically valid expression.</span><span style="display: none;" class="add_version">This rule has as a consequence that certain forms which would otherwise be syntactically valid and unambiguous are not recognized: in "4 treat as item() + 5", the "+" is taken as an <a href="#doc-xquery40-OccurrenceIndicator">OccurrenceIndicator</a>, and not as an operator, which means this is not a syntactically valid expression.</span><span class="modify_version">This rule has as a consequence that certain forms which would otherwise be syntactically valid and unambiguous are not recognized: in <span class="deltaxml-new">"</span>4 treat as item() + 5<span class="deltaxml-new">"</span>, the "+" is taken as an <a href="#doc-xquery40-OccurrenceIndicator">OccurrenceIndicator</a>, and not as an operator, which means this is not a syntactically valid expression.</span></p></div></div><div class="div3"><h4><a id="notes-on-parsing"></a>A.1.3 Grammar Notes</h4><p>This section contains general notes on the EBNF productions, which may be helpful in understanding how to interpret and implement the EBNF. These notes are not normative. The notes below are referenced from the right side of the production, with the notation: <em>/* gn: &lt;id&gt; */</em>.</p><div class="note"><p class="prefix"><b>Note:</b></p><dl><dt class="label"><a id="parse-note-parens"></a>grammar-note: parens</dt><dd><p><span style="display: none;" class="delete_version">Lookahead is required to distinguish a <a href="#doc-xquery40-FunctionCall">FunctionCall</a> from an EQName or keyword followed by a <span class="xquery"><a href="#doc-xquery40-Pragma">Pragma</a> or </span><a href="#doc-xquery40-Comment">Comment</a>. For example: <code>address (: this may be empty :)</code> may be mistaken for a call to a function named "address" unless this lookahead is employed. Another example is <code>for (: whom the bell :) $tolls in 3 return $tolls</code>, where the keyword "for" must not be mistaken for a function name.</span><span style="display: none;" class="add_version">Look-ahead is required to distinguish <a href="#doc-xquery40-FunctionCall">FunctionCall</a> from a EQName or keyword followed by a <span class="xquery"><a href="#doc-xquery40-Pragma">Pragma</a> or </span><a href="#doc-xquery40-Comment">Comment</a>. For example: <code>address (: this may be empty :)</code> may be mistaken for a call to a function named "address" unless this lookahead is employed. Another example is <code>for (: whom the bell :) $tolls in 3 return $tolls</code>, where the keyword "for" must not be mistaken for a function name.</span><span class="modify_version"><span class="deltaxml-old">Lookahead</span><span class="deltaxml-new">Look-ahead</span> is required to distinguish <span class="deltaxml-old">a </span><a href="#doc-xquery40-FunctionCall">FunctionCall</a> from <span class="deltaxml-old">an</span><span class="deltaxml-new">a</span> EQName or keyword followed by a <span class="xquery"><a href="#doc-xquery40-Pragma">Pragma</a> or </span><a href="#doc-xquery40-Comment">Comment</a>. For example: <code>address (: this may be empty :)</code> may be mistaken for a call to a function named "address" unless this lookahead is employed. Another example is <code>for (: whom the bell :) $tolls in 3 return $tolls</code>, where the keyword "for" must not be mistaken for a function name.</span></p></dd><dt class="label"><a id="parse-note-comments"></a>grammar-note: comments</dt><dd><p><span style="display: none;" class="delete_version">Comments are allowed everywhere that <a title="ignorable whitespace" class="termref" href="#IgnorableWhitespace">ignorable whitespace</a> is allowed, and the <a href="#doc-xquery40-Comment">Comment</a> symbol does not explicitly appear on the right-hand side of the grammar (except in its own production). See <a href="#DefaultWhitespaceHandling"><span class="delete_version"><b>A.3.5.1 Default Whitespace Handling</b></span><span class="modify_version"><b>A.3.5.1 Default Whitespace Handling</b></span></a>. <span class="xquery">Note that comments are not allowed in direct constructor content, though they are allowed in nested <a href="#doc-xquery40-EnclosedExpr"> EnclosedExprs</a>.</span></span><span style="display: none;" class="add_version">Comments are allowed everywhere that <a title="ignorable whitespace" class="termref" href="#IgnorableWhitespace">ignorable whitespace</a> is allowed, and the <a href="#doc-xquery40-Comment">Comment</a> symbol does not explicitly appear on the right-hand side of the grammar (except in its own production). See <a href="#DefaultWhitespaceHandling"><span class="add_version"><b>A.2.4.1 Default Whitespace Handling</b></span><span class="modify_version"><b>A.2.4.1 Default Whitespace Handling</b></span></a>. <span class="xquery">Note that comments are not allowed in direct constructor content, though they are allowed in nested <a href="#doc-xquery40-EnclosedExpr"> EnclosedExprs</a>.</span></span><span class="modify_version">Comments are allowed everywhere that <a title="ignorable whitespace" class="termref" href="#IgnorableWhitespace">ignorable whitespace</a> is allowed, and the <a href="#doc-xquery40-Comment">Comment</a> symbol does not explicitly appear on the right-hand side of the grammar (except in its own production). See <a href="#DefaultWhitespaceHandling"><span style="display: none;" class="delete_version"><b>A.3.5.1 Default Whitespace Handling</b></span><span style="display: none;" class="add_version"><b>A.2.4.1 Default Whitespace Handling</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">3.5.1</span><span class="deltaxml-new">2.4.1</span> Default Whitespace Handling</b></span></a>. <span class="xquery">Note that comments are not allowed in direct constructor content, though they are allowed in nested <a href="#doc-xquery40-EnclosedExpr"> EnclosedExprs</a>.</span></span></p><p><span style="display: none;" class="delete_version">A comment can contain nested comments, as long as all <code>"(:"</code> and <code>":)"</code> patterns are balanced, no matter where they occur within the outer comment.</span><span style="display: none;" class="add_version">A comment can contain nested comments, as long as all "(:" and ":)" patterns are balanced, no matter where they occur within the outer comment.</span><span class="modify_version">A comment can contain nested comments, as long as all "(:" and ":)" patterns are balanced, no matter where they occur within the outer comment.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">Lexical analysis may typically handle nested comments by incrementing a counter for each <code>"(:"</code> pattern, and decrementing the counter for each <code>":)"</code> pattern. The comment does not terminate until the counter is back to zero.</span><span style="display: none;" class="add_version">Lexical analysis may typically handle nested comments by incrementing a counter for each "(:" pattern, and decrementing the counter for each ":)" pattern. The comment does not terminate until the counter is back to zero.</span><span class="modify_version">Lexical analysis may typically handle nested comments by incrementing a counter for each "(:" pattern, and decrementing the counter for each ":)" pattern. The comment does not terminate until the counter is back to zero.</span></p></div><p>Some illustrative examples:</p><ul><li><p><span style="display: none;" class="delete_version"><code>(: commenting out a (: comment :) may be confusing, but often helpful :)</code> is a syntactically valid <a href="#doc-xquery40-Comment">Comment</a>, since balanced nesting of comments is allowed.</span><span style="display: none;" class="add_version"><code>(: commenting out a (: comment :) may be confusing, but often helpful :)</code> is a syntactically valid Comment, since balanced nesting of comments is allowed.</span><span class="modify_version"><code>(: commenting out a (: comment :) may be confusing, but often helpful :)</code> is a syntactically valid <a href="#doc-xquery40-Comment"><span class="deltaxml-old">Comment</span></a><span class="deltaxml-new">Comment</span>, since balanced nesting of comments is allowed.</span></p></li><li><p><code>"this is just a string :)"</code> is a syntactically valid expression. However, <code>(: "this is just a string :)" :)</code> will cause a syntax error. Likewise, <code>"this is another string (:"</code> is a syntactically valid expression, but <code>(: "this is another string (:" :)</code> will cause a syntax error. It is a limitation of nested comments that literal content can cause unbalanced nesting of comments.</p></li><li><p><code>for (: set up loop :) $i in $x return $i</code> is syntactically valid, ignoring the comment.</p></li><li><p><code>5 instance (: strange place for a comment :) of xs:integer</code> is also syntactically valid.</p></li><li class="xquery"><p><code> &lt;eg (: an example:)&gt;{$i//title}&lt;/eg&gt; </code> is not syntactically valid.</p></li><li class="xquery"><p><code> &lt;eg&gt; (: an example:) &lt;/eg&gt; </code> is syntactically valid, but the characters that look like a comment are in fact literal element content.</p></li></ul></dd></dl></div></div></div><div class="div2"><h3><a id="productions-derived-from-XML"></a><span class="deltaxml-old">A.2 Productions Derived from XML</span></h3><p><span class="deltaxml-old">Some productions are defined by reference to the XML and XML Names specifications (e.g. </span><a href="#XML"><span class="deltaxml-old">[XML 1.0]</span></a><span class="deltaxml-old"> and </span><a href="#XMLNAMES"><span class="deltaxml-old">[XML Names]</span></a><span class="deltaxml-old">, or </span><a href="#XML1.1"><span class="deltaxml-old">[XML 1.1]</span></a><span class="deltaxml-old"> and </span><a href="#XMLNAMES11"><span class="deltaxml-old">[XML Names 1.1]</span></a><span class="deltaxml-old">. </span><span class="xquery"><span class="deltaxml-old">It is implementation-defined</span></span><span class="deltaxml-old"> which version of these specifications is used; it is recommended that the latest applicable version be used (even if it is published later than this specification).</span></p><p class="xquery"><span class="deltaxml-old">It is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-old"> implementation-defined</span></a><span class="deltaxml-old"> whether the lexical rules of </span><a href="#XML"><span class="deltaxml-old">[XML 1.0]</span></a><span class="deltaxml-old"> and </span><a href="#XMLNAMES"><span class="deltaxml-old">[XML Names]</span></a><span class="deltaxml-old"> are followed, or alternatively, the lexical rules of </span><a href="#XML1.1"><span class="deltaxml-old">[XML 1.1]</span></a><span class="deltaxml-old"> and </span><a href="#XMLNAMES11"><span class="deltaxml-old">[XML Names 1.1]</span></a><span class="deltaxml-old"> are followed. Implementations that support the full </span><a href="#XML1.1"><span class="deltaxml-old">[XML 1.1]</span></a><span class="deltaxml-old"> character set </span><a title="should" class="termref" href="#should"><span class="deltaxml-old">SHOULD</span></a><span class="deltaxml-old">, for purposes of interoperability, provide a mode that follows only the </span><a href="#XML"><span class="deltaxml-old">[XML 1.0]</span></a><span class="deltaxml-old"> and </span><a href="#XMLNAMES"><span class="deltaxml-old">[XML Names]</span></a><span class="deltaxml-old"> lexical rules.</span></p></div><div class="div2"><h3><a id="lexical-structure"></a>A.<span class="deltaxml-old">3</span><span class="deltaxml-new">2</span> Lexical structure</h3><p><span class="deltaxml-old">This section describes how an XQuery 4.0 text is tokenized prior to parsing.</span></p><p><span class="deltaxml-new">The terminal symbols assumed by the grammar above are described in this section.</span></p><p><span class="deltaxml-new">Quoted strings appearing in production rules are terminal symbols.</span></p><p><span class="deltaxml-new">Other terminal symbols are defined in </span><a href="#terminal-symbols"><b><span class="deltaxml-new">A.2.1 Terminal Symbols</span></b></a><span class="deltaxml-new">.</span></p><p><span class="deltaxml-new">Some productions are defined by reference to the XML and XML Names specifications (e.g. </span><a href="#XML"><span class="deltaxml-new">[XML 1.0]</span></a><span class="deltaxml-new"> and </span><a href="#XMLNAMES"><span class="deltaxml-new">[XML Names]</span></a><span class="deltaxml-new">, or </span><a href="#XML1.1"><span class="deltaxml-new">[XML 1.1]</span></a><span class="deltaxml-new"> and </span><a href="#XMLNAMES11"><span class="deltaxml-new">[XML Names 1.1]</span></a><span class="deltaxml-new"> . </span><span class="xquery"><span class="deltaxml-new">It is implementation-defined</span></span><span class="deltaxml-new"> which version of these specifications is used; it is recommended that the latest applicable version be used (even if it is published later than this specification).</span></p><p class="xquery"><span class="deltaxml-new">It is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new"> implementation-defined</span></a><span class="deltaxml-new"> whether the lexical rules of </span><a href="#XML"><span class="deltaxml-new">[XML 1.0]</span></a><span class="deltaxml-new"> and </span><a href="#XMLNAMES"><span class="deltaxml-new">[XML Names]</span></a><span class="deltaxml-new"> are followed, or alternatively, the lexical rules of </span><a href="#XML1.1"><span class="deltaxml-new">[XML 1.1]</span></a><span class="deltaxml-new"> and </span><a href="#XMLNAMES11"><span class="deltaxml-new">[XML Names 1.1]</span></a><span class="deltaxml-new"> are followed. Implementations that support the full </span><a href="#XML1.1"><span class="deltaxml-new">[XML 1.1]</span></a><span class="deltaxml-new"> character set </span><a title="should" class="termref" href="#should"><span class="deltaxml-new">SHOULD</span></a><span class="deltaxml-new">, for purposes of interoperability, provide a mode that follows only the </span><a href="#XML"><span class="deltaxml-new">[XML 1.0]</span></a><span class="deltaxml-new"> and </span><a href="#XMLNAMES"><span class="deltaxml-new">[XML Names]</span></a><span class="deltaxml-new"> lexical rules.</span></p><p><span class="deltaxml-new">When tokenizing, the longest possible match that is consistent with the EBNF is used.</span></p><p>All keywords are case sensitive. Keywords are not reserved—that is, any <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> may duplicate a keyword except as noted in <a href="#id-reserved-fn-names"><span style="display: none;" class="delete_version"><b>A.4 Reserved Function Names</b></span><span style="display: none;" class="add_version"><b>A.3 Reserved Function Names</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">4</span><span class="deltaxml-new">3</span> Reserved Function Names</b></span></a>.</p><p><span class="deltaxml-old">Tokenizing an input string is a process that follows the following rules:</span></p><ul><li><p><span class="deltaxml-old"> [</span><a id="dt-ordinary-production-rule" title="ordinary production rule"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: An </span><b><span class="deltaxml-old">ordinary production rule</span></b><span class="deltaxml-old"> is a production rule in </span><a href="#id-grammar"><b><span class="deltaxml-old">A.1 EBNF</span></b></a><span class="deltaxml-old"> that is not annotated </span><code><span class="deltaxml-old">ws:explicit</span></code><span class="deltaxml-old">.] </span></p></li><li><p><span class="deltaxml-old"> [</span><a id="dt-literal-terminal" title="literal terminal"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">literal terminal</span></b><span class="deltaxml-old"> is a token appearing as a string in quotation marks on the right-hand side of an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-old">ordinary production rule</span></a><span class="deltaxml-old">.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Strings that appear in other production rules do not qualify. </span><span class="xquery"><span class="deltaxml-old">For example, </span><code><span class="deltaxml-old">"]]&gt;"</span></code><span class="deltaxml-old"> is not a literal terminal, because it appears only in the rule </span><a href="#doc-xquery40-CDataSection"><span class="deltaxml-old">CDataSection</span></a><span class="deltaxml-old">, which is not an ordinary production rule; similarly </span><a href="#doc-xquery40-BracedURILiteral"><span class="deltaxml-old">BracedURILiteral</span></a><span class="deltaxml-old"> does not qualify because it appears only in </span><a href="#doc-xquery40-URIQualifiedName"><span class="deltaxml-old">URIQualifiedName</span></a><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">"0x"</span></code><span class="deltaxml-old"> does not qualify because it appears only in </span><a href="#doc-xquery40-HexIntegerLiteral"></a><span class="deltaxml-old">.</span></span></p></div><p><span class="deltaxml-old"> The </span><a title="literal terminal" class="termref" href="#dt-literal-terminal"><span class="deltaxml-old">literal terminals</span></a><span class="deltaxml-old"> in XQuery 4.0 are: </span><code><span class="deltaxml-old">!</span></code><code><span class="deltaxml-old">!=</span></code><code><span class="deltaxml-old">#</span></code><code><span class="deltaxml-old">$</span></code><code><span class="deltaxml-old">%</span></code><code><span class="deltaxml-old">(</span></code><code><span class="deltaxml-old">)</span></code><code><span class="deltaxml-old">*</span></code><code><span class="deltaxml-old">+</span></code><code><span class="deltaxml-old">,</span></code><code><span class="deltaxml-old">.</span></code><code><span class="deltaxml-old">..</span></code><code><span class="deltaxml-old">/</span></code><code><span class="deltaxml-old">//</span></code><code><span class="deltaxml-old">:</span></code><code><span class="deltaxml-old">::</span></code><code><span class="deltaxml-old">:=</span></code><code><span class="deltaxml-old">;</span></code><code><span class="deltaxml-old">&lt;</span></code><code><span class="deltaxml-old">&lt;&lt;</span></code><code><span class="deltaxml-old">&lt;=</span></code><code><span class="deltaxml-old">=</span></code><code><span class="deltaxml-old">=!&gt;</span></code><code><span class="deltaxml-old">=&gt;</span></code><code><span class="deltaxml-old">=?&gt;</span></code><code><span class="deltaxml-old">&gt;</span></code><code><span class="deltaxml-old">&gt;=</span></code><code><span class="deltaxml-old">&gt;&gt;</span></code><code><span class="deltaxml-old">?</span></code><code><span class="deltaxml-old">??</span></code><code><span class="deltaxml-old">@</span></code><code><span class="deltaxml-old">[</span></code><code><span class="deltaxml-old">]</span></code><code><span class="deltaxml-old">{</span></code><code><span class="deltaxml-old">|</span></code><code><span class="deltaxml-old">||</span></code><code><span class="deltaxml-old">}</span></code><code><span class="deltaxml-old">×</span></code><code><span class="deltaxml-old">÷</span></code><code><span class="deltaxml-old">-</span></code><code><span class="deltaxml-old">allowing</span></code><code><span class="deltaxml-old">ancestor</span></code><code><span class="deltaxml-old">ancestor-or-self</span></code><code><span class="deltaxml-old">and</span></code><code><span class="deltaxml-old">array</span></code><code><span class="deltaxml-old">as</span></code><code><span class="deltaxml-old">ascending</span></code><code><span class="deltaxml-old">at</span></code><code><span class="deltaxml-old">attribute</span></code><code><span class="deltaxml-old">base-uri</span></code><code><span class="deltaxml-old">boundary-space</span></code><code><span class="deltaxml-old">by</span></code><code><span class="deltaxml-old">case</span></code><code><span class="deltaxml-old">cast</span></code><code><span class="deltaxml-old">castable</span></code><code><span class="deltaxml-old">catch</span></code><code><span class="deltaxml-old">child</span></code><code><span class="deltaxml-old">collation</span></code><code><span class="deltaxml-old">comment</span></code><code><span class="deltaxml-old">construction</span></code><code><span class="deltaxml-old">context</span></code><code><span class="deltaxml-old">copy-namespaces</span></code><code><span class="deltaxml-old">count</span></code><code><span class="deltaxml-old">decimal-format</span></code><code><span class="deltaxml-old">decimal-separator</span></code><code><span class="deltaxml-old">declare</span></code><code><span class="deltaxml-old">default</span></code><code><span class="deltaxml-old">descendant</span></code><code><span class="deltaxml-old">descendant-or-self</span></code><code><span class="deltaxml-old">descending</span></code><code><span class="deltaxml-old">digit</span></code><code><span class="deltaxml-old">div</span></code><code><span class="deltaxml-old">document</span></code><code><span class="deltaxml-old">document-node</span></code><code><span class="deltaxml-old">element</span></code><code><span class="deltaxml-old">else</span></code><code><span class="deltaxml-old">empty</span></code><code><span class="deltaxml-old">empty-sequence</span></code><code><span class="deltaxml-old">encoding</span></code><code><span class="deltaxml-old">end</span></code><code><span class="deltaxml-old">enum</span></code><code><span class="deltaxml-old">eq</span></code><code><span class="deltaxml-old">every</span></code><code><span class="deltaxml-old">except</span></code><code><span class="deltaxml-old">exponent-separator</span></code><code><span class="deltaxml-old">external</span></code><code><span class="deltaxml-old">false</span></code><code><span class="deltaxml-old">fixed</span></code><code><span class="deltaxml-old">fn</span></code><code><span class="deltaxml-old">following</span></code><code><span class="deltaxml-old">following-sibling</span></code><code><span class="deltaxml-old">for</span></code><code><span class="deltaxml-old">function</span></code><code><span class="deltaxml-old">ge</span></code><code><span class="deltaxml-old">greatest</span></code><code><span class="deltaxml-old">group</span></code><code><span class="deltaxml-old">grouping-separator</span></code><code><span class="deltaxml-old">gt</span></code><code><span class="deltaxml-old">idiv</span></code><code><span class="deltaxml-old">if</span></code><code><span class="deltaxml-old">import</span></code><code><span class="deltaxml-old">in</span></code><code><span class="deltaxml-old">infinity</span></code><code><span class="deltaxml-old">inherit</span></code><code><span class="deltaxml-old">instance</span></code><code><span class="deltaxml-old">intersect</span></code><code><span class="deltaxml-old">is</span></code><code><span class="deltaxml-old">item</span></code><code><span class="deltaxml-old">item-type</span></code><code><span class="deltaxml-old">lax</span></code><code><span class="deltaxml-old">le</span></code><code><span class="deltaxml-old">least</span></code><code><span class="deltaxml-old">let</span></code><code><span class="deltaxml-old">lt</span></code><code><span class="deltaxml-old">map</span></code><code><span class="deltaxml-old">member</span></code><code><span class="deltaxml-old">minus-sign</span></code><code><span class="deltaxml-old">mod</span></code><code><span class="deltaxml-old">module</span></code><code><span class="deltaxml-old">namespace</span></code><code><span class="deltaxml-old">namespace-node</span></code><code><span class="deltaxml-old">NaN</span></code><code><span class="deltaxml-old">ne</span></code><code><span class="deltaxml-old">next</span></code><code><span class="deltaxml-old">no-inherit</span></code><code><span class="deltaxml-old">no-preserve</span></code><code><span class="deltaxml-old">node</span></code><code><span class="deltaxml-old">of</span></code><code><span class="deltaxml-old">only</span></code><code><span class="deltaxml-old">option</span></code><code><span class="deltaxml-old">or</span></code><code><span class="deltaxml-old">order</span></code><code><span class="deltaxml-old">ordered</span></code><code><span class="deltaxml-old">ordering</span></code><code><span class="deltaxml-old">otherwise</span></code><code><span class="deltaxml-old">parent</span></code><code><span class="deltaxml-old">pattern-separator</span></code><code><span class="deltaxml-old">per-mille</span></code><code><span class="deltaxml-old">percent</span></code><code><span class="deltaxml-old">preceding</span></code><code><span class="deltaxml-old">preceding-sibling</span></code><code><span class="deltaxml-old">preserve</span></code><code><span class="deltaxml-old">previous</span></code><code><span class="deltaxml-old">processing-instruction</span></code><code><span class="deltaxml-old">record</span></code><code><span class="deltaxml-old">return</span></code><code><span class="deltaxml-old">satisfies</span></code><code><span class="deltaxml-old">schema</span></code><code><span class="deltaxml-old">schema-attribute</span></code><code><span class="deltaxml-old">schema-element</span></code><code><span class="deltaxml-old">self</span></code><code><span class="deltaxml-old">sliding</span></code><code><span class="deltaxml-old">some</span></code><code><span class="deltaxml-old">stable</span></code><code><span class="deltaxml-old">start</span></code><code><span class="deltaxml-old">strict</span></code><code><span class="deltaxml-old">strip</span></code><code><span class="deltaxml-old">switch</span></code><code><span class="deltaxml-old">text</span></code><code><span class="deltaxml-old">then</span></code><code><span class="deltaxml-old">to</span></code><code><span class="deltaxml-old">treat</span></code><code><span class="deltaxml-old">true</span></code><code><span class="deltaxml-old">try</span></code><code><span class="deltaxml-old">tumbling</span></code><code><span class="deltaxml-old">type</span></code><code><span class="deltaxml-old">typeswitch</span></code><code><span class="deltaxml-old">union</span></code><code><span class="deltaxml-old">unordered</span></code><code><span class="deltaxml-old">validate</span></code><code><span class="deltaxml-old">value</span></code><code><span class="deltaxml-old">variable</span></code><code><span class="deltaxml-old">version</span></code><code><span class="deltaxml-old">when</span></code><code><span class="deltaxml-old">where</span></code><code><span class="deltaxml-old">while</span></code><code><span class="deltaxml-old">window</span></code><code><span class="deltaxml-old">with</span></code><code><span class="deltaxml-old">xquery</span></code><code><span class="deltaxml-old">zero-digit</span></code></p></li><li><p><span class="deltaxml-old"> [</span><a id="dt-variable-terminal" title="variable terminal"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">variable terminal</span></b><span class="deltaxml-old"> is an instance of a production rule that is not itself an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-old">ordinary production rule</span></a><span class="deltaxml-old"> but that is named (directly) on the right-hand side of an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-old">ordinary production rule</span></a><span class="deltaxml-old">.] </span></p><p><span class="deltaxml-old"> The </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-old">variable terminals</span></a><span class="deltaxml-old"> in XQuery 4.0 are: </span><a href="#prod-xquery40-BinaryIntegerLiteral"><span class="deltaxml-old">BinaryIntegerLiteral</span></a><a href="#prod-xquery40-CDataSection"><span class="deltaxml-old">CDataSection</span></a><a href="#prod-xquery40-DecimalLiteral"><span class="deltaxml-old">DecimalLiteral</span></a><a href="#prod-xquery40-DirCommentConstructor"><span class="deltaxml-old">DirCommentConstructor</span></a><a href="#prod-xquery40-DirElemConstructor"><span class="deltaxml-old">DirElemConstructor</span></a><a href="#prod-xquery40-DirPIConstructor"><span class="deltaxml-old">DirPIConstructor</span></a><a href="#prod-xquery40-DoubleLiteral"><span class="deltaxml-old">DoubleLiteral</span></a><a href="#prod-xquery40-HexIntegerLiteral"><span class="deltaxml-old">HexIntegerLiteral</span></a><a href="#prod-xquery40-IntegerLiteral"><span class="deltaxml-old">IntegerLiteral</span></a><code><span class="deltaxml-old">NCName</span></code><a href="#prod-xquery40-Pragma"><span class="deltaxml-old">Pragma</span></a><a href="#prod-xquery40-QName"><span class="deltaxml-old">QName</span></a><a href="#prod-xquery40-StringConstructor"><span class="deltaxml-old">StringConstructor</span></a><a href="#prod-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a><a href="#prod-xquery40-StringTemplate"><span class="deltaxml-old">StringTemplate</span></a><a href="#prod-xquery40-URIQualifiedName"><span class="deltaxml-old">URIQualifiedName</span></a><a href="#prod-xquery40-Wildcard"><span class="deltaxml-old">Wildcard</span></a></p></li><li><p><span class="deltaxml-old"> [</span><a id="dt-complex-terminal" title="complex terminal"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: A </span><b><span class="deltaxml-old">complex terminal</span></b><span class="deltaxml-old"> is a </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-old">variable terminal</span></a><span class="deltaxml-old"> whose production rule references, directly or indirectly, an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-old">ordinary production rule</span></a><span class="deltaxml-old">.] </span></p><p><span class="deltaxml-old"> The </span><a title="complex terminal" class="termref" href="#dt-complex-terminal"><span class="deltaxml-old">complex terminals</span></a><span class="deltaxml-old"> in XQuery 4.0 are: </span><a href="#prod-xquery40-DirElemConstructor"><span class="deltaxml-old">DirElemConstructor</span></a><a href="#prod-xquery40-Pragma"><span class="deltaxml-old">Pragma</span></a><a href="#prod-xquery40-StringConstructor"><span class="deltaxml-old">StringConstructor</span></a><a href="#prod-xquery40-StringTemplate"><span class="deltaxml-old">StringTemplate</span></a></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The significance of complex terminals is that at one level, a complex terminal is treated as a single token, but internally it may contain arbitrary expressions that must be parsed using the full EBNF grammar.</span></p></div></li><li><p><span class="deltaxml-old">Tokenization is the process of splitting the supplied input string into a sequence of terminals, where each terminal is either a </span><a title="literal terminal" class="termref" href="#dt-literal-terminal"><span class="deltaxml-old">literal terminal</span></a><span class="deltaxml-old"> or a </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-old">variable terminal</span></a><span class="deltaxml-old"> (which may itself be a </span><a title="complex terminal" class="termref" href="#dt-complex-terminal"><span class="deltaxml-old">complex terminal</span></a><span class="deltaxml-old">). Tokenization is done by repeating the following steps:</span></p><ol class="enumar"><li><p><span class="deltaxml-old">Starting at the current position, skip any whitespace and comments.</span></p></li><li><p><span class="deltaxml-old">If the current position is not the end of the input, then return the longest </span><a title="literal terminal" class="termref" href="#dt-literal-terminal"><span class="deltaxml-old">literal terminal</span></a><span class="deltaxml-old"> or </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-old">variable terminal</span></a><span class="deltaxml-old"> that can be matched starting at the current position, regardless whether this terminal is valid at this point in the grammar. If no such terminal can be identified starting at the current position, or if the terminal that is identified is not a valid continuation of the grammar rules, then a syntax error is reported.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Here are some examples showing the effect of the longest token rule:</span></p><ul><li><p><span class="deltaxml-old">The expression </span><code><span class="deltaxml-old">map{a:b}</span></code><span class="deltaxml-old"> is a syntax error. Although there is a tokenization of this string that satisfies the grammar (by treating </span><code><span class="deltaxml-old">a</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">b</span></code><span class="deltaxml-old"> as separate expressions), this tokenization does not satisfy the longest token rule, which requires that </span><code><span class="deltaxml-old">a:b</span></code><span class="deltaxml-old"> is interpreted as a single </span><code><span class="deltaxml-old">QName</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">The expression </span><code><span class="deltaxml-old">10 div3</span></code><span class="deltaxml-old"> is a syntax error. The longest token rule requires that this be interpreted as two tokens (</span><code><span class="deltaxml-old">"10"</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">"div3"</span></code><span class="deltaxml-old">) even though it would be a valid expression if treated as three tokens (</span><code><span class="deltaxml-old">"10"</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">"div"</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">"3"</span></code><span class="deltaxml-old">).</span></p></li><li><p><span class="deltaxml-old">The expression </span><code><span class="deltaxml-old">$x-$y</span></code><span class="deltaxml-old"> is a syntax error. This is interpreted as four tokens, (</span><code><span class="deltaxml-old">"$"</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">"x-"</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">"$"</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">"y"</span></code><span class="deltaxml-old">).</span></p></li></ul></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">The lexical production rules for </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-old">variable terminals</span></a><span class="deltaxml-old"> have been designed so that there is minimal need for backtracking. For example, if the next terminal starts with </span><code><span class="deltaxml-old">"0x"</span></code><span class="deltaxml-old">, then it can only be either a </span><a href="#doc-xquery40-HexIntegerLiteral"><span class="deltaxml-old">HexIntegerLiteral</span></a><span class="deltaxml-old"> or an error; if it starts with </span><code><span class="deltaxml-old">"`"</span></code><span class="deltaxml-old"> (and not with </span><code><span class="deltaxml-old">"```"</span></code><span class="deltaxml-old">) then it can only be a </span><a href="#doc-xquery40-StringTemplate"><span class="deltaxml-old">StringTemplate</span></a><span class="deltaxml-old"> or an error.</span></p><p><span class="deltaxml-old">This convention, together with the rules for whitespace separation of tokens (see </span><a href="#id-terminal-delimitation"><b><span class="deltaxml-old">A.3.2 Terminal Delimitation</span></b></a><span class="deltaxml-old">) means that the longest-token rule does not normally result in any need for backtracking. For example, suppose that a </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-old">variable terminal</span></a><span class="deltaxml-old"> has been identified as a </span><a href="#doc-xquery40-StringTemplate"><span class="deltaxml-old">StringTemplate</span></a><span class="deltaxml-old"> by examining its first few characters. If the construct turns out not to be a valid </span><a href="#doc-xquery40-StringTemplate"><span class="deltaxml-old">StringTemplate</span></a><span class="deltaxml-old">, an error can be reported without first considering whether there is some shorter token that might be returned instead.</span></p></div></li></ol></li><li><p><span class="deltaxml-old">Tokenization unambiguously identifies the boundaries of the terminals in the input, and this can be achieved without backtracking or lookahead. However, tokenization does not unambiguously classify each terminal. For example, it might identify the string </span><code><span class="deltaxml-old">"div"</span></code><span class="deltaxml-old"> as a terminal, but it does not resolve whether this is the operator symbol </span><code><span class="deltaxml-old">div</span></code><span class="deltaxml-old">, or an </span><code><span class="deltaxml-old">NCName</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">QName</span></code><span class="deltaxml-old"> used as a node test or as a variable or function name. Classification of terminals generally requires information about the grammatical context, and in some cases requires lookahead.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">Operationally, classification of terminals may be done either in the tokenizer or the parser, or in some combination of the two. For example, according to the EBNF, the expression </span><code><span class="deltaxml-old">"parent::x"</span></code><span class="deltaxml-old"> is made up of three tokens, </span><code><span class="deltaxml-old">"parent"</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">"::"</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">"x"</span></code><span class="deltaxml-old">. The name </span><code><span class="deltaxml-old">"parent"</span></code><span class="deltaxml-old"> can be classified as an axis name as soon as the following token </span><code><span class="deltaxml-old">"::"</span></code><span class="deltaxml-old"> is recognized, and this might be done either in the tokenizer or in the parser. (Note that whitespace and comments are allowed both before and after </span><code><span class="deltaxml-old">"::"</span></code><span class="deltaxml-old">.)</span></p></div></li><li><p><span class="deltaxml-old">In the case of a </span><a title="complex terminal" class="termref" href="#dt-complex-terminal"><span class="deltaxml-old">complex terminal</span></a><span class="deltaxml-old">, identifying the end of the complex terminal typically involves invoking the parser to process any embedded expressions. Tokenization, as described here, is therefore a recursive process. But other implementations are possible.</span></p></li></ul><div class="div3"><h4><a id="terminal-symbols"></a>A.<span class="deltaxml-old">3.1</span><span class="deltaxml-new">2.1</span> Terminal Symbols</h4><a id="d3e38566"></a><a id="d3e34271"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-IntegerLiteral"></a>[<span class="deltaxml-old">267</span><span class="deltaxml-new">253</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-IntegerLiteral">IntegerLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-Digits">Digits</a></code></td><td><span style="display: none;" class="delete_version"><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></span><span style="display: none;" class="add_version"></span><span class="modify_version"><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></span></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-HexIntegerLiteral"></a>[<span class="deltaxml-old">268</span><span class="deltaxml-new">254</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-HexIntegerLiteral">HexIntegerLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"0x" <a href="#prod-xquery40-HexDigits">HexDigits</a></code></td><td><span style="display: none;" class="delete_version"><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></span><span style="display: none;" class="add_version"></span><span class="modify_version"><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></span></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-BinaryIntegerLiteral"></a>[<span class="deltaxml-old">269</span><span class="deltaxml-new">255</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-BinaryIntegerLiteral">BinaryIntegerLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"0b" <a href="#prod-xquery40-BinaryDigits">BinaryDigits</a></code></td><td><span style="display: none;" class="delete_version"><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></span><span style="display: none;" class="add_version"></span><span class="modify_version"><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></span></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DecimalLiteral"></a>[<span class="deltaxml-old">270</span><span class="deltaxml-new">256</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DecimalLiteral">DecimalLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>("." <a href="#prod-xquery40-Digits">Digits</a>) | (<a href="#prod-xquery40-Digits">Digits</a> "." <a href="#prod-xquery40-Digits">Digits</a>?)</code></span><span style="display: none;" class="add_version"><code>("." <a href="#prod-xquery40-Digits">Digits</a>) | (<a href="#prod-xquery40-Digits">Digits</a> "." [0-9]*)</code></span><span class="modify_version"><code>("." <a href="#prod-xquery40-Digits">Digits</a>) | (<a href="#prod-xquery40-Digits">Digits</a> "." <a href="#prod-xquery40-Digits"><span class="deltaxml-old">Digits</span></a><span class="deltaxml-old">?</span><span class="deltaxml-new">[0-9]*</span>)</code></span></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DoubleLiteral"></a>[<span class="deltaxml-old">271</span><span class="deltaxml-new">257</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-DoubleLiteral">DoubleLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>(("." <a href="#prod-xquery40-Digits">Digits</a>) | (<a href="#prod-xquery40-Digits">Digits</a> ("." <a href="#prod-xquery40-Digits">Digits</a>?)?)) [eE] [+-]? <a href="#prod-xquery40-Digits">Digits</a></code></span><span style="display: none;" class="add_version"><code>(("." <a href="#prod-xquery40-Digits">Digits</a>) | (<a href="#prod-xquery40-Digits">Digits</a> ("." [0-9]*)?)) [eE] [+-]? <a href="#prod-xquery40-Digits">Digits</a></code></span><span class="modify_version"><code>(("." <a href="#prod-xquery40-Digits">Digits</a>) | (<a href="#prod-xquery40-Digits">Digits</a> ("." <a href="#prod-xquery40-Digits"><span class="deltaxml-old">Digits</span></a><span class="deltaxml-old">?</span><span class="deltaxml-new">[0-9]*</span>)?)) [eE] [+-]? <a href="#prod-xquery40-Digits">Digits</a></code></span></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-StringLiteral"></a><span class="deltaxml-old">[272]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-AposStringLiteral"><span class="deltaxml-old">AposStringLiteral</span></a><span class="deltaxml-old"> | </span><a href="#prod-xquery40-QuotStringLiteral"><span class="deltaxml-old">QuotStringLiteral</span></a></code></td><td><i><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AposStringLiteral"></a><span class="deltaxml-old">[273]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-AposStringLiteral"><span class="deltaxml-old">AposStringLiteral</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">"'" (</span><a href="#prod-xquery40-PredefinedEntityRef"><span class="deltaxml-old">PredefinedEntityRef</span></a><span class="deltaxml-old"> | </span><a href="#prod-xquery40-CharRef"><span class="deltaxml-old">CharRef</span></a><span class="deltaxml-old"> | </span><a href="#prod-xquery40-EscapeApos"><span class="deltaxml-old">EscapeApos</span></a><span class="deltaxml-old"> | [^'&amp;])* "'"</span></code></td><td><i><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-QuotStringLiteral"></a><a id="prod-xquery40-StringLiteral"></a>[<span class="deltaxml-old">274</span><span class="deltaxml-new">258</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-QuotStringLiteral">QuotStringLiteral</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-StringLiteral">StringLiteral</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-QuotStringLiteral"><span class="deltaxml-old">QuotStringLiteral</span></a><a href="#doc-xquery40-StringLiteral"><span class="deltaxml-new">StringLiteral</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>'"' (<a href="#prod-xquery40-PredefinedEntityRef">PredefinedEntityRef</a> | <a href="#prod-xquery40-CharRef">CharRef</a> | <a href="#prod-xquery40-EscapeQuot">EscapeQuot</a> | [^"&amp;])* '"'</code></span><span style="display: none;" class="add_version"><code>('"' (<a href="#prod-xquery40-PredefinedEntityRef">PredefinedEntityRef</a> | <a href="#prod-xquery40-CharRef">CharRef</a> | <a href="#prod-xquery40-EscapeQuot">EscapeQuot</a> | [^"&amp;])* '"') | ("'" (<a href="#prod-xquery40-PredefinedEntityRef">PredefinedEntityRef</a> | <a href="#prod-xquery40-CharRef">CharRef</a> | <a href="#prod-xquery40-EscapeApos">EscapeApos</a> | [^'&amp;])* "'")</code></span><span class="modify_version"><code><span class="deltaxml-new">(</span>'"' (<a href="#prod-xquery40-PredefinedEntityRef">PredefinedEntityRef</a> | <a href="#prod-xquery40-CharRef">CharRef</a> | <a href="#prod-xquery40-EscapeQuot">EscapeQuot</a> | [^"&amp;])* '"'<span class="deltaxml-new">) | ("'" (</span><a href="#prod-xquery40-PredefinedEntityRef"><span class="deltaxml-new">PredefinedEntityRef</span></a><span class="deltaxml-new"> | </span><a href="#prod-xquery40-CharRef"><span class="deltaxml-new">CharRef</span></a><span class="deltaxml-new"> | </span><a href="#prod-xquery40-EscapeApos"><span class="deltaxml-new">EscapeApos</span></a><span class="deltaxml-new"> | [^'&amp;])* "'")</span></code></span></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-URIQualifiedName"></a>[<span class="deltaxml-old">275</span><span class="deltaxml-new">259</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-URIQualifiedName">URIQualifiedName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xquery40-BracedURILiteral">BracedURILiteral</a><a href="#prod-xquery40-NCName">NCName</a></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-BracedURILiteral"></a>[<span class="deltaxml-old">276</span><span class="deltaxml-new">260</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-BracedURILiteral">BracedURILiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"Q" "{" (<a href="#prod-xquery40-PredefinedEntityRef">PredefinedEntityRef</a> | <a href="#prod-xquery40-CharRef">CharRef</a> | [^&amp;{}])* "}"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-PredefinedEntityRef"></a>[<span class="deltaxml-old">277</span><span class="deltaxml-new">261</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-PredefinedEntityRef">PredefinedEntityRef</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"&amp;" ("lt" | "gt" | "amp" | "quot" | "apos") ";"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-EscapeQuot"></a>[<span class="deltaxml-old">278</span><span class="deltaxml-new">262</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EscapeQuot">EscapeQuot</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>'""'</code></td><td><span style="display: none;" class="delete_version"><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></span><span style="display: none;" class="add_version"></span><span class="modify_version"><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></span></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-EscapeApos"></a>[<span class="deltaxml-old">279</span><span class="deltaxml-new">263</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-EscapeApos">EscapeApos</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"''"</code></td><td><span style="display: none;" class="delete_version"><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></span><span style="display: none;" class="add_version"></span><span class="modify_version"><span class="deltaxml-old">/* </span><a href="#ws-explicit"><span class="deltaxml-old">ws: explicit</span></a><span class="deltaxml-old"> */</span></span></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-ElementContentChar"></a>[<span class="deltaxml-old">280</span><span class="deltaxml-new">264</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-ElementContentChar">ElementContentChar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a> - [{}&lt;&amp;])</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-QuotAttrContentChar"></a>[<span class="deltaxml-old">281</span><span class="deltaxml-new">265</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-QuotAttrContentChar">QuotAttrContentChar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a> - ["{}&lt;&amp;])</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-AposAttrContentChar"></a>[<span class="deltaxml-old">282</span><span class="deltaxml-new">266</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-AposAttrContentChar">AposAttrContentChar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xquery40-Char">Char</a> - ['{}&lt;&amp;])</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Comment"></a>[<span class="deltaxml-old">283</span><span class="deltaxml-new">267</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Comment">Comment</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(:" (<a href="#prod-xquery40-CommentContents">CommentContents</a> | <a href="#prod-xquery40-Comment">Comment</a>)* ":)"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr><tr style="vertical-align:baseline;"><td></td><td></td><td></td><td></td><td><i>/* <a href="#parse-note-comments">gn: comments</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-PITarget"></a>[<span class="deltaxml-old">284</span><span class="deltaxml-new">268</span>]&nbsp;&nbsp;&nbsp;</td><td><code>PITarget</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://www.w3.org/TR/REC-xml/#NT-PITarget">[http://www.w3.org/TR/REC-xml#NT-PITarget]</a><sup><small>XML</small></sup></code></td><td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CharRef"></a>[<span class="deltaxml-old">285</span><span class="deltaxml-new">269</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-CharRef">CharRef</a></code></span><span style="display: none;" class="add_version"><code>CharRef</code></span><span class="modify_version"><code><a href="#doc-xquery40-CharRef"><span class="deltaxml-old">CharRef</span></a><span class="deltaxml-new">CharRef</span></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://www.w3.org/TR/REC-xml/#NT-CharRef">[http://www.w3.org/TR/REC-xml#NT-CharRef]</a><sup><small>XML</small></sup></code></td><td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-QName"></a>[<span class="deltaxml-old">286</span><span class="deltaxml-new">270</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-QName">QName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td><td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-NCName"></a>[<span class="deltaxml-old">287</span><span class="deltaxml-new">271</span>]&nbsp;&nbsp;&nbsp;</td><td><code>NCName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td><td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-S"></a>[<span class="deltaxml-old">288</span><span class="deltaxml-new">272</span>]&nbsp;&nbsp;&nbsp;</td><td><code>S</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a><sup><small>XML</small></sup></code></td><td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a> */</i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Char"></a>[<span class="deltaxml-old">289</span><span class="deltaxml-new">273</span>]&nbsp;&nbsp;&nbsp;</td><td><code>Char</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td><td><i>/* <a href="#parse-note-xml-version">xgc: xml-version</a> */</i></td></tr></tbody></table><p>The following symbols are used only in the definition of terminal symbols; they are not terminal symbols in the grammar of <a href="#id-grammar"><b>A.1 EBNF</b></a>.</p><a id="d3e38867"></a><a id="d3e34517"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-Digits"></a>[<span class="deltaxml-old">290</span><span class="deltaxml-new">274</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-Digits">Digits</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-DecDigit">DecDigit</a> ((<a href="#prod-xquery40-DecDigit">DecDigit</a> | "_")* <a href="#prod-xquery40-DecDigit">DecDigit</a>)?</code></span><span style="display: none;" class="add_version"><code>[0-9]+ [0-9_]*</code></span><span class="modify_version"><code><a href="#prod-xquery40-DecDigit"><span class="deltaxml-old">DecDigit</span></a><span class="deltaxml-old"> ((</span><span class="deltaxml-new">[0-9]+ [0-</span><a href="#prod-xquery40-DecDigit"><span class="deltaxml-old">DecDigit</span></a><span class="deltaxml-old"> | "_")</span><span class="deltaxml-new">9_]</span>*<span class="deltaxml-old"> </span><a href="#prod-xquery40-DecDigit"><span class="deltaxml-old">DecDigit</span></a><span class="deltaxml-old">)?</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-DecDigit"></a><a id="prod-xquery40-CommentContents"></a>[<span class="deltaxml-old">291</span><span class="deltaxml-new">275</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-DecDigit">DecDigit</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-CommentContents">CommentContents</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-DecDigit"><span class="deltaxml-old">DecDigit</span></a><a href="#doc-xquery40-CommentContents"><span class="deltaxml-new">CommentContents</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>[0-9]</code></span><span style="display: none;" class="add_version"><code>(<a href="#prod-xquery40-Char">Char</a>+ - (Char* ('(:' | ':)') Char*))</code></span><span class="modify_version"><code><span class="deltaxml-old">[0</span><span class="deltaxml-new">(</span><a href="#prod-xquery40-Char"><span class="deltaxml-new">Char</span></a><span class="deltaxml-old">-9]</span><span class="deltaxml-new">+ - (Char* ('(:' | ':)') Char*))</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-HexDigits"></a><span class="deltaxml-old">[292]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-HexDigits"><span class="deltaxml-old">HexDigits</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xquery40-HexDigit"><span class="deltaxml-old">HexDigit</span></a><span class="deltaxml-old"> ((</span><a href="#prod-xquery40-HexDigit"><span class="deltaxml-old">HexDigit</span></a><span class="deltaxml-old"> | "_")* </span><a href="#prod-xquery40-HexDigit"><span class="deltaxml-old">HexDigit</span></a><span class="deltaxml-old">)?</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-HexDigit"></a><a id="prod-xquery40-HexDigits"></a>[<span class="deltaxml-old">293</span><span class="deltaxml-new">276</span>]&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#doc-xquery40-HexDigit">HexDigit</a></code></span><span style="display: none;" class="add_version"><code><a href="#doc-xquery40-HexDigits">HexDigits</a></code></span><span class="modify_version"><code><a href="#doc-xquery40-HexDigit"><span class="deltaxml-old">HexDigit</span></a><a href="#doc-xquery40-HexDigits"><span class="deltaxml-new">HexDigits</span></a></code></span></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code>[0-9a-fA-F]</code></span><span style="display: none;" class="add_version"><code>[0-9a-fA-F_]+</code></span><span class="modify_version"><code>[0-9a-fA-<span class="deltaxml-old">F</span><span class="deltaxml-new">F_</span>]<span class="deltaxml-new">+</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-BinaryDigits"></a>[<span class="deltaxml-old">294</span><span class="deltaxml-new">277</span>]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xquery40-BinaryDigits">BinaryDigits</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><span style="display: none;" class="delete_version"><code><a href="#prod-xquery40-BinaryDigit">BinaryDigit</a> ((<a href="#prod-xquery40-BinaryDigit">BinaryDigit</a> | "_")* <a href="#prod-xquery40-BinaryDigit">BinaryDigit</a>)?</code></span><span style="display: none;" class="add_version"><code>[01_]+</code></span><span class="modify_version"><code><a href="#prod-xquery40-BinaryDigit"><span class="deltaxml-old">BinaryDigit</span></a><span class="deltaxml-old"> ((</span><span class="deltaxml-new">[01_]</span><a href="#prod-xquery40-BinaryDigit"><span class="deltaxml-old">BinaryDigit</span></a><span class="deltaxml-old"> | "_")* </span><span class="deltaxml-new">+</span><a href="#prod-xquery40-BinaryDigit"><span class="deltaxml-old">BinaryDigit</span></a><span class="deltaxml-old">)?</span></code></span></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-BinaryDigit"></a><span class="deltaxml-old">[295]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-BinaryDigit"><span class="deltaxml-old">BinaryDigit</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">[01]</span></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="prod-xquery40-CommentContents"></a><span class="deltaxml-old">[296]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xquery40-CommentContents"><span class="deltaxml-old">CommentContents</span></a></code></td><td><span class="deltaxml-old">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-old">(</span><a href="#prod-xquery40-Char"><span class="deltaxml-old">Char</span></a><span class="deltaxml-old">+ - (Char* ('(:' | ':)') Char*))</span></code></td><td></td></tr></tbody></table></div><div class="div3"><h4><a id="id-terminal-delimitation"></a>A.<span class="deltaxml-old">3.2</span><span class="deltaxml-new">2.2</span> Terminal Delimitation</h4><p>XQuery 4.0 expressions consist of <a href="#terminal-symbols">terminal symbols</a> and <a title="symbol separators" class="termref" href="#symbolseparators">symbol separators</a>.</p><p><span style="display: none;" class="delete_version"><span><a title="literal terminal" class="termref" href="#dt-literal-terminal">Literal</a> and <a title="variable terminal" class="termref" href="#dt-variable-terminal">variable</a></span> terminal symbols are of two kinds: delimiting and non-delimiting.</span><span style="display: none;" class="add_version">Terminal symbols that are not used exclusively in <a href="#ws-explicit">/* ws: explicit */</a> productions are of two kinds: delimiting and non-delimiting.</span><span class="modify_version"><a title="literal terminal" class="termref" href="#dt-literal-terminal"><span class="deltaxml-old">Literal</span></a><span class="deltaxml-new">Terminal</span> <span class="deltaxml-old">and</span><span class="deltaxml-new">symbols</span> <a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-old">variable</span></a><span class="deltaxml-new">that</span> <span class="deltaxml-old">terminal symbols</span><span class="deltaxml-new">are not used exclusively in</span> <a href="#ws-explicit"><span class="deltaxml-new">/* ws: explicit */</span></a><span class="deltaxml-new"> productions </span>are of two kinds: delimiting and non-delimiting.</span></p><p><span class="deltaxml-old"> [</span><a id="delimiting-token" title="delimiting terminal symbol"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: The </span><b><span class="deltaxml-old">delimiting terminal symbols</span></b><span class="deltaxml-old"> are: </span><code><span class="deltaxml-old">!</span></code><code><span class="deltaxml-old">!=</span></code><code><span class="deltaxml-old">#</span></code><code><span class="deltaxml-old">$</span></code><code><span class="deltaxml-old">%</span></code><code><span class="deltaxml-old">(</span></code><code><span class="deltaxml-old">)</span></code><code><span class="deltaxml-old">*</span></code><code><span class="deltaxml-old">*:</span></code><code><span class="deltaxml-old">,</span></code><code><span class="deltaxml-old">-</span></code><code><span class="deltaxml-old">.</span></code><code><span class="deltaxml-old">..</span></code><code><span class="deltaxml-old">:</span></code><code><span class="deltaxml-old">:*</span></code><code><span class="deltaxml-old">::</span></code><code><span class="deltaxml-old">:=</span></code><code><span class="deltaxml-old">;</span></code><code><span class="deltaxml-old">&lt;&lt;</span></code><code><span class="deltaxml-old">&lt;=</span></code><code><span class="deltaxml-old">=</span></code><code><span class="deltaxml-old">=!&gt;</span></code><code><span class="deltaxml-old">=&gt;</span></code><code><span class="deltaxml-old">=?&gt;</span></code><code><span class="deltaxml-old">&gt;</span></code><code><span class="deltaxml-old">&gt;=</span></code><code><span class="deltaxml-old">&gt;&gt;</span></code><code><span class="deltaxml-old">?</span></code><code><span class="deltaxml-old">??</span></code><code><span class="deltaxml-old">@</span></code><code><span class="deltaxml-old">[</span></code><code><span class="deltaxml-old">]</span></code><code><span class="deltaxml-old">`</span></code><code><span class="deltaxml-old">``</span></code><code><span class="deltaxml-old">{</span></code><code><span class="deltaxml-old">{{</span></code><code><span class="deltaxml-old">|</span></code><code><span class="deltaxml-old">||</span></code><code><span class="deltaxml-old">}</span></code><code><span class="deltaxml-old">}}</span></code><code><span class="deltaxml-old">×</span></code><code><span class="deltaxml-old">÷</span></code><a href="#prod-xquery40-AposStringLiteral"><span class="deltaxml-old">AposStringLiteral</span></a><a href="#prod-xquery40-BracedURILiteral"><span class="deltaxml-old">BracedURILiteral</span></a><code><span class="deltaxml-old">]]&gt;</span></code><code><span class="deltaxml-old">&lt;![CDATA[</span></code><code><span class="deltaxml-old">--&gt;</span></code><code><span class="deltaxml-old">&lt;!--</span></code><code><span class="deltaxml-old">/&gt;</span></code><code><span class="deltaxml-old">&lt;/</span></code><code><span class="deltaxml-old">&lt;</span></code><code><span class="deltaxml-old">+</span></code><code><span class="deltaxml-old">#)</span></code><code><span class="deltaxml-old">(#</span></code><code><span class="deltaxml-old">?&gt;</span></code><code><span class="deltaxml-old">&lt;?</span></code><a href="#prod-xquery40-QuotStringLiteral"><span class="deltaxml-old">QuotStringLiteral</span></a><a href="#prod-xquery40-S"><span class="deltaxml-old">S</span></a><code><span class="deltaxml-old">/</span></code><code><span class="deltaxml-old">//</span></code><code><span class="deltaxml-old">]``</span></code><code><span class="deltaxml-old">``[</span></code><code><span class="deltaxml-old">}`</span></code><code><span class="deltaxml-old">`{</span></code><a href="#prod-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a><span class="deltaxml-old"> ] </span></p><p><span class="deltaxml-new"> [</span><a id="delimiting-token" title="delimiting terminal symbol"><span class="deltaxml-new">Definition</span></a><span class="deltaxml-new">: The </span><b><span class="deltaxml-new">delimiting terminal symbols</span></b><span class="deltaxml-new"> are: </span><a href="#prod-xquery40-S"><span class="deltaxml-new">S</span></a><span class="deltaxml-new">, "!", "!=", </span><a href="#prod-xquery40-StringLiteral"><span class="deltaxml-new">StringLiteral</span></a><span class="deltaxml-new">, "#", "#)", "$", "%", "(", "(#", ")", "*", "*:", "+", (comma), "-", "--&gt;", "-&gt;", (dot), "..", "/", "//", "/&gt;", (colon), ":*", "::", ":=", (semi-colon), "&lt;", "&lt;!--", "&lt;![CDATA[", "&lt;/", "&lt;&lt;", "&lt;=", "&lt;?", "=", "=&gt;", "&gt;", "&gt;=", "&gt;&gt;", "?", "?&gt;", "@", </span><a href="#prod-xquery40-BracedURILiteral"><span class="deltaxml-new">BracedURILiteral</span></a><span class="deltaxml-new">, "[", "]", "]]&gt;", "]``", "`", "``", "``[", "`{", "{", "{{", "|", "||", "}", "}`", "}}" ] </span></p><p><span style="display: none;" class="delete_version"> [<a id="non-delimiting-token" title="non-delimiting terminal symbol">Definition</a>: The <b>non-delimiting terminal symbols</b> are: <code>allowing</code><code>ancestor</code><code>ancestor-or-self</code><code>and</code><code>array</code><code>as</code><code>at</code><code>attribute</code><code>base-uri</code><code>boundary-space</code><code>by</code><code>case</code><code>cast</code><code>castable</code><code>catch</code><code>child</code><code>collation</code><code>comment</code><code>construction</code><code>context</code><code>copy-namespaces</code><code>count</code><code>decimal-format</code><code>decimal-separator</code><code>declare</code><code>default</code><code>descendant</code><code>descendant-or-self</code><code>digit</code><code>div</code><code>document</code><code>document-node</code><code>element</code><code>else</code><code>empty</code><code>empty-sequence</code><code>encoding</code><code>end</code><code>enum</code><code>eq</code><code>every</code><code>except</code><code>exponent-separator</code><code>false</code><code>fixed</code><code>fn</code><code>following</code><code>following-sibling</code><code>for</code><code>function</code><code>ge</code><code>group</code><code>grouping-separator</code><code>gt</code><code>idiv</code><code>if</code><code>import</code><code>in</code><code>infinity</code><code>inherit</code><code>instance</code><code>intersect</code><code>is</code><code>item</code><code>item-type</code><code>lax</code><code>le</code><code>let</code><code>lt</code><code>map</code><code>member</code><code>minus-sign</code><code>mod</code><code>module</code><code>namespace</code><code>namespace-node</code><code>NaN</code><code>ne</code><code>next</code><code>no-inherit</code><code>no-preserve</code><code>node</code><code>of</code><code>only</code><code>option</code><code>or</code><code>order</code><code>ordered</code><code>ordering</code><code>otherwise</code><code>parent</code><code>pattern-separator</code><code>per-mille</code><code>percent</code><code>preceding</code><code>preceding-sibling</code><code>preserve</code><code>previous</code><code>processing-instruction</code><code>record</code><code>return</code><code>satisfies</code><code>schema</code><code>schema-attribute</code><code>schema-element</code><code>self</code><code>sliding</code><code>some</code><code>stable</code><code>start</code><code>strict</code><code>strip</code><code>switch</code><code>text</code><code>then</code><code>to</code><code>treat</code><code>true</code><code>try</code><code>tumbling</code><code>type</code><code>typeswitch</code><code>union</code><code>unordered</code><code>validate</code><code>value</code><code>variable</code><code>version</code><code>when</code><code>where</code><code>while</code><code>window</code><code>with</code><code>xquery</code><code>zero-digit</code><code>ascending</code><a href="#prod-xquery40-BinaryIntegerLiteral">BinaryIntegerLiteral</a><a href="#prod-xquery40-DecimalLiteral">DecimalLiteral</a><code>descending</code><a href="#prod-xquery40-DoubleLiteral">DoubleLiteral</a><code>external</code><code>greatest</code><a href="#prod-xquery40-HexIntegerLiteral">HexIntegerLiteral</a><a href="#prod-xquery40-IntegerLiteral">IntegerLiteral</a><code>least</code><a href="#prod-xquery40-NCName">NCName</a><a href="#prod-xquery40-QName">QName</a><a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a> ] </span><span style="display: none;" class="add_version"> [<a id="non-delimiting-token" title="non-delimiting terminal symbol">Definition</a>: The <b>non-delimiting terminal symbols</b> are: <a href="#prod-xquery40-IntegerLiteral">IntegerLiteral</a>, <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a>, <a href="#prod-xquery40-NCName">NCName</a>, <a href="#prod-xquery40-DecimalLiteral">DecimalLiteral</a>, <a href="#prod-xquery40-DoubleLiteral">DoubleLiteral</a>, <a href="#prod-xquery40-BinaryIntegerLiteral">BinaryIntegerLiteral</a>, <a href="#prod-xquery40-HexIntegerLiteral">HexIntegerLiteral</a>, <a href="#prod-xquery40-QName">QName</a>, "NaN", "allowing", "ancestor", "ancestor-or-self", "and", "array", "as", "ascending", "at", "attribute", "base-uri", "boundary-space", "by", "case", "cast", "castable", "catch", "child", "collation", "comment", "construction", "context", "copy-namespaces", "count", "decimal-format", "decimal-separator", "declare", "default", "descendant", "descendant-or-self", "descending", "digit", "div", "document", "document-node", "element", "else", "empty", "empty-sequence", "encoding", "end", "enum", "eq", "every", "except", "exponent-separator", "external", "following", "following-sibling", "for", "function", "ge", "greatest", "group", "grouping-separator", "gt", "idiv", "if", "import", "in", "infinity", "inherit", "instance", "intersect", "is", "item", "item-type", "lax", "le", "least", "let", "lt", "map", "member", "minus-sign", "mod", "module", "namespace", "namespace-node", "ne", "next", "no-inherit", "no-preserve", "node", "of", "only", "option", "or", "order", "ordered", "ordering", "otherwise", "parent", "pattern-separator", "per-mille", "percent", "preceding", "preceding-sibling", "preserve", "previous", "processing-instruction", "record", "return", "satisfies", "schema", "schema-attribute", "schema-element", "self", "sliding", "some", "stable", "start", "strict", "strip", "switch", "text", "then", "to", "treat", "try", "tumbling", "type", "typeswitch", "union", "unordered", "validate", "variable", "version", "when", "where", "window", "with", "xquery", "zero-digit" ] </span><span class="modify_version"> [<a id="non-delimiting-token" title="non-delimiting terminal symbol">Definition</a>: The <b>non-delimiting terminal symbols</b> are: <a href="#prod-xquery40-IntegerLiteral"><span class="deltaxml-new">IntegerLiteral</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-URIQualifiedName"><span class="deltaxml-new">URIQualifiedName</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-NCName"><span class="deltaxml-new">NCName</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-DecimalLiteral"><span class="deltaxml-new">DecimalLiteral</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-DoubleLiteral"><span class="deltaxml-new">DoubleLiteral</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-BinaryIntegerLiteral"><span class="deltaxml-new">BinaryIntegerLiteral</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-HexIntegerLiteral"><span class="deltaxml-new">HexIntegerLiteral</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-QName"><span class="deltaxml-new">QName</span></a><span class="deltaxml-new">, "NaN", "</span>allowing<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>ancestor<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>ancestor-or-self<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>and<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>array<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>as<span class="deltaxml-new">"</span><span class="deltaxml-new">, "ascending", "</span>at<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>attribute<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>base-uri<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>boundary-space<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>by<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>case<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>cast<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>castable<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>catch<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>child<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>collation<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>comment<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>construction<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>context<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>copy-namespaces<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>count<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>decimal-format<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>decimal-separator<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>declare<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>default<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>descendant<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>descendant-or-self<span class="deltaxml-new">"</span><span class="deltaxml-new">, "descending", "</span>digit<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>div<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>document<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>document-node<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>element<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>else<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>empty<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>empty-sequence<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>encoding<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>end<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>enum<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>eq<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>every<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>except<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>exponent-separator<span class="deltaxml-new">"</span><span class="deltaxml-old">false</span><span class="deltaxml-new">, "external</span><span class="deltaxml-new">"</span><span class="deltaxml-old">fixed</span><span class="deltaxml-new">, </span><span class="deltaxml-old">fn</span><span class="deltaxml-new">"</span>following<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>following-sibling<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>for<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>function<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>ge<span class="deltaxml-new">"</span><span class="deltaxml-new">, "greatest", "</span>group<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>grouping-separator<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>gt<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>idiv<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>if<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>import<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>in<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>infinity<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>inherit<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>instance<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>intersect<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>is<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>item<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>item-type<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>lax<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>le<span class="deltaxml-new">"</span><span class="deltaxml-new">, "least", "</span>let<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>lt<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>map<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>member<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>minus-sign<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>mod<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>module<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>namespace<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>namespace-node<span class="deltaxml-new">"</span><span class="deltaxml-old">NaN</span><span class="deltaxml-new">, </span><span class="deltaxml-new">"</span>ne<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>next<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>no-inherit<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>no-preserve<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>node<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>of<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>only<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>option<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>or<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>order<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>ordered<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>ordering<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>otherwise<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>parent<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>pattern-separator<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>per-mille<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>percent<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>preceding<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>preceding-sibling<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>preserve<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>previous<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>processing-instruction<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>record<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>return<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>satisfies<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>schema<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>schema-attribute<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>schema-element<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>self<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>sliding<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>some<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>stable<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>start<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>strict<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>strip<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>switch<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>text<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>then<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>to<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>treat<span class="deltaxml-new">"</span><span class="deltaxml-old">true</span><span class="deltaxml-new">, </span><span class="deltaxml-new">"</span>try<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>tumbling<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>type<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>typeswitch<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>union<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>unordered<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>validate<span class="deltaxml-new">"</span><span class="deltaxml-old">value</span><span class="deltaxml-new">, </span><span class="deltaxml-new">"</span>variable<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>version<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>when<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>where<span class="deltaxml-new">"</span><span class="deltaxml-old">while</span><span class="deltaxml-new">, </span><span class="deltaxml-new">"</span>window<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>with<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>xquery<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>zero-digit<span class="deltaxml-old">ascending</span><a href="#prod-xquery40-BinaryIntegerLiteral"><span class="deltaxml-old">BinaryIntegerLiteral</span></a><a href="#prod-xquery40-DecimalLiteral"><span class="deltaxml-old">DecimalLiteral</span></a><span class="deltaxml-old">descending</span><a href="#prod-xquery40-DoubleLiteral"><span class="deltaxml-old">DoubleLiteral</span></a><span class="deltaxml-old">external</span><span class="deltaxml-old">greatest</span><a href="#prod-xquery40-HexIntegerLiteral"><span class="deltaxml-old">HexIntegerLiteral</span></a><a href="#prod-xquery40-IntegerLiteral"><span class="deltaxml-old">IntegerLiteral</span></a><span class="deltaxml-old">least</span><a href="#prod-xquery40-NCName"><span class="deltaxml-old">NCName</span></a><a href="#prod-xquery40-QName"><span class="deltaxml-old">QName</span></a><a href="#prod-xquery40-URIQualifiedName"><span class="deltaxml-old">URIQualifiedName</span></a><span class="deltaxml-new">"</span> ] </span></p><p> [<a id="symbolseparators" title="symbol separators">Definition</a>: <a title="whitespace" class="termref" href="#Whitespace">Whitespace</a> and <a href="#doc-xquery40-Comment">Comments</a> function as <b>symbol separators</b>. For the most part, they are not mentioned in the grammar, and may occur between any two terminal symbols mentioned in the grammar, except where that is forbidden by the <a href="#ws-explicit">/* ws: explicit */</a> annotation in the EBNF, or by the <a href="#parse-note-xml-version">/* xgc: xml-version */</a> annotation.] </p><p><span style="display: none;" class="delete_version"><span>As a consequence of the longest token rule (see <a href="#lexical-structure"><b>A.3 Lexical structure</b></a>), </span> one or more <a title="symbol separators" class="termref" href="#symbolseparators">symbol separators</a> are required between two consecutive terminal symbols T and U (where T precedes U) when any of the following is true: </span><span style="display: none;" class="add_version"> One or more <a title="symbol separators" class="termref" href="#symbolseparators">symbol separators</a> are required between two consecutive terminal symbols T and U (where T precedes U) when any of the following is true: </span><span class="modify_version"><span class="deltaxml-old">As a consequence of the longest token rule (see</span><span class="deltaxml-new"> One</span> <a href="#lexical-structure"><b><span class="deltaxml-old">A.3 Lexical structure</span></b></a><span class="deltaxml-old">), </span><span class="deltaxml-old"> one </span>or more <a title="symbol separators" class="termref" href="#symbolseparators">symbol separators</a> are required between two consecutive terminal symbols T and U (where T precedes U) when any of the following is true: </span></p><ul><li><p>T and U are both <a title="non-delimiting terminal symbol" class="termref" href="#non-delimiting-token">non-delimiting terminal symbols</a>.</p></li><li><p>T is a QName or an NCName and U is "." or "-".</p></li><li><p>T is a numeric literal and U is ".", or vice versa.</p></li></ul></div><div class="div3"><h4><a id="id-lt-and-gt-characters"></a><span class="deltaxml-old">A.3.3 Less-Than and Greater-Than Characters</span></h4><p><span class="deltaxml-old">The operator symbols </span><code><span class="deltaxml-old">&lt;</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">&lt;=</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">&gt;</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">&gt;=</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">&lt;&lt;</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">&gt;&gt;</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">=&gt;</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">=!&gt;</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">-&gt;</span></code><span class="deltaxml-old"> have alternative representations using the characters </span><code><span class="deltaxml-old">"＜"</span></code><span class="deltaxml-old"> (xFF1C, full-width less-than sign) and </span><code><span class="deltaxml-old">"＞"</span></code><span class="deltaxml-old"> (xFF1E, full-width greater-than sign) in place of </span><code><span class="deltaxml-old">"&lt;"</span></code><span class="deltaxml-old"> (x3C, less-than sign) and </span><code><span class="deltaxml-old">"&gt;"</span></code><span class="deltaxml-old"> (x3E, greater-than sign). The alternative tokens are respectively </span><code><span class="deltaxml-old">＜</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">＜=</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">＞</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">＞=</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">＜＜</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">＞＞</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">=＞</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">=!＞</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">-＞</span></code><span class="deltaxml-old">. In order to avoid visual confusion these alternatives are not shown explicitly in the grammar.</span></p><p><span class="deltaxml-old">This option is provided to improve the readability of XPath expressions embedded in XML-based host languages such as XSLT; it enables these operators to be depicted using characters that do not require escaping as XML entities or character references.</span></p><p class="xquery"><span class="deltaxml-old">This rule does not apply to the </span><code><span class="deltaxml-old">&lt;</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">&gt;</span></code><span class="deltaxml-old"> symbols used to delimit node constructor expressions, which (because they mimic XML syntax) must use x3C (less-than sign) and x3E (greater-than sign) respectively.</span></p></div><div class="div3"><h4><a id="id-eol-handling"></a>A.<span class="deltaxml-old">3.4</span><span class="deltaxml-new">2.3</span> End-of-Line Handling</h4><p class="xquery">Prior to parsing, the XQuery 4.0 processor must normalize all line breaks. The rules for line breaking follow the rules of <a href="#XML">[XML 1.0]</a> or <a href="#XML1.1">[XML 1.1]</a>. It is implementation-defined which version is used.</p><div class="div4"><h5><a id="id-xml10-eol-handling"></a>A.<span class="deltaxml-old">3.4.1</span><span class="deltaxml-new">2.3.1</span> XML 1.0 End-of-Line Handling</h5><p>For <a href="#XML">[XML 1.0]</a> processing, all of the following must be translated to a single #xA character:</p><ol class="enumar"><li><p>the two-character sequence #xD #xA</p></li><li><p>any #xD character that is not immediately followed by #xA.</p></li></ol></div><div class="div4"><h5><a id="id-xml11-eol-handling"></a>A.<span class="deltaxml-old">3.4.2</span><span class="deltaxml-new">2.3.2</span> XML 1.1 End-of-Line Handling</h5><p>For <a href="#XML1.1">[XML 1.1]</a> processing, all of the following must be translated to a single #xA character:</p><ol class="enumar"><li><p>the two-character sequence #xD #xA</p></li><li><p>the two-character sequence #xD #x85</p></li><li><p>the single character #x85</p></li><li><p>the single character #x2028</p></li><li><p>any #xD character that is not immediately followed by #xA or #x85.</p></li></ol><p class="xquery">The characters #x85 and #x2028 cannot be reliably recognized and translated until the <a href="#doc-xquery40-VersionDecl">VersionDecl</a> declaration (if present) has been read.</p></div></div><div class="div3"><h4><a id="whitespace-rules"></a>A.<span class="deltaxml-old">3.5</span><span class="deltaxml-new">2.4</span> Whitespace Rules</h4><div class="div4"><h5><a id="DefaultWhitespaceHandling"></a>A.<span class="deltaxml-old">3.5.1</span><span class="deltaxml-new">2.4.1</span> Default Whitespace Handling</h5><p> [<a id="Whitespace" title="whitespace">Definition</a>: A <b>whitespace</b> character is any of the characters defined by <a href="http://www.w3.org/TR/REC-xml/#NT-S"> [http://www.w3.org/TR/REC-xml/#NT-S]</a>.] </p><p><span style="display: none;" class="delete_version"> [<a id="IgnorableWhitespace" title="ignorable whitespace">Definition</a>: <b>Ignorable whitespace</b> consists of any <a title="whitespace" class="termref" href="#Whitespace">whitespace</a> characters that may occur between <a title="terminal" class="termref" href="#terminal">terminals</a>, unless these characters occur in the context of a production marked with a <a href="#ExplicitWhitespaceHandling"> ws:explicit</a> annotation, in which case they can occur only where explicitly specified (see <a href="#ExplicitWhitespaceHandling"><span class="delete_version"><b>A.3.5.2 Explicit Whitespace Handling</b></span><span class="modify_version"><b>A.3.5.2 Explicit Whitespace Handling</b></span></a>).] Ignorable whitespace characters are not significant to the semantics of an expression. Whitespace is allowed before the first terminal and after the last terminal <span class="xquery">of a module</span>. Whitespace is allowed between any two <a title="terminal" class="termref" href="#terminal">terminals</a>. <a href="#doc-xquery40-Comment">Comments</a> may also act as "whitespace" to prevent two adjacent terminals from being recognized as one. Some illustrative examples are as follows:</span><span style="display: none;" class="add_version"> [<a id="IgnorableWhitespace" title="ignorable whitespace">Definition</a>: <b>Ignorable whitespace</b> consists of any <a title="whitespace" class="termref" href="#Whitespace">whitespace</a> characters that may occur between <a title="terminal" class="termref" href="#terminal">terminals</a>, unless these characters occur in the context of a production marked with a <a href="#ExplicitWhitespaceHandling"> ws:explicit</a> annotation, in which case they can occur only where explicitly specified (see <a href="#ExplicitWhitespaceHandling"><span class="add_version"><b>A.2.4.2 Explicit Whitespace Handling</b></span><span class="modify_version"><b>A.2.4.2 Explicit Whitespace Handling</b></span></a>).] Ignorable whitespace characters are not significant to the semantics of an expression. Whitespace is allowed before the first terminal and after the last terminal <span class="xquery">of a module</span>. Whitespace is allowed between any two <a title="terminal" class="termref" href="#terminal">terminals</a>. <a href="#doc-xquery40-Comment">Comments</a> may also act as "whitespace" to prevent two adjacent terminals from being recognized as one. Some illustrative examples are as follows:</span><span class="modify_version"> [<a id="IgnorableWhitespace" title="ignorable whitespace">Definition</a>: <b>Ignorable whitespace</b> consists of any <a title="whitespace" class="termref" href="#Whitespace">whitespace</a> characters that may occur between <a title="terminal" class="termref" href="#terminal">terminals</a>, unless these characters occur in the context of a production marked with a <a href="#ExplicitWhitespaceHandling"> ws:explicit</a> annotation, in which case they can occur only where explicitly specified (see <a href="#ExplicitWhitespaceHandling"><span style="display: none;" class="delete_version"><b>A.3.5.2 Explicit Whitespace Handling</b></span><span style="display: none;" class="add_version"><b>A.2.4.2 Explicit Whitespace Handling</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">3.5.2</span><span class="deltaxml-new">2.4.2</span> Explicit Whitespace Handling</b></span></a>).] Ignorable whitespace characters are not significant to the semantics of an expression. Whitespace is allowed before the first terminal and after the last terminal <span class="xquery">of a module</span>. Whitespace is allowed between any two <a title="terminal" class="termref" href="#terminal">terminals</a>. <a href="#doc-xquery40-Comment">Comments</a> may also act as "whitespace" to prevent two adjacent terminals from being recognized as one. Some illustrative examples are as follows:</span></p><ul><li><p><code>foo- foo</code> results in a syntax error. "foo-" would be recognized as a QName.</p></li><li><p><code>foo -foo</code> is syntactically equivalent to <code>foo - foo</code>, two QNames separated by a subtraction operator.</p></li><li><p><code>foo(: This is a comment :)- foo</code> is syntactically equivalent to <code>foo - foo</code>. This is because the comment prevents the two adjacent terminals from being recognized as one.</p></li><li><p><code>foo-foo</code> is syntactically equivalent to single QName. This is because "-" is a valid character in a QName. When used as an operator after the characters of a name, the "-" must be separated from the name, e.g. by using whitespace or parentheses.</p></li><li><p><code>10div 3</code> results in a syntax error.</p></li><li><p><code>10 div3</code> also results in a syntax error.</p></li><li><p><code>10div3</code> also results in a syntax error.</p></li></ul></div><div class="div4"><h5><a id="ExplicitWhitespaceHandling"></a>A.<span class="deltaxml-old">3.5.2</span><span class="deltaxml-new">2.4.2</span> Explicit Whitespace Handling</h5><p>Explicit whitespace notation is specified with the EBNF productions, when it is different from the default rules, using the notation shown below. This notation is not inherited. In other words, if an EBNF rule is marked as /* ws: explicit */, the notation does not automatically apply to all the 'child' EBNF productions of that rule.</p><dl><dt class="label"><a id="ws-explicit"></a>ws: explicit</dt><dd><p><span style="display: none;" class="delete_version">/* ws: explicit */ means that the EBNF notation explicitly notates, with <code>S</code> or otherwise, where <a title="whitespace" class="termref" href="#Whitespace">whitespace characters</a> are allowed. In productions with the /* ws: explicit */ annotation, <a href="#DefaultWhitespaceHandling"><span class="delete_version"><b>A.3.5.1 Default Whitespace Handling</b></span><span class="modify_version"><b>A.3.5.1 Default Whitespace Handling</b></span></a> does not apply. Comments are not allowed in these productions except where the <a href="#doc-xquery40-Comment">Comment</a> non-terminal appears. </span><span style="display: none;" class="add_version">/* ws: explicit */ means that the EBNF notation explicitly notates, with <code>S</code> or otherwise, where <a title="whitespace" class="termref" href="#Whitespace">whitespace characters</a> are allowed. In productions with the /* ws: explicit */ annotation, <a href="#DefaultWhitespaceHandling"><span class="add_version"><b>A.2.4.1 Default Whitespace Handling</b></span><span class="modify_version"><b>A.2.4.1 Default Whitespace Handling</b></span></a> does not apply. Comments are not allowed in these productions except where the <a href="#doc-xquery40-Comment">Comment</a> non-terminal appears. </span><span class="modify_version">/* ws: explicit */ means that the EBNF notation explicitly notates, with <code>S</code> or otherwise, where <a title="whitespace" class="termref" href="#Whitespace">whitespace characters</a> are allowed. In productions with the /* ws: explicit */ annotation, <a href="#DefaultWhitespaceHandling"><span style="display: none;" class="delete_version"><b>A.3.5.1 Default Whitespace Handling</b></span><span style="display: none;" class="add_version"><b>A.2.4.1 Default Whitespace Handling</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">3.5.1</span><span class="deltaxml-new">2.4.1</span> Default Whitespace Handling</b></span></a> does not apply. Comments are not allowed in these productions except where the <a href="#doc-xquery40-Comment">Comment</a> non-terminal appears. </span></p></dd></dl><p id="ws-explicit-lex-states" class="xquery">For example, whitespace is not freely allowed by the direct constructor productions, but is specified explicitly in the grammar, in order to be more consistent with XML.</p></div></div></div><div class="div2"><h3><a id="id-reserved-fn-names"></a>A.<span class="deltaxml-old">4</span><span class="deltaxml-new">3</span> Reserved Function Names</h3><p>The following names are not allowed as function names in an unprefixed form<span class="deltaxml-old">, because they can appear, followed by a left parenthesis, at the start of an XPath or XQuery expression that is not a function call</span><span class="deltaxml-new"> because expression syntax takes precedence</span>.</p><p><span class="deltaxml-old">Names used in </span><a href="#doc-xquery40-KindTest"><span class="deltaxml-old">KindTests</span></a><span class="deltaxml-old">:</span></p><blockquote><p><span class="deltaxml-old">attribute</span><span class="deltaxml-old">comment</span><span class="deltaxml-old">document-node</span><span class="deltaxml-old">element</span><span class="deltaxml-old">namespace-node</span><span class="deltaxml-old">node</span><span class="deltaxml-old">schema-attribute</span><span class="deltaxml-old">schema-element</span><span class="deltaxml-old">processing-instruction</span><span class="deltaxml-old">text</span></p></blockquote><p><span class="deltaxml-old">Names used as syntactic keywords:</span></p><blockquote><p><span class="deltaxml-old">fn</span><span class="deltaxml-old">function</span><span class="deltaxml-old">if</span><span class="deltaxml-old">switch</span><span class="deltaxml-old">typeswitch</span></p></blockquote><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">XQuery 3.1 added </span><code><span class="deltaxml-old">map</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">array</span></code><span class="deltaxml-old"> as reserved function names, but this was unnecessary since they never appear followed by a left parenthesis at the start of an expression. They have therefore been removed from the list. New keywords introducing item types, such as </span><code><span class="deltaxml-old">record</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">union</span></code><span class="deltaxml-old">, have not been included in the list.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">As the language evolves in the future, it may become necessary to reserve additional names. Furthermore, use of common programming terms like </span><code><span class="deltaxml-old">return</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">while</span></code><span class="deltaxml-old"> as function names may cause confusion even though they are not reserved. The easiest way to avoid problems is to use an explicit namespace prefix in all calls to user-defined functions.</span></p></div><ul><li><p><code><span class="deltaxml-new">array</span></code></p></li><li><p><code><span class="deltaxml-new">attribute</span></code></p></li><li><p><code><span class="deltaxml-new">comment</span></code></p></li><li><p><code><span class="deltaxml-new">document-node</span></code></p></li><li><p><code><span class="deltaxml-new">element</span></code></p></li><li><p><code><span class="deltaxml-new">empty-sequence</span></code></p></li><li><p><code><span class="deltaxml-new">function</span></code></p></li><li><p><code><span class="deltaxml-new">if</span></code></p></li><li><p><code><span class="deltaxml-new">item</span></code></p></li><li><p><code><span class="deltaxml-new">map</span></code></p></li><li><p><code><span class="deltaxml-new">namespace-node</span></code></p></li><li><p><code><span class="deltaxml-new">node</span></code></p></li><li><p><code><span class="deltaxml-new">processing-instruction</span></code></p></li><li><p><code><span class="deltaxml-new">schema-attribute</span></code></p></li><li><p><code><span class="deltaxml-new">schema-element</span></code></p></li><li><p><code><span class="deltaxml-new">switch</span></code></p></li><li><p><code><span class="deltaxml-new">text</span></code></p></li><li><p><code><span class="deltaxml-new">tuple</span></code></p></li><li><p><code><span class="deltaxml-new">typeswitch</span></code></p></li><li><p><code><span class="deltaxml-new">union</span></code></p></li></ul></div><div class="div2"><h3><a id="id-precedence-order"></a>A.<span class="deltaxml-old">5</span><span class="deltaxml-new">4</span> Precedence Order (Non-Normative)</h3><p>The grammar in <a href="#id-grammar"><b>A.1 EBNF</b></a> normatively defines built-in precedence among the operators of <span class="xquery">XQuery</span>. These operators are summarized here to make clear the order of their precedence from lowest to highest. The associativity column indicates the order in which operators of equal precedence in an expression are applied.</p><table class="medium"><tbody><tr><th>#</th><th>Operator</th><th>Associativity</th></tr><tr><td>1</td><td><a href="#doc-xquery40-Expr">, (comma)</a></td><td>either</td></tr><tr><td>2</td><td><span class="xquery"><a href="#doc-xquery40-FLWORExpr">FLWOR</a>,</span><a href="#doc-xquery40-QuantifiedExpr">some, every</a>, <span class="xquery"><a href="#doc-xquery40-SwitchExpr">switch</a>,</span><span class="xquery"><a href="#doc-xquery40-TypeswitchExpr">typeswitch</a>,</span><span class="xquery"><a href="#doc-xquery40-TryCatchExpr">try</a>,</span><a href="#doc-xquery40-IfExpr">if</a></td><td>NA</td></tr><tr><td>3</td><td><a href="#doc-xquery40-OrExpr">or</a></td><td>either</td></tr><tr><td>4</td><td><a href="#doc-xquery40-AndExpr">and</a></td><td>either</td></tr><tr><td>5</td><td><a href="#doc-xquery40-ValueComp">eq, ne, lt, le, gt, ge</a>, <a href="#doc-xquery40-GeneralComp">=, !=, &lt;, &lt;=, &gt;, &gt;=</a>, <a href="#doc-xquery40-NodeComp">is, &lt;&lt;, &gt;&gt;</a></td><td>NA</td></tr><tr class="delete_version" style="display: none;"><td>6</td><td><a href="#doc-xquery40-OtherwiseExpr">otherwise</a></td><td>either</td></tr><tr class="modify_version"><td><span class="deltaxml-old">6</span></td><td><a href="#doc-xquery40-OtherwiseExpr"><span class="deltaxml-old">otherwise</span></a></td><td><span class="deltaxml-old">either</span></td></tr><tr><td><span class="deltaxml-old">7</span><span class="deltaxml-new">6</span></td><td><a href="#doc-xquery40-StringConcatExpr">||</a></td><td>left-to-right</td></tr><tr><td><span class="deltaxml-old">8</span><span class="deltaxml-new">7</span></td><td><a href="#doc-xquery40-RangeExpr">to</a></td><td>NA</td></tr><tr><td><span class="deltaxml-old">9</span><span class="deltaxml-new">8</span></td><td><a href="#doc-xquery40-AdditiveExpr">+, - (binary)</a></td><td>left-to-right</td></tr><tr><td><span class="deltaxml-old">10</span><span class="deltaxml-new">9</span></td><td><a href="#doc-xquery40-MultiplicativeExpr">*, div, idiv, mod</a></td><td>left-to-right</td></tr><tr><td><span class="deltaxml-old">11</span><span class="deltaxml-new">10</span></td><td><a href="#doc-xquery40-UnionExpr">union, |</a></td><td>either</td></tr><tr><td><span class="deltaxml-old">12</span><span class="deltaxml-new">11</span></td><td><a href="#doc-xquery40-IntersectExceptExpr">intersect, except</a></td><td>left-to-right</td></tr><tr><td><span class="deltaxml-old">13</span><span class="deltaxml-new">12</span></td><td><a href="#doc-xquery40-InstanceofExpr">instance of</a></td><td>NA</td></tr><tr><td><span class="deltaxml-old">14</span><span class="deltaxml-new">13</span></td><td><a href="#doc-xquery40-TreatExpr">treat as</a></td><td>NA</td></tr><tr><td><span class="deltaxml-old">15</span><span class="deltaxml-new">14</span></td><td><a href="#doc-xquery40-CastableExpr">castable as</a></td><td>NA</td></tr><tr><td><span class="deltaxml-old">16</span><span class="deltaxml-new">15</span></td><td><a href="#doc-xquery40-CastExpr">cast as</a></td><td>NA</td></tr><tr><td><span class="deltaxml-old">17</span><span class="deltaxml-new">16</span></td><td><a href="#doc-xquery40-ArrowExpr">=&gt;<span class="deltaxml-old">, =!&gt;, =?&gt;</span></a></td><td>left-to-right</td></tr><tr><td><span class="deltaxml-old">18</span><span class="deltaxml-new">17</span></td><td><a href="#doc-xquery40-UnaryExpr">-, + (unary)</a></td><td>right-to-left</td></tr><tr><td><span class="deltaxml-old">19</span><span class="deltaxml-new">18</span></td><td><a href="#doc-xquery40-SimpleMapExpr">!</a></td><td>left-to-right</td></tr><tr><td><span class="deltaxml-old">20</span><span class="deltaxml-new">19</span></td><td><a href="#doc-xquery40-PathExpr">/, //</a></td><td>left-to-right</td></tr><tr><td><span class="deltaxml-old">21</span><span class="deltaxml-new">20</span></td><td><a href="#doc-xquery40-Predicate">[ ]</a>, <a href="#doc-xquery40-Lookup">?<span class="deltaxml-old">, ??</span></a></td><td>left-to-right</td></tr><tr><td><span class="deltaxml-old">22</span><span class="deltaxml-new">21</span></td><td><a href="#doc-xquery40-UnaryLookup">? (unary)</a></td><td>NA</td></tr></tbody></table><p> In the "Associativity" column, "either" indicates that all the operators at that level have the associative property (i.e., <code>(A op B) op C</code> is equivalent to <code>A op (B op C)</code>), so their associativity is inconsequential. "NA" (not applicable) indicates that the EBNF does not allow an expression that directly contains multiple operators from that precedence level, so the question of their associativity does not arise. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Parentheses can be used to override the operator precedence in the usual way. Square brackets in an expression such as A[B] serve two roles: they act as an operator causing B to be evaluated once for each item in the value of A, and they act as parentheses enclosing the expression B.</p><p class="xquery">Curly braces in an expression such as validate{E} or ordered{E} perform a similar bracketing role to the parentheses in a function call, but with the difference in most cases that E is an Expr rather than ExprSingle, meaning that it can use the comma operator.</p></div></div></div><div class="div1"><h2><a id="id-type-promotion-and-operator-mapping"></a>B Type Promotion and Operator Mapping</h2><div class="div2"><h3><a id="promotion"></a>B.1 Type Promotion</h3><p><span style="display: none;" class="delete_version"> [<a id="dt-type-promotion" title="type promotion">Definition</a>: Under certain circumstances, an atomic value can be promoted from one type to another.] <b>Type promotion</b> is used in a number of contexts:</span><span style="display: none;" class="add_version"> [<a id="dt-type-promotion" title="type promotion">Definition</a>: Under certain circumstances, an atomic value can be promoted from one type to another. <b>Type promotion</b> is used in evaluating function calls (see <a href="#id-function-calls"><b>4.4.1.1 Static Function Call Syntax</b></a>)<span class="xquery">, <code>order by</code> clauses (see <a href="#id-order-by-clause"><b>4.14.8 Order By Clause</b></a>),</span> and operators that accept numeric or string operands (see <a href="#mapping"><b>B.2 Operator Mapping</b></a>).] The following type promotions are permitted:</span><span class="modify_version"> [<a id="dt-type-promotion" title="type promotion">Definition</a>: Under certain circumstances, an atomic value can be promoted from one type to another.<span class="deltaxml-old">]</span> <b>Type promotion</b> is used in <span class="deltaxml-old">a number of contexts</span><span class="deltaxml-new">evaluating function calls (see </span><a href="#id-function-calls"><b><span class="deltaxml-new">4.4.1.1 Static Function Call Syntax</span></b></a><span class="deltaxml-new">)</span><span class="xquery"><span class="deltaxml-new">, </span><code><span class="deltaxml-new">order by</span></code><span class="deltaxml-new"> clauses (see </span><a href="#id-order-by-clause"><b><span class="deltaxml-new">4.14.8 Order By Clause</span></b></a><span class="deltaxml-new">),</span></span><span class="deltaxml-new"> and operators that accept numeric or string operands (see </span><a href="#mapping"><b><span class="deltaxml-new">B.2 Operator Mapping</span></b></a><span class="deltaxml-new">).] The following type promotions are permitted</span>:</span></p><ul><li><p><span class="deltaxml-old">It forms part of the process described by the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-old">coercion rules</span></a><span class="deltaxml-old">, invoked for example when a value of one type is supplied as an argument of a function call where the required type of the corresponding function parameter is declared with a different type.</span></p></li><li><p><span class="deltaxml-old">It forms part of the process described in </span><a href="#mapping"><b><span class="deltaxml-old">B.2 Operator Mapping</span></b></a><span class="deltaxml-old">, which selects the implementation of a binary operator based on the types of the supplied operands.</span></p></li><li><p><span class="deltaxml-old">It is invoked (by explicit reference) in a number of other situations, for example when computing an average of a sequence of numeric values (in the </span><code><span class="deltaxml-old">fn:avg</span></code><span class="deltaxml-old"> function)</span><span class="xquery"><span class="deltaxml-old">, and in </span><code><span class="deltaxml-old">order by</span></code><span class="deltaxml-old"> clauses (see </span><a href="#id-order-by-clause"><b><span class="deltaxml-old">4.15.9 Order By Clause</span></b></a><span class="deltaxml-old">)</span></span><span class="deltaxml-old">.</span></p></li></ul><p><span class="deltaxml-old">In general, type promotion takes a set of one or more atomic values as input, potentially having different types, and selects a single common type to which all the input values can be converted by casting.</span></p><p><span class="deltaxml-old">There are three families of atomic types that can be mixed in this way:</span></p><ol class="enumar"><li><p><span class="deltaxml-old">Numeric types. This applies when the input contains values of types </span><code><span class="deltaxml-old">xs:decimal</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">xs:float</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old"> (including types derived from these, such as </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old">).</span></p><p><span class="deltaxml-old">The rules are:</span></p><p><span class="deltaxml-new">Numeric type promotion:</span></p><ol class="enumla"><li><p><span class="deltaxml-old">If any of the items is of type </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old">, then all the values are cast to type </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-new">A value of type </span><code><span class="deltaxml-new">xs:float</span></code><span class="deltaxml-new"> (or any type derived by restriction from </span><code><span class="deltaxml-new">xs:float</span></code><span class="deltaxml-new">) can be promoted to the type </span><code><span class="deltaxml-new">xs:double</span></code><span class="deltaxml-new">. The result is the </span><code><span class="deltaxml-new">xs:double</span></code><span class="deltaxml-new"> value that is the same as the original value.</span></p></li><li><p><span class="deltaxml-old">Otherwise, if any of the items is of type </span><code><span class="deltaxml-old">xs:float</span></code><span class="deltaxml-old">, then all the values are cast to type </span><code><span class="deltaxml-old">xs:float</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-new">A value of type </span><code><span class="deltaxml-new">xs:decimal</span></code><span class="deltaxml-new"> (or any type derived by restriction from </span><code><span class="deltaxml-new">xs:decimal</span></code><span class="deltaxml-new">) can be promoted to either of the types </span><code><span class="deltaxml-new">xs:float</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">xs:double</span></code><span class="deltaxml-new">. The result of this promotion is created by casting the original value to the required type. This kind of promotion may cause loss of precision.</span></p></li><li class="delete_version" style="display: none;"><p>Otherwise, no casting takes place: the values remain as <code>xs:decimal</code>.</p></li><li class="modify_version"><p><span class="deltaxml-old">Otherwise, no casting takes place: the values remain as </span><code><span class="deltaxml-old">xs:decimal</span></code><span class="deltaxml-old">.</span></p></li></ol></li><li><p><span class="deltaxml-old">String types. This applies when the input contains values of types </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:anyURI</span></code><span class="deltaxml-old"> (including types derived from these, such as </span><code><span class="deltaxml-old">xs:NCName</span></code><span class="deltaxml-old">).</span></p><p><span class="deltaxml-old">The rule is that if any of the items is of type </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">, then all the values are cast to type </span><code><span class="deltaxml-old">xs:string</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-new">URI type promotion: A value of type </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new"> (or any type derived by restriction from </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new">) can be promoted to the type </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new">. The result of this promotion is created by casting the original value to the type </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new">Note:</span></b></p><p><span class="deltaxml-new">Since </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new"> values can be promoted to </span><code><span class="deltaxml-new">xs:string</span></code><span class="deltaxml-new">, functions and operators that compare strings using the </span><a title="default collation" class="termref" href="#dt-def-collation"><span class="deltaxml-new">default collation</span></a><span class="deltaxml-new"> also compare </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new"> values using the </span><a title="default collation" class="termref" href="#dt-def-collation"><span class="deltaxml-new">default collation</span></a><span class="deltaxml-new">. This ensures that orderings that include strings, </span><code><span class="deltaxml-new">xs:anyURI</span></code><span class="deltaxml-new"> values, or any combination of the two types are consistent and well-defined.</span></p></div></li><li class="delete_version" style="display: none;"><p>Binary types. This applies when the input contains values of types <code>xs:hexBinary</code> and <code>xs:base64Binary</code> (including types derived from these).</p><p>The rule is that if any of the items is of type <code>xs:hexBinary</code>, then all the values are cast to type <code>xs:hexBinary</code>.</p></li><li class="modify_version"><p><span class="deltaxml-old">Binary types. This applies when the input contains values of types </span><code><span class="deltaxml-old">xs:hexBinary</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:base64Binary</span></code><span class="deltaxml-old"> (including types derived from these).</span></p><p><span class="deltaxml-old">The rule is that if any of the items is of type </span><code><span class="deltaxml-old">xs:hexBinary</span></code><span class="deltaxml-old">, then all the values are cast to type </span><code><span class="deltaxml-old">xs:hexBinary</span></code><span class="deltaxml-old">.</span></p></li></ol><p><span class="deltaxml-new">Note that </span><a title="type promotion" class="termref" href="#dt-type-promotion"><span class="deltaxml-new">type promotion</span></a><span class="deltaxml-new"> is different from </span><a title="subtype substitution" class="termref" href="#dt-subtype-substitution"><span class="deltaxml-new">subtype substitution</span></a><span class="deltaxml-new">. For example:</span></p><ul><li><p><span class="deltaxml-new">A function that expects a parameter </span><code><span class="deltaxml-new">$p</span></code><span class="deltaxml-new"> of type </span><code><span class="deltaxml-new">xs:float</span></code><span class="deltaxml-new"> can be invoked with a value of type </span><code><span class="deltaxml-new">xs:decimal</span></code><span class="deltaxml-new">. This is an example of </span><a title="type promotion" class="termref" href="#dt-type-promotion"><span class="deltaxml-new">type promotion</span></a><span class="deltaxml-new">. The value is actually converted to the expected type. Within the body of the function, </span><code><span class="deltaxml-new">$p instance of xs:decimal</span></code><span class="deltaxml-new"> returns </span><code><span class="deltaxml-new">false</span></code><span class="deltaxml-new">.</span></p></li><li><p><span class="deltaxml-new">A function that expects a parameter </span><code><span class="deltaxml-new">$p</span></code><span class="deltaxml-new"> of type </span><code><span class="deltaxml-new">xs:decimal</span></code><span class="deltaxml-new"> can be invoked with a value of type </span><code><span class="deltaxml-new">xs:integer</span></code><span class="deltaxml-new">. This is an example of </span><a title="subtype substitution" class="termref" href="#dt-subtype-substitution"><span class="deltaxml-new">subtype substitution</span></a><span class="deltaxml-new">. The value retains its original type. Within the body of the function, </span><code><span class="deltaxml-new">$p instance of xs:integer</span></code><span class="deltaxml-new"> returns </span><code><span class="deltaxml-new">true</span></code><span class="deltaxml-new">.</span></p></li></ul></div><div class="div2"><h3><a id="mapping"></a>B.2 Operator Mapping</h3><p><span class="deltaxml-old">The operator mapping tables in this section list the combinations of types for which various operators of XQuery 4.0 are defined. The operators covered by this appendix are the value comparison operators </span><code><span class="deltaxml-old">eq</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">lt</span></code><span class="deltaxml-old">, and the arithmetic operators </span><code><span class="deltaxml-old">+</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">-</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">*</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">div</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">idiv</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">mod</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">Other operators (such as </span><code><span class="deltaxml-old">and</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">or</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">intersect</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">union</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">=</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">||</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">is</span></code><span class="deltaxml-old">) are defined directly in the main body of this document, and do not occur in the operator mapping table.</span></p><p><span class="deltaxml-old">The operators </span><code><span class="deltaxml-old">ne</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">le</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">gt</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">ge</span></code><span class="deltaxml-old"> do not occur in the operator mapping table, but are instead defined by the following equivalences:</span></p><ul><li><p><code><span class="deltaxml-old">A ne B</span></code><span class="deltaxml-old"> is equivalent to </span><code><span class="deltaxml-old">not(A eq B)</span></code></p></li><li><p><code><span class="deltaxml-old">A le B</span></code><span class="deltaxml-old"> is equivalent to </span><code><span class="deltaxml-old">A lt B or A eq B</span></code></p></li><li><p><code><span class="deltaxml-old">A gt B</span></code><span class="deltaxml-old"> is equivalent to </span><code><span class="deltaxml-old">B lt A</span></code></p></li><li><p><code><span class="deltaxml-old">A ge B</span></code><span class="deltaxml-old"> is equivalent to </span><code><span class="deltaxml-old">B lt A or B eq A</span></code></p></li></ul><p><span style="display: none;" class="delete_version"> [<a id="dt-operator-function" title="operator function">Definition</a>: For each operator and valid combination of operand types, the operator mapping tables specify a result type and an expression that invokes an <b>operator function</b>; the operator function implements the semantics of the operator for the given types.] The definitions of the operator functions are given in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>. The result of an operator may be the raising of an error by its operator function, as defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>. The operator function fully defines the semantics of a given operator for the case where the operands are single atomic values of the types given in the table. For the definition of each operator (including its behavior for empty sequences or sequences of length greater than one), see the descriptive material in the main part of this document.</span><span style="display: none;" class="add_version">The operator mapping tables in this section list the combinations of types for which the various operators of XQuery 4.0 are defined. [<a id="dt-operator-function" title="operator function">Definition</a>: For each operator and valid combination of operand types, the operator mapping tables specify a result type and an <b>operator function</b> that implements the semantics of the operator for the given types.] The definitions of the operator functions are given in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>. The result of an operator may be the raising of an error by its operator function, as defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>. The operator function fully defines the semantics of a given operator for the case where the operands are single atomic values of the types given in the table. For the definition of each operator (including its behavior for empty sequences or sequences of length greater than one), see the descriptive material in the main part of this document.</span><span class="modify_version"><span class="deltaxml-new">The operator mapping tables in this section list the combinations of types for which the various operators of XQuery 4.0 are defined.</span> [<a id="dt-operator-function" title="operator function">Definition</a>: For each operator and valid combination of operand types, the operator mapping tables specify a result type and an <span class="deltaxml-old">expression that invokes an </span><b>operator function</b><span class="deltaxml-old">; the operator function</span><span class="deltaxml-new"> that</span> implements the semantics of the operator for the given types.] The definitions of the operator functions are given in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>. The result of an operator may be the raising of an error by its operator function, as defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>. The operator function fully defines the semantics of a given operator for the case where the operands are single atomic values of the types given in the table. For the definition of each operator (including its behavior for empty sequences or sequences of length greater than one), see the descriptive material in the main part of this document.</span></p><p><span class="deltaxml-new">The </span><code><span class="deltaxml-new">and</span></code><span class="deltaxml-new"> and </span><code><span class="deltaxml-new">or</span></code><span class="deltaxml-new"> operators are defined directly in the main body of this document, and do not occur in the operator mapping table.</span></p><p><span class="deltaxml-new">The operators </span><code><span class="deltaxml-new">ne</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">le</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">gt</span></code><span class="deltaxml-new">, and </span><code><span class="deltaxml-new">ge</span></code><span class="deltaxml-new"> do not occur in the operator mapping table, but are instead defined by the following equivalences:</span></p><ul><li><p><code><span class="deltaxml-new">A ne B</span></code><span class="deltaxml-new"> is equivalent to </span><code><span class="deltaxml-new">not(A eq B)</span></code></p></li><li><p><code><span class="deltaxml-new">A le B</span></code><span class="deltaxml-new"> is equivalent to </span><code><span class="deltaxml-new">A lt B or A eq B</span></code></p></li><li><p><code><span class="deltaxml-new">A gt B</span></code><span class="deltaxml-new"> is equivalent to </span><code><span class="deltaxml-new">B lt A</span></code></p></li><li><p><code><span class="deltaxml-new">A ge B</span></code><span class="deltaxml-new"> is equivalent to </span><code><span class="deltaxml-new">B lt A or B eq A</span></code></p></li></ul><p>If an operator in the operator mapping tables expects an operand of type <em>ET</em>, that operator can be applied to an operand of type <em>AT</em> if type <em>AT</em> can be converted to type <em>ET</em> by a combination of <a title="type promotion" class="termref" href="#dt-type-promotion">type promotion</a> and <a title="subtype substitution" class="termref" href="#dt-subtype-substitution">subtype substitution</a>. For example, a table entry indicates that the <code>gt</code> operator may be applied to two <code>xs:date</code> operands, returning <code>xs:boolean</code>. Therefore, the <code>gt</code> operator may also be applied to two (possibly different) subtypes of <code>xs:date</code>, also returning <code>xs:boolean</code>.</p><p> [<a id="dt-numeric" title="numeric">Definition</a>: When referring to a type, the term <b>numeric</b> denotes the types <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>, and <code>xs:double</code> which are all member types of the built-in union type <code>xs:numeric</code>.] An operator whose operands and result are designated as <a title="numeric" class="termref" href="#dt-numeric">numeric</a> might be thought of as representing four operators, one for each of the numeric types. For example, the numeric <code>+</code> operator might be thought of as representing the following four operators:</p><table style="width:80%" class="medium"><tbody><tr><th style="text-align:center">Operator</th><th style="text-align:center">First operand type</th><th style="text-align:center">Second operand type</th><th style="text-align:center">Result type</th></tr><tr><td style="text-align:center"><code>+</code></td><td style="text-align:center"><code>xs:integer</code></td><td style="text-align:center"><code>xs:integer</code></td><td style="text-align:center"><code>xs:integer</code></td></tr><tr><td style="text-align:center"><code>+</code></td><td style="text-align:center"><code>xs:decimal</code></td><td style="text-align:center"><code>xs:decimal</code></td><td style="text-align:center"><code>xs:decimal</code></td></tr><tr><td style="text-align:center"><code>+</code></td><td style="text-align:center"><code>xs:float</code></td><td style="text-align:center"><code>xs:float</code></td><td style="text-align:center"><code>xs:float</code></td></tr><tr><td style="text-align:center"><code>+</code></td><td style="text-align:center"><code>xs:double</code></td><td style="text-align:center"><code>xs:double</code></td><td style="text-align:center"><code>xs:double</code></td></tr></tbody></table><p>A numeric operator may be validly applied to an operand of type <em>AT</em> if type <em>AT</em> can be converted to any of the four numeric types by a combination of <a title="type promotion" class="termref" href="#dt-type-promotion">type promotion</a> and <a title="subtype substitution" class="termref" href="#dt-subtype-substitution">subtype substitution</a>. If the result type of an operator is listed as numeric, it means "the first type in the ordered list <code>(xs:integer, xs:decimal, xs:float, xs:double)</code> into which all operands can be converted by <a title="subtype substitution" class="termref" href="#dt-subtype-substitution">subtype substitution</a> and <a title="type promotion" class="termref" href="#dt-type-promotion">type promotion</a>." As an example, suppose that the type <code>hatsize</code> is derived from <code>xs:integer</code> and the type <code>shoesize</code> is derived from <code>xs:float</code>. Then if the <code>+</code> operator is invoked with operands of type <code>hatsize</code> and <code>shoesize</code>, it returns a result of type <code>xs:float</code>. Similarly, if <code>+</code> is invoked with two operands of type <code>hatsize</code> it returns a result of type <code>xs:integer</code>.</p><p> [<a id="dt-gregorian" title="Gregorian">Definition</a>: In the operator mapping tables, the term <b>Gregorian</b> refers to the types <code>xs:gYearMonth</code>, <code>xs:gYear</code>, <code>xs:gMonthDay</code>, <code>xs:gDay</code>, and <code>xs:gMonth</code>.] For binary operators that accept two Gregorian-type operands, both operands must have the same type (for example, if one operand is of type <code>xs:gDay</code>, the other operand must be of type <code>xs:gDay</code>.)</p><p><span class="deltaxml-old"> [</span><a id="dt-binary" title="binary"><span class="deltaxml-old">Definition</span></a><span class="deltaxml-old">: In the operator mapping tables, the term </span><b><span class="deltaxml-old">binary</span></b><span class="deltaxml-old"> refers to the types </span><code><span class="deltaxml-old">xs:hexBinary</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:base64Binary</span></code><span class="deltaxml-old">.] For operators that accept two binary operands, both operands are promoted to type </span><code><span class="deltaxml-old">xs:hexBinary</span></code><span class="deltaxml-old">.</span></p><table style="border:1px solid" class="small"><caption>Binary Operators</caption><tbody><tr><th>Operator</th><th>Type(A)</th><th>Type(B)</th><th>Function</th><th>Result type</th></tr><tr><td>A + B</td><td>numeric</td><td>numeric</td><td>op:numeric-add(A, B)</td><td>numeric</td></tr><tr><td>A + B</td><td>xs:date</td><td>xs:yearMonthDuration</td><td>op:add-yearMonthDuration-to-date(A, B)</td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:date</td><td>op:add-yearMonthDuration-to-date(B, A)</td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:date</td><td>xs:dayTimeDuration</td><td>op:add-dayTimeDuration-to-date(A, B)</td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:date</td><td>op:add-dayTimeDuration-to-date(B, A)</td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:time</td><td>xs:dayTimeDuration</td><td>op:add-dayTimeDuration-to-time(A, B)</td><td>xs:time</td></tr><tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:time</td><td>op:add-dayTimeDuration-to-time(B, A)</td><td>xs:time</td></tr><tr><td>A + B</td><td>xs:dateTime</td><td>xs:yearMonthDuration</td><td>op:add-yearMonthDuration-to-dateTime(A, B)</td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:dateTime</td><td>op:add-yearMonthDuration-to-dateTime(B, A)</td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xs:dateTime</td><td>xs:dayTimeDuration</td><td>op:add-dayTimeDuration-to-dateTime(A, B)</td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:dateTime</td><td>op:add-dayTimeDuration-to-dateTime(B, A)</td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:add-yearMonthDurations(A, B)</td><td>xs:yearMonthDuration</td></tr><tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:add-dayTimeDurations(A, B)</td><td>xs:dayTimeDuration</td></tr><tr><td>A - B</td><td>numeric</td><td>numeric</td><td>op:numeric-subtract(A, B)</td><td>numeric</td></tr><tr><td>A - B</td><td>xs:date</td><td>xs:date</td><td>op:subtract-dates(A, B)</td><td>xs:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:date</td><td>xs:yearMonthDuration</td><td>op:subtract-yearMonthDuration-from-date(A, B)</td><td>xs:date</td></tr><tr><td>A - B</td><td>xs:date</td><td>xs:dayTimeDuration</td><td>op:subtract-dayTimeDuration-from-date(A, B)</td><td>xs:date</td></tr><tr><td>A - B</td><td>xs:time</td><td>xs:time</td><td>op:subtract-times(A, B)</td><td>xs:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:time</td><td>xs:dayTimeDuration</td><td>op:subtract-dayTimeDuration-from-time(A, B)</td><td>xs:time</td></tr><tr><td>A - B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>op:subtract-dateTimes(A, B)</td><td>xs:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:dateTime</td><td>xs:yearMonthDuration</td><td>op:subtract-yearMonthDuration-from-dateTime(A, B)</td><td>xs:dateTime</td></tr><tr><td>A - B</td><td>xs:dateTime</td><td>xs:dayTimeDuration</td><td>op:subtract-dayTimeDuration-from-dateTime(A, B)</td><td>xs:dateTime</td></tr><tr><td>A - B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:subtract-yearMonthDurations(A, B)</td><td>xs:yearMonthDuration</td></tr><tr><td>A - B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:subtract-dayTimeDurations(A, B)</td><td>xs:dayTimeDuration</td></tr><tr><td>A * B</td><td>numeric</td><td>numeric</td><td>op:numeric-multiply(A, B)</td><td>numeric</td></tr><tr><td>A * B</td><td>xs:yearMonthDuration</td><td>numeric</td><td>op:multiply-yearMonthDuration(A, B)</td><td>xs:yearMonthDuration</td></tr><tr><td>A * B</td><td>numeric</td><td>xs:yearMonthDuration</td><td>op:multiply-yearMonthDuration(B, A)</td><td>xs:yearMonthDuration</td></tr><tr><td>A * B</td><td>xs:dayTimeDuration</td><td>numeric</td><td>op:multiply-dayTimeDuration(A, B)</td><td>xs:dayTimeDuration</td></tr><tr><td>A * B</td><td>numeric</td><td>xs:dayTimeDuration</td><td>op:multiply-dayTimeDuration(B, A)</td><td>xs:dayTimeDuration</td></tr><tr class="delete_version" style="display: none;"><td>A × B</td><td>numeric</td><td>numeric</td><td>op:numeric-multiply(A, B)</td><td>numeric</td></tr><tr class="modify_version"><td><span class="deltaxml-old">A × B</span></td><td><span class="deltaxml-old">numeric</span></td><td><span class="deltaxml-old">numeric</span></td><td><span class="deltaxml-old">op:numeric-multiply(A, B)</span></td><td><span class="deltaxml-old">numeric</span></td></tr><tr class="delete_version" style="display: none;"><td>A × B</td><td>xs:yearMonthDuration</td><td>numeric</td><td>op:multiply-yearMonthDuration(A, B)</td><td>xs:yearMonthDuration</td></tr><tr class="modify_version"><td><span class="deltaxml-old">A × B</span></td><td><span class="deltaxml-old">xs:yearMonthDuration</span></td><td><span class="deltaxml-old">numeric</span></td><td><span class="deltaxml-old">op:multiply-yearMonthDuration(A, B)</span></td><td><span class="deltaxml-old">xs:yearMonthDuration</span></td></tr><tr class="delete_version" style="display: none;"><td>A × B</td><td>numeric</td><td>xs:yearMonthDuration</td><td>op:multiply-yearMonthDuration(B, A)</td><td>xs:yearMonthDuration</td></tr><tr class="modify_version"><td><span class="deltaxml-old">A × B</span></td><td><span class="deltaxml-old">numeric</span></td><td><span class="deltaxml-old">xs:yearMonthDuration</span></td><td><span class="deltaxml-old">op:multiply-yearMonthDuration(B, A)</span></td><td><span class="deltaxml-old">xs:yearMonthDuration</span></td></tr><tr class="delete_version" style="display: none;"><td>A × B</td><td>xs:dayTimeDuration</td><td>numeric</td><td>op:multiply-dayTimeDuration(A, B)</td><td>xs:dayTimeDuration</td></tr><tr class="modify_version"><td><span class="deltaxml-old">A × B</span></td><td><span class="deltaxml-old">xs:dayTimeDuration</span></td><td><span class="deltaxml-old">numeric</span></td><td><span class="deltaxml-old">op:multiply-dayTimeDuration(A, B)</span></td><td><span class="deltaxml-old">xs:dayTimeDuration</span></td></tr><tr class="delete_version" style="display: none;"><td>A × B</td><td>numeric</td><td>xs:dayTimeDuration</td><td>op:multiply-dayTimeDuration(B, A)</td><td>xs:dayTimeDuration</td></tr><tr class="modify_version"><td><span class="deltaxml-old">A × B</span></td><td><span class="deltaxml-old">numeric</span></td><td><span class="deltaxml-old">xs:dayTimeDuration</span></td><td><span class="deltaxml-old">op:multiply-dayTimeDuration(B, A)</span></td><td><span class="deltaxml-old">xs:dayTimeDuration</span></td></tr><tr><td>A idiv B</td><td>numeric</td><td>numeric</td><td>op:numeric-integer-divide(A, B)</td><td>xs:integer</td></tr><tr><td>A div B</td><td>numeric</td><td>numeric</td><td>op:numeric-divide(A, B)</td><td>numeric; but xs:decimal if both operands are xs:integer</td></tr><tr><td>A div B</td><td>xs:yearMonthDuration</td><td>numeric</td><td>op:divide-yearMonthDuration(A, B)</td><td>xs:yearMonthDuration</td></tr><tr><td>A div B</td><td>xs:dayTimeDuration</td><td>numeric</td><td>op:divide-dayTimeDuration(A, B)</td><td>xs:dayTimeDuration</td></tr><tr><td>A div B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td><td>xs:decimal</td></tr><tr><td>A div B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td><td>xs:decimal</td></tr><tr class="delete_version" style="display: none;"><td>A ÷ B</td><td>numeric</td><td>numeric</td><td>op:numeric-divide(A, B)</td><td>numeric; but xs:decimal if both operands are xs:integer</td></tr><tr class="modify_version"><td><span class="deltaxml-old">A ÷ B</span></td><td><span class="deltaxml-old">numeric</span></td><td><span class="deltaxml-old">numeric</span></td><td><span class="deltaxml-old">op:numeric-divide(A, B)</span></td><td><span class="deltaxml-old">numeric; but xs:decimal if both operands are xs:integer</span></td></tr><tr class="delete_version" style="display: none;"><td>A ÷ B</td><td>xs:yearMonthDuration</td><td>numeric</td><td>op:divide-yearMonthDuration(A, B)</td><td>xs:yearMonthDuration</td></tr><tr class="modify_version"><td><span class="deltaxml-old">A ÷ B</span></td><td><span class="deltaxml-old">xs:yearMonthDuration</span></td><td><span class="deltaxml-old">numeric</span></td><td><span class="deltaxml-old">op:divide-yearMonthDuration(A, B)</span></td><td><span class="deltaxml-old">xs:yearMonthDuration</span></td></tr><tr class="delete_version" style="display: none;"><td>A ÷ B</td><td>xs:dayTimeDuration</td><td>numeric</td><td>op:divide-dayTimeDuration(A, B)</td><td>xs:dayTimeDuration</td></tr><tr class="modify_version"><td><span class="deltaxml-old">A ÷ B</span></td><td><span class="deltaxml-old">xs:dayTimeDuration</span></td><td><span class="deltaxml-old">numeric</span></td><td><span class="deltaxml-old">op:divide-dayTimeDuration(A, B)</span></td><td><span class="deltaxml-old">xs:dayTimeDuration</span></td></tr><tr class="delete_version" style="display: none;"><td>A ÷ B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td><td>xs:decimal</td></tr><tr class="modify_version"><td><span class="deltaxml-old">A ÷ B</span></td><td><span class="deltaxml-old">xs:yearMonthDuration</span></td><td><span class="deltaxml-old">xs:yearMonthDuration</span></td><td><span class="deltaxml-old">op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</span></td><td><span class="deltaxml-old">xs:decimal</span></td></tr><tr class="delete_version" style="display: none;"><td>A ÷ B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td><td>xs:decimal</td></tr><tr class="modify_version"><td><span class="deltaxml-old">A ÷ B</span></td><td><span class="deltaxml-old">xs:dayTimeDuration</span></td><td><span class="deltaxml-old">xs:dayTimeDuration</span></td><td><span class="deltaxml-old">op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</span></td><td><span class="deltaxml-old">xs:decimal</span></td></tr><tr><td>A mod B</td><td>numeric</td><td>numeric</td><td>op:numeric-mod(A, B)</td><td>numeric</td></tr><tr><td>A eq B</td><td>numeric</td><td>numeric</td><td>op:numeric-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:boolean</td><td>xs:boolean</td><td>op:boolean-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:string</td><td>xs:string</td><td>op:numeric-equal(fn:compare(A, B), 0)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:date</td><td>xs:date</td><td>op:date-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:time</td><td>xs:time</td><td>op:time-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>op:dateTime-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:duration</td><td>xs:duration</td><td>op:duration-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>Gregorian</td><td>Gregorian</td><td>op:gYear-equal(A, B) etc.</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td><span class="deltaxml-old">binary</span><span class="deltaxml-new">xs:hexBinary</span></td><td><span class="deltaxml-old">binary</span><span class="deltaxml-new">xs:hexBinary</span></td><td><span class="deltaxml-old">op:binary</span><span class="deltaxml-new">op:hexBinary</span>-equal(A, B)</td><td>xs:boolean</td></tr><tr class="add_version" style="display: none;"><td>A eq B</td><td>xs:base64Binary</td><td>xs:base64Binary</td><td>op:base64Binary-equal(A, B)</td><td>xs:boolean</td></tr><tr class="modify_version"><td><span class="deltaxml-new">A eq B</span></td><td><span class="deltaxml-new">xs:base64Binary</span></td><td><span class="deltaxml-new">xs:base64Binary</span></td><td><span class="deltaxml-new">op:base64Binary-equal(A, B)</span></td><td><span class="deltaxml-new">xs:boolean</span></td></tr><tr><td>A eq B</td><td>xs:QName</td><td>xs:QName</td><td>op:QName-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:NOTATION</td><td>xs:NOTATION</td><td>op:NOTATION-equal(A, B)</td><td>xs:boolean</td></tr><tr class="add_version" style="display: none;"><td>A eq B</td><td>xs:hexBinary</td><td>xs:hexBinary</td><td>op:hexBinary-equal(A, B)</td><td>xs:boolean</td></tr><tr class="modify_version"><td><span class="deltaxml-new">A eq B</span></td><td><span class="deltaxml-new">xs:hexBinary</span></td><td><span class="deltaxml-new">xs:hexBinary</span></td><td><span class="deltaxml-new">op:hexBinary-equal(A, B)</span></td><td><span class="deltaxml-new">xs:boolean</span></td></tr><tr class="add_version" style="display: none;"><td>A eq B</td><td>xs:base64Binary</td><td>xs:base64Binary</td><td>op:hexBinary-equal(A, B)</td><td>xs:boolean</td></tr><tr class="modify_version"><td><span class="deltaxml-new">A eq B</span></td><td><span class="deltaxml-new">xs:base64Binary</span></td><td><span class="deltaxml-new">xs:base64Binary</span></td><td><span class="deltaxml-new">op:hexBinary-equal(A, B)</span></td><td><span class="deltaxml-new">xs:boolean</span></td></tr><tr><td>A lt B</td><td>numeric</td><td>numeric</td><td>op:numeric-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xs:boolean</td><td>xs:boolean</td><td>op:boolean-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xs:string</td><td>xs:string</td><td>op:numeric-less-than(fn:compare(A, B), 0)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xs:date</td><td>xs:date</td><td>op:date-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xs:time</td><td>xs:time</td><td>op:time-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>op:dateTime-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:yearMonthDuration-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:dayTimeDuration-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td><span class="deltaxml-old">binary</span><span class="deltaxml-new">xs:hexBinary</span></td><td><span class="deltaxml-old">binary</span><span class="deltaxml-new">xs:hexBinary</span></td><td><span class="deltaxml-old">op:binary</span><span class="deltaxml-new">op:hexBinary</span>-less-than(A, B)</td><td>xs:boolean</td></tr><tr class="add_version" style="display: none;"><td>A lt B</td><td>xs:base64Binary</td><td>xs:base64Binary</td><td>op:base64Binary-less-than(A, B)</td><td>xs:boolean</td></tr><tr class="modify_version"><td><span class="deltaxml-new">A lt B</span></td><td><span class="deltaxml-new">xs:base64Binary</span></td><td><span class="deltaxml-new">xs:base64Binary</span></td><td><span class="deltaxml-new">op:base64Binary-less-than(A, B)</span></td><td><span class="deltaxml-new">xs:boolean</span></td></tr></tbody></table><table style="border:1px solid" class="small"><caption>Unary Operators</caption><thead><tr><th>Operator</th><th>Operand type</th><th>Function</th><th>Result type</th></tr></thead><tbody><tr><td>+ A</td><td>numeric</td><td>op:numeric-unary-plus(A)</td><td>numeric</td></tr><tr><td>- A</td><td>numeric</td><td>op:numeric-unary-minus(A)</td><td>numeric</td></tr></tbody></table></div><div class="div2"><h3><a id="id-math-symbols"></a><span class="deltaxml-new">B.3 Mathematical Operator Symbols</span></h3><p><span class="deltaxml-new">Various operators written in the grammar using alphabetic keywords (such as </span><code><span class="deltaxml-new">and</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">or</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">le</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">ge</span></code><span class="deltaxml-new">) can instead be written using mathematical symbols. The equivalents are given in the table below:</span></p><table style="border:1px solid"><caption><span class="deltaxml-new">Mathematical Operator Symbols</span></caption><thead><tr><th><span class="deltaxml-new">Operator</span></th><th><span class="deltaxml-new">Symbol</span></th><th><span class="deltaxml-new">Codepoint</span></th></tr></thead><tbody><tr><td><span class="deltaxml-new">and</span></td><td><span class="deltaxml-new">∧</span></td><td><span class="deltaxml-new">x2227</span></td></tr><tr><td><span class="deltaxml-new">or</span></td><td><span class="deltaxml-new">∨</span></td><td><span class="deltaxml-new">x2228</span></td></tr><tr><td><span class="deltaxml-new">eq</span></td><td><span class="deltaxml-new">≐</span></td><td><span class="deltaxml-new">x2250</span></td></tr><tr><td><span class="deltaxml-new">ne</span></td><td><span class="deltaxml-new">≠</span></td><td><span class="deltaxml-new">x2260</span></td></tr><tr><td><span class="deltaxml-new">lt</span></td><td><span class="deltaxml-new">⋖</span></td><td><span class="deltaxml-new">x22D6</span></td></tr><tr><td><span class="deltaxml-new">gt</span></td><td><span class="deltaxml-new">⋗</span></td><td><span class="deltaxml-new">x22D7</span></td></tr><tr><td><span class="deltaxml-new">le</span></td><td><span class="deltaxml-new">≤</span></td><td><span class="deltaxml-new">x2264</span></td></tr><tr><td><span class="deltaxml-new">ge</span></td><td><span class="deltaxml-new">≥</span></td><td><span class="deltaxml-new">x2265</span></td></tr><tr><td><span class="deltaxml-new">div</span></td><td><span class="deltaxml-new">÷</span></td><td><span class="deltaxml-new">xF7</span></td></tr><tr><td><span class="deltaxml-new">mod</span></td><td></td><td></td></tr><tr><td><span class="deltaxml-new">idiv</span></td><td><span class="deltaxml-new">⨸</span></td><td><span class="deltaxml-new">x2A38</span></td></tr><tr><td><span class="deltaxml-new">union (|)</span></td><td><span class="deltaxml-new">∪</span></td><td><span class="deltaxml-new">x222A</span></td></tr><tr><td><span class="deltaxml-new">intersect</span></td><td><span class="deltaxml-new">∩</span></td><td><span class="deltaxml-new">x2229</span></td></tr><tr><td><span class="deltaxml-new">except</span></td><td><span class="deltaxml-new">∖</span></td><td><span class="deltaxml-new">x2216</span></td></tr><tr><td><span class="deltaxml-new">is</span></td><td><span class="deltaxml-new">≡</span></td><td><span class="deltaxml-new">x2261</span></td></tr><tr><td><span class="deltaxml-new">&lt;&lt; (precedes)</span></td><td><span class="deltaxml-new">≪</span></td><td><span class="deltaxml-new">x226A</span></td></tr><tr><td><span class="deltaxml-new">&gt;&gt; (follows)</span></td><td><span class="deltaxml-new">≫</span></td><td><span class="deltaxml-new">x226B</span></td></tr><tr><td><span class="deltaxml-new">otherwise</span></td><td><span class="deltaxml-new">⊩</span></td><td><span class="deltaxml-new">x22A9</span></td></tr><tr><td><span class="deltaxml-new">some</span></td><td><span class="deltaxml-new">∃</span></td><td><span class="deltaxml-new">x2203</span></td></tr><tr><td><span class="deltaxml-new">every</span></td><td><span class="deltaxml-new">∀</span></td><td><span class="deltaxml-new">x2200</span></td></tr><tr><td><span class="deltaxml-new">satisfies</span></td><td><span class="deltaxml-new">⧴</span></td><td><span class="deltaxml-new">x29F4</span></td></tr></tbody></table><p><span class="deltaxml-new">For example, the expression </span><code><span class="deltaxml-new">some $x in $X satisfies $x le 17</span></code><span class="deltaxml-new"> can equivalently be written </span><code><span class="deltaxml-new">∃ $x in $X ⧴ $x ≤ 17</span></code></p></div></div><div class="div1"><h2><a id="id-xq-context-components"></a>C Context Components</h2><p>The tables in this section describe how values are assigned to the various components of the static context and dynamic context, and to the parameters that control the serialization process.</p><div class="div2"><h3><a id="id-xq-static-context-components"></a>C.1 Static Context Components</h3><p>The following table describes the components of the <b>static context</b>. The following aspects of each component are described:</p><ul><li><p><em>Default initial value:</em> This is the initial value of the component if it is not overridden or augmented by the implementation or by a query.</p></li><li><p><em>Can be overwritten or augmented by implementation:</em> Indicates whether an XQuery implementation is allowed to replace the default initial value of the component by a different, <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> value and/or to augment the default initial value by additional <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> values.</p></li><li><p><em>Can be overwritten or augmented by prolog:</em> Indicates whether there are prolog declarations that can replace and/or augment the initial value provided by default or by the implementation. </p></li><li><p><em>Can be overwritten or augmented by expressions:</em> Indicates whether there are expressions that can replace and/or augment the value of the component for their subexpressions. </p></li><li><p><em>Consistency Rules:</em> Indicates rules that must be observed in assigning values to the component. Additional consistency rules may be found in <a href="#id-consistency-constraints"><b>2.3.5 Consistency Constraints</b></a>.</p></li></ul><table style="width:100%; border:1px solid" class="small"><caption>Static Context Components</caption><tbody><tr><th>Component</th><th>Default initial value</th><th>Can be overwritten or augmented by implementation?</th><th>Can be overwritten or augmented by prolog?</th><th>Can be overwritten or augmented by expressions?</th><th>Consistency rules</th></tr><tr><td>Statically known namespaces</td><td><code>fn</code>, <code>xml</code>, <code>xs</code>, <code>xsi</code>, <code>local</code></td><td>overwriteable and augmentable (except for <code>xml</code>)</td><td>overwriteable and augmentable by <a href="#id-namespace-declaration"><b>5.13 Namespace Declaration</b></a></td><td>overwriteable and augmentable by element constructor</td><td>Only one namespace can be assigned to a given prefix per lexical scope.</td></tr><tr><td>Default element/type namespace</td><td>no namespace</td><td>overwriteable</td><td>overwriteable by <a href="#id-default-namespace"><b>5.14 Default Namespace Declaration</b></a></td><td>overwriteable by element constructor</td><td>Only one default namespace per lexical scope.</td></tr><tr><td>In-scope variables</td><td>none</td><td>augmentable</td><td>overwriteable and augmentable by <a href="#id-variable-declarations"><b>5.16 Variable Declaration</b></a> and <a href="#id-inline-func"><span style="display: none;" class="delete_version"><b>4.6.2.5 Inline Function Expressions</b></span><span style="display: none;" class="add_version"><b>4.4.2.4 Inline Function Expressions</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.2.5</span><span class="deltaxml-new">4.4.2.4</span> Inline Function Expressions</b></span></a>, augmentable by <a href="#id-module-import"><b>5.12 Module Import</b></a></td><td>overwriteable and augmentable by variable-binding expressions</td><td>Only one definition per variable per lexical scope.</td></tr><tr><td>Context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> static type</td><td>item()</td><td>overwriteable</td><td>overwriteable by <a><span style="display: none;" class="delete_version" href="#id-context-value-declarations"><b>5.17 Context Value Declaration</b></span><span style="display: none;" class="add_version" href="#id-context-item-declarations"><b>5.17 Context Item Declaration</b></span><span class="modify_version" href="#id-context-item-declarations"><b>5.17 Context <span class="deltaxml-old">Value</span><span class="deltaxml-new">Item</span> Declaration</b></span></a></td><td>overwriteable by expresssions that set the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span></td><td>None.</td></tr><tr><td>Ordering mode</td><td><code>ordered</code></td><td>overwriteable</td><td>overwriteable by <a href="#id-default-ordering-decl"><b>5.7 Ordering Mode Declaration</b></a></td><td>overwriteable by expression</td><td>Value must be <code>ordered</code> or <code>unordered</code>.</td></tr><tr><td>Default function namespace</td><td><code>fn</code></td><td>overwriteable (not recommended)</td><td>overwriteable by <a href="#id-default-namespace"><b>5.14 Default Namespace Declaration</b></a></td><td>no</td><td>None.</td></tr><tr><td>In-scope schema types</td><td>built-in types in <code>xs</code></td><td>augmentable</td><td>augmentable by <a href="#id-schema-import"><b>5.11 Schema Import</b></a></td><td>no</td><td>Only one definition per global or local type.</td></tr><tr><td>In-scope element declarations</td><td>none</td><td>augmentable</td><td>augmentable by <a href="#id-schema-import"><b>5.11 Schema Import</b></a></td><td>no</td><td>Only one definition per global or local element name.</td></tr><tr><td>In-scope attribute declarations</td><td>none</td><td>augmentable</td><td>augmentable by <a href="#id-schema-import"><b>5.11 Schema Import</b></a></td><td>no</td><td>Only one definition per global or local attribute name.</td></tr><tr><td>Statically known function signatures</td><td>the signatures of the <a class="termref" title="built-in function" href="#dt-built-in-function"><span class="deltaxml-old">system</span><span class="deltaxml-new">built-in</span> functions</a></td><td>augmentable</td><td>augmentable by <a href="#id-module-import"><b>5.12 Module Import</b></a> and by <a href="#FunctionDeclns"><span style="display: none;" class="delete_version"><b>5.18 Function Declarations</b></span><span style="display: none;" class="add_version"><b>5.18 Function Declaration</b></span><span class="modify_version"><b>5.18 Function <span class="deltaxml-old">Declarations</span><span class="deltaxml-new">Declaration</span></b></span></a>; augmentable by <a href="#id-schema-import"><b>5.11 Schema Import</b></a> (which adds constructor functions for user-defined types)</td><td>no</td><td>Each function must have a unique <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and number of arguments.</td></tr><tr><td>Default collation</td><td>Unicode codepoint collation</td><td>overwriteable</td><td>overwriteable by <a href="#id-default-collation-declaration"><b>5.4 Default Collation Declaration</b></a></td><td>no</td><td>None.</td></tr><tr><td>Construction mode</td><td><code>preserve</code></td><td>overwriteable</td><td>overwriteable by <a href="#id-construction-declaration"><b>5.6 Construction Declaration</b></a></td><td>no</td><td>Value must be <code>preserve</code> or <code>strip</code>. </td></tr><tr><td>Default order for empty sequences</td><td>implementation-defined</td><td>overwriteable</td><td>overwriteable by <a href="#id-empty-order-decl"><b>5.8 Empty Order Declaration</b></a></td><td>no</td><td>Value must be <code>greatest</code> or <code>least</code>.</td></tr><tr><td>Boundary-space policy</td><td><code>strip</code></td><td>overwriteable</td><td>overwriteable by <a href="#id-boundary-space-decls"><b>5.3 Boundary-space Declaration</b></a></td><td>no</td><td>Value must be <code>preserve</code> or <code>strip</code>. </td></tr><tr><td>Copy-namespaces mode</td><td><code>inherit, preserve</code></td><td>overwriteable</td><td>overwriteable by <a href="#id-copy-namespaces-decl"><b>5.9 Copy-Namespaces Declaration</b></a></td><td>no</td><td>Value consists of <code>inherit</code> or <code>no-inherit</code>, and <code>preserve</code> or <code>no-preserve</code>.</td></tr><tr><td>Static Base URI</td><td>See rules in <a href="#id-base-uri-decl"><b>5.5 Base URI Declaration</b></a></td><td>overwriteable</td><td>overwriteable by <a href="#id-base-uri-decl"><b>5.5 Base URI Declaration</b></a></td><td>no</td><td>Value must be a valid lexical representation of the type xs:anyURI.</td></tr><tr><td>Statically known decimal formats</td><td>the default (unnamed) decimal format, which has an implementation-dependent value</td><td>augmentable</td><td>augmentable, using <a title="decimal-format         declaration" class="termref" href="#dt-decimal-format-decl">decimal format declarations</a></td><td>no</td><td>each QName uniquely identifies a decimal format</td></tr><tr><td>Statically known documents</td><td>none</td><td>augmentable</td><td>no</td><td>no</td><td>None.</td></tr><tr><td>Statically known collections</td><td>none</td><td>augmentable</td><td>no</td><td>no</td><td>None.</td></tr><tr><td>Statically known default collection type</td><td><code>item()*</code></td><td>overwriteable</td><td>no</td><td>no</td><td>None.</td></tr><tr><td>Statically known collations</td><td>only the default collation</td><td>augmentable</td><td>no</td><td>no</td><td>Each URI uniquely identifies a collation.</td></tr><tr><td>XPath 1.0 Compatibility Mode</td><td><code>false</code></td><td>no</td><td>no</td><td>no</td><td>Must be <code>false</code>.</td></tr><tr><th colspan="6">Serialization Parameters</th></tr><tr><td>allow-duplicate-names</td><td>no</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>byte-order-mark</td><td>implementation-defined</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>cdata-section-elements</td><td>empty</td><td>overwriteable and augmentable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>doctype-public</td><td>none</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>doctype-system</td><td>none</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>encoding</td><td><span style="display: none;" class="delete_version">implementation-defined choice between <code>"utf-8"</code> and <code>"utf-16"</code></span><span style="display: none;" class="add_version">implementation-defined choice between "utf-8" and "utf-16"</span><span class="modify_version">implementation-defined choice between "utf-8" and "utf-16"</span></td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr class="delete_version" style="display: none;"><td>escape-solidus</td><td>yes</td><td>overwriteable and augmentable</td><td>overwriteable by prolog</td><td>yes</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr class="modify_version"><td><span class="deltaxml-old">escape-solidus</span></td><td><span class="deltaxml-old">yes</span></td><td><span class="deltaxml-old">overwriteable and augmentable</span></td><td><span class="deltaxml-old">overwriteable by prolog</span></td><td><span class="deltaxml-old">yes</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-old">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-old">SER31</span></small></sup></td></tr><tr><td>escape-uri-attributes</td><td>yes</td><td>overwriteable and augmentable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>html-version</td><td>implementation-defined</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>include-content-type</td><td>yes</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>indent</td><td>no</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>item-separator</td><td>implementation-defined</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>json-node-output-method</td><td>xml</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>media-type</td><td>implementation-defined</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>method</td><td>xml</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>normalization-form</td><td>implementation-defined</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>omit-xml-declaration</td><td>implementation-defined</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>standalone</td><td>implementation-defined</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>suppress-indentation</td><td>empty</td><td>overwriteable and augmentable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>undeclare-prefixes</td><td>no</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>use-character-maps</td><td>empty</td><td>overwriteable and augmentable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr><tr><td>version</td><td>implementation-defined</td><td>overwriteable</td><td>overwriteable by prolog</td><td>no</td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam">Section 3 Serialization Parameters </a><sup><small>SER31</small></sup></td></tr></tbody></table></div><div class="div2"><h3><a id="id-xq-evaluation-context-components"></a>C.2 Dynamic Context Components</h3><p>The following table describes the components of the <b>dynamic context</b>. The following aspects of each component are described:</p><ul><li><p><em>Default initial value:</em> This is the initial value of the component if it is not overridden or augmented by the implementation or by a query.</p></li><li><p><em>Can be overwritten or augmented by implementation:</em> Indicates whether an XQuery implementation is allowed to replace the default initial value of the component by a different <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> value and/or to augment the default initial value by additional <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> values.</p></li><li><p><em>Can be overwritten or augmented by prolog:</em> Indicates whether there are prolog declarations that can replace and/or augment the initial value provided by default or by the implementation.</p></li><li><p><em>Can be overwritten or augmented by expressions:</em> Indicates whether there are expressions that can replace and/or augment the value of the component for their subexpressions.</p></li><li><p><em>Consistency Rules:</em> Indicates rules that must be observed in assigning values to the component. Additional consistency rules may be found in <a href="#id-consistency-constraints"><b>2.3.5 Consistency Constraints</b></a>.</p></li></ul><table style="width:100%; border:1px solid" class="small"><caption>Dynamic Context Components</caption><tbody><tr><th>Component</th><th>Default initial value</th><th>Can be overwritten or augmented by implementation?</th><th>Can be overwritten or augmented by prolog?</th><th>Can be overwritten or augmented by expressions?</th><th>Consistency rules</th></tr><tr><td>Context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span></td><td>none</td><td>overwriteable</td><td>overwriteable by a <a><span style="display: none;" class="delete_version" href="#id-context-value-declarations"><b>5.17 Context Value Declaration</b></span><span style="display: none;" class="add_version" href="#id-context-item-declarations"><b>5.17 Context Item Declaration</b></span><span class="modify_version" href="#id-context-item-declarations"><b>5.17 Context <span class="deltaxml-old">Value</span><span class="deltaxml-new">Item</span> Declaration</b></span></a> in the main module </td><td>overwritten during evaluation of path expressions and predicates</td><td>Must be the same in the dynamic context of every module in a query. </td></tr><tr><td>Context position</td><td>none</td><td>overwriteable</td><td>overwriteable by a <a><span style="display: none;" class="delete_version" href="#id-context-value-declarations"><b>5.17 Context Value Declaration</b></span><span style="display: none;" class="add_version" href="#id-context-item-declarations"><b>5.17 Context Item Declaration</b></span><span class="modify_version" href="#id-context-item-declarations"><b>5.17 Context <span class="deltaxml-old">Value</span><span class="deltaxml-new">Item</span> Declaration</b></span></a> in the main module </td><td>overwritten during evaluation of path expressions and predicates</td><td><span style="display: none;" class="delete_version">If context value is defined, context position must be &gt;0 and &lt;= context size; else context position is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. </span><span style="display: none;" class="add_version">If context item is defined, context position must be &gt;0 and &lt;= context size; else context position is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. </span><span class="modify_version">If context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> is defined, context position must be &gt;0 and &lt;= context size; else context position is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. </span></td></tr><tr><td>Context size</td><td>none </td><td>overwriteable</td><td>overwriteable by a <a><span style="display: none;" class="delete_version" href="#id-context-value-declarations"><b>5.17 Context Value Declaration</b></span><span style="display: none;" class="add_version" href="#id-context-item-declarations"><b>5.17 Context Item Declaration</b></span><span class="modify_version" href="#id-context-item-declarations"><b>5.17 Context <span class="deltaxml-old">Value</span><span class="deltaxml-new">Item</span> Declaration</b></span></a> in the main module </td><td>overwritten during evaluation of path expressions and predicates</td><td><span style="display: none;" class="delete_version">If context value is defined, context size must be &gt;0; else context size is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.</span><span style="display: none;" class="add_version">If context item is defined, context size must be &gt;0; else context size is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.</span><span class="modify_version">If context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> is defined, context size must be &gt;0; else context size is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>.</span></td></tr><tr><td>Variable values</td><td>none</td><td>augmentable</td><td>overwriteable and augmentable by <a href="#id-variable-declarations"><b>5.16 Variable Declaration</b></a> and <a href="#id-inline-func"><span style="display: none;" class="delete_version"><b>4.6.2.5 Inline Function Expressions</b></span><span style="display: none;" class="add_version"><b>4.4.2.4 Inline Function Expressions</b></span><span class="modify_version"><b><span class="deltaxml-old">4.6.2.5</span><span class="deltaxml-new">4.4.2.4</span> Inline Function Expressions</b></span></a>, augmentable by <a href="#id-module-import"><b>5.12 Module Import</b></a></td><td>overwriteable and augmentable by variable-binding expressions</td><td>Names and values must be consistent with in-scope variables.</td></tr><tr><td>Named functions</td><td>the <a class="termref" title="built-in function" href="#dt-built-in-function"><span class="deltaxml-old">system</span><span class="deltaxml-new">built-in</span> functions</a></td><td>augmentable</td><td>augmentable by <a href="#FunctionDeclns"><span style="display: none;" class="delete_version"><b>5.18 Function Declarations</b></span><span style="display: none;" class="add_version"><b>5.18 Function Declaration</b></span><span class="modify_version"><b>5.18 Function <span class="deltaxml-old">Declarations</span><span class="deltaxml-new">Declaration</span></b></span></a>, <a href="#id-module-import"><b>5.12 Module Import</b></a>, and <a href="#id-schema-import"><b>5.11 Schema Import</b></a> ( (which adds constructor functions for user-defined types)</td><td>no</td><td>Must be consistent with statically known function signatures</td></tr><tr><td>Current dateTime</td><td>none</td><td>must be initialized <span class="xquery">by implementation</span></td><td>no</td><td>no</td><td>Must include a timezone. Remains constant during evaluation of a query.</td></tr><tr><td>Implicit timezone</td><td>none</td><td>must be initialized <span class="xquery">by implementation</span></td><td>no</td><td>no</td><td>Remains constant during evaluation of a query.</td></tr><tr><td>Available documents</td><td>none</td><td>must be initialized <span class="xquery">by implementation</span></td><td>no</td><td>no</td><td>None</td></tr><tr><td>Available text resources</td><td>none</td><td>must be initialized <span class="xquery">by implementation</span></td><td>no</td><td>no</td><td>None</td></tr><tr><td>Available collections</td><td>none</td><td>must be initialized <span class="xquery">by implementation</span></td><td>no</td><td>no</td><td>None</td></tr><tr><td>Default collection</td><td>none</td><td>overwriteable</td><td>no</td><td>no</td><td>None</td></tr><tr><td>Available URI collections</td><td>none</td><td>must be initialized <span class="xquery">by implementation</span></td><td>no</td><td>no</td><td>None</td></tr><tr><td>Default URI collection</td><td>none</td><td>overwriteable</td><td>no</td><td>no</td><td>None</td></tr></tbody></table></div></div><div class="div1"><h2><a id="id-impl-defined-items"></a>D Implementation-Defined Items</h2><p>The following items in this specification are <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>:</p><ol class="enumar"><li><p>The version of Unicode that is used to construct expressions.</p></li><li><p>The <a title="statically known collations" class="termref" href="#dt-static-collations">statically-known collations</a>.</p></li><li><p>The <a title="implicit timezone" class="termref" href="#dt-timezone">implicit timezone</a>.</p></li><li><p>The circumstances in which <a title="warning" class="termref" href="#dt-warning">warnings</a> are raised, and the ways in which warnings are handled.</p></li><li><p>The method by which errors are reported to the external processing environment.</p></li><li><p>Which version of XML and XML Names (e.g. <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a> or <a href="#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a>) and which version of XML Schema (e.g. <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>) is used for the definitions of primitives such as characters and names, and for the definitions of operations such as normalization of line endings and normalization of whitespace in attribute values. It is recommended that the latest applicable version be used (even if it is published later than this specification).</p></li><li><p>How XDM instances are created from sources other than an Infoset or PSVI.</p></li><li class="xquery"><p>Any components of the <a title="static context" class="termref" href="#dt-static-context">static context</a> or <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> that are overwritten or augmented by the implementation.</p></li><li class="xquery"><p>The default handling of empty sequences returned by an ordering key (orderspec) in an <code>order by</code> clause (<code>empty least</code> or <code>empty greatest</code>).</p></li><li class="xquery"><p>The names and semantics of any <a title="extension expression" class="termref" href="#dt-extension-expression">extension expressions</a> (<a title="pragma" class="termref" href="#dt-pragma">pragmas</a>) recognized by the implementation.</p></li><li class="xquery"><p>The names and semantics of any <a title="option declaration" class="termref" href="#dt-option-declaration">option declarations</a> recognized by the implementation.</p></li><li class="xquery"><p>Protocols (if any) by which parameters can be passed to an external function, and the result of the function can returned to the invoking query.</p></li><li class="xquery"><p>The process by which the specific modules to be imported by a <a title="module import" class="termref" href="#dt-module-import">module import</a> are identified, if the <a title="module feature" class="termref" href="#dt-module-feature">Module Feature</a> is supported (includes processing of location hints, if any.)</p></li><li class="xquery"><p>The means by which serialization is invoked, if the <a title="serialization feature" class="termref" href="#dt-serialization-feature">Serialization Feature</a> is supported.</p></li><li class="xquery"><p>The default values for the <code>byte-order-mark</code>, <code>encoding</code>, <code>html-version</code>, <code>item-separator</code>, <code>media-type</code>, <code>normalization-form</code>, <code>omit-xml-declaration</code>, <code>standalone</code>, and <code>version</code> parameters, if the <a title="serialization feature" class="termref" href="#dt-serialization-feature">Serialization Feature</a> is supported.</p></li><li class="xquery"><p>The result of an unsuccessful call to an external function (for example, if the function implementation cannot be found or does not return a value of the declared type).</p></li><li class="xquery"><p>Limits on ranges of values for various data types, as enumerated in <a href="#id-data-model-conformance"><b>6.3 Data Model Conformance</b></a>.</p></li><li class="xquery"><p>Syntactic extensions to XQuery, including both their syntax and semantics, as discussed in <a href="#id-syntax-extensions"><b>6.4 Syntax Extensions</b></a>.</p></li><li><p>Whether the type system is based on <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>. An implementation that has based its type system on XML Schema 1.0 is not required to support the use of the <code>xs:dateTimeStamp</code> constructor or the use of <code>xs:dateTimeStamp</code> or <code>xs:error</code> as <a href="#doc-xquery40-TypeName">TypeName</a> in any expression.</p></li><li><p>The signatures of functions provided by the implementation or via an implementation-defined API (see <a href="#static_context"><b>2.2.1 Static Context</b></a>).</p></li><li><p>Any <a title="environment variables" class="termref" href="#dt-environment-variables">environment variables</a> provided by the implementation.</p></li><li><p>Any rules used for static typing (see <a href="#id-static-analysis"><b>2.3.3.1 Static Analysis Phase</b></a>).</p></li><li><p>Any serialization parameters provided by the implementation<span class="xquery"> (see <a href="#id-serialization"><b>2.3.4 Serialization</b></a>).</span></p></li><li class="xquery"><p>The means by which the location hint for a serialization parameter document identifies the corresponding XDM instance (see <a href="#id-serialization"><b>2.3.4 Serialization</b></a>).</p></li><li><p>What error, if any, is returned if an external function's implementation does not return the declared result type (see <a href="#id-consistency-constraints"><b>2.3.5 Consistency Constraints</b></a>).</p></li><li class="xquery"><p>Any annotations defined by the implementation, and their associated behavior (see <a href="#id-annotations"><b>5.15 Annotations</b></a>).</p></li><li class="xquery"><p>Any <a title="function assertion" class="termref" href="#dt-function-assertion">function assertions</a> defined by the implementation.</p></li><li class="xquery"><p>The effect of function assertions understood by the implementation on <a href="#id-assertions-subtype"><b>3.7.3 The judgement subtype-assertions(AnnotationsA, AnnotationsB) </b></a>.</p></li><li class="xquery"><p>Any implementation-defined variables defined by the implementation. (see <a href="#id-variables"><b>4.3.2 Variable References</b></a>).</p></li><li class="xquery"><p><span style="display: none;" class="delete_version">The ordering associated with <code>fn:unordered</code> in the implementation (see <a href="#id-unordered-expressions"><span class="delete_version"><b>4.16 Ordered and Unordered Expressions</b></span><span class="modify_version"><b>4.16 Ordered and Unordered Expressions</b></span></a>).</span><span style="display: none;" class="add_version">The ordering associated with <code>fn:unordered</code> in the implementation (see <a href="#id-unordered-expressions"><span class="add_version"><b>4.15 Ordered and Unordered Expressions</b></span><span class="modify_version"><b>4.15 Ordered and Unordered Expressions</b></span></a>).</span><span class="modify_version">The ordering associated with <code>fn:unordered</code> in the implementation (see <a href="#id-unordered-expressions"><span style="display: none;" class="delete_version"><b>4.16 Ordered and Unordered Expressions</b></span><span style="display: none;" class="add_version"><b>4.15 Ordered and Unordered Expressions</b></span><span class="modify_version"><b><span class="deltaxml-old">4.16</span><span class="deltaxml-new">4.15</span> Ordered and Unordered Expressions</b></span></a>).</span></p></li><li class="xquery"><p><span style="display: none;" class="delete_version">Any additional information provided for try/catch via the <code>err:additional</code> variable (see <a href="#id-try-catch"><span class="delete_version"><b>4.21 Try/Catch Expressions</b></span><span class="modify_version"><b>4.21 Try/Catch Expressions</b></span></a>).</span><span style="display: none;" class="add_version">Any additional information provided for try/catch via the <code>err:additional</code> variable (see <a href="#id-try-catch"><span class="add_version"><b>4.20 Try/Catch Expressions</b></span><span class="modify_version"><b>4.20 Try/Catch Expressions</b></span></a>).</span><span class="modify_version">Any additional information provided for try/catch via the <code>err:additional</code> variable (see <a href="#id-try-catch"><span style="display: none;" class="delete_version"><b>4.21 Try/Catch Expressions</b></span><span style="display: none;" class="add_version"><b>4.20 Try/Catch Expressions</b></span><span class="modify_version"><b><span class="deltaxml-old">4.21</span><span class="deltaxml-new">4.20</span> Try/Catch Expressions</b></span></a>).</span></p></li><li class="xquery"><p>The default boundary-space policy (see <a href="#id-boundary-space-decls"><b>5.3 Boundary-space Declaration</b></a>).</p></li><li class="xquery"><p>The default collation (see <a href="#id-default-collation-declaration"><b>5.4 Default Collation Declaration</b></a>).</p></li><li class="xquery"><p>The default base URI (see <a href="#id-base-uri-decl"><b>5.5 Base URI Declaration</b></a>).</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Additional <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> items are listed in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a> and <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>.</p></div></div><div class="div1"><h2><a id="id-references"></a>E References</h2><div class="div2"><h3><a id="id-normative-references"></a>E.1 Normative References</h3><dl><dt class="label"><span><a id="RFC2119"></a>RFC2119</span></dt><dd><div>S. Bradner. <em>Key Words for use in RFCs to Indicate Requirement Levels.</em> IETF RFC 2119. See <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</div></dd><dt class="label"><span><a id="RFC3986"></a>RFC3986</span></dt><dd><div>T. Berners-Lee, R. Fielding, and L. Masinter. <em>Uniform Resource Identifiers (URI): Generic Syntax</em>. IETF RFC 3986. See <a href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.</div></dd><dt class="label"><span><a id="RFC3987"></a>RFC3987</span></dt><dd><div>M. Duerst and M. Suignard. <em>Internationalized Resource Identifiers (IRIs)</em>. IETF RFC 3987. See <a href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.</div></dd><dt class="label"><span><a id="ISO10646"></a>ISO/IEC 10646</span></dt><dd><div>ISO (International Organization for Standardization). <em>ISO/IEC 10646:2003. Information technology—Universal Multiple-Octet Coded Character Set (UCS)</em>, as, from time to time, amended, replaced by a new edition, or expanded by the addition of new parts. [Geneva]: International Organization for Standardization. (See <a href="http://www.iso.org">http://www.iso.org</a> for the latest version.)</div></dd><dt class="label"><span><a id="Unicode"></a>Unicode</span></dt><dd><div><span style="display: none;" class="delete_version">The Unicode Consortium. <em>The Unicode Standard.</em> Reading, Mass.: Addison-Wesley, 2003, as updated from time to time by the publication of new versions. See <a href="http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</a> for the latest version and additional information on versions of the standard and of the Unicode Character Database. The version of Unicode to be used is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, but implementations are recommended to use the latest Unicode version.</span><span style="display: none;" class="add_version">The Unicode Consortium. <em>The Unicode Standard</em> Reading, Mass.: Addison-Wesley, 2003, as updated from time to time by the publication of new versions. See <a href="http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</a> for the latest version and additional information on versions of the standard and of the Unicode Character Database. The version of Unicode to be used is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, but implementations are recommended to use the latest Unicode version.</span><span class="modify_version">The Unicode Consortium. <em>The Unicode Standard<span class="deltaxml-old">.</span></em> Reading, Mass.: Addison-Wesley, 2003, as updated from time to time by the publication of new versions. See <a href="http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</a> for the latest version and additional information on versions of the standard and of the Unicode Character Database. The version of Unicode to be used is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, but implementations are recommended to use the latest Unicode version.</span></div></dd><dt class="label"><span><a id="XML"></a>XML 1.0</span></dt><dd><div>World Wide Web Consortium. <em>Extensible Markup Language (XML) 1.0.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/REC-xml/">http://www.w3.org/TR/REC-xml/</a>. The edition of XML 1.0 must be no earlier than the Third Edition; the edition used is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, but we recommend that implementations use the latest version. </div></dd><dt class="label"><span><a id="XML1.1"></a>XML 1.1</span></dt><dd><div>World Wide Web Consortium. <em>Extensible Markup Language (XML) 1.1.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a></div></dd><dt class="label"><span><a id="XMLBASE"></a>XML Base</span></dt><dd><div>World Wide Web Consortium. <em>XML Base.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a></div></dd><dt class="label"><span><a id="XMLNAMES"></a>XML Names</span></dt><dd><div>World Wide Web Consortium. <em>Namespaces in XML.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a></div></dd><dt class="label"><span><a id="XMLNAMES11"></a>XML Names 1.1</span></dt><dd><div>World Wide Web Consortium. <em>Namespaces in XML 1.1.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a></div></dd><dt class="label"><span><a id="XMLID"></a>XML ID</span></dt><dd><div>World Wide Web Consortium. <em>xml:id Version 1.0.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/xml-id/">http://www.w3.org/TR/xml-id/</a></div></dd><dt class="label"><span><a id="XMLSchema10"></a>XML Schema 1.0</span></dt><dd><div>World Wide Web Consortium. <em>XML Schema, Parts 0, 1, and 2 (Second Edition)</em>. W3C Recommendation, 28 October 2004. See <a href="http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</a>, <a id="schema1" href="http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</a>, and <a id="schema2" href="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>.</div></dd><dt class="label"><span><a id="XMLSchema11"></a>XML Schema 1.1</span></dt><dd><div>World Wide Web Consortium. <em>XML Schema, Parts 1, and 2</em>. W3C Recommendation 5 April 2012. See <a id="schema1-11" href="http://www.w3.org/TR/xmlschema11-1/">http://www.w3.org/TR/xmlschema11-1/</a>, and <a id="schema2-11" href="http://www.w3.org/TR/xmlschema11-2/">http://www.w3.org/TR/xmlschema11-2/</a>.</div></dd><dt class="label"><span style="display: none;" class="delete_version"><span><a id="xpath-datamodel-40"></a>XQuery and XPath Data Model (XDM) 4.0</span></span><span style="display: none;" class="add_version"><span><a id="xpath-datamodel-31"></a>XQuery and XPath Data Model (XDM) 3.1</span></span><span class="modify_version"><span><a id="xpath-datamodel-40"></a><a id="xpath-datamodel-31"></a>XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span></span></span></dt><dd><div><a href="https://qt4cg.org/specifications/xpath-datamodel-40/Overview.html"><cite><span class="deltaxml-old">XQuery and XPath Data Model (XDM) 4.0</span></cite></a><span class="deltaxml-old">, XSLT Extensions Community Group, World Wide Web Consortium.</span></div><div><a href="https://www.w3.org/TR/xpath-datamodel-31/"><cite><span class="deltaxml-new">XQuery and XPath Data Model (XDM) 3.1</span></cite></a><span class="deltaxml-new">, Norman Walsh, John Snelson, Andrew Coleman, Editors. World Wide Web Consortium, 21 March 2017. This version is https://www.w3.org/TR/2017/REC-xpath-datamodel-31-20170321/. The </span><a href="https://www.w3.org/TR/xpath-datamodel-31/"><span class="deltaxml-new">latest version</span></a><span class="deltaxml-new"> is available at https://www.w3.org/TR/xpath-datamodel-31/.</span></div></dd><dt class="label"><span><a id="xpath-functions-40"></a>XQuery and XPath Functions and Operators 4.0</span></dt><dd><div><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html"><cite>XQuery and XPath Functions and Operators 4.0</cite></a>, XSLT Extensions Community Group, World Wide Web Consortium.</div></dd><dt class="label"><span><a id="xpath-40"></a><span class="deltaxml-old">XPath 4.0</span></span></dt><dd><div><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html"><cite><span class="deltaxml-old">XML Path Language (XPath) 4.0</span></cite></a><span class="deltaxml-old">, XSLT Extensions Community Group, World Wide Web Consortium.</span></div></dd><dt class="label"><span style="display: none;" class="delete_version"><span><a id="xslt-xquery-serialization-40"></a>XSLT and XQuery Serialization 4.0</span></span><span style="display: none;" class="add_version"><span><a id="xslt-xquery-serialization-31"></a>XSLT and XQuery Serialization 3.1</span></span><span class="modify_version"><span><a id="xslt-xquery-serialization-40"></a><a id="xslt-xquery-serialization-31"></a>XSLT and XQuery Serialization <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span></span></span></dt><dd><div><a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/Overview.html"><cite><span class="deltaxml-old">XSLT and XQuery Serialization 4.0</span></cite></a><span class="deltaxml-old">, XSLT Extensions Community Group, World Wide Web Consortium.</span></div><div><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/"><cite><span class="deltaxml-new">XSLT and XQuery Serialization 3.1</span></cite></a><span class="deltaxml-new">, Andrew Coleman and Michael Sperberg-McQueen, Editors. World Wide Web Consortium, 21 March 2017. This version is https://www.w3.org/TR/2017/REC-xslt-xquery-serialization-31-20170321/. The </span><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/"><span class="deltaxml-new">latest version</span></a><span class="deltaxml-new"> is available at https://www.w3.org/TR/xslt-xquery-serialization-31/.</span></div></dd><dt class="label"><span class="xquery"><a id="xquery-update-30"></a><span class="deltaxml-new">XQuery Update Facility 3.0</span></span></dt><dd><div class="xquery"><a href="https://www.w3.org/TR/xquery-update-30/"><cite><span class="deltaxml-new">XQuery Update Facility 3.0</span></cite></a><span class="deltaxml-new">, John Snelson, Editor. World Wide Web Consortium, 24 January 2017. This version is https://www.w3.org/TR/2017/NOTE-xquery-update-30-20170124/. The </span><a href="https://www.w3.org/TR/xquery-update-30/"><span class="deltaxml-new">latest version</span></a><span class="deltaxml-new"> is available at https://www.w3.org/TR/xquery-update-30/.</span></div></dd></dl></div><div class="div2"><h3><a id="id-non-normative-references"></a>E.2 Non-normative References</h3><dl><dt class="label"><span class="xquery"><a id="xquery-30-requirements"></a>XQuery 3.0 Requirements</span></dt><dd><div class="xquery"><a href="https://www.w3.org/TR/xquery-30-requirements/"><cite>XQuery 3.0 Requirements</cite></a>, Daniel Engovatov, Jonathan Robie, Editors. World Wide Web Consortium, 08 April 2014. This version is https://www.w3.org/TR/2014/NOTE-xquery-30-requirements-20140408/. The <a href="https://www.w3.org/TR/xquery-30-requirements/">latest version</a> is available at https://www.w3.org/TR/xquery-30-requirements/.</div></dd><dt class="label"><span class="xquery"><a id="xquery-31-requirements"></a>XQuery 3.1 Requirements</span></dt><dd><div class="xquery"><a href="https://www.w3.org/TR/xquery-31-requirements/"><cite>XQuery 3.1 Requirements and Use Cases</cite></a>, Jonathan Robie, Editor. World Wide Web Consortium, 13 December 2016. This version is https://www.w3.org/TR/2016/NOTE-xquery-31-requirements-20161213/. The <a href="https://www.w3.org/TR/xquery-31-requirements/">latest version</a> is available at https://www.w3.org/TR/xquery-31-requirements/.</div></dd><dt class="label"><span class="xquery"><a id="xquery-30"></a>XQuery 3.0: An XML Query Language</span></dt><dd><div class="xquery"><a href="https://www.w3.org/TR/xquery-30/"><cite>XQuery 3.0: An XML Query Language</cite></a>, Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 08 April 2014. This version is https://www.w3.org/TR/2014/REC-xquery-30-20140408/. The <a href="https://www.w3.org/TR/xquery-30/">latest version</a> is available at https://www.w3.org/TR/xquery-30/.</div></dd><dt class="label"><span><a id="xquery-semantics"></a>XQuery 1.0 and XPath 2.0 Formal Semantics</span></dt><dd><div><a href="https://www.w3.org/TR/xquery-semantics/"><cite>XQuery 1.0 and XPath 2.0 Formal Semantics (Second Edition)</cite></a>, Jérôme Siméon, Denise Draper, Peter Frankhauser, <em>et. al.</em>, Editors. World Wide Web Consortium, 14 December 2010. This version is https://www.w3.org/TR/2010/REC-xquery-semantics-20101214/. The <a href="https://www.w3.org/TR/xquery-semantics/">latest version</a> is available at https://www.w3.org/TR/xquery-semantics/.</div></dd><dt class="label"><span class="xquery"><a id="xqueryx-31"></a><span class="deltaxml-new">XQueryX 3.1</span></span></dt><dd><div class="xquery"><a href="https://www.w3.org/TR/xqueryx-31/"><cite><span class="deltaxml-new">XQueryX 3.1</span></cite></a><span class="deltaxml-new">, Jim Melton, Editor. World Wide Web Consortium, 21 March 2017. This version is https://www.w3.org/TR/2017/REC-xqueryx-31-20170321/. The </span><a href="https://www.w3.org/TR/xqueryx-31/"><span class="deltaxml-new">latest version</span></a><span class="deltaxml-new"> is available at https://www.w3.org/TR/xqueryx-31/.</span></div></dd><dt class="label"><span style="display: none;" class="delete_version"><span><a id="xslt-40"></a>XSL Transformations (XSLT) Version 4.0</span></span><span style="display: none;" class="add_version"><span><a id="xslt-30"></a>XSL Transformations (XSLT) Version 3.0</span></span><span class="modify_version"><span><a id="xslt-40"></a><a id="xslt-30"></a>XSL Transformations (XSLT) Version <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.0</span></span></span></dt><dd><div><a href="https://qt4cg.org/specifications/xslt-40/Overview.html"><cite><span class="deltaxml-old">XSL Transformations (XSLT) Version 4.0</span></cite></a><span class="deltaxml-old">, XSLT Extensions Community Group, World Wide Web Consortium.</span></div><div><a href="https://www.w3.org/TR/xslt-30/"><cite><span class="deltaxml-new">XSL Transformations (XSLT) Version 3.0</span></cite></a><span class="deltaxml-new">, Michael Kay, Editor. World Wide Web Consortium, 7 February 2017. This version is https://www.w3.org/TR/2017/CR-xslt-30-20170207/. The </span><a href="https://www.w3.org/TR/xslt-30/"><span class="deltaxml-new">latest version</span></a><span class="deltaxml-new"> is available at https://www.w3.org/TR/xslt-30/.</span></div></dd><dt class="label"><span class="xquery"><a id="DOM"></a>Document Object Model</span></dt><dd><div class="xquery">World Wide Web Consortium. <em>Document Object Model (DOM) Level 3 Core Specification.</em> W3C Recommendation, April 7, 2004. See <a href="http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/</a>.</div></dd><dt class="label"><span><a id="XINFO"></a>XML Infoset</span></dt><dd><div>World Wide Web Consortium. <em>XML Information Set (Second Edition).</em> W3C Recommendation 4 February 2004. See <a href="http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</a></div></dd><dt class="label"><span><a id="xpath"></a>XML Path Language (XPath) Version 1.0</span></dt><dd><div><a href="http://www.w3.org/TR/xpath/"><cite>XML Path Language (XPath) Version 1.0</cite></a>, James Clark and Steven DeRose, Editors. World Wide Web Consortium, 16&nbsp;Nov&nbsp;1999. This version is http://www.w3.org/TR/1999/REC-xpath-19991116. The <a href="http://www.w3.org/TR/xpath/">latest version</a> is available at http://www.w3.org/TR/xpath.</div></dd><dt class="label"><span><a id="xpath20"></a>XML Path Language (XPath) Version 2.0</span></dt><dd><div><a href="https://www.w3.org/TR/xpath20/"><cite>XML Path Language (XPath) 2.0 (Second Edition)</cite></a>, Don Chamberlin, Anders Berglund, Scott Boag, <em>et. al.</em>, Editors. World Wide Web Consortium, 14 December 2010. This version is https://www.w3.org/TR/2010/REC-xpath20-20101214/. The <a href="https://www.w3.org/TR/xpath20/">latest version</a> is available at https://www.w3.org/TR/xpath20/.</div></dd><dt class="label"><span><a id="xpath-30"></a>XML Path Language (XPath) Version 3.0</span></dt><dd><div><a href="https://www.w3.org/TR/xpath-30/"><cite>XML Path Language (XPath) 3.0</cite></a>, Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 08 April 2014. This version is https://www.w3.org/TR/2014/REC-xpath-30-20140408/. The <a href="https://www.w3.org/TR/xpath-30/">latest version</a> is available at https://www.w3.org/TR/xpath-30/.</div></dd><dt class="label"><span class="xquery"><a id="xpath-31"></a>XML Path Language (XPath) Version 3.1</span></dt><dd><div class="xquery"><a href="https://www.w3.org/TR/xpath-31/"><cite>XML Path Language (XPath) 3.1</cite></a>, Jonathan Robie, Michael Dyck and Josh Spiegel, Editors. World Wide Web Consortium, 21 March 2017. This version is https://www.w3.org/TR/2017/REC-xpath-31-20170321/. The <a href="https://www.w3.org/TR/xpath-31/">latest version</a> is available at https://www.w3.org/TR/xpath-31/.</div></dd><dt class="label"><span><a id="XPTR"></a>XPointer</span></dt><dd><div>World Wide Web Consortium. <em>XML Pointer Language (XPointer).</em> W3C Last Call Working Draft 8 January 2001. See <a href="http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</a></div></dd><dt class="label"><span class="xquery"><a id="UseCases"></a>XML Query Use Cases</span></dt><dd><div class="xquery">World Wide Web Consortium. <em>XML Query Use Cases</em>. W3C Working Draft, 8 June 2006. See <a href="http://www.w3.org/TR/xquery-use-cases/">http://www.w3.org/TR/xquery-use-cases/</a>.</div></dd><dt class="label"><span class="xquery"><a id="xml11schema10"></a>XML 1.1 and Schema 1.0</span></dt><dd><div class="xquery">World Wide Web Consortium. <em>Processing XML 1.1 Documents with XML Schema 1.0 Processors</em>. W3C Working Group Note, 11 May 2005. See <a href="http://www.w3.org/TR/xml11schema10/">http://www.w3.org/TR/xml11schema10/</a>.</div></dd><dt class="label"><span class="xquery"><a id="RFC1738"></a>Uniform Resource Locators (URL)</span></dt><dd><div class="xquery">Internet Engineering Task Force (IETF). <em>Uniform Resource Locators (URL)</em>. Request For Comment No. 1738, Dec. 1994. See <a href="http://www.ietf.org/rfc/rfc1738.txt">http://www.ietf.org/rfc/rfc1738.txt</a>.</div></dd><dt class="label"><span class="xquery"><a id="ODMG"></a>ODMG</span></dt><dd><div class="xquery">Rick Cattell et al. <em>The Object Database Standard: ODMG-93, Release 1.2</em>. Morgan Kaufmann Publishers, San Francisco, 1996.</div></dd><dt class="label"><span class="xquery"><a id="Quilt"></a>Quilt</span></dt><dd><div class="xquery">Don Chamberlin, Jonathan Robie, and Daniela Florescu. <em>Quilt: an XML Query Language for Heterogeneous Data Sources</em>. In <em>Lecture Notes in Computer Science</em>, Springer-Verlag, Dec. 2000. </div></dd><dt class="label"><span class="xquery"><a id="XML-QL"></a>XML-QL</span></dt><dd><div class="xquery">Alin Deutsch, Mary Fernandez, Daniela Florescu, Alon Levy, and Dan Suciu. <em>A Query Language for XML</em>. </div></dd><dt class="label"><span class="xquery"><a id="SQL"></a>SQL</span></dt><dd><div class="xquery">International Organization for Standardization (ISO). <em>Information Technology — Database Language SQL</em>. Standard No. ISO/IEC 9075:2011. (Available from American National Standards Institute, New York, NY 10036, (212) 642-4900.)</div></dd><dt class="label"><span class="xquery"><a id="XQL"></a>XQL</span></dt><dd><div class="xquery">J. Robie, J. Lapp, D. Schach. <em>XML Query Language (XQL)</em>. See <a href="http://www.w3.org/TandS/QL/QL98/pp/xql.html">http://www.w3.org/TandS/QL/QL98/pp/xql.html</a>.</div></dd></dl></div><div class="div2"><h3><a id="id-background-material"></a>E.3 Background Material</h3><dl><dt class="label"><span><a id="CHARMOD"></a>Character Model</span></dt><dd><div>World Wide Web Consortium. <em>Character Model for the World Wide Web.</em> W3C Working Draft. See <a href="http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a>.</div></dd><dt class="label"><span><a id="xslt"></a>XSL Transformations (XSLT) Version 1.0</span></dt><dd><div><a href="http://www.w3.org/TR/xslt"><cite>XSL Transformations (XSLT) Version 1.0</cite></a>, James Clark, Editor. World Wide Web Consortium, 16&nbsp;Nov&nbsp;1999. This version is http://www.w3.org/TR/1999/REC-xslt-19991116. The <a href="http://www.w3.org/TR/xslt">latest version</a> is available at http://www.w3.org/TR/xslt.</div></dd><dt class="label"><span class="xquery"><a id="UseCaseQueries"></a>Use Case Sample Queries</span></dt><dd><div class="xquery">Queries from the XQuery 1.0 Use Cases, presented in a single file. See <a href="http://www.w3.org/2010/12/xquery-30-use-cases/xquery-30-use-case-queries.txt">http://www.w3.org/2010/12/xquery-30-use-cases/xquery-30-use-case-queries.txt</a>. </div></dd><dt class="label"><span class="xquery"><a id="XQueryQueries"></a>XQuery Sample Queries</span></dt><dd><div class="xquery">Queries from this document, presented in a single file. See <a href="http://www.w3.org/2013/01/xquery-30-use-cases/xquery-30-example-queries.txt">http://www.w3.org/2013/01/xquery-30-use-cases/xquery-30-example-queries.txt</a>. </div></dd><dt class="label"><span class="xquery"><a id="Moustache"></a>Moustache</span></dt><dd><div class="xquery"><em>mustache</em> - Logic-less templates. See <a href="http://mustache.github.io/mustache.5.html">http://mustache.github.io/mustache.5.html</a>. </div></dd></dl></div></div><div class="div1"><h2><a id="id-errors"></a>F Error Conditions</h2><dl><dt><a id="ERRXPST0001"></a>err:XPST0001</dt><dd><p><span style="display: none;" class="delete_version"> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if analysis of an expression relies on some component of the <a title="static context" class="termref" href="#dt-static-context">static context</a> that <span>is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup></span>.</span><span style="display: none;" class="add_version"> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if analysis of an expression relies on some component of the <a title="static context" class="termref" href="#dt-static-context">static context</a> that <span>is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup></span>.</span><span class="modify_version"> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if analysis of an expression relies on some component of the <a title="static context" class="termref" href="#dt-static-context">static context</a> that <span>is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup></span>.</span></p></dd><dt><a id="ERRXPDY0002"></a>err:XPDY0002</dt><dd><p><span style="display: none;" class="delete_version">It is a <a class="termref" title="type error" href="#dt-type-error">type error</a> if evaluation of an expression relies on some part of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> that is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>.</span><span style="display: none;" class="add_version">It is a <a class="termref" title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if evaluation of an expression relies on some part of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> that <span>is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup></span>.</span><span class="modify_version">It is a <a class="termref" title="dynamic error" href="#dt-dynamic-error"><span class="deltaxml-old">type</span><span class="deltaxml-new">dynamic</span> error</a> if evaluation of an expression relies on some part of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> that <span>is <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup></span>.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old">Note:</span></b></p><p><span class="deltaxml-old">In version 4.0 this has been reclassified as a type error rather than a dynamic error. This change allows a processor to report the error during static analysis where possible; for example if the body of a user-defined function is written as </span><code><span class="deltaxml-old">fn($x){@code}</span></code><span class="deltaxml-old">. The error code is prefixed </span><code><span class="deltaxml-old">XPDY</span></code><span class="deltaxml-old"> rather than </span><code><span class="deltaxml-old">XPTY</span></code><span class="deltaxml-old"> for backwards compatibility reasons.</span></p></div></dd><dt><a id="ERRXPST0003"></a>err:XPST0003</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an expression is not a valid instance of the grammar defined in <a href="#id-grammar"><b>A.1 EBNF</b></a>.</p></dd><dt><a id="ERRXPTY0004"></a>err:XPTY0004</dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if, during the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a>, an expression is found to have a <a title="static type" class="termref" href="#dt-static-type">static type</a> that is not appropriate for the context in which the expression occurs, or during the <a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation">dynamic evaluation phase</a>, the <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> of a value does not match a required type as specified by the matching rules in <a href="#id-sequencetype-matching"><b>3.5 Sequence Type Matching</b></a>.</p></dd><dt><a id="ERRXPST0005"></a>err:XPST0005</dt><dd><p> During the analysis phase, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a title="static type" class="termref" href="#dt-static-type">static type</a> assigned to an expression other than the expression <code>()</code> or <code>data(())</code> is <code>empty-sequence()</code>.</p></dd><dt><a id="ERRXPTY0006"></a><span class="deltaxml-old">err:XPTY0006</span></dt><dd><p><span class="deltaxml-old">During the analysis phase, an expression is classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-old">implausible</span></a><span class="deltaxml-old"> if the inferred </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-old">static type</span></a><var><span class="deltaxml-old">S</span></var><span class="deltaxml-old"> and the required type </span><var><span class="deltaxml-old">R</span></var><span class="deltaxml-old"> are substantively disjoint; more specifically, if neither of the types is a subtype of the other, and if the only values that are instances of both types are one or more of: the empty sequence, the empty map, and the empty array.</span></p></dd><dt><a id="ERRXPST0008"></a>err:XPST0008</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an expression refers to an element name, attribute name, schema type name, namespace prefix, or variable name that is not defined in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, except for an ElementName in an <a href="#doc-xquery40-ElementTest">ElementTest</a> or an AttributeName in an <a href="#doc-xquery40-AttributeTest">AttributeTest</a>.</p></dd><dt><a id="ERRXQST0009"></a>err:XQST0009</dt><dd><p> An implementation that does not support the Schema Aware Feature must raise a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a Prolog contains a schema import.</p></dd><dt><a id="ERRXQST0012"></a>err:XQST0012</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the set of definitions contained in all schemas imported by a Prolog do not satisfy the conditions for schema validity specified in Sections 3 and 5 of Part 1 of <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a><span class="deltaxml-old">.</span><span class="deltaxml-new"> --i.e., each definition must be valid, complete, and unique.</span></p></dd><dt><a id="ERRXQST0013"></a>err:XQST0013</dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an implementation recognizes a pragma but determines that its content is invalid.</p></dd><dt><a id="ERRXQST0016"></a>err:XQST0016</dt><dd><p>An implementation that does not support the Module Feature raises a <a title="static error" class="termref" href="#dt-static-error">static error</a> if it encounters a <a title="module declaration" class="termref" href="#dt-module-declaration">module declaration</a> or a <a title="module import" class="termref" href="#dt-module-import">module import</a>.</p></dd><dt><a id="ERRXPST0017"></a>err:XPST0017</dt><dd><p><span class="deltaxml-new"> </span>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and number of arguments in a static function call do not match the name and <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> of a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a><span class="deltaxml-old">, or if an argument keyword in the function call does not match a parameter name in that function definition, or if two arguments in the function call bind to the same parameter in the function definition</span>.</p></dd><dt><a id="ERRXPTY0018"></a>err:XPTY0018</dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of a path operator contains both nodes and non-nodes.</p></dd><dt><a id="ERRXPTY0019"></a>err:XPTY0019</dt><dd><p> It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if <code>E1</code> in a path expression <code>E1/E2</code> does not evaluate to a sequence of nodes.</p></dd><dt><a id="ERRXPTY0020"></a>err:XPTY0020</dt><dd><p> It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if, in an axis step, the context item is not a node.</p></dd><dt><a id="ERRXQST0022"></a>err:XQST0022</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attribute</a><span>contains an <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a>.</span></p></dd><dt><a id="ERRXQTY0024"></a>err:XQTY0024</dt><dd><p> It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the content sequence in an element constructor contains an attribute node following a node that is not an attribute node.</p></dd><dt><a id="ERRXQDY0025"></a>err:XQDY0025</dt><dd><p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if any attribute of a constructed element does not have a name that is distinct from the names of all other attributes of the constructed element.</p></dd><dt><a id="ERRXQDY0026"></a>err:XQDY0026</dt><dd><p><span style="display: none;" class="delete_version"> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the result of the content expression of a computed processing instruction constructor contains the string <code>"?&gt;"</code>.</span><span style="display: none;" class="add_version"> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the result of the content expression of a computed processing instruction constructor contains the string "<code>?&gt;</code>".</span><span class="modify_version"> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the result of the content expression of a computed processing instruction constructor contains the string "<code>?&gt;<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p></dd><dt><a id="ERRXQDY0027"></a>err:XQDY0027</dt><dd><p> In a validate expression, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the root element information item in the PSVI resulting from validation does not have the expected validity property: <code>valid</code> if validation mode is <code>strict</code>, or either <code>valid</code> or <code>notKnown</code> if validation mode is <code>lax</code>.</p></dd><dt><a id="ERRXQTY0030"></a>err:XQTY0030</dt><dd><p> It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the argument of a <code>validate</code> expression does not evaluate to exactly one document or element node. </p></dd><dt><a id="ERRXQST0031"></a>err:XQST0031</dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the version number specified in a version declaration is not supported by the implementation. </p></dd><dt><a id="ERRXQST0032"></a>err:XQST0032</dt><dd><p>A <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised if a Prolog contains more than one <a title="base URI declaration" class="termref" href="#dt-base-uri-decl">base URI declaration</a>.</p></dd><dt><a id="ERRXQST0033"></a>err:XQST0033</dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a module contains multiple bindings for the same namespace prefix.</p></dd><dt><a id="ERRXQST0034"></a>err:XQST0034</dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if multiple functions declared <span class="xquery">or imported by a <a title="module" class="termref" href="#dt-module">module</a></span> have the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and overlapping arity ranges (the arity range of a function declaration is <var>M</var> to <var>M+N</var>, where <var>M</var> is the number of required parameters and <var>N</var> is the number of optional parameters).</p></dd><dt><a id="ERRXQST0035"></a><span class="deltaxml-new">err:XQST0035</span></dt><dd><p><span class="deltaxml-new"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new">static error</span></a><span class="deltaxml-new"> to import two schema components that both define the same name in the same symbol space and in the same scope. </span></p></dd><dt><a id="ERRXQST0038"></a>err:XQST0038</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a Prolog contains more than one <a title="default collation declaration" class="termref" href="#dt-default-collation-decl">default collation declaration</a>, or the value specified by a default collation declaration is not present in <a title="statically known collations" class="termref" href="#dt-static-collations">statically known collations</a>.</p></dd><dt><a id="ERRXQST0039"></a>err:XQST0039</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for <span class="xquery">a function declaration or</span><span>an inline function expression</span> to have more than one parameter with the same name. </p></dd><dt><a id="ERRXQST0040"></a>err:XQST0040</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the attributes specified by a direct element constructor do not have distinct <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a>.</p></dd><dt><a id="ERRXQDY0041"></a>err:XQDY0041</dt><dd><p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the value of the name expression in a computed processing instruction constructor cannot be cast to the type <code>xs:NCName</code>.</p></dd><dt><a id="ERRXQDY0044"></a>err:XQDY0044</dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> the node-name of a node constructed by a computed attribute constructor has any of the following properties: </p><ul><li><p>Its namespace prefix is <code>xmlns</code>. </p></li><li><p>It has no namespace prefix and its local name is <code>xmlns</code>. </p></li><li><p>Its namespace URI is <code>http://www.w3.org/2000/xmlns/</code>. </p></li><li><p>Its namespace prefix is <code>xml</code> and its namespace URI is not <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Its namespace prefix is other than <code>xml</code> and its namespace URI is <code>http://www.w3.org/XML/1998/namespace</code>. </p></li></ul></dd><dt><a id="ERRXQST0045"></a>err:XQST0045</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if <span>the name of <span>a variable annotation,</span> a function annotation, or</span> the function name in a function declaration is <span>in a <a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces">reserved namespace</a>.</span></p></dd><dt><a id="ERRXQST0046"></a>err:XQST0046</dt><dd><p>An implementation <span class="xquery"><a title="may" class="termref" href="#may">MAY</a></span> raise a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of <span class="xquery">a <a href="#doc-xquery40-URILiteral">URILiteral</a> or </span>a <a href="#doc-xquery40-BracedURILiteral">BracedURILiteral</a> is of nonzero length and is <span>neither an absolute URI nor a relative URI</span>.</p></dd><dt><a id="ERRXQST0047"></a>err:XQST0047</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if multiple module imports in the same Prolog specify the same target namespace.</p></dd><dt><a id="ERRXQST0048"></a>err:XQST0048</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a function or variable declared in a library module is not in the target namespace of the library module.</p></dd><dt><a id="ERRXQST0049"></a>err:XQST0049</dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two or more variables declared or imported by a <a title="module" class="termref" href="#dt-module">module</a> have equal <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> (as defined by the <code>eq</code> operator.)</p></dd><dt><a id="ERRXPDY0050"></a>err:XPDY0050</dt><dd><p><span style="display: none;" class="delete_version">It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> of the operand of a <code>treat</code> expression does not match the <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> specified by the <code>treat</code> expression. This error might also be raised by a path expression beginning with <code>/</code> or <code>//</code> if the context node is not in a tree that is rooted at a document node. This is because a leading <code>/</code> or <code>//</code> in a path expression is an abbreviation for an initial step that includes the clause <code>treat as document-node()</code>.</span><span style="display: none;" class="add_version">It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> of the operand of a <code>treat</code> expression does not match the <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> specified by the <code>treat</code> expression. This error might also be raised by a path expression beginning with "<code>/</code>" or "<code>//</code>" if the context node is not in a tree that is rooted at a document node. This is because a leading "<code>/</code>" or "<code>//</code>" in a path expression is an abbreviation for an initial step that includes the clause <code>treat as document-node()</code>.</span><span class="modify_version">It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> of the operand of a <code>treat</code> expression does not match the <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> specified by the <code>treat</code> expression. This error might also be raised by a path expression beginning with <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> or <span class="deltaxml-new">"</span><code>//</code><span class="deltaxml-new">"</span> if the context node is not in a tree that is rooted at a document node. This is because a leading <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> or <span class="deltaxml-new">"</span><code>//</code><span class="deltaxml-new">"</span> in a path expression is an abbreviation for an initial step that includes the clause <code>treat as document-node()</code>.</span></p></dd><dt><a id="ERRXPST0051"></a>err:XPST0051</dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> used as an <a href="#doc-xquery40-ItemType">ItemType</a> in a <a href="#doc-xquery40-SequenceType">SequenceType</a> is not defined in the <a title="static context" class="termref" href="#dt-static-context">static context</a> either as a <a class="termref" title="named item type" href="#dt-named-item-type"><span class="deltaxml-old">named item type</span></a><a class="termref" title="type alias" href="#dt-type-alias"><span class="deltaxml-new">type alias</span></a> <span class="deltaxml-old">in the </span><a title="in-scope named item types" class="termref" href="#dt-in-scope-named-item-types"><span class="deltaxml-old">in-scope named item types</span></a><span class="deltaxml-old">, </span>or as a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a>.</p></dd><dt><a id="ERRXQST0052"></a>err:XQST0052</dt><dd><p>The type named in a cast or castable expression must be the name of a type defined in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a>, and the type must be <code>simple</code>.</p></dd><dt><a id="ERRXQDY0054"></a>err:XQDY0054</dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if a cycle is encountered in the definition of a <span class="deltaxml-old">module’s</span><span class="deltaxml-new">module's</span> dynamic context components, for example because of a cycle in variable declarations.</p></dd><dt><a id="ERRXQST0055"></a>err:XQST0055</dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a Prolog contains more than one <a title="copy-namespaces declaration" class="termref" href="#dt-copy-namespaces-decl">copy-namespaces declaration</a>.</p></dd><dt><a id="ERRXQST0057"></a>err:XQST0057</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a schema import binds a namespace prefix but does not specify a target namespace other than a zero-length string.</p></dd><dt><a id="ERRXQST0058"></a>err:XQST0058</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if multiple schema imports specify the same target namespace.</p></dd><dt><a id="ERRXQST0059"></a>err:XQST0059</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an implementation is unable to process a schema or module import by finding a schema or module with the specified target namespace.</p></dd><dt><a id="ERRXQST0060"></a>err:XQST0060</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the name of a function in a function declaration is not in a namespace (<a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> has a null namespace URI).</p></dd><dt><a id="ERRXQDY0061"></a>err:XQDY0061</dt><dd><p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the operand of a validate expression is a document node whose children do not consist of exactly one element node and zero or more comment and processing instruction nodes, in any order.</p></dd><dt><a id="ERRXQDY0064"></a>err:XQDY0064</dt><dd><p><span style="display: none;" class="delete_version"> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the value of the name expression in a computed processing instruction constructor is equal to <code>XML</code> (in any combination of upper and lower case).</span><span style="display: none;" class="add_version"> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the value of the name expression in a computed processing instruction constructor is equal to "XML" (in any combination of upper and lower case).</span><span class="modify_version"> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the value of the name expression in a computed processing instruction constructor is equal to <span class="deltaxml-new">"</span>XML<span class="deltaxml-new">"</span> (in any combination of upper and lower case).</span></p></dd><dt><a id="ERRXQST0065"></a>err:XQST0065</dt><dd><p>A <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised if a Prolog contains more than one <a title="ordering mode declaration" class="termref" href="#dt-ordering-mode-decl">ordering mode declaration</a>.</p></dd><dt><a id="ERRXQST0066"></a>err:XQST0066</dt><dd><p>A <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised if a Prolog contains more than one default element/type namespace declaration, or more than one default function namespace declaration. </p></dd><dt><a id="ERRXQST0067"></a>err:XQST0067</dt><dd><p>A <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised if a Prolog contains more than one <a title="construction declaration" class="termref" href="#dt-construction-decl">construction declaration</a>.</p></dd><dt><a id="ERRXQST0068"></a>err:XQST0068</dt><dd><p>A <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised if a Prolog contains more than one <a title="boundary-space declaration" class="termref" href="#dt-boundary-space-decl">boundary-space declaration</a>.</p></dd><dt><a id="ERRXQST0069"></a>err:XQST0069</dt><dd><p>A <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised if a Prolog contains more than one <a title="empty order declaration" class="termref" href="#dt-empty-order-decl">empty order declaration</a>.</p></dd><dt><a id="ERRXQST0070"></a>err:XQST0070</dt><dd><p class="xquery">A <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised if one of the predefined prefixes <code>xml</code> or <code>xmlns</code> appears in a namespace declaration <span>or a default namespace declaration,</span> or if any of the following conditions is statically detected in any expression or declaration: </p><ul><li><p>The prefix <code>xml</code> is bound to some namespace URI other than <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>A prefix other than <code>xml</code> is bound to the namespace URI <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>The prefix <code>xmlns</code> is bound to any namespace URI. </p></li><li><p>A prefix other than <code>xmlns</code> is bound to the namespace URI <code>http://www.w3.org/2000/xmlns/</code>. </p></li></ul></dd><dt><a id="ERRXQST0071"></a>err:XQST0071</dt><dd><p>A <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised if the namespace declaration attributes of a direct element constructor do not have distinct names.</p></dd><dt><a id="ERRXQDY0072"></a>err:XQDY0072</dt><dd><p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the result of the content expression of a computed comment constructor contains two adjacent hyphens or ends with a hyphen.</p></dd><dt><a id="ERRXQDY0074"></a>err:XQDY0074</dt><dd><p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the value of the name expression in a computed element or attribute constructor cannot be converted to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for example, because it contains a namespace prefix not found in <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>.)</p></dd><dt><a id="ERRXQST0075"></a>err:XQST0075</dt><dd><p> An implementation that does not support the <span>Schema Aware Feature</span> must raise a <a title="static error" class="termref" href="#dt-static-error">static error</a> if it encounters a <code>validate</code> expression.</p></dd><dt><a id="ERRXQST0076"></a>err:XQST0076</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <code>collation</code> subclause in an <code>order by</code><span>or <code>group by</code></span> clause of a FLWOR expression does not identify a collation that is present in <a title="statically known collations" class="termref" href="#dt-static-collations">statically known collations</a>.</p></dd><dt><a id="ERRXQST0079"></a>err:XQST0079</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an extension expression contains neither a <a title="pragma" class="termref" href="#dt-pragma">pragma</a> that is recognized by the implementation nor an expression enclosed in curly braces.</p></dd><dt><a id="ERRXPST0080"></a>err:XPST0080</dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the target type of a <code>cast</code> or <code>castable</code> expression is <code>xs:NOTATION</code>, <span><code>xs:anySimpleType</code>,</span> or <code>xs:anyAtomicType</code>.</p></dd><dt><a id="ERRXPST0081"></a>err:XPST0081</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a QName used in <span class="xquery">a query</span> contains a namespace prefix that cannot be expanded into a namespace URI by using the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>.</p></dd><dt><a id="ERRXQDY0084"></a>err:XQDY0084</dt><dd><p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the element validated by a <code>validate</code> statement does not have a top-level element declaration in the <a title="in-scope element declarations" class="termref" href="#dt-is-elems">in-scope element declarations</a>, if validation mode is <code>strict</code>.</p></dd><dt><a id="ERRXQST0085"></a>err:XQST0085</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the namespace URI in a namespace declaration attribute is a zero-length string, and the implementation does not support <a href="#XMLNAMES11">[XML Names 1.1]</a>.</p></dd><dt><a id="ERRXQTY0086"></a>err:XQTY0086</dt><dd><p> It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the typed value of a copied element or attribute node is <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a> when <a title="construction mode" class="termref" href="#dt-construction-mode">construction mode</a> is <code>preserve</code> and <a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> is <code>no-preserve</code>.</p></dd><dt><a id="ERRXQST0087"></a>err:XQST0087</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the encoding specified in a Version Declaration does not conform to the definition of <code>EncName</code> specified in <a href="#XML">[XML 1.0]</a>.</p></dd><dt><a id="ERRXQST0088"></a>err:XQST0088</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the literal that specifies the target namespace in a <a title="module import" class="termref" href="#dt-module-import">module import</a> or a <a title="module declaration" class="termref" href="#dt-module-declaration">module declaration</a> is of zero length.</p></dd><dt><a id="ERRXQST0089"></a>err:XQST0089</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a variable bound in a <code>for</code> or <code>window</code> clause of a FLWOR expression, and its associated positional variable, do not have distinct names (<a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a>).</p></dd><dt><a id="ERRXQST0090"></a>err:XQST0090</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="character reference" class="termref" href="#dt-character-reference">character reference</a> does not identify a valid character in the version of XML that is in use.</p></dd><dt><a id="ERRXQDY0091"></a>err:XQDY0091</dt><dd><p>An implementation <a title="may" class="termref" href="#may">MAY</a> raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <code>xml:id</code> error, as defined in <a href="#XMLID">[XML ID]</a>, is encountered during construction of an attribute named <code>xml:id</code>.</p></dd><dt><a id="ERRXQDY0092"></a>err:XQDY0092</dt><dd><p>An implementation <a title="may" class="termref" href="#may">MAY</a> raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if a constructed attribute named <code>xml:space</code> has a value other than <code>preserve</code> or <code>default</code>.</p></dd><dt><a id="ERRXQST0094"></a>err:XQST0094</dt><dd><p> The name of each grouping variable must be equal (by the <code>eq</code> operator on <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a>) to the name of a variable in the input tuple stream.</p></dd><dt><a id="ERRXQDY0096"></a>err:XQDY0096</dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a><span>if</span> the node-name of a node constructed by a computed element constructor has any of the following properties: </p><ul><li><p>Its namespace prefix is <code>xmlns</code>. </p></li><li><p>Its namespace URI is <code>http://www.w3.org/2000/xmlns/</code>. </p></li><li><p>Its namespace prefix is <code>xml</code> and its namespace URI is not <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Its namespace prefix is other than <code>xml</code> and its namespace URI is <code>http://www.w3.org/XML/1998/namespace</code>. </p></li></ul></dd><dt><a id="ERRXQST0097"></a>err:XQST0097</dt><dd><p> It is a static error for a decimal-format to specify a value that is not valid for a given property, as described in <a title="statically known decimal formats" class="termref" href="#dt-static-decimal-formats">statically known decimal formats</a></p></dd><dt><a id="ERRXQST0098"></a>err:XQST0098</dt><dd><p> It is a static error if, for any named or unnamed decimal format, the properties representing characters used in a picture string do not each have distinct values. <span> The following properties represent characters used in a picture string: <a title="decimal-separator" class="termref" href="#id-static-decimal-format-decimal-separator">decimal-separator</a>, <a title="exponent-separator" class="termref" href="#id-static-decimal-format-exponent-separator">exponent-separator</a>, <a title="grouping-separator" class="termref" href="#id-static-decimal-format-grouping-separator">grouping-separator</a>, <a title="percent" class="termref" href="#id-static-decimal-format-percent">percent</a>, <a title="per-mille" class="termref" href="#id-static-decimal-format-per-mille">per-mille</a>, the family of ten decimal digits starting with <a title="zero-digit" class="termref" href="#id-static-decimal-format-zero-digit">zero-digit</a>, <a title="digit" class="termref" href="#id-static-decimal-format-digit">digit</a>, and <a title="pattern-separator" class="termref" href="#id-static-decimal-format-pattern-separator">pattern-separator</a>. </span></p></dd><dt><a id="ERRXQST0099"></a>err:XQST0099</dt><dd><p><span>No module</span> may contain more than one ContextItemDecl. </p></dd><dt><a id="ERRXQDY0101"></a>err:XQDY0101</dt><dd><p>An error is raised if a computed namespace constructor attempts to do any of the following:</p><ul><li><p>Bind the prefix <code>xml</code> to some namespace URI other than <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Bind a prefix other than <code>xml</code> to the namespace URI <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Bind the prefix <code>xmlns</code> to any namespace URI. </p></li><li><p>Bind a prefix to the namespace URI <code>http://www.w3.org/2000/xmlns/</code>. </p></li><li><p>Bind any prefix (including the empty prefix) to a zero-length namespace URI.</p></li></ul></dd><dt><a id="ERRXQDY0102"></a>err:XQDY0102</dt><dd><p> In an element constructor, if two or more namespace bindings in the in-scope bindings would have the same prefix, then an error is raised if they have different URIs; if they would have the same prefix and URI, duplicate bindings are ignored. </p><p> If the name of an element in an element constructor is in no namespace, creating a default namespace for that element using a computed namespace constructor is an error. </p></dd><dt><a id="ERRXQST0103"></a>err:XQST0103</dt><dd><p>All variables in a <code>window</code> clause must have distinct names.</p></dd><dt><a id="ERRXQST0104"></a>err:XQST0104</dt><dd><p>A <a href="#doc-xquery40-TypeName">TypeName</a> that is specified in a <code>validate</code> expression must be found in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a></p></dd><dt><a id="ERRXQTY0105"></a>err:XQTY0105</dt><dd><p> It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the content sequence in an element constructor contains a function .</p></dd><dt><a id="ERRXQST0106"></a>err:XQST0106</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a function declaration contains both a <code>%private</code> and a <code>%public</code> annotation.</p></dd><dt><a id="ERRXQST0108"></a>err:XQST0108</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a title="output declaration" class="termref" href="#dt-output-declaration">output declaration</a> occurs in a <a title="library module" class="termref" href="#dt-library-module">library module</a>. </p></dd><dt><a id="ERRXQST0109"></a>err:XQST0109</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the local name of an output declaration in the <code>http://www.w3.org/2010/xslt-xquery-serialization</code> namespace is not one of the serialization parameter names listed in <a href="#id-xq-static-context-components"><b>C.1 Static Context Components</b></a>, <span>or if the name of an output declaration is <code>use-character-maps</code></span>. </p></dd><dt><a id="ERRXQST0110"></a>err:XQST0110</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the same serialization parameter is used more than once in an <a title="output declaration" class="termref" href="#dt-output-declaration">output declaration</a>.</p></dd><dt><a id="ERRXQST0111"></a>err:XQST0111</dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a query prolog to contain two decimal formats with the same name, or to contain two default decimal formats. </p></dd><dt><a id="ERRXQST0113"></a>err:XQST0113</dt><dd><p> Specifying a <a href="#doc-xquery40-VarValue">VarValue</a> or <a href="#doc-xquery40-VarDefaultValue">VarDefaultValue</a> for a context item declaration in a library module is a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></dd><dt><a id="ERRXQST0114"></a>err:XQST0114</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a decimal format declaration to define the same property more than once. </p></dd><dt><a id="ERRXQST0115"></a>err:XQST0115</dt><dd><p><span style="display: none;" class="delete_version"> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the document specified by the option <code>Q{http://www.w3.org/2010/xslt-xquery-serialization}parameter-document</code> raises a serialization error. </span><span style="display: none;" class="add_version"> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the document specified by the option "http://www.w3.org/2010/xslt-xquery-serialization":parameter-document raises a serialization error. </span><span class="modify_version"> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the document specified by the option <span class="deltaxml-old">Q{</span><span class="deltaxml-new">"</span>http://www.w3.org/2010/xslt-xquery-serialization<span class="deltaxml-old">}</span><span class="deltaxml-new">":</span>parameter-document raises a serialization error. </span></p></dd><dt><a id="ERRXQST0116"></a>err:XQST0116</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a><span>if a variable declaration contains both a <code>%private</code> and a <code>%public</code> annotation, more than one <code>%private</code> annotation, or more than one <code>%public</code> annotation.</span></p></dd><dt><a id="ERRXPTY0117"></a>err:XPTY0117</dt><dd><p>When applying the function conversion rules, if an item is of type <code>xs:untypedAtomic</code> and the expected type is <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a>, a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a href="#ERRXPTY0117" title="err:XPTY0117">err:XPTY0117</a>] is raised. </p></dd><dt><a id="ERRXQST0118"></a>err:XQST0118</dt><dd><p>In a direct element constructor, the name used in the end tag must exactly match the name used in the corresponding start tag, including its prefix or absence of a prefix.</p></dd><dt><a id="ERRXQST0119"></a>err:XQST0119</dt><dd><p>It is a static error if the implementation is not able to process the value of an <code>output:parameter-document</code> declaration to produce an XDM instance.</p></dd><dt><a id="ERRXQST0125"></a>err:XQST0125</dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an inline function <span>expression</span> is annotated as <code>%public</code> or <code>%private</code>. </p></dd><dt><a id="ERRXPDY0130"></a>err:XPDY0130</dt><dd><p>An implementation-dependent limit has been exceeded.</p></dd><dt><a id="ERRXQST0134"></a>err:XQST0134</dt><dd><p>The namespace axis is not supported.</p></dd><dt><a id="ERRXQDY0137"></a>err:XQDY0137</dt><dd><p>No two keys in a map may have the <a title="same key" class="termref" href="#dt-same-key">same key value</a>.</p></dd><dt><a id="ERRXQST0140"></a><span class="deltaxml-old">err:XQST0140</span></dt><dt><a id="ERRXPST0140"></a><span class="deltaxml-new">err:XPST0140</span></dt><dd><p><span class="deltaxml-old"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-old">static error</span></a><span class="deltaxml-old"> if a named item type declaration is recursive, unless it satisfies the conditions defined in </span><a href="#id-recursive-record-tests"><b><span class="deltaxml-old">3.6.4.4 Recursive Record Tests</span></b></a><span class="deltaxml-old">.</span></p><p><span class="deltaxml-new"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new">static error</span></a><span class="deltaxml-new"> if a self-reference within a </span><code><span class="deltaxml-new">RecordTest</span></code><span class="deltaxml-new"> appears as the type of a field declaration that is not optional and not emptiable.</span></p></dd><dt><a id="ERRXPTY0141"></a><span class="deltaxml-old">err:XPTY0141</span></dt><dt><a id="ERRXPST0141"></a><span class="deltaxml-new">err:XPST0141</span></dt><dd><p><span class="deltaxml-old">In a </span><code><span class="deltaxml-old">for</span></code><span class="xquery"><span class="deltaxml-old">clause</span></span><span class="deltaxml-old">, when the keyword </span><code><span class="deltaxml-old">member</span></code><span class="deltaxml-old"> precedes the variable name, the value of the binding collection must be a single array.</span></p><p><span class="deltaxml-new"> In a static function call, every required parameter in the corresponding </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new">function definition</span></a><span class="deltaxml-new"> must be matched to exactly one argument in the function call, and every optional parameter in the corresponding </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new">function definition</span></a><span class="deltaxml-new"> must be matched to zero or one arguments in the function call.</span></p></dd><dt><a id="ERRXPTY0144"></a><span class="deltaxml-old">err:XPTY0144</span></dt><dd><p><span class="deltaxml-old">During the analysis phase, an axis step is classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-old">implausible</span></a><span class="deltaxml-old"> if the combination of the inferred context item type, the choice of axis, and the supplied node test, is such that the axis step will always return an empty sequence.</span></p></dd><dt><a id="ERRXPTY0145"></a><span class="deltaxml-old">err:XPTY0145</span></dt><dd><p><span class="deltaxml-old">During the analysis phase, a unary or postfix lookup expression is classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-old">implausible</span></a><span class="deltaxml-old"> if the combination of the inferred type of the left-hand operand (or the context item type in the case of a unary expression) and the choice of key specifier is such that the lookup expression will always return an empty sequence.</span></p></dd><dt><a id="ERRXQST0146"></a><span class="deltaxml-old">err:XQST0146</span></dt><dd><p><span class="deltaxml-old">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-old">static error</span></a><span class="deltaxml-old"> if two or more item types declared or imported by a </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-old">module</span></a><span class="deltaxml-old"> have equal </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-old">expanded QNames</span></a><span class="deltaxml-old"> (as defined by the </span><code><span class="deltaxml-old">eq</span></code><span class="deltaxml-old"> operator.)</span></p></dd><dt><a id="ERRXPST0147"></a><span class="deltaxml-old">err:XPST0147</span></dt><dd><p><span class="deltaxml-old">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-old">static error</span></a><span class="deltaxml-old"> if a type used as a member type in a </span><a href="#doc-xquery40-LocalUnionType"><span class="deltaxml-old">LocalUnionType</span></a><span class="deltaxml-old"> is not a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-old">generalized atomic type</span></a><span class="deltaxml-old">.</span></p></dd><dt><a id="ERRXQST0148"></a><span class="deltaxml-old">err:XQST0148</span></dt><dt><a id="ERRXPST0142"></a><span class="deltaxml-new">err:XPST0142</span></dt><dd><p><span class="deltaxml-old">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-old">static error</span></a><span class="deltaxml-old"> if an optional parameter in a function declaration is followed by a parameter that does not have a default value.</span></p><p><span class="deltaxml-new"> In a static function call, every keyword used in a </span><a href="#doc-xquery40-KeywordArgument"><span class="deltaxml-new">KeywordArgument</span></a><span class="deltaxml-new"> (after expansion to a QName) must match the name of a parameter in the corresponding </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new">function definition</span></a><span class="deltaxml-new">.</span></p></dd><dt><a id="ERRXQST0149"></a><span class="deltaxml-old">err:XQST0149</span></dt><dt><a id="ERRXPTY0143"></a><span class="deltaxml-new">err:XPTY0143</span></dt><dd><p><span class="deltaxml-old"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-old">static error</span></a><span class="deltaxml-old"> if the schemas imported by different modules of a query are not compatible as defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#schema-consistency"><span class="deltaxml-old">Section 2.8.1 Schema Consistency</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">.</span></p><p><span class="deltaxml-new">In a </span><code><span class="deltaxml-new">for</span></code><span class="xquery"><span class="deltaxml-new">clause</span></span><span class="deltaxml-new">, when the keyword </span><code><span class="deltaxml-new">member</span></code><span class="deltaxml-new"> precedes the variable name, the value of the binding collection must be a single array.</span></p></dd></dl></div><div class="div1"><h2><a id="id-mime-type"></a>G The <code>application/xquery</code> Media Type</h2><p>This Appendix specifies the media type for XQuery Version 1.0. XQuery is a language for querying over collections of data from XML data sources, as specified in the main body of this document. This media type is being submitted to the IESG (Internet Engineering Steering Group) for review, approval, and registration with IANA (Internet Assigned Numbers Authority.)</p><div class="div2"><h3><a id="id-mime-type-intro"></a>G.1 Introduction</h3><p> This document, found at <a href="http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</a>, together with its normative references, defines the language XQuery Version 1.0. This Appendix provides information about the <code>application/xquery</code> media type, which is intended to be used for transmitting queries written in the XQuery language.</p><p>This document was prepared by members of the W3C XML Query Working Group. Please send comments to public-qt-comments@w3.org, a public mailing list with archives at <a href="http://lists.w3.org/Archives/Public/public-qt-comments">http://lists.w3.org/Archives/Public/public-qt-comments</a>.</p></div><div class="div2"><h3><a id="id-registration-of-mime-type"></a>G.2 Registration of MIME Media Type <code>application/xquery</code></h3><p>MIME media type name: <code>application</code></p><p>MIME subtype name: <code>xquery</code></p><p>Required parameters: none</p><p>Optional parameters: none</p><p>The syntax of XQuery is expressed in Unicode but may be written with any Unicode-compatible character encoding, including UTF-8 or UTF-16, or transported as US-ASCII or ISO-8859-1 with Unicode characters outside the range of the given encoding represented using an XML-style <code>&amp;#xddd;</code> syntax.</p><div class="div3"><h4><a id="id-interoperability-considerations"></a>G.2.1 Interoperability Considerations</h4><p>None known.</p></div><div class="div3"><h4><a id="id-applications-of-media-type"></a>G.2.2 Applications Using this Media Type</h4><p>The public <a href="http://www.w3.org/XML/Query/">XQuery Web page</a> lists more than two dozen implementations of the XQuery language, both proprietary and open source.</p><p>This media type is registered to allow for deployment of XQuery on the World Wide Web.</p></div><div class="div3"><h4><a id="id-file-extensions"></a>G.2.3 File Extensions</h4><p>The most common file extensions in use for XQuery are <code>.xq</code> and <code>.xquery</code>.</p><p>The appropriate Macintosh file type code is <code>TEXT</code>.</p></div><div class="div3"><h4><a id="id-intended-usage"></a>G.2.4 Intended Usage</h4><p>The intended usage of this media type is for interchange of XQuery expressions.</p></div><div class="div3"><h4><a id="id-author-change-controller"></a>G.2.5 Author/Change Controller</h4><p>XQuery was produced by, and is maintained by, the World Wide Web <span class="deltaxml-old">Consortium’s</span><span class="deltaxml-new">Consortium's</span> XML Query Working Group. The W3C has change control over this specification.</p></div></div><div class="div2"><h3><a id="xquery-mime-encoding"></a>G.3 Encoding Considerations</h3><p>For use with transports that are not 8-bit clean, quoted-printable encoding is recommended since the XQuery syntax itself uses the US-ASCII-compatible subset of Unicode.</p><p>An XQuery document may contain an <a title="encoding declaration" class="termref" href="#dt-encoding-declaration">encoding declaration</a> as part of its <a title="version declaration" class="termref" href="#dt-version-declaration">version declaration</a>:</p><div class="exampleInner"><pre>xquery version "3.1" encoding "utf-8";</pre></div></div><div class="div2"><h3><a id="xquery-mime-recognizing"></a>G.4 Recognizing XQuery Files</h3><p>An XQuery file may have the string <code>xquery version "V.V"</code> near the beginning of the document, where <code>"V.V"</code> is a version number. Currently the version number, if present, must be <code>"1.0"</code><span>, <code>"3.0"</code>, or <code>"3.1"</code></span>.</p></div><div class="div2"><h3><a id="id-charset-default-rules"></a>G.5 Charset Default Rules</h3><p>XQuery documents use the Unicode character set and, by default, the UTF-8 encoding.</p></div><div class="div2"><h3><a id="id-security-considerations"></a>G.6 Security Considerations</h3><p>Queries written in XQuery may cause arbitrary URIs or IRIs to be dereferenced. Therefore, the security issues of <a href="#RFC3987">[RFC3987]</a> Section 8 should be considered. In addition, the contents of resources identified by <code>file:</code> URIs can in some cases be accessed, processed and returned as results. XQuery expressions can invoke any of the functions defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>. For example, the <code>fn:doc()</code> and <code>fn:doc-available()</code> functions allow local filesystem probes as well as access to any URI-defined resource accessible from the system evaluating the XQuery expression. <span> The <code>fn:transform()</code> function allows calls to URI-identified XSLT transformations which may in turn call external extension functions and access or write to the file system. The <code>fn:transform()</code> function should be sandboxed or disabled if untrusted queries are run. </span></p><p>XQuery is a full declarative programming language, and supports user-defined functions, external function libraries (modules) referenced by URI, and system-specific <span class="deltaxml-old">“native”</span><span class="deltaxml-new">"native"</span> functions.</p><p>Arbitrary recursion is possible, as is arbitrarily large memory usage, and implementations may place limits on CPU and memory usage, as well as restricting access to system-defined functions. </p><p> The optional XQuery Update Facility allows XQuery expressions to create and update persistent data, potentially including writing to arbitrary locations on the local filesystem as well as to remote URIs. Untrusted queries should not be given write access to data. </p><p>Furthermore, because the XQuery language permits extensions, it is possible that <code>application/xquery</code> may describe content that has security implications beyond those described here.</p></div></div><div class="div1"><h2><a id="id-glossary"></a>H Glossary (Non-Normative)</h2><dl><dt><a id="GLdt-EnumerationType"></a><span class="deltaxml-new">EnumerationType</span></dt><dd><p><span class="deltaxml-new">An </span><b><span class="deltaxml-new">EnumerationType</span></b><span class="deltaxml-new"> accepts a fixed set of string values.</span></p></dd><dt><a id="GLdt-gregorian"></a><span class="deltaxml-new">Gregorian</span></dt><dd><p><span class="deltaxml-new">In the operator mapping tables, the term </span><b><span class="deltaxml-new">Gregorian</span></b><span class="deltaxml-new"> refers to the types </span><code><span class="deltaxml-new">xs:gYearMonth</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">xs:gYear</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">xs:gMonthDay</span></code><span class="deltaxml-new">, </span><code><span class="deltaxml-new">xs:gDay</span></code><span class="deltaxml-new">, and </span><code><span class="deltaxml-new">xs:gMonth</span></code><span class="deltaxml-new">.</span></p></dd><dt><a id="GLid-static-decimal-format-NaN"></a><span class="deltaxml-new">NaN</span></dt><dd><p><b><span class="deltaxml-new">NaN</span></b><span class="deltaxml-new"> is the string used to represent the double value NaN (not-a-number); the default value is the string "NaN"</span></p></dd><dt><a id="GLdt-prolog"></a><span class="deltaxml-new">Prolog</span></dt><dd><p><span class="deltaxml-new">A </span><b><span class="deltaxml-new">Prolog</span></b><span class="deltaxml-new"> is a series of declarations and imports that define the processing environment for the </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new">module</span></a><span class="deltaxml-new"> that contains the Prolog.</span></p></dd><dt><a id="GLdt-sequencetype-matching"></a><span class="deltaxml-new">SequenceType matching</span></dt><dd><p><b><span class="deltaxml-new">SequenceType matching</span></b><span class="deltaxml-new"> compares a value with an expected </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new">sequence type</span></a><span class="deltaxml-new">. </span></p></dd><dt><a id="GLdt-static-base-uri"></a><span class="deltaxml-new">Static Base URI</span></dt><dd><p><b><span class="deltaxml-new">Static Base URI.</span></b><span class="deltaxml-new"> This is an absolute URI, used to resolve </span><span class="xquery"><span class="deltaxml-new">relative URIs both during static analysis and during dynamic evaluation.</span></span></p></dd><dt><a id="GLdt-URI"></a><span class="deltaxml-new">URI</span></dt><dd><p><span class="deltaxml-new">Within this specification, the term </span><b><span class="deltaxml-new">URI</span></b><span class="deltaxml-new"> refers to a Universal Resource Identifier as defined in </span><a href="#RFC3986"><span class="deltaxml-new">[RFC3986]</span></a><span class="deltaxml-new"> and extended in </span><a href="#RFC3987"><span class="deltaxml-new">[RFC3987]</span></a><span class="deltaxml-new"> with the new name </span><b><span class="deltaxml-new">IRI</span></b><span class="deltaxml-new">.</span></p></dd><dt><a id="GLdt-data-model-instance"></a><span class="deltaxml-new">XDM instance</span></dt><dd><p><span class="deltaxml-new">The term </span><b><span class="deltaxml-new">XDM instance</span></b><span class="deltaxml-new"> is used, synonymously with the term </span><a title="value" class="termref" href="#dt-value"><span class="deltaxml-new">value</span></a><span class="deltaxml-new">, to denote an unconstrained </span><a title="sequence" class="termref" href="#dt-sequence"><span class="deltaxml-new">sequence</span></a><span class="deltaxml-new"> of </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new">items</span></a><span class="deltaxml-new">.</span></p></dd><dt><a id="GLdt-xpath-compat-mode"></a><span class="deltaxml-new">XPath 1.0 compatibility mode</span></dt><dd><p><b><span class="deltaxml-new">XPath 1.0 compatibility mode.</span></b><span class="xquery"><span class="deltaxml-new">This component must be set by all host languages that include XPath 3.1 as a subset, indicating whether rules for compatibility with XPath 1.0 are in effect. XQuery sets the value of this component to </span><code><span class="deltaxml-new">false</span></code><span class="deltaxml-new">. </span></span></p></dd><dt><a id="GLdt-xquery-10-processor"></a><span class="deltaxml-new">XQuery 1.0 Processor</span></dt><dd><p><span class="deltaxml-new"> An </span><b><span class="deltaxml-new">XQuery 1.0 Processor</span></b><span class="deltaxml-new"> processes a query according to the XQuery 1.0 specification. </span></p></dd><dt><a id="GLdt-xquery-30-processor"></a><span class="deltaxml-new">XQuery 3.0 Processor</span></dt><dd><p><span class="deltaxml-new"> An </span><b><span class="deltaxml-new">XQuery 3.0 Processor</span></b><span class="deltaxml-new"> processes a query according to the XQuery 3.0 specification. </span></p></dd><dt><a id="GLdt-xquery-31-processor"></a><span class="deltaxml-new">XQuery 3.1 Processor</span></dt><dd><p><span class="deltaxml-new"> An </span><b><span class="deltaxml-new">XQuery 3.1 Processor</span></b><span class="deltaxml-new"> processes a query according to the XQuery 3.1 specification. </span></p></dd><dt><a id="GLdt-version-number"></a><span class="deltaxml-new">XQuery version number</span></dt><dd><p><span class="deltaxml-new">An </span><b><span class="deltaxml-new">XQuery version number</span></b><span class="deltaxml-new"> consists of two integers separated by a dot. The first integer is referred to as the </span><b><span class="deltaxml-new">major version number</span></b><span class="deltaxml-new">; the second as the </span><b><span class="deltaxml-new">minor version number</span></b><span class="deltaxml-new">.</span></p></dd><dt><a id="GLdt-anonymous-function"></a>anonymous function</dt><dd><p> An <b>anonymous function</b> is a <a title="function item" class="termref" href="#dt-function-item">function item</a> with no name. Anonymous functions may be created, for example, by evaluating an inline function expression or by partial function application.</p></dd><dt><a id="GLdt-application-function"></a>application function</dt><dd><p><span style="display: none;" class="delete_version"><b>Application functions</b> are function definitions written in a host language such as XQuery or XSLT whose syntax and semantics are defined in this family of specifications. Their behavior (including the rules determining the static and dynamic context) follows the rules for such functions in the relevant host language specification.</span><span style="display: none;" class="add_version"><b>Application functions</b> are function definitions written in a host language such as XQuery or XSLT whose semantics are defined in this family of specifications. Their behavior (including the rules determining the static and dynamic context) follows the rules for such functions in the relevant host language specification.</span><span class="modify_version"><b>Application functions</b> are function definitions written in a host language such as XQuery or XSLT whose <span class="deltaxml-old">syntax and </span>semantics are defined in this family of specifications. Their behavior (including the rules determining the static and dynamic context) follows the rules for such functions in the relevant host language specification.</span></p></dd><dt><a id="GLdt-arg-expr"></a>argument expression</dt><dd><p>An argument to a function call is either an <b>argument expression</b> or an <a href="#doc-xquery40-ArgumentPlaceholder">ArgumentPlaceholder</a> (<code>?</code>); in both cases it may either be supplied positionally, or identified by a name (called a keyword).</p></dd><dt><a id="GLdt-arity-range"></a>arity range</dt><dd><p>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> has an <b>arity range</b>, which is a range of consecutive non-negative integers. If the function definition has <var>M</var> required parameters and <var>N</var> optional parameters, then its arity range is from <var>M</var> to <var>M</var>+<var>N</var> inclusive.</p></dd><dt><a id="GLdt-array"></a>array</dt><dd><p>An <b>array</b> is a <a title="function item" class="termref" href="#dt-function-item">function item</a> that associates a set of positions, represented as positive integer keys, with values.</p></dd><dt><a id="GLdt-arrow-operator"></a><span class="deltaxml-new">arrow operator</span></dt><dd><p><span class="deltaxml-new">An </span><b><span class="deltaxml-new">arrow operator</span></b><span class="deltaxml-new"> applies a function to the value of an expression, using the value as the first argument to the function.</span></p></dd><dt><a id="GLdt-associated-value"></a>associated value</dt><dd><p>The value associated with a given key is called the <b>associated value</b> of the key.</p></dd><dt><a id="GLdt-atomic-value"></a>atomic value</dt><dd><p>An <b>atomic value</b> is a value in the value space of an <b>atomic type</b>, as defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.</p></dd><dt><a id="GLdt-atomization"></a>atomization</dt><dd><p><span style="display: none;" class="delete_version"><b>Atomization</b> of a sequence is defined as the result of invoking the <code>fn:data</code> function, as defined in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-data">Section 2.4 fn:data</a><sup><small>FO40</small></sup>.</span><span style="display: none;" class="add_version"><b>Atomization</b> of a sequence is defined as the result of invoking the <code>fn:data</code> function, as defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-data">Section 2.4 fn:data </a><sup><small>FO31</small></sup>.</span><span class="modify_version"><b>Atomization</b> of a sequence is defined as the result of invoking the <code>fn:data</code> function, as defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-data">Section 2.4 fn:data<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>.</span></p></dd><dt><a id="GLdt-available-docs"></a>available documents</dt><dd><p><b>Available documents.</b> This is a mapping of strings to document nodes. Each string represents the absolute URI of a resource. The document node is the root of a tree that represents that resource using the <a title="data model" class="termref" href="#dt-datamodel">data model</a>. The document node is returned by the <code>fn:doc</code> function when applied to that URI.</p></dd><dt><a id="GLdt-available-collections"></a>available item collections</dt><dd><p><b>Available collections.</b> This is a mapping of strings to sequences of items. Each string represents the absolute URI of a resource. The sequence of items represents the result of the <code>fn:collection</code> function when that URI is supplied as the argument. </p></dd><dt><a id="GLdt-available-text-resources"></a>available text resources</dt><dd><p><b>Available text resources</b>. This is a mapping of strings to text resources. Each string represents the absolute URI of a resource. The resource is returned by the <code>fn:unparsed-text</code> function when applied to that URI.</p></dd><dt><a id="GLdt-available-uri-collections"></a>available uri collections</dt><dd><p><b>Available URI collections.</b> This is a mapping of strings to sequences of URIs. The string represents the absolute URI of a resource which can be interpreted as an aggregation of a number of individual resources each of which has its own URI. The sequence of URIs represents the result of the <code>fn:uri-collection</code> function when that URI is supplied as the argument. </p></dd><dt><a id="GLdt-axis-step"></a>axis step</dt><dd><p><span style="display: none;" class="delete_version">An <b>axis step</b> returns a sequence of nodes that are reachable from a starting node via a specified axis. Such a step has two parts: an <b>axis</b>, which defines the "direction of movement" for the step, and a <a title="node test" class="termref" href="#dt-node-test">node test</a>, which selects nodes based on their kind, name, and/or <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> .</span><span style="display: none;" class="add_version">An <b>axis step</b> returns a sequence of nodes that are reachable from the context node via a specified axis. Such a step has two parts: an <b>axis</b>, which defines the "direction of movement" for the step, and a <a title="node test" class="termref" href="#dt-node-test">node test</a>, which selects nodes based on their kind, name, and/or <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>.</span><span class="modify_version">An <b>axis step</b> returns a sequence of nodes that are reachable from <span class="deltaxml-old">a starting</span><span class="deltaxml-new">the context</span> node via a specified axis. Such a step has two parts: an <b>axis</b>, which defines the "direction of movement" for the step, and a <a title="node test" class="termref" href="#dt-node-test">node test</a>, which selects nodes based on their kind, name, and/or <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><span class="deltaxml-old"> </span>.</span></p></dd><dt><a id="GLdt-base-uri-decl"></a>base URI declaration</dt><dd><p>A <b>base URI declaration</b> specifies the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property. The <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is used when resolving relative URI references.</p></dd><dt><a id="GLdt-binary"></a><span class="deltaxml-old">binary</span></dt><dd><p><span class="deltaxml-old">In the operator mapping tables, the term </span><b><span class="deltaxml-old">binary</span></b><span class="deltaxml-old"> refers to the types </span><code><span class="deltaxml-old">xs:hexBinary</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:base64Binary</span></code><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-binding-collection"></a>binding collection</dt><dd><p>In a <code>for</code> clause, when an expression is preceded by the keyword <code>in</code>, the value of that expression is called a <b>binding collection</b>.</p></dd><dt><a id="GLdt-binding-sequence"></a>binding sequence</dt><dd><p>In a <code>window</code> clause, when an expression is preceded by the keyword <code>in</code>, the value of that expression is called a <b>binding sequence</b>.</p></dd><dt><a id="GLdt-boundary-whitespace"></a><span class="deltaxml-new">boundary whitespace</span></dt><dd><p><b><span class="deltaxml-new">Boundary whitespace</span></b><span class="deltaxml-new"> is a sequence of consecutive whitespace characters within the content of a </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-new">direct element constructor</span></a><span class="deltaxml-new">, that is delimited at each end either by the start or end of the content, or by a </span><a href="#doc-xquery40-DirectConstructor"><span class="deltaxml-new">DirectConstructor</span></a><span class="deltaxml-new">, or by an </span><a href="#doc-xquery40-EnclosedExpr"><span class="deltaxml-new">EnclosedExpr</span></a><span class="deltaxml-new">. For this purpose, characters generated by </span><a title="character reference" class="termref" href="#dt-character-reference"><span class="deltaxml-new">character references</span></a><span class="deltaxml-new"> such as </span><code><span class="deltaxml-new">&amp;#x20;</span></code><span class="deltaxml-new"> or by </span><a href="#doc-xquery40-CDataSection"><span class="deltaxml-new">CDataSections</span></a><span class="deltaxml-new"> are not considered to be whitespace characters.</span></p></dd><dt><a id="GLdt-boundary-space-decl"></a>boundary-space declaration</dt><dd><p>A <b>boundary-space declaration</b> sets the <a title="boundary-space policy" class="termref" href="#dt-boundary-space-policy">boundary-space policy</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default. Boundary-space policy controls whether <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> is preserved by element constructors during processing of the query.</p></dd><dt><a id="GLdt-boundary-space-policy"></a>boundary-space policy</dt><dd><p><span style="display: none;" class="delete_version"><b>Boundary-space policy.</b> This component controls the processing of <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> by <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructors</a>, as described in <a href="#id-whitespace"><span class="delete_version"><b>4.13.1.4 Boundary Whitespace</b></span><span class="modify_version"><b>4.13.1.4 Boundary Whitespace</b></span></a>.</span><span style="display: none;" class="add_version"><b>Boundary-space policy.</b> This component controls the processing of <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> by <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructors</a>, as described in <a href="#id-whitespace"><span class="add_version"><b>4.12.1.4 Boundary Whitespace</b></span><span class="modify_version"><b>4.12.1.4 Boundary Whitespace</b></span></a>.</span><span class="modify_version"><b>Boundary-space policy.</b> This component controls the processing of <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> by <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructors</a>, as described in <a href="#id-whitespace"><span style="display: none;" class="delete_version"><b>4.13.1.4 Boundary Whitespace</b></span><span style="display: none;" class="add_version"><b>4.12.1.4 Boundary Whitespace</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1.4</span><span class="deltaxml-new">4.12.1.4</span> Boundary Whitespace</b></span></a>.</span></p></dd><dt><a id="GLdt-boundary-whitespace"></a><span class="deltaxml-old">boundary whitespace</span></dt><dt><a id="GLdt-built-in-function"></a><span class="deltaxml-new">built-in function</span></dt><dd><p><b><span class="deltaxml-old">Boundary whitespace</span></b><span class="deltaxml-old"> is a sequence of consecutive whitespace characters within the content of a </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-old">direct element constructor</span></a><span class="deltaxml-old">, that is delimited at each end either by the start or end of the content, or by a </span><a href="#doc-xquery40-DirectConstructor"><span class="deltaxml-old">DirectConstructor</span></a><span class="deltaxml-old">, or by an </span><a href="#doc-xquery40-EnclosedExpr"><span class="deltaxml-old">EnclosedExpr</span></a><span class="deltaxml-old">. For this purpose, characters generated by </span><a title="character reference" class="termref" href="#dt-character-reference"><span class="deltaxml-old">character references</span></a><span class="deltaxml-old"> such as </span><code><span class="deltaxml-old">&amp;#x20;</span></code><span class="deltaxml-old"> or by </span><a href="#doc-xquery40-CDataSection"><span class="deltaxml-old">CDataSections</span></a><span class="deltaxml-old"> are not considered to be whitespace characters.</span></p><p><b><span class="deltaxml-new">Built-in functions</span></b><span class="deltaxml-new"> are </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new">function definitions</span></a><span class="deltaxml-new"> that are always present in the static context by virtue of rules in the host language; they will typically include the functions specified in </span><a href="#xpath-functions-40"><span class="deltaxml-new">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new">.</span></p></dd><dt><a id="GLdt-character-reference"></a>character reference</dt><dd><p>A <b>character reference</b> is an XML-style reference to a <a href="#Unicode">[Unicode]</a> character, identified by its decimal or hexadecimal codepoint.</p></dd><dt><a id="GLdt-coercion-rules"></a>coercion rules</dt><dd><p>The <b>coercion rules</b> are rules used to convert a supplied value to a required type, for example when converting an argument of a function call to the declared type of the function parameter. </p></dd><dt><a id="GLdt-collation"></a>collation</dt><dd><p><span style="display: none;" class="delete_version">A <b>collation</b> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <a href="https://qt4cg.org/specifications/xpath-functions-40/#string-compare">Section 5.3 Comparison of strings</a><sup><small>FO40</small></sup>.</span><span style="display: none;" class="add_version">A <b>collation</b> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <a href="https://www.w3.org/TR/xpath-functions-31/#string-compare">Section 5.3 Comparison of strings </a><sup><small>FO31</small></sup>.</span><span class="modify_version">A <b>collation</b> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <a href="https://www.w3.org/TR/xpath-functions-31/#string-compare">Section 5.3 Comparison of strings<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>.</span></p></dd><dt><a id="GLdt-comma-operator"></a>comma operator</dt><dd><p>One way to construct a sequence is by using the <b>comma operator</b>, which evaluates each of its operands and concatenates the resulting sequences, in order, into a single result sequence.</p></dd><dt><a id="GLdt-complex-terminal"></a><span class="deltaxml-old">complex terminal</span></dt><dd><p><span class="deltaxml-old">A </span><b><span class="deltaxml-old">complex terminal</span></b><span class="deltaxml-old"> is a </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-old">variable terminal</span></a><span class="deltaxml-old"> whose production rule references, directly or indirectly, an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-old">ordinary production rule</span></a><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-computed-elem-const"></a>computed element constructor</dt><dd><p>A <b>computed element constructor</b> creates an element node, allowing both the name and the content of the node to be computed.</p></dd><dt><a id="GLdt-construction-decl"></a>construction declaration</dt><dd><p>A <b>construction declaration</b> sets the <a title="construction mode" class="termref" href="#dt-construction-mode">construction mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default.</p></dd><dt><a id="GLdt-construction-mode"></a>construction mode</dt><dd><p><b>Construction mode.</b> The construction mode governs the behavior of element and document node constructors. If construction mode is <code>preserve</code>, the type of a constructed element node is <code>xs:anyType</code>, and all attribute and element nodes copied during node construction retain their original types. If construction mode is <code>strip</code>, the type of a constructed element node is <code>xs:untyped</code>; all element nodes copied during node construction receive the type <code>xs:untyped</code>, and all attribute nodes copied during node construction receive the type <code>xs:untypedAtomic</code>.</p></dd><dt><a id="GLdt-constructor-function"></a>constructor function</dt><dd><p><span style="display: none;" class="delete_version">The <b>constructor function</b> for a given simple type is used to convert instances of other simple types into the given type. The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code>(($arg) cast as T?)</code>.</span><span style="display: none;" class="add_version">The <b>constructor function</b> for a given type is used to convert instances of other simple types into the given type. The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code>(($arg) cast as T?)</code>.</span><span class="modify_version">The <b>constructor function</b> for a given <span class="deltaxml-old">simple </span>type is used to convert instances of other simple types into the given type. The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code>(($arg) cast as T?)</code>.</span></p></dd><dt><a id="GLdt-content-expression"></a>content expression</dt><dd><p>In an <a title="enclosed expression" class="termref" href="#dt-enclosed-expression">enclosed expression</a>, the optional expression enclosed in curly braces is called the <b>content expression</b>.</p></dd><dt><a id="GLdt-context-dependent"></a>context dependent</dt><dd><p><span style="display: none;" class="delete_version">A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> is said to be <b>context dependent</b> if its result depends on the static or dynamic context of its caller. A function definition may be context-dependent for some arities in its arity range, and context-independent for others: for example <code>fn:name#0</code> is context-dependent while <code>fn:name#1</code> is context-independent.</span><span style="display: none;" class="add_version">A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> is said to be <b>context dependent</b> if its result depends on the static or dynamic context of its caller.</span><span class="modify_version">A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> is said to be <b>context dependent</b> if its result depends on the static or dynamic context of its caller.<span class="deltaxml-old"> A function definition may be context-dependent for some arities in its arity range, and context-independent for others: for example </span><span class="deltaxml-old">fn:name#0</span><span class="deltaxml-old"> is context-dependent while </span><span class="deltaxml-old">fn:name#1</span><span class="deltaxml-old"> is context-independent.</span></span></p></dd><dt><a id="GLdt-context-item"></a><span class="deltaxml-new">context item</span></dt><dd><p><span class="deltaxml-new">The </span><b><span class="deltaxml-new">context item</span></b><span class="deltaxml-new"> is the </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new">item</span></a><span class="deltaxml-new"> currently being processed.</span></p></dd><dt><a id="GLdt-context-item-static-type"></a><span class="deltaxml-new">context item static type</span></dt><dd><p><b><span class="deltaxml-new">Context item static type.</span></b><span class="deltaxml-new"> This component defines the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new">static type</span></a><span class="deltaxml-new"> of the context item within the scope of a given expression.</span></p></dd><dt><a id="GLdt-context-node"></a>context node</dt><dd><p><span style="display: none;" class="delete_version">When the context value is a single item, it can also be referred to as the <b>context item</b>; when it is a single node, it can also be referred to as the <b>context node</b>.</span><span style="display: none;" class="add_version">When the context item is a node, it can also be referred to as the <b>context node</b>.</span><span class="modify_version">When the context <span class="deltaxml-old">value is a single item, it can also be referred to as the</span><span class="deltaxml-new">item</span> <span class="deltaxml-old">context item</span><span class="deltaxml-old">; when it </span>is a <span class="deltaxml-old">single </span>node, it can also be referred to as the <b>context node</b>.</span></p></dd><dt><a id="GLdt-context-position"></a>context position</dt><dd><p><span style="display: none;" class="delete_version">The <b>context position</b> is the position of the context value within the series of values currently being processed.</span><span style="display: none;" class="add_version">The <b>context position</b> is the position of the context item within the sequence of items currently being processed.</span><span class="modify_version">The <b>context position</b> is the position of the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span> within the <span class="deltaxml-old">series of values</span><span class="deltaxml-new">sequence of items</span> currently being processed.</span></p></dd><dt><a id="GLdt-context-size"></a>context size</dt><dd><p><span style="display: none;" class="delete_version">The <b>context size</b> is the number of values in the series of values currently being processed.</span><span style="display: none;" class="add_version">The <b>context size</b> is the number of items in the sequence of items currently being processed.</span><span class="modify_version">The <b>context size</b> is the number of <span class="deltaxml-old">values</span><span class="deltaxml-new">items</span> in the <span class="deltaxml-old">series of values</span><span class="deltaxml-new">sequence of items</span> currently being processed.</span></p></dd><dt><a id="GLdt-context-value"></a><span class="deltaxml-old">context value</span></dt><dd><p><span class="deltaxml-old">The </span><b><span class="deltaxml-old">context value</span></b><span class="deltaxml-old"> is the </span><a title="value" class="termref" href="#dt-value"><span class="deltaxml-old">value</span></a><span class="deltaxml-old"> currently being processed.</span></p></dd><dt><a id="GLdt-context-value-static-type"></a><span class="deltaxml-old">context value static type</span></dt><dd><p><b><span class="deltaxml-old">Context value static type.</span></b><span class="deltaxml-old"> This is a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-old">sequence type</span></a><span class="deltaxml-old">; it defines the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-old">static type</span></a><span class="deltaxml-old"> of the </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-old">context value</span></a><span class="deltaxml-old"> within the scope of a given expression.</span></p></dd><dt><a id="GLdt-copy-namespaces-decl"></a>copy-namespaces declaration</dt><dd><p>A <b>copy-namespaces declaration</b> sets the value of <a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default. Copy-namespaces mode controls the namespace bindings that are assigned when an existing element node is copied by an element constructor or document constructor.</p></dd><dt><a id="GLdt-copy-namespaces-mode"></a>copy-namespaces mode</dt><dd><p><span style="display: none;" class="delete_version"><b>Copy-namespaces mode.</b> This component controls the namespace bindings that are assigned when an existing element node is copied by an element constructor, as described in <a href="#id-element-constructor"><span class="delete_version"><b>4.13.1 Direct Element Constructors</b></span><span class="modify_version"><b>4.13.1 Direct Element Constructors</b></span></a>. Its value consists of two parts: <code>preserve</code> or <code>no-preserve</code>, and <code>inherit</code> or <code>no-inherit</code>.</span><span style="display: none;" class="add_version"><b>Copy-namespaces mode.</b> This component controls the namespace bindings that are assigned when an existing element node is copied by an element constructor, as described in <a href="#id-element-constructor"><span class="add_version"><b>4.12.1 Direct Element Constructors</b></span><span class="modify_version"><b>4.12.1 Direct Element Constructors</b></span></a>. Its value consists of two parts: <code>preserve</code> or <code>no-preserve</code>, and <code>inherit</code> or <code>no-inherit</code>.</span><span class="modify_version"><b>Copy-namespaces mode.</b> This component controls the namespace bindings that are assigned when an existing element node is copied by an element constructor, as described in <a href="#id-element-constructor"><span style="display: none;" class="delete_version"><b>4.13.1 Direct Element Constructors</b></span><span style="display: none;" class="add_version"><b>4.12.1 Direct Element Constructors</b></span><span class="modify_version"><b><span class="deltaxml-old">4.13.1</span><span class="deltaxml-new">4.12.1</span> Direct Element Constructors</b></span></a>. Its value consists of two parts: <code>preserve</code> or <code>no-preserve</code>, and <code>inherit</code> or <code>no-inherit</code>.</span></p></dd><dt><a id="GLdt-date-time"></a>current dateTime</dt><dd><p><b>Current dateTime.</b> This information represents an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> point in time during the processing of <span class="xquery">a query</span> , and includes an explicit timezone. It can be retrieved by the <code>fn:current-dateTime</code> function. If called multiple times during the execution of <span class="xquery">a query</span> , this function always returns the same result.</p></dd><dt><a id="GLdt-datamodel"></a>data model</dt><dd><p><span style="display: none;" class="delete_version">XQuery 4.0 operates on the abstract, logical structure of an XML document or JSON object rather than its surface syntax. This logical structure, known as the <b>data model</b>, is defined in <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>.</span><span style="display: none;" class="add_version">XQuery 4.0 operates on the abstract, logical structure of an XML document or JSON object, rather than its surface syntax. This logical structure, known as the <b>data model</b>, is defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a>.</span><span class="modify_version">XQuery 4.0 operates on the abstract, logical structure of an XML document or JSON object<span class="deltaxml-new">,</span> rather than its surface syntax. This logical structure, known as the <b>data model</b>, is defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a>.</span></p></dd><dt><a id="GLdt-decimal-format-decl"></a>decimal-format declaration</dt><dd><p>A <b>decimal format declaration</b> adds a decimal format to the <a title="statically known decimal formats" class="termref" href="#dt-static-decimal-formats">statically known decimal formats</a>, which define the properties used to format numbers using the <code>fn:format-number()</code> function</p></dd><dt><a id="GLid-static-decimal-format-decimal-separator"></a>decimal-separator</dt><dd><p><b>decimal-separator</b> is the character used to separate the integer part of the number from the fractional part, both in the picture string and in the formatted number; the default value is the period character (.)</p></dd><dt><a id="GLdt-default-calendar"></a><a id="GLdt-default-uri-collection"></a>default <span class="deltaxml-old">calendar</span><span class="deltaxml-new">URI collection</span></dt><dd><p><b><span class="deltaxml-new">Default URI collection.</span></b><span class="deltaxml-new"> This is the sequence of URIs that would result from calling the </span><code><span class="deltaxml-new">fn:uri-collection</span></code><span class="deltaxml-new"> function with no arguments.</span></p></dd><dt><a id="GLdt-default-calendar"></a><span class="deltaxml-new">default calendar</span></dt><dd><p><b>Default calendar.</b> This is the calendar used when formatting dates in human-readable output (for example, by the functions <code>fn:format-date</code> and <code>fn:format-dateTime</code>) if no other calendar is requested. The value is a string.</p></dd><dt><a id="GLdt-def-collation"></a>default collation</dt><dd><p><b>Default collation.</b> This identifies one of the collations in <a title="statically known collations" class="termref" href="#dt-static-collations">statically known collations</a> as the collation to be used by functions and operators for comparing and ordering values of type <code>xs:string</code> and <code>xs:anyURI</code> (and types derived from them) when no explicit collation is specified.</p></dd><dt><a id="GLdt-default-collation-decl"></a>default collation declaration</dt><dd><p>A <b>default collation declaration</b> sets the value of the <a title="default collation" class="termref" href="#dt-def-collation">default collation</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default.</p></dd><dt><a id="GLdt-default-collection"></a>default collection</dt><dd><p><b>Default collection.</b> This is the sequence of items that would result from calling the <code>fn:collection</code> function with no arguments.</p></dd><dt><a id="GLdt-def-element-ns"></a><span class="deltaxml-new">default element namespace</span></dt><dd><p><b><span class="deltaxml-new">Default element namespace.</span></b><span class="deltaxml-new"> This is a namespace URI or </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent"><span class="deltaxml-new">absent</span></a><sup><small><span class="deltaxml-new">DM31</span></small></sup><span class="deltaxml-new">. The namespace URI, if present, is used for any unprefixed QName appearing in a position where an element name is expected.</span></p></dd><dt><a id="GLdt-def-elem-ns"></a><span class="deltaxml-new">default element namespace</span></dt><dd><p><span class="deltaxml-new">PLACEHOLDER</span></p></dd><dt><a id="GLdt-default-function-namespace"></a>default function namespace</dt><dd><p><span style="display: none;" class="delete_version"><b>Default function namespace.</b> This is either a namespace URI, or <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM40</small></sup>. The namespace URI, if present, is used for any unprefixed QName appearing in a position where a function name is expected.</span><span style="display: none;" class="add_version"><b>Default function namespace.</b> This is either a namespace URI, or <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small>DM31</small></sup>. The namespace URI, if present, is used for any unprefixed QName appearing in a position where a function name is expected.</span><span class="modify_version"><b>Default function namespace.</b> This is either a namespace URI, or <a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent">absent</a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>. The namespace URI, if present, is used for any unprefixed QName appearing in a position where a function name is expected.</span></p></dd><dt><a id="GLdt-default-language"></a>default language</dt><dd><p><b>Default language.</b> This is the natural language used when creating human-readable output (for example, by the functions <code>fn:format-date</code> and <code>fn:format-integer</code>) if no other language is requested. The value is a language code as defined by the type <code>xs:language</code>.</p></dd><dt><a id="GLdt-default-namespace-elements-and-types"></a><span class="deltaxml-old">default namespace for elements and types</span></dt><dd><p><b><span class="deltaxml-old">Default namespace for elements and types.</span></b><span class="deltaxml-old"> This is a namespace URI, or </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-old">absent</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">. This indicates how unprefixed QNames are interpreted when they appear in a position where an element name or type name is expected.</span></p></dd><dt><a id="GLdt-default-empty-order"></a>default order for empty sequences</dt><dd><p><span style="display: none;" class="delete_version"><b>Default order for empty sequences.</b> This component controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression, as described in <a href="#id-order-by-clause"><span class="delete_version"><b>4.15.9 Order By Clause</b></span><span class="modify_version"><b>4.15.9 Order By Clause</b></span></a>.</span><span style="display: none;" class="add_version"><b>Default order for empty sequences.</b> This component controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression, as described in <a href="#id-order-by-clause"><span class="add_version"><b>4.14.8 Order By Clause</b></span><span class="modify_version"><b>4.14.8 Order By Clause</b></span></a>.</span><span class="modify_version"><b>Default order for empty sequences.</b> This component controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression, as described in <a href="#id-order-by-clause"><span style="display: none;" class="delete_version"><b>4.15.9 Order By Clause</b></span><span style="display: none;" class="add_version"><b>4.14.8 Order By Clause</b></span><span class="modify_version"><b><span class="deltaxml-old">4.15.9</span><span class="deltaxml-new">4.14.8</span> Order By Clause</b></span></a>.</span></p></dd><dt><a id="GLdt-default-place"></a>default place</dt><dd><p><b>Default place.</b> This is a geographical location used to identify the place where events happened (or will happen) when formatting dates and times using functions such as <code>fn:format-date</code> and <code>fn:format-dateTime</code>, if no other place is specified. It is used when translating timezone offsets to civil timezone names, and when using calendars where the translation from ISO dates/times to a local representation is dependent on geographical location. Possible representations of this information are an ISO country code or an Olson timezone name, but implementations are free to use other representations from which the above information can be derived.</p></dd><dt><a id="GLdt-default-uri-collection"></a><span class="deltaxml-old">default URI collection</span></dt><dt><a id="GLdt-def-type-ns"></a><span class="deltaxml-new">default type namespace</span></dt><dd><p><b><span class="deltaxml-old">Default URI collection.</span></b><span class="deltaxml-old"> This is the sequence of URIs that would result from calling the </span><code><span class="deltaxml-old">fn:uri-collection</span></code><span class="deltaxml-old"> function with no arguments.</span></p><p><b><span class="deltaxml-new">Default type namespace.</span></b><span class="deltaxml-new"> This is a namespace URI or </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent"><span class="deltaxml-new">absent</span></a><sup><small><span class="deltaxml-new">DM31</span></small></sup><span class="deltaxml-new">. The namespace URI, if present, is used for any unprefixed QName appearing in a position where a type name is expected.</span></p></dd><dt><a id="GLdelimiting-token"></a>delimiting terminal symbol</dt><dd><p><span class="deltaxml-old">The </span><b><span class="deltaxml-old">delimiting terminal symbols</span></b><span class="deltaxml-old"> are: </span><code><span class="deltaxml-old">!</span></code><code><span class="deltaxml-old">!=</span></code><code><span class="deltaxml-old">#</span></code><code><span class="deltaxml-old">$</span></code><code><span class="deltaxml-old">%</span></code><code><span class="deltaxml-old">(</span></code><code><span class="deltaxml-old">)</span></code><code><span class="deltaxml-old">*</span></code><code><span class="deltaxml-old">*:</span></code><code><span class="deltaxml-old">,</span></code><code><span class="deltaxml-old">-</span></code><code><span class="deltaxml-old">.</span></code><code><span class="deltaxml-old">..</span></code><code><span class="deltaxml-old">:</span></code><code><span class="deltaxml-old">:*</span></code><code><span class="deltaxml-old">::</span></code><code><span class="deltaxml-old">:=</span></code><code><span class="deltaxml-old">;</span></code><code><span class="deltaxml-old">&lt;&lt;</span></code><code><span class="deltaxml-old">&lt;=</span></code><code><span class="deltaxml-old">=</span></code><code><span class="deltaxml-old">=!&gt;</span></code><code><span class="deltaxml-old">=&gt;</span></code><code><span class="deltaxml-old">=?&gt;</span></code><code><span class="deltaxml-old">&gt;</span></code><code><span class="deltaxml-old">&gt;=</span></code><code><span class="deltaxml-old">&gt;&gt;</span></code><code><span class="deltaxml-old">?</span></code><code><span class="deltaxml-old">??</span></code><code><span class="deltaxml-old">@</span></code><code><span class="deltaxml-old">[</span></code><code><span class="deltaxml-old">]</span></code><code><span class="deltaxml-old">`</span></code><code><span class="deltaxml-old">``</span></code><code><span class="deltaxml-old">{</span></code><code><span class="deltaxml-old">{{</span></code><code><span class="deltaxml-old">|</span></code><code><span class="deltaxml-old">||</span></code><code><span class="deltaxml-old">}</span></code><code><span class="deltaxml-old">}}</span></code><code><span class="deltaxml-old">×</span></code><code><span class="deltaxml-old">÷</span></code><a href="#prod-xquery40-AposStringLiteral"><span class="deltaxml-old">AposStringLiteral</span></a><a href="#prod-xquery40-BracedURILiteral"><span class="deltaxml-old">BracedURILiteral</span></a><code><span class="deltaxml-old">]]&gt;</span></code><code><span class="deltaxml-old">&lt;![CDATA[</span></code><code><span class="deltaxml-old">--&gt;</span></code><code><span class="deltaxml-old">&lt;!--</span></code><code><span class="deltaxml-old">/&gt;</span></code><code><span class="deltaxml-old">&lt;/</span></code><code><span class="deltaxml-old">&lt;</span></code><code><span class="deltaxml-old">+</span></code><code><span class="deltaxml-old">#)</span></code><code><span class="deltaxml-old">(#</span></code><code><span class="deltaxml-old">?&gt;</span></code><code><span class="deltaxml-old">&lt;?</span></code><a href="#prod-xquery40-QuotStringLiteral"><span class="deltaxml-old">QuotStringLiteral</span></a><a href="#prod-xquery40-S"><span class="deltaxml-old">S</span></a><code><span class="deltaxml-old">/</span></code><code><span class="deltaxml-old">//</span></code><code><span class="deltaxml-old">]``</span></code><code><span class="deltaxml-old">``[</span></code><code><span class="deltaxml-old">}`</span></code><code><span class="deltaxml-old">`{</span></code><a href="#prod-xquery40-StringLiteral"><span class="deltaxml-old">StringLiteral</span></a></p><p><span class="deltaxml-new">The </span><b><span class="deltaxml-new">delimiting terminal symbols</span></b><span class="deltaxml-new"> are: </span><a href="#prod-xquery40-S"><span class="deltaxml-new">S</span></a><span class="deltaxml-new">, "!", "!=", </span><a href="#prod-xquery40-StringLiteral"><span class="deltaxml-new">StringLiteral</span></a><span class="deltaxml-new">, "#", "#)", "$", "%", "(", "(#", ")", "*", "*:", "+", (comma), "-", "--&gt;", "-&gt;", (dot), "..", "/", "//", "/&gt;", (colon), ":*", "::", ":=", (semi-colon), "&lt;", "&lt;!--", "&lt;![CDATA[", "&lt;/", "&lt;&lt;", "&lt;=", "&lt;?", "=", "=&gt;", "&gt;", "&gt;=", "&gt;&gt;", "?", "?&gt;", "@", </span><a href="#prod-xquery40-BracedURILiteral"><span class="deltaxml-new">BracedURILiteral</span></a><span class="deltaxml-new">, "[", "]", "]]&gt;", "]``", "`", "``", "``[", "`{", "{", "{{", "|", "||", "}", "}`", "}}" </span></p></dd><dt><a id="GLdt-depends-on"></a>depends on</dt><dd><p><span style="display: none;" class="delete_version">A variable value (or the context value) <b>depends on</b> another variable value (or the context value) if, during the evaluation of the initializing expression of the former, the latter is accessed through the module context.</span><span style="display: none;" class="add_version">A variable value (or the context item) <b>depends on</b> another variable value (or the context item) if, during the evaluation of the initializing expression of the former, the latter is accessed through the module context.</span><span class="modify_version">A variable value (or the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>) <b>depends on</b> another variable value (or the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>) if, during the evaluation of the initializing expression of the former, the latter is accessed through the module context.</span></p></dd><dt><a id="GLid-static-decimal-format-digit"></a>digit</dt><dd><p><b>digit</b> is a character used in the picture string to represent an optional digit; the default value is the number sign character (#)</p></dd><dt><a id="GLdt-direct-elem-const"></a>direct element constructor</dt><dd><p>A <b>direct element constructor</b> is a form of element constructor in which the name of the constructed element is a constant.</p></dd><dt><a id="GLdt-document-order"></a>document order</dt><dd><p>Informally, <b>document order</b> is the order in which nodes appear in the XML serialization of a document.</p></dd><dt><a id="GLdt-dynamically-known-function-definitions"></a><span class="deltaxml-old">dynamically known function definitions</span></dt><dd><p><b><span class="deltaxml-old">Dynamically known function definitions</span></b><span class="deltaxml-old">. This is a set of </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-old">function definitions</span></a><span class="deltaxml-old">. It includes the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-old">statically known function definitions</span></a><span class="deltaxml-old"> as a subset, but may include other function definitions that are not known statically. </span></p></dd><dt><a id="GLdt-dynamic-context"></a>dynamic context</dt><dd><p>The <b>dynamic context</b> of an expression is defined as information that is needed for the dynamic evaluation of an expression.</p></dd><dt><a id="GLdt-dynamic-error"></a>dynamic error</dt><dd><p><span style="display: none;" class="delete_version">A <b>dynamic error</b> is an error that must be detected during the dynamic evaluation phase and may be detected during the static analysis phase.</span><span style="display: none;" class="add_version">A <b>dynamic error</b> is an error that must be detected during the dynamic evaluation phase and may be detected during the static analysis phase. Numeric overflow is an example of a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>.</span><span class="modify_version">A <b>dynamic error</b> is an error that must be detected during the dynamic evaluation phase and may be detected during the static analysis phase.<span class="deltaxml-new"> Numeric overflow is an example of a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new">dynamic error</span></a><span class="deltaxml-new">.</span></span></p></dd><dt><a id="GLdt-dynamic-evaluation"></a>dynamic evaluation phase</dt><dd><p>The <b>dynamic evaluation phase</b> is the phase during which the value of an expression is computed.</p></dd><dt><a id="GLdt-dynamic-function-invocation"></a><a id="GLdt-dynamic-function-call"></a>dynamic function call</dt><dd><p><span class="deltaxml-new">A </span><b><span class="deltaxml-new">dynamic function call</span></b><span class="deltaxml-new"> is an expression that is evaluated by calling a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new">function item</span></a><span class="deltaxml-new">, which is typically obtained dynamically.</span></p></dd><dt><a id="GLdt-dynamic-function-invocation"></a><span class="deltaxml-new">dynamic function call</span></dt><dd><p>A <b>dynamic function call</b> consists of a base expression that returns the function and a parenthesized list of zero or more arguments (<a title="argument expression" class="termref" href="#dt-arg-expr">argument expressions</a> or ArgumentPlaceholders).</p></dd><dt><a id="GLdt-dynamic-function-call"></a><a id="GLdt-dynamic-type"></a>dynamic <span class="deltaxml-old">function call</span><span class="deltaxml-new">type</span></dt><dd><p><span class="deltaxml-old">A </span><b><span class="deltaxml-old">dynamic function call</span></b><span class="deltaxml-old"> is an expression that is evaluated by calling a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-old">function item</span></a><span class="deltaxml-old">, which is typically obtained dynamically.</span></p></dd><dt><a id="GLdt-dynamic-type"></a><span class="deltaxml-old">dynamic type</span></dt><dd><p> Every value matches one or more <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a>. A value is said to have a <b>dynamic type</b><var>T</var> if it matches (or <b>is an instance of</b>) the sequence type <var>T</var>.</p></dd><dt><a id="GLdt-dynamically-known-function-definitions"></a><span class="deltaxml-new">dynamically known function definitions</span></dt><dd><p><b><span class="deltaxml-new">Dynamically known function definitions</span></b><span class="deltaxml-new">. This is a set of </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new">function definitions</span></a><span class="deltaxml-new">. It includes the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new">statically known function definitions</span></a><span class="deltaxml-new"> as a subset, but may include other function definitions that are not known statically. </span></p></dd><dt><a id="GLdt-ebv"></a>effective boolean value</dt><dd><p><span style="display: none;" class="delete_version">The <b>effective boolean value</b> of a value is defined as the result of applying the <code>fn:boolean</code> function to the value, as defined in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-boolean">Section 7.3.1 fn:boolean</a><sup><small>FO40</small></sup>.</span><span style="display: none;" class="add_version">The <b>effective boolean value</b> of a value is defined as the result of applying the <code>fn:boolean</code> function to the value, as defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-boolean">Section 7.3.1 fn:boolean </a><sup><small>FO31</small></sup>.</span><span class="modify_version">The <b>effective boolean value</b> of a value is defined as the result of applying the <code>fn:boolean</code> function to the value, as defined in <a href="https://www.w3.org/TR/xpath-functions-31/#func-boolean">Section 7.3.1 fn:boolean<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup>.</span></p></dd><dt><a id="GLid-effective-case-switch-expression"></a>effective case</dt><dd><p> The <b>effective case</b> of a switch expression is the first case clause that matches, using the rules given above, or the default clause if no such case clause exists.</p></dd><dt><a id="GLdt-effective-case"></a>effective case</dt><dd><p>The <b>effective case</b> in a <code>typeswitch</code> expression is the first <code>case</code> clause in which the value of the operand expression matches a <a href="#doc-xquery40-SequenceType">SequenceType</a> in the <a href="#doc-xquery40-SequenceType">SequenceTypeUnion</a> of the <code>case</code> clause, using the rules of <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType matching</a>. </p></dd><dt><a id="GLdt-empty-order-decl"></a>empty order declaration</dt><dd><p>An <b>empty order declaration</b> sets the <a title="default order for empty sequences" class="termref" href="#dt-default-empty-order">default order for empty sequences</a> in the <a title="static context" class="termref" href="#dt-static-context">static context,</a> overriding any implementation-defined default. This declaration controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression.</p></dd><dt><a id="GLdt-empty-sequence"></a>empty sequence</dt><dd><p>A sequence containing zero items is called an <b>empty sequence</b>.</p></dd><dt><a id="GLdt-enclosed-expression"></a>enclosed expression</dt><dd><p>An <b>enclosed expression</b> is an instance of the <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a> production, which allows an optional expression within curly braces.</p></dd><dt><a id="GLdt-encoding-declaration"></a>encoding declaration</dt><dd><p><span style="display: none;" class="delete_version">If present, a version declaration may optionally include an <b>encoding declaration</b>. The value of the string literal following the keyword <code>encoding</code> is an encoding name, and must conform to the definition of <code>EncName</code> specified in <a href="#XML">[XML 1.0]</a> [<a href="#ERRXQST0087" title="err:XQST0087">err:XQST0087</a>]. The purpose of an encoding declaration is to allow the writer of a query to provide a string that indicates how the query is encoded, such as <code>"UTF-8"</code>, <code>"UTF-16"</code>, or <code>"US-ASCII"</code>.</span><span style="display: none;" class="add_version">If present, a version declaration may optionally include an <b>encoding declaration</b>. The value of the string literal following the keyword <code>encoding</code> is an encoding name, and must conform to the definition of <code>EncName</code> specified in <a href="#XML">[XML 1.0]</a> [<a href="#ERRXQST0087" title="err:XQST0087">err:XQST0087</a>]. The purpose of an encoding declaration is to allow the writer of a query to provide a string that indicates how the query is encoded, such as "<code>UTF-8</code>", "<code>UTF-16</code>", or "<code>US-ASCII</code>".</span><span class="modify_version">If present, a version declaration may optionally include an <b>encoding declaration</b>. The value of the string literal following the keyword <code>encoding</code> is an encoding name, and must conform to the definition of <code>EncName</code> specified in <a href="#XML">[XML 1.0]</a> [<a href="#ERRXQST0087" title="err:XQST0087">err:XQST0087</a>]. The purpose of an encoding declaration is to allow the writer of a query to provide a string that indicates how the query is encoded, such as "<code>UTF-8<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>, "<code>UTF-16<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>, or "<code>US-ASCII<span class="deltaxml-old">"</span></code><span class="deltaxml-new">"</span>.</span></p></dd><dt><a id="GLdt-entry"></a>entry</dt><dd><p>Each key / value pair in a map is called an <b>entry</b>.</p></dd><dt><a id="GLdt-EnumerationType"></a><span class="deltaxml-old">EnumerationType</span></dt><dd><p><span class="deltaxml-old">An </span><b><span class="deltaxml-old">EnumerationType</span></b><span class="deltaxml-old"> accepts a fixed set of string values.</span></p></dd><dt><a id="GLdt-environment-variables"></a>environment variables</dt><dd><p><b>Environment variables.</b> This is a mapping from names to values. Both the names and the values are strings. The names are compared using an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> collation, and are unique under this collation. The set of environment variables is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> and <strong>may</strong> be empty.</p></dd><dt><a id="GLdt-equivalent-grouping-keys"></a>equivalent grouping keys</dt><dd><p>Two tuples <var>T<sub>1</sub></var> and <var>T<sub>2</sub></var> have <b>equivalent grouping keys</b> if and only if, for each grouping variable <var>GV</var>, the atomized value of <var>GV</var> in <var>T<sub>1</sub></var> is deep-equal to the atomized value of <var>GV</var> in <var>T<sub>2</sub></var>, as defined by applying the function <code>fn:deep-equal</code> using the appropriate collation.</p></dd><dt><a id="GLdt-error-value"></a>error value</dt><dd><p>In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called <b>error values</b>.</p></dd><dt><a id="GLdt-executable-base-uri"></a><span class="deltaxml-old">Executable Base URI</span></dt><dd><p><b><span class="deltaxml-old">Executable Base URI.</span></b><span class="deltaxml-old"> This is an absolute URI used to resolve relative URIs during the evaluation of expressions; it is used, for example, to resolve a relative URI supplied to the </span><code><span class="deltaxml-old">fn:doc</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">fn:unparsed-text</span></code><span class="deltaxml-old"> functions. </span></p></dd><dt><a id="GLdt-expanded-qname"></a>expanded QName</dt><dd><p>An <b>expanded QName</b> is a triple: its components are a prefix, a local name, and a namespace URI. In the case of a name in no namespace, the namespace URI and prefix are both absent. In the case of a name in the default namespace, the prefix is absent.</p></dd><dt><a id="GLid-static-decimal-format-exponent-separator"></a>exponent-separator</dt><dd><p><span style="display: none;" class="delete_version"><b>exponent-separator</b> is the character used to separate the mantissa from the exponent in scientific notation both in the picture string and in the formatted number; the default value is the Unicode Latin small letter e character (#x65).</span><span style="display: none;" class="add_version"><b>exponent-separator</b> is the character used to separate the mantissa from the exponent in scientific notation both in the picture string and in the formatted number; the default value is the character (e).</span><span class="modify_version"><b>exponent-separator</b> is the character used to separate the mantissa from the exponent in scientific notation both in the picture string and in the formatted number; the default value is the <span class="deltaxml-old">Unicode Latin small letter e character (#x65</span><span class="deltaxml-new">character (e</span>).</span></p></dd><dt><a id="GLdt-expression-context"></a>expression context</dt><dd><p>The <b>expression context</b> for a given expression consists of all the information that can affect the result of the expression.</p></dd><dt><a id="GLdt-extension-expression"></a>extension expression</dt><dd><p>An <b>extension expression</b> is an expression whose semantics are <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p></dd><dt><a id="GLdt-external-function"></a>external function</dt><dd><p><b><span class="deltaxml-old">External functions</span></b><span class="deltaxml-old"> can be characterized as functions that are neither part of the processor implementation, nor written in a language whose semantics are under the control of this family of specifications. The semantics of external functions, including any context dependencies, are entirely implementation-defined. In XSLT, external functions are called </span><a href="https://www.w3.org/TR/xslt-30/#extension-functions"><span class="deltaxml-old">Section 24.1 Extension Functions </span></a><sup><small><span class="deltaxml-old">XT30</span></small></sup><span class="deltaxml-old">. </span></p><p><b><span class="deltaxml-new">External functions</span></b><span class="deltaxml-new"> are functions that are implemented outside the query environment.</span></p></dd><dt><a id="GLdt-filter-expression"></a>filter expression</dt><dd><p><span style="display: none;" class="delete_version"> A <b>filter expression</b> is an expression in the form <code>E1[E2]</code>: its effect is to return those items from the value of <code>E1</code> that satisfy the predicate in E2.</span><span style="display: none;" class="add_version">An expression followed by a predicate (that is, <code>E1[E2]</code>) is referred to as a <b>filter expression</b>: its effect is to return those items from the value of <code>E1</code> that satisfy the predicate in E2.</span><span class="modify_version"><span class="deltaxml-old"> A</span><span class="deltaxml-new">An expression</span> <span class="deltaxml-old">filter expression</span><span class="deltaxml-new">followed by</span> <span class="deltaxml-old">is an expression in the form</span><span class="deltaxml-new">a predicate (that is,</span> <code>E1[E2]</code><span class="deltaxml-new">) is referred to as a </span><b><span class="deltaxml-new">filter expression</span></b>: its effect is to return those items from the value of <code>E1</code> that satisfy the predicate in E2.</span></p></dd><dt><a id="GLdt-fixed-focus"></a><span class="deltaxml-old">fixed </span><a id="GLdt-focus"></a>focus</dt><dd><p><span class="deltaxml-old">A </span><b><span class="deltaxml-old">fixed focus</span></b><span class="deltaxml-old"> is a focus for an expression that is evaluated once, rather than being applied to a series of values; in a fixed focus, the context value is set to one specific value, the context position is 1, and the context size is 1.</span></p></dd><dt><a id="GLdt-focus"></a><span class="deltaxml-old">focus</span></dt><dd><p><span style="display: none;" class="delete_version">The first three components of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> (context value, context position, and context size) are called the <b>focus</b> of the expression. </span><span style="display: none;" class="add_version">The first three components of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> (context item, context position, and context size) are called the <b>focus</b> of the expression. </span><span class="modify_version">The first three components of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> (context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>, context position, and context size) are called the <b>focus</b> of the expression. </span></p></dd><dt><a id="GLdt-focus-function"></a><span class="deltaxml-old">focus function</span></dt><dd><p><span class="deltaxml-old">A </span><b><span class="deltaxml-old">focus function</span></b><span class="deltaxml-old"> is an inline function expression in which the function signature is implicit: the function takes a single argument of type </span><code><span class="deltaxml-old">item()*</span></code><span class="deltaxml-old"> (that is, any value), and binds this to the context value when evaluating the function body, which returns a result of type </span><code><span class="deltaxml-old">item()*</span></code><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-function-assertion"></a><span class="deltaxml-old">function assertion</span></dt><dt><a id="GLdt-function-assertion"></a><span class="deltaxml-new">function assertion</span></dt><dd><p> A <b>function assertion</b> is a predicate that restricts the set of functions matched by a FunctionTest. It uses the same syntax as <a href="#id-annotations"><b>5.15 Annotations</b></a>.</p></dd><dt><a id="GLdt-function-coercion"></a>function coercion</dt><dd><p><b>Function coercion</b> wraps a <a title="function item" class="termref" href="#dt-function-item">function item</a> in a new function whose signature is the same as the expected type. This effectively delays the checking of the argument and return types until the function is called.</p></dd><dt><a id="GLdt-function-definition"></a>function definition</dt><dd><p>A <b>function definition</b> contains information used to evaluate a static function call, including the name, parameters, and return type of the function.</p></dd><dt><a id="GLdt-function-item"></a>function item</dt><dd><p>A <b>function item</b> is an item that can be called using a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a>.</p></dd><dt><a id="GLdt-generalized-atomic-type"></a>generalized atomic type</dt><dd><p>A <b>generalized atomic type</b> is a <span><a title="schema type" class="termref" href="#dt-schema-type">schema type</a></span> that is either (a) an atomic type or (b) a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a></p></dd><dt><a id="GLdt-gregorian"></a><span class="deltaxml-old">Gregorian</span></dt><dd><p><span class="deltaxml-old">In the operator mapping tables, the term </span><b><span class="deltaxml-old">Gregorian</span></b><span class="deltaxml-old"> refers to the types </span><code><span class="deltaxml-old">xs:gYearMonth</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">xs:gYear</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">xs:gMonthDay</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">xs:gDay</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">xs:gMonth</span></code><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-grouping-key"></a>grouping key</dt><dd><p>The atomized value of a <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a> is called a <b>grouping key</b>.</p></dd><dt><a id="GLid-static-decimal-format-grouping-separator"></a><a id="GLdt-grouping-variable"></a>grouping<span class="deltaxml-old">-separator</span><span class="deltaxml-new"> variable</span></dt><dd><p><b><span class="deltaxml-old">grouping-separator</span></b><span class="deltaxml-old"> is the character typically used as a thousands separator, both in the picture string and in the formatted number; the default value is the comma character (,)</span></p></dd><dt><a id="GLdt-grouping-variable"></a><span class="deltaxml-old">grouping variable</span></dt><dd><p>Each grouping specification specifies one <a href="#doc-xquery40-GroupingVariable">grouping variable</a>, which refers to variable bindings in the pre-grouping tuples. The values of the grouping variables are used to assign pre-grouping tuples to groups.</p></dd><dt><a id="GLid-static-decimal-format-grouping-separator"></a><span class="deltaxml-new">grouping-separator</span></dt><dd><p><b><span class="deltaxml-new">grouping-separator</span></b><span class="deltaxml-new"> is the character typically used as a thousands separator, both in the picture string and in the formatted number; the default value is the comma character (,)</span></p></dd><dt><a id="GLdt-guarded"></a>guarded</dt><dd><p>An expression <var>E</var> is said to be <b>guarded</b> by some governing condition <var>C</var> if evaluation of <var>E</var> is not allowed to fail with a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> except when <var>C</var> applies.</p></dd><dt><a id="GLIgnorableWhitespace"></a>ignorable whitespace</dt><dd><p><span style="display: none;" class="delete_version"><b>Ignorable whitespace</b> consists of any <a title="whitespace" class="termref" href="#Whitespace">whitespace</a> characters that may occur between <a title="terminal" class="termref" href="#terminal">terminals</a>, unless these characters occur in the context of a production marked with a <a href="#ExplicitWhitespaceHandling"> ws:explicit</a> annotation, in which case they can occur only where explicitly specified (see <a href="#ExplicitWhitespaceHandling"><span class="delete_version"><b>A.3.5.2 Explicit Whitespace Handling</b></span><span class="modify_version"><b>A.3.5.2 Explicit Whitespace Handling</b></span></a>).</span><span style="display: none;" class="add_version"><b>Ignorable whitespace</b> consists of any <a title="whitespace" class="termref" href="#Whitespace">whitespace</a> characters that may occur between <a title="terminal" class="termref" href="#terminal">terminals</a>, unless these characters occur in the context of a production marked with a <a href="#ExplicitWhitespaceHandling"> ws:explicit</a> annotation, in which case they can occur only where explicitly specified (see <a href="#ExplicitWhitespaceHandling"><span class="add_version"><b>A.2.4.2 Explicit Whitespace Handling</b></span><span class="modify_version"><b>A.2.4.2 Explicit Whitespace Handling</b></span></a>).</span><span class="modify_version"><b>Ignorable whitespace</b> consists of any <a title="whitespace" class="termref" href="#Whitespace">whitespace</a> characters that may occur between <a title="terminal" class="termref" href="#terminal">terminals</a>, unless these characters occur in the context of a production marked with a <a href="#ExplicitWhitespaceHandling"> ws:explicit</a> annotation, in which case they can occur only where explicitly specified (see <a href="#ExplicitWhitespaceHandling"><span style="display: none;" class="delete_version"><b>A.3.5.2 Explicit Whitespace Handling</b></span><span style="display: none;" class="add_version"><b>A.2.4.2 Explicit Whitespace Handling</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">3.5.2</span><span class="deltaxml-new">2.4.2</span> Explicit Whitespace Handling</b></span></a>).</span></p></dd><dt><a id="GLdt-implausible"></a><span class="deltaxml-old">implausible</span></dt><dd><p><span class="deltaxml-old">Certain expressions, while not erroneous, are classified as being </span><b><span class="deltaxml-old">implausible</span></b><span class="deltaxml-old">, because they achieve no useful effect.</span></p></dd><dt><a id="GLdt-implementation-defined"></a><a id="GLdt-implementation-dependent"></a>implementation <span class="deltaxml-old">defined</span><span class="deltaxml-new">dependent</span></dt><dd><p><span style="display: none;" class="delete_version"><b>Implementation-defined</b> indicates an aspect that may differ between implementations, but must be specified by the implementor for each particular implementation.</span><span style="display: none;" class="add_version"><b>Implementation-dependent</b> indicates an aspect that may differ between implementations, is not specified by this or any W3C specification, and is not required to be specified by the implementor for any particular implementation.</span><span class="modify_version"><b>Implementation-<span class="deltaxml-old">defined</span><span class="deltaxml-new">dependent</span></b> indicates an aspect that may differ between implementations, <span class="deltaxml-old">but must</span><span class="deltaxml-new">is not specified by this or any W3C specification, and is not required to</span> be specified by the implementor for <span class="deltaxml-old">each</span><span class="deltaxml-new">any</span> particular implementation.</span></p></dd><dt><a id="GLdt-implementation-dependent"></a><a id="GLdt-implementation-defined"></a>implementation <span class="deltaxml-old">dependent</span><span class="deltaxml-new">defined</span></dt><dd><p><span style="display: none;" class="delete_version"><b>Implementation-dependent</b> indicates an aspect that may differ between implementations, is not specified by this or any W3C specification, and is not required to be specified by the implementor for any particular implementation.</span><span style="display: none;" class="add_version"><b>Implementation-defined</b> indicates an aspect that may differ between implementations, but must be specified by the implementor for each particular implementation.</span><span class="modify_version"><b>Implementation-<span class="deltaxml-old">dependent</span><span class="deltaxml-new">defined</span></b> indicates an aspect that may differ between implementations, <span class="deltaxml-old">is not specified by this or any W3C specification, and is not required to</span><span class="deltaxml-new">but must</span> be specified by the implementor for <span class="deltaxml-old">any</span><span class="deltaxml-new">each</span> particular implementation.</span></p></dd><dt><a id="GLdt-timezone"></a>implicit timezone</dt><dd><p><b>Implicit timezone.</b> This is the timezone to be used when a date, time, or dateTime value that does not have a timezone is used in a comparison or arithmetic operation. The implicit timezone is an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> value of type <code>xs:dayTimeDuration</code>. See <a href="https://www.w3.org/TR/xmlschema-2/#dateTime-timezones">Section 3.2.7.3 Timezones </a><sup><small>XS1-2</small></sup> or <a href="https://www.w3.org/TR/xmlschema11-2/#dateTime">Section 3.3.7 dateTime </a><sup><small>XS11-2</small></sup> for the range of valid values of a timezone.</p></dd><dt><a id="GLid-static-decimal-format-infinity"></a><span class="deltaxml-old">infinity</span></dt><dd><p><b><span class="deltaxml-old">infinity</span></b><span class="deltaxml-old"> is the string used to represent the double value infinity (</span><code><span class="deltaxml-old">INF</span></code><span class="deltaxml-old">); the default value is the string </span><code><span class="deltaxml-old">"Infinity"</span></code></p></dd><dt><a id="GLdt-initial-context-value"></a><span class="deltaxml-old">initial context value</span></dt><dd><p><span class="deltaxml-old"> In the dynamic context of every module in a query, the context value component must have the same setting. If this shared setting is not </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-old">absent</span></a><sup><small><span class="deltaxml-old">DM40</span></small></sup><span class="deltaxml-old">, it is referred to as the </span><b><span class="deltaxml-old">initial context value</span></b><span class="deltaxml-old">. </span></p></dd><dt><a id="GLdt-initializing-expression"></a><span class="deltaxml-old">initializing expression</span></dt><dd><p><span class="deltaxml-old">If a variable declaration includes an expression (</span><code><span class="deltaxml-old">VarValue</span></code><span class="deltaxml-old"> or </span><code><span class="deltaxml-old">VarDefaultValue</span></code><span class="deltaxml-old">), the expression is called an </span><b><span class="deltaxml-old">initializing expression.</span></b><span class="deltaxml-old"> The static context for an initializing expression includes all functions, variables, and namespaces that are declared or imported anywhere in the Prolog, other than the variable being declared.</span></p></dd><dt><a id="GLdt-inline-func"></a><span class="deltaxml-old">inline function expression</span></dt><dd><p><span class="deltaxml-old">An </span><b><span class="deltaxml-old">inline function expression</span></b><span><span class="deltaxml-old">, when evaluated,</span></span><span class="deltaxml-old"> creates an </span><a title="anonymous function" class="termref" href="#dt-anonymous-function"><span class="deltaxml-old">anonymous function</span></a><span class="deltaxml-old"> defined directly in the inline function expression.</span></p></dd><dt><a id="GLdt-is-attrs"></a>in-scope attribute declarations</dt><dd><p><b>In-scope attribute declarations.</b> Each attribute declaration is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a top-level attribute declaration) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> attribute identifier (for a local attribute declaration). <span class="xquery">If the <a title="schema aware feature" class="termref" href="#dt-schema-aware-feature">Schema Aware Feature</a> is supported, in-scope attribute declarations include all attribute declarations found in imported schemas.</span></p></dd><dt><a id="GLdt-is-elems"></a>in-scope element declarations</dt><dd><p><b>In-scope element declarations.</b> Each element declaration is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a top-level element declaration) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> element identifier (for a local element declaration). <span class="xquery"> If the <a title="schema aware feature" class="termref" href="#dt-schema-aware-feature">Schema Aware Feature</a> is supported, in-scope element declarations include all element declarations found in imported schemas. </span></p></dd><dt><a id="GLdt-in-scope-named-item-types"></a><a id="GLdt-in-scope-namespaces"></a>in-scope <span class="deltaxml-old">named item types</span><span class="deltaxml-new">namespaces</span></dt><dd><p><b><span class="deltaxml-old">In-scope named item types.</span></b><span class="deltaxml-old"> This is a mapping from </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-old">expanded QName</span></a><span class="deltaxml-old"> to </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-old">named item types</span></a><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-in-scope-namespaces"></a><span class="deltaxml-old">in-scope namespaces</span></dt><dd><p>The <b>in-scope namespaces</b> property of an element node is a set of namespace bindings, each of which associates a namespace prefix with a URI.</p></dd><dt><a id="GLdt-issd"></a>in-scope schema definitions</dt><dd><p><span style="display: none;" class="delete_version"><b>In-scope schema definitions</b> is a generic term for all the element declarations, attribute declarations, and schema type definitions that are in scope during static analysis of an expression.</span><span style="display: none;" class="add_version"><b>In-scope schema definitions.</b> This is a generic term for all the element declarations, attribute declarations, and schema type definitions that are in scope during static analysis of an expression.</span><span class="modify_version"><b>In-scope schema definitions<span class="deltaxml-new">.</span></b> <span class="deltaxml-new">This </span>is a generic term for all the element declarations, attribute declarations, and schema type definitions that are in scope during static analysis of an expression.</span></p></dd><dt><a id="GLdt-is-types"></a>in-scope schema type</dt><dd><p><b>In-scope schema types.</b> Each schema type definition is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a <b>named type</b>) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> type identifier (for an <b>anonymous type</b>). The in-scope schema types include the predefined schema types described in <a href="#id-predefined-types"><b>3.1 Predefined Schema Types</b></a>. <span class="xquery">If the <a title="schema aware feature" class="termref" href="#dt-schema-aware-feature">Schema Aware Feature</a> is supported, in-scope schema types also include all type definitions found in imported schemas.</span></p></dd><dt><a id="GLdt-in-scope-variables"></a>in-scope variables</dt><dd><p><b>In-scope variables.</b> This is a mapping from <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> to type. It defines the set of variables that are available for reference within an expression. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is the name of the variable, and the type is the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the variable.</p></dd><dt><a id="GLid-static-decimal-format-infinity"></a><span class="deltaxml-new">infinity</span></dt><dd><p><b><span class="deltaxml-new">infinity</span></b><span class="deltaxml-new"> is the string used to represent the double value infinity (</span><code><span class="deltaxml-new">INF</span></code><span class="deltaxml-new">); the default value is the string "Infinity"</span></p></dd><dt><a id="GLdt-item"></a><a id="GLdt-initial-context-item"></a><span class="deltaxml-new">initial context </span>item</dt><dd><p><span class="deltaxml-new"> In the dynamic context of every module in a query, the context item component must have the same setting. If this shared setting is not </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent"><span class="deltaxml-new">absent</span></a><sup><small><span class="deltaxml-new">DM31</span></small></sup><span class="deltaxml-new">, it is referred to as the </span><b><span class="deltaxml-new">initial context item</span></b><span class="deltaxml-new">. </span></p></dd><dt><a id="GLdt-initializing-expression"></a><span class="deltaxml-new">initializing expression</span></dt><dd><p><span class="deltaxml-new">If a variable declaration includes an expression (</span><code><span class="deltaxml-new">VarValue</span></code><span class="deltaxml-new"> or </span><code><span class="deltaxml-new">VarDefaultValue</span></code><span class="deltaxml-new">), the expression is called an </span><b><span class="deltaxml-new">initializing expression.</span></b><span class="deltaxml-new"> The static context for an initializing expression includes all functions, variables, and namespaces that are declared or imported anywhere in the Prolog, other than the variable being declared.</span></p></dd><dt><a id="GLdt-inline-func"></a><span class="deltaxml-new">inline function expression</span></dt><dd><p><span class="deltaxml-new">An </span><b><span class="deltaxml-new">inline function expression</span></b><span><span class="deltaxml-new">, when evaluated,</span></span><span class="deltaxml-new"> creates an </span><a title="anonymous function" class="termref" href="#dt-anonymous-function"><span class="deltaxml-new">anonymous function</span></a><span class="deltaxml-new"> defined directly in the inline function expression.</span></p></dd><dt><a id="GLdt-item"></a><span class="deltaxml-new">item</span></dt><dd><p> An <b>item</b> is either an <a title="atomic value" class="termref" href="#dt-atomic-value">atomic value</a>, a <a title="node" class="termref" href="#dt-node">node</a>, or a <a title="function item" class="termref" href="#dt-function-item">function item</a>.</p></dd><dt><a id="GLdt-item-type"></a>item type</dt><dd><p>An <b>item type</b> is a type that can be expressed using the <a href="#doc-xquery40-ItemType">ItemType</a> syntax, which forms part of the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax. Item types match individual <a title="item" class="termref" href="#dt-item">items</a>.</p></dd><dt><a id="GLdt-item-type-designator"></a><a id="GLdt-item-type-aliases"></a>item type <span class="deltaxml-old">designator</span><span class="deltaxml-new">aliases</span></dt><dd><p><span class="deltaxml-old">An </span><b><span class="deltaxml-old">item type designator</span></b><span class="deltaxml-old"> is a syntactic construct conforming to the grammar rule </span><a href="#doc-xquery40-ItemType"><span class="deltaxml-old">ItemType</span></a><span class="deltaxml-old">. An item type designator is said to </span><b><span class="deltaxml-old">designate</span></b><span class="deltaxml-old"> an </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-old">item type</span></a><span class="deltaxml-old">.</span></p><p><b><span class="deltaxml-new">Item type aliases.</span></b><span class="deltaxml-new"> This is a mapping from </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new">expanded QName</span></a><span class="deltaxml-new"> to </span><code><span class="deltaxml-new">ItemTypes</span></code><span class="deltaxml-new">.</span></p></dd><dt><a id="GLdt-kind-test"></a>kind test</dt><dd><p>An alternative form of a node test called a <b>kind test</b> can select nodes based on their kind, name, and <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>.</p></dd><dt><a id="GLdt-qname"></a>lexical QName</dt><dd><p>A <b>lexical QName</b> is a name that conforms to the syntax of the <a href="#doc-xquery40-QName">QName</a> production</p></dd><dt><a id="GLdt-library-module"></a>library module</dt><dd><p>A module that does not contain a <a title="query body" class="termref" href="#dt-queryBody">Query Body</a> is called a <b>library module</b>. A library module consists of a <a title="module declaration" class="termref" href="#dt-module-declaration">module declaration</a> followed by a <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a>.</p></dd><dt><a id="GLdt-literal"></a>literal</dt><dd><p>A <b>literal</b> is a direct syntactic representation of an atomic value.</p></dd><dt><a id="GLdt-literal-terminal"></a><span class="deltaxml-old">literal terminal</span></dt><dd><p><span class="deltaxml-old">A </span><b><span class="deltaxml-old">literal terminal</span></b><span class="deltaxml-old"> is a token appearing as a string in quotation marks on the right-hand side of an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-old">ordinary production rule</span></a><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-main-module"></a>main module</dt><dd><p>A <b>main module</b> consists of a <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> followed by a <a title="query body" class="termref" href="#dt-queryBody">Query Body</a>.</p></dd><dt><a id="GLdt-map"></a>map</dt><dd><p>A <b>map</b> is a function that associates a set of keys with values, resulting in a collection of key / value pairs.</p></dd><dt><a id="GLdt-mapping-arrow-operator"></a><span class="deltaxml-old">mapping arrow operator</span></dt><dd><p><span class="deltaxml-old"> The </span><b><span class="deltaxml-old">mapping arrow operator</span></b><code><span class="deltaxml-old">=!&gt;</span></code><span class="deltaxml-old"> applies a function to each item in a sequence.</span></p></dd><dt><a id="GLmay"></a>may</dt><dd><p><b>MAY</b> means that an item is truly optional.</p></dd><dt><a id="GLdt-member"></a>member</dt><dd><p>The values of an array are called its <b>members</b>.</p></dd><dt><a id="GLid-static-decimal-format-minus-sign"></a>minus-sign</dt><dd><p><b>minus-sign</b> is the single character used to mark negative numbers; the default value is the hyphen-minus character (#x2D). </p></dd><dt><a id="GLdt-module"></a>module</dt><dd><p>A <b>module</b> is a fragment of XQuery code that conforms to the <a href="#doc-xquery40-Module">Module</a> grammar and can independently undergo the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a> described in <a href="#id-expression-processing"><b>2.3.3 Expression Processing</b></a>. Each module is either a <a title="main module" class="termref" href="#dt-main-module">main module</a> or a <a title="library module" class="termref" href="#dt-library-module">library module</a>.</p></dd><dt><a id="GLdt-module-context"></a>module context</dt><dd><p>The <b>module context</b> for a given module consists of all the information that is accessible to top-level expressions in the module.</p></dd><dt><a id="GLdt-module-declaration"></a>module declaration</dt><dd><p>A <b>module declaration</b> serves to identify a <a title="module" class="termref" href="#dt-module">module</a> as a <a title="library module" class="termref" href="#dt-library-module">library module</a>. A module declaration begins with the keyword <code>module</code> and contains a namespace prefix and a <a href="#doc-xquery40-URILiteral">URILiteral</a>.</p></dd><dt><a id="GLdt-module-feature"></a>module feature</dt><dd><p>The <b>Module Feature</b> allows a query Prolog to contain a <b>Module Import</b> and allows <b>library modules</b> to be created.</p></dd><dt><a id="GLdt-module-import"></a>module import</dt><dd><p><span style="display: none;" class="delete_version">A <b>module import</b> imports the public variable declarations, public function declarations<span>, and public item type declarations</span> from one or more <a title="library module" class="termref" href="#dt-library-module">library modules</a> into the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>, <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a><span>, or <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types">in-scope named item types</a></span> of the importing <a title="module" class="termref" href="#dt-module">module</a>.</span><span style="display: none;" class="add_version">A <b>module import</b> imports the public variable declarations, public function declarations<span>, and public item type declarations</span> from one or more <a title="library module" class="termref" href="#dt-library-module">library modules</a> into the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>, <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a><span>, or <a class="termref" title="item type aliases" href="#dt-item-type-aliases">item type aliases</a></span> of the importing <a title="module" class="termref" href="#dt-module">module</a>.</span><span class="modify_version">A <b>module import</b> imports the public variable declarations, public function declarations<span>, and public item type declarations</span> from one or more <a title="library module" class="termref" href="#dt-library-module">library modules</a> into the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>, <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a><span>, or <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types"><span class="deltaxml-old">in-scope named item types</span></a><a class="termref" title="item type aliases" href="#dt-item-type-aliases"><span class="deltaxml-new">item type aliases</span></a></span> of the importing <a title="module" class="termref" href="#dt-module">module</a>.</span></p></dd><dt><a id="GLmust"></a>must</dt><dd><p><b>MUST</b> means that the item is an absolute requirement of the specification.</p></dd><dt><a id="GLmustnot"></a>must not</dt><dd><p><b>MUST NOT</b> means that the item is an absolute prohibition of the specification.</p></dd><dt><a id="GLdt-name-expression"></a><span class="deltaxml-new">name expression</span></dt><dd><p><span class="deltaxml-new">When an expression is used to specify the name of a constructed node, that expression is called the </span><b><span class="deltaxml-new">name expression</span></b><span class="deltaxml-new"> of the constructor.</span></p></dd><dt><a id="GLdt-name-test"></a><span class="deltaxml-new">name test</span></dt><dd><p><span class="deltaxml-new">A node test that consists only of an EQName or a Wildcard is called a </span><b><span class="deltaxml-new">name test</span></b><span class="deltaxml-new">.</span></p></dd><dt><a id="GLdt-named-function-ref"></a>named function reference</dt><dd><p> A <b>named function reference</b> is an expression (written <code>name#arity</code>) which evaluates to a <a title="function item" class="termref" href="#dt-function-item">function item</a>, <span>the details of the function item being based on the properties of a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a></span>.</p></dd><dt><a id="GLdt-named-item-type"></a><span class="deltaxml-old">named item type</span></dt><dd><p><span class="deltaxml-old">A </span><b><span class="deltaxml-old">named item type</span></b><span class="deltaxml-old"> is an </span><code><span class="deltaxml-old">ItemType</span></code><span class="deltaxml-old"> identified by an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-old">expanded QName</span></a><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-name-expression"></a><span class="deltaxml-old">name expression</span></dt><dd><p><span class="deltaxml-old">When an expression is used to specify the name of a constructed node, that expression is called the </span><b><span class="deltaxml-old">name expression</span></b><span class="deltaxml-old"> of the constructor.</span></p></dd><dt><a id="GLdt-namespace-declaration"></a>namespace declaration</dt><dd><p>A <b>namespace declaration</b> declares a namespace prefix and associates it with a namespace URI, adding the (prefix, URI) pair to the set of <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>.</p></dd><dt><a id="GLdt-namespace-decl-attr"></a>namespace declaration attribute</dt><dd><p>A <b>namespace declaration attribute</b> is used inside a direct element constructor. Its purpose is to bind a namespace prefix <span>(including the zero-length prefix)</span> for the constructed element node, including its attributes.</p></dd><dt><a id="GLdt-namespace-sensitive"></a>namespace-sensitive</dt><dd><p>The <b>namespace-sensitive</b> types are <code>xs:QName</code>, <code>xs:NOTATION</code>, types derived by restriction from <code>xs:QName</code> or <code>xs:NOTATION</code>, list types that have a namespace-sensitive item type, and union types with a namespace-sensitive type in their transitive membership.</p></dd><dt><a id="GLdt-name-test"></a><span class="deltaxml-old">name test</span></dt><dd><p><span class="deltaxml-old">A node test that consists only of an EQName or a Wildcard is called a </span><b><span class="deltaxml-old">name test</span></b><span class="deltaxml-old">.</span></p></dd><dt><a id="GLid-static-decimal-format-NaN"></a><span class="deltaxml-old">NaN</span></dt><dd><p><b><span class="deltaxml-old">NaN</span></b><span class="deltaxml-old"> is the string used to represent the double value </span><code><span class="deltaxml-old">NaN</span></code><span class="deltaxml-old"> (not a number); the default value is the string </span><code><span class="deltaxml-old">"NaN"</span></code></p></dd><dt><a id="GLdt-node"></a>node</dt><dd><p><span style="display: none;" class="delete_version">A <b>node</b> is an instance of one of the <b>node kinds</b> defined in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#Node">Section 5 Nodes</a><sup><small>DM40</small></sup>.</span><span style="display: none;" class="add_version">A <b>node</b> is an instance of one of the <b>node kinds</b> defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#Node">Section 6 Nodes </a><sup><small>DM31</small></sup>.</span><span class="modify_version">A <b>node</b> is an instance of one of the <b>node kinds</b> defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#Node">Section <span class="deltaxml-old">5</span><span class="deltaxml-new">6</span> Nodes<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>.</span></p></dd><dt><a id="GLdt-node-test"></a>node test</dt><dd><p>A <b>node test</b> is a condition on the name, kind (element, attribute, text, document, comment, or processing instruction), and/or <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of a node. A node test determines which nodes contained by an axis are selected by a <a title="step" class="termref" href="#dt-step">step</a>.</p></dd><dt><a id="GLnon-delimiting-token"></a>non-delimiting terminal symbol</dt><dd><p><span style="display: none;" class="delete_version">The <b>non-delimiting terminal symbols</b> are: <code>allowing</code><code>ancestor</code><code>ancestor-or-self</code><code>and</code><code>array</code><code>as</code><code>at</code><code>attribute</code><code>base-uri</code><code>boundary-space</code><code>by</code><code>case</code><code>cast</code><code>castable</code><code>catch</code><code>child</code><code>collation</code><code>comment</code><code>construction</code><code>context</code><code>copy-namespaces</code><code>count</code><code>decimal-format</code><code>decimal-separator</code><code>declare</code><code>default</code><code>descendant</code><code>descendant-or-self</code><code>digit</code><code>div</code><code>document</code><code>document-node</code><code>element</code><code>else</code><code>empty</code><code>empty-sequence</code><code>encoding</code><code>end</code><code>enum</code><code>eq</code><code>every</code><code>except</code><code>exponent-separator</code><code>false</code><code>fixed</code><code>fn</code><code>following</code><code>following-sibling</code><code>for</code><code>function</code><code>ge</code><code>group</code><code>grouping-separator</code><code>gt</code><code>idiv</code><code>if</code><code>import</code><code>in</code><code>infinity</code><code>inherit</code><code>instance</code><code>intersect</code><code>is</code><code>item</code><code>item-type</code><code>lax</code><code>le</code><code>let</code><code>lt</code><code>map</code><code>member</code><code>minus-sign</code><code>mod</code><code>module</code><code>namespace</code><code>namespace-node</code><code>NaN</code><code>ne</code><code>next</code><code>no-inherit</code><code>no-preserve</code><code>node</code><code>of</code><code>only</code><code>option</code><code>or</code><code>order</code><code>ordered</code><code>ordering</code><code>otherwise</code><code>parent</code><code>pattern-separator</code><code>per-mille</code><code>percent</code><code>preceding</code><code>preceding-sibling</code><code>preserve</code><code>previous</code><code>processing-instruction</code><code>record</code><code>return</code><code>satisfies</code><code>schema</code><code>schema-attribute</code><code>schema-element</code><code>self</code><code>sliding</code><code>some</code><code>stable</code><code>start</code><code>strict</code><code>strip</code><code>switch</code><code>text</code><code>then</code><code>to</code><code>treat</code><code>true</code><code>try</code><code>tumbling</code><code>type</code><code>typeswitch</code><code>union</code><code>unordered</code><code>validate</code><code>value</code><code>variable</code><code>version</code><code>when</code><code>where</code><code>while</code><code>window</code><code>with</code><code>xquery</code><code>zero-digit</code><code>ascending</code><a href="#prod-xquery40-BinaryIntegerLiteral">BinaryIntegerLiteral</a><a href="#prod-xquery40-DecimalLiteral">DecimalLiteral</a><code>descending</code><a href="#prod-xquery40-DoubleLiteral">DoubleLiteral</a><code>external</code><code>greatest</code><a href="#prod-xquery40-HexIntegerLiteral">HexIntegerLiteral</a><a href="#prod-xquery40-IntegerLiteral">IntegerLiteral</a><code>least</code><a href="#prod-xquery40-NCName">NCName</a><a href="#prod-xquery40-QName">QName</a><a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></span><span style="display: none;" class="add_version">The <b>non-delimiting terminal symbols</b> are: <a href="#prod-xquery40-IntegerLiteral">IntegerLiteral</a>, <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a>, <a href="#prod-xquery40-NCName">NCName</a>, <a href="#prod-xquery40-DecimalLiteral">DecimalLiteral</a>, <a href="#prod-xquery40-DoubleLiteral">DoubleLiteral</a>, <a href="#prod-xquery40-BinaryIntegerLiteral">BinaryIntegerLiteral</a>, <a href="#prod-xquery40-HexIntegerLiteral">HexIntegerLiteral</a>, <a href="#prod-xquery40-QName">QName</a>, "NaN", "allowing", "ancestor", "ancestor-or-self", "and", "array", "as", "ascending", "at", "attribute", "base-uri", "boundary-space", "by", "case", "cast", "castable", "catch", "child", "collation", "comment", "construction", "context", "copy-namespaces", "count", "decimal-format", "decimal-separator", "declare", "default", "descendant", "descendant-or-self", "descending", "digit", "div", "document", "document-node", "element", "else", "empty", "empty-sequence", "encoding", "end", "enum", "eq", "every", "except", "exponent-separator", "external", "following", "following-sibling", "for", "function", "ge", "greatest", "group", "grouping-separator", "gt", "idiv", "if", "import", "in", "infinity", "inherit", "instance", "intersect", "is", "item", "item-type", "lax", "le", "least", "let", "lt", "map", "member", "minus-sign", "mod", "module", "namespace", "namespace-node", "ne", "next", "no-inherit", "no-preserve", "node", "of", "only", "option", "or", "order", "ordered", "ordering", "otherwise", "parent", "pattern-separator", "per-mille", "percent", "preceding", "preceding-sibling", "preserve", "previous", "processing-instruction", "record", "return", "satisfies", "schema", "schema-attribute", "schema-element", "self", "sliding", "some", "stable", "start", "strict", "strip", "switch", "text", "then", "to", "treat", "try", "tumbling", "type", "typeswitch", "union", "unordered", "validate", "variable", "version", "when", "where", "window", "with", "xquery", "zero-digit" </span><span class="modify_version">The <b>non-delimiting terminal symbols</b> are: <a href="#prod-xquery40-IntegerLiteral"><span class="deltaxml-new">IntegerLiteral</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-URIQualifiedName"><span class="deltaxml-new">URIQualifiedName</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-NCName"><span class="deltaxml-new">NCName</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-DecimalLiteral"><span class="deltaxml-new">DecimalLiteral</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-DoubleLiteral"><span class="deltaxml-new">DoubleLiteral</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-BinaryIntegerLiteral"><span class="deltaxml-new">BinaryIntegerLiteral</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-HexIntegerLiteral"><span class="deltaxml-new">HexIntegerLiteral</span></a><span class="deltaxml-new">, </span><a href="#prod-xquery40-QName"><span class="deltaxml-new">QName</span></a><span class="deltaxml-new">, "NaN", "</span>allowing<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>ancestor<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>ancestor-or-self<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>and<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>array<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>as<span class="deltaxml-new">"</span><span class="deltaxml-new">, "ascending", "</span>at<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>attribute<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>base-uri<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>boundary-space<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>by<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>case<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>cast<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>castable<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>catch<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>child<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>collation<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>comment<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>construction<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>context<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>copy-namespaces<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>count<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>decimal-format<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>decimal-separator<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>declare<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>default<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>descendant<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>descendant-or-self<span class="deltaxml-new">"</span><span class="deltaxml-new">, "descending", "</span>digit<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>div<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>document<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>document-node<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>element<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>else<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>empty<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>empty-sequence<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>encoding<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>end<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>enum<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>eq<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>every<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>except<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>exponent-separator<span class="deltaxml-new">"</span><span class="deltaxml-old">false</span><span class="deltaxml-new">, "external</span><span class="deltaxml-new">"</span><span class="deltaxml-old">fixed</span><span class="deltaxml-new">, </span><span class="deltaxml-old">fn</span><span class="deltaxml-new">"</span>following<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>following-sibling<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>for<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>function<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>ge<span class="deltaxml-new">"</span><span class="deltaxml-new">, "greatest", "</span>group<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>grouping-separator<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>gt<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>idiv<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>if<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>import<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>in<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>infinity<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>inherit<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>instance<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>intersect<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>is<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>item<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>item-type<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>lax<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>le<span class="deltaxml-new">"</span><span class="deltaxml-new">, "least", "</span>let<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>lt<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>map<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>member<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>minus-sign<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>mod<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>module<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>namespace<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>namespace-node<span class="deltaxml-new">"</span><span class="deltaxml-old">NaN</span><span class="deltaxml-new">, </span><span class="deltaxml-new">"</span>ne<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>next<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>no-inherit<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>no-preserve<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>node<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>of<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>only<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>option<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>or<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>order<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>ordered<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>ordering<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>otherwise<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>parent<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>pattern-separator<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>per-mille<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>percent<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>preceding<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>preceding-sibling<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>preserve<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>previous<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>processing-instruction<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>record<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>return<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>satisfies<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>schema<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>schema-attribute<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>schema-element<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>self<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>sliding<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>some<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>stable<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>start<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>strict<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>strip<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>switch<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>text<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>then<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>to<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>treat<span class="deltaxml-new">"</span><span class="deltaxml-old">true</span><span class="deltaxml-new">, </span><span class="deltaxml-new">"</span>try<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>tumbling<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>type<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>typeswitch<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>union<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>unordered<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>validate<span class="deltaxml-new">"</span><span class="deltaxml-old">value</span><span class="deltaxml-new">, </span><span class="deltaxml-new">"</span>variable<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>version<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>when<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>where<span class="deltaxml-new">"</span><span class="deltaxml-old">while</span><span class="deltaxml-new">, </span><span class="deltaxml-new">"</span>window<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>with<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>xquery<span class="deltaxml-new">"</span><span class="deltaxml-new">, "</span>zero-digit<span class="deltaxml-new">"</span><span class="deltaxml-old">ascending</span><span class="deltaxml-new"> </span><a href="#prod-xquery40-BinaryIntegerLiteral"><span class="deltaxml-old">BinaryIntegerLiteral</span></a><a href="#prod-xquery40-DecimalLiteral"><span class="deltaxml-old">DecimalLiteral</span></a><span class="deltaxml-old">descending</span><a href="#prod-xquery40-DoubleLiteral"><span class="deltaxml-old">DoubleLiteral</span></a><span class="deltaxml-old">external</span><span class="deltaxml-old">greatest</span><a href="#prod-xquery40-HexIntegerLiteral"><span class="deltaxml-old">HexIntegerLiteral</span></a><a href="#prod-xquery40-IntegerLiteral"><span class="deltaxml-old">IntegerLiteral</span></a><span class="deltaxml-old">least</span><a href="#prod-xquery40-NCName"><span class="deltaxml-old">NCName</span></a><a href="#prod-xquery40-QName"><span class="deltaxml-old">QName</span></a><a href="#prod-xquery40-URIQualifiedName"><span class="deltaxml-old">URIQualifiedName</span></a></span></p></dd><dt><a id="GLdt-numeric"></a>numeric</dt><dd><p>When referring to a type, the term <b>numeric</b> denotes the types <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>, and <code>xs:double</code> which are all member types of the built-in union type <code>xs:numeric</code>.</p></dd><dt><a id="GLdt-numeric-predicate"></a>numeric predicate</dt><dd><p><span style="display: none;" class="delete_version">A predicate whose predicate expression returns a value of type <code>xs:numeric+</code> is called a <b>numeric predicate</b>.</span><span style="display: none;" class="add_version">A predicate whose predicate expression returns a numeric type is called a <b>numeric predicate</b>.</span><span class="modify_version">A predicate whose predicate expression returns a <span class="deltaxml-old">value of</span><span class="deltaxml-new">numeric</span> type <span class="deltaxml-old">xs:numeric+</span><span class="deltaxml-old"> </span>is called a <b>numeric predicate</b>.</span></p></dd><dt><a id="GLdt-operator-function"></a>operator function</dt><dd><p><span style="display: none;" class="delete_version">For each operator and valid combination of operand types, the operator mapping tables specify a result type and an expression that invokes an <b>operator function</b>; the operator function implements the semantics of the operator for the given types.</span><span style="display: none;" class="add_version">For each operator and valid combination of operand types, the operator mapping tables specify a result type and an <b>operator function</b> that implements the semantics of the operator for the given types.</span><span class="modify_version">For each operator and valid combination of operand types, the operator mapping tables specify a result type and an <span class="deltaxml-old">expression that invokes an </span><b>operator function</b><span class="deltaxml-old">; the operator function</span><span class="deltaxml-new"> that</span> implements the semantics of the operator for the given types.</span></p></dd><dt><a id="GLdt-option-declaration"></a>option declaration</dt><dd><p>An <b>option declaration</b> declares an option that affects the behavior of a particular implementation. Each option consists of an identifying EQName and a StringLiteral.</p></dd><dt><a id="GLdt-ordering-mode"></a>ordering mode</dt><dd><p><span style="display: none;" class="delete_version"><b>Ordering mode.</b> Ordering mode, which has the value <code>ordered</code> or <code>unordered</code>, affects the ordering of the result sequence returned by certain expressions, as discussed in <a href="#id-unordered-expressions"><span class="delete_version"><b>4.16 Ordered and Unordered Expressions</b></span><span class="modify_version"><b>4.16 Ordered and Unordered Expressions</b></span></a>.</span><span style="display: none;" class="add_version"><b>Ordering mode.</b> Ordering mode, which has the value <code>ordered</code> or <code>unordered</code>, affects the ordering of the result sequence returned by certain expressions, as discussed in <a href="#id-unordered-expressions"><span class="add_version"><b>4.15 Ordered and Unordered Expressions</b></span><span class="modify_version"><b>4.15 Ordered and Unordered Expressions</b></span></a>.</span><span class="modify_version"><b>Ordering mode.</b> Ordering mode, which has the value <code>ordered</code> or <code>unordered</code>, affects the ordering of the result sequence returned by certain expressions, as discussed in <a href="#id-unordered-expressions"><span style="display: none;" class="delete_version"><b>4.16 Ordered and Unordered Expressions</b></span><span style="display: none;" class="add_version"><b>4.15 Ordered and Unordered Expressions</b></span><span class="modify_version"><b><span class="deltaxml-old">4.16</span><span class="deltaxml-new">4.15</span> Ordered and Unordered Expressions</b></span></a>.</span></p></dd><dt><a id="GLdt-ordering-mode-decl"></a>ordering mode declaration</dt><dd><p>An <b>ordering mode declaration</b> sets the <a title="ordering mode" class="termref" href="#dt-ordering-mode">ordering mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default.</p></dd><dt><a id="GLdt-ordinary-production-rule"></a><span class="deltaxml-old">ordinary production rule</span></dt><dd><p><span class="deltaxml-old">An </span><b><span class="deltaxml-old">ordinary production rule</span></b><span class="deltaxml-old"> is a production rule in </span><a href="#id-grammar"><b><span class="deltaxml-old">A.1 EBNF</span></b></a><span class="deltaxml-old"> that is not annotated </span><code><span class="deltaxml-old">ws:explicit</span></code><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-output-declaration"></a>output declaration</dt><dd><p><span style="display: none;" class="delete_version">An <b>output declaration</b> is an option declaration in the namespace <code>http://www.w3.org/2010/xslt-xquery-serialization</code>; it is used to declare serialization parameters.</span><span style="display: none;" class="add_version">An <b>output declaration</b> is an option declaration in the namespace "http://www.w3.org/2010/xslt-xquery-serialization"; it is used to declare serialization parameters.</span><span class="modify_version">An <b>output declaration</b> is an option declaration in the namespace <span class="deltaxml-new">"</span>http://www.w3.org/2010/xslt-xquery-serialization<span class="deltaxml-new">"</span>; it is used to declare serialization parameters.</span></p></dd><dt><a id="GLdt-partial-function-application"></a>partial function application</dt><dd><p> A static or <a title="dynamic function call" class="termref" href="#dt-dynamic-function-invocation">dynamic</a> function call is a <b>partial function application</b> if one or more arguments is an <a href="#doc-xquery40-ArgumentPlaceholder">ArgumentPlaceholder</a>.</p></dd><dt><a id="GLdt-partially-applied-function"></a>partially applied function</dt><dd><p>A <b>partially applied function</b> is a function created by <a title="partial function application" class="termref" href="#dt-partial-function-application">partial function application</a>.</p></dd><dt><a id="GLdt-path-expression"></a>path expression</dt><dd><p><span style="display: none;" class="delete_version">A path expression consists of a series of one or more <a title="step" class="termref" href="#dt-step">steps</a>, separated by <code>/</code> or <code>//</code>, and optionally beginning with <code>/</code> or <code>//</code>. A <b>path expression</b> is typically used to locate nodes within trees. </span><span style="display: none;" class="add_version">A <b>path expression</b> can be used to locate nodes within trees. A path expression consists of a series of one or more <a title="step" class="termref" href="#dt-step">steps</a>, separated by "<code>/</code>" or "<code>//</code>", and optionally beginning with "<code>/</code>" or "<code>//</code>".</span><span class="modify_version">A <b>path expression</b> <span class="deltaxml-new">can be used to locate nodes within trees. A path expression </span>consists of a series of one or more <a title="step" class="termref" href="#dt-step">steps</a>, separated by <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> or <span class="deltaxml-new">"</span><code>//</code><span class="deltaxml-new">"</span>, and optionally beginning with <span class="deltaxml-new">"</span><code>/</code><span class="deltaxml-new">"</span> or <span class="deltaxml-new">"</span><code>//</code><span class="deltaxml-new">"</span>.<span class="deltaxml-old"> A </span><span class="deltaxml-old">path expression</span><span class="deltaxml-old"> is typically used to locate nodes within trees. </span></span></p></dd><dt><a id="GLid-static-decimal-format-pattern-separator"></a>pattern-separator</dt><dd><p><span style="display: none;" class="delete_version"><b>pattern-separator</b> is a character used to separate positive and negative sub-pictures in a picture string; the default value is the semicolon character (;)</span><span style="display: none;" class="add_version"><b>pattern-separator</b> is a character used to separate positive and negative sub-pictures in a picture string; the default value is the semi-colon character (;)</span><span class="modify_version"><b>pattern-separator</b> is a character used to separate positive and negative sub-pictures in a picture string; the default value is the <span class="deltaxml-old">semicolon</span><span class="deltaxml-new">semi-colon</span> character (;)</span></p></dd><dt><a id="GLid-static-decimal-format-percent"></a><span class="deltaxml-old">percent</span></dt><dt><a id="GLid-static-decimal-format-per-mille"></a><span class="deltaxml-new">per-mille</span></dt><dd><p><span style="display: none;" class="delete_version"><b>percent</b> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-hundred fraction; the default value is the percent character (%)</span><span style="display: none;" class="add_version"><b>per-mille</b> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-thousand fraction; the default value is the Unicode per-mille character (#x2030)</span><span class="modify_version"><b><span class="deltaxml-old">percent</span><span class="deltaxml-new">per-mille</span></b> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-<span class="deltaxml-old">hundred</span><span class="deltaxml-new">thousand</span> fraction; the default value is the <span class="deltaxml-old">percent character (%</span><span class="deltaxml-new">Unicode per-mille character (#x2030</span>)</span></p></dd><dt><a id="GLid-static-decimal-format-per-mille"></a><span class="deltaxml-old">per-mille</span></dt><dt><a id="GLid-static-decimal-format-percent"></a><span class="deltaxml-new">percent</span></dt><dd><p><span style="display: none;" class="delete_version"><b>per-mille</b> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-thousand fraction; the default value is the Unicode per mille sign character (#x2030)</span><span style="display: none;" class="add_version"><b>percent</b> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-hundred fraction; the default value is the percent character (%)</span><span class="modify_version"><b><span class="deltaxml-old">per-mille</span><span class="deltaxml-new">percent</span></b> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-<span class="deltaxml-old">thousand</span><span class="deltaxml-new">hundred</span> fraction; the default value is the <span class="deltaxml-old">Unicode per mille sign character (#x2030</span><span class="deltaxml-new">percent character (%</span>)</span></p></dd><dt><a id="GLdt-positional-variable"></a>positional variable</dt><dd><p>A <b>positional variable</b> is a variable that is preceded by the keyword <code>at</code>.</p></dd><dt><a id="GLdt-pragma"></a>pragma</dt><dd><p>A <b>pragma</b> is denoted by the delimiters <code>(#</code> and <code>#)</code>, and consists of an identifying EQName followed by <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> content.</p></dd><dt><a id="GLdt-predefined-entity-reference"></a>predefined entity reference</dt><dd><p>A <b>predefined entity reference</b> is a short sequence of characters, beginning with an ampersand, that represents a single character that might otherwise have syntactic significance.</p></dd><dt><a id="GLdt-primary-expression"></a>primary expression</dt><dd><p><span style="display: none;" class="delete_version"><b>Primary expressions</b> are the basic primitives of the language. They include literals, variable references, context value references, <span class="xquery">constructors, </span> and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.</span><span style="display: none;" class="add_version"><b>Primary expressions</b> are the basic primitives of the language. They include literals, variable references, context item expressions, <span class="xquery">constructors, </span> and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.</span><span class="modify_version"><b>Primary expressions</b> are the basic primitives of the language. They include literals, variable references, context <span class="deltaxml-old">value references</span><span class="deltaxml-new">item expressions</span>, <span class="xquery">constructors, </span> and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.</span></p></dd><dt><a id="GLdt-principal-node-kind"></a>principal node kind</dt><dd><p>Every axis has a <b>principal node kind</b>. If an axis can contain elements, then the principal node kind is element; otherwise, it is the kind of nodes that the axis can contain.</p></dd><dt><a id="GLdt-private-function"></a><a id="GLdt-private-variable"></a>private <span class="deltaxml-old">function</span><span class="deltaxml-new">variable</span></dt><dd><p><span style="display: none;" class="delete_version">A <b>private function</b> is a function with a <code>%private</code> annotation. A private function is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a class="termref" title="statically known function definitions" href="#dt-statically-known-function-definitions">statically known function definitions</a> of another module. </span><span style="display: none;" class="add_version">A <b>private variable</b> is a variable with a <code>%private</code> annotation. A private variable is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a class="termref" title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> of another module.</span><span class="modify_version">A <b>private <span class="deltaxml-old">function</span><span class="deltaxml-new">variable</span></b> is a <span class="deltaxml-old">function</span><span class="deltaxml-new">variable</span> with a <code>%private</code> annotation. A private <span class="deltaxml-old">function</span><span class="deltaxml-new">variable</span> is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a class="termref" title="statically known function definitions" href="#dt-statically-known-function-definitions"><span class="deltaxml-old">statically known function definitions</span></a><a class="termref" title="in-scope variables" href="#dt-in-scope-variables"><span class="deltaxml-new">in-scope variables</span></a> of another module.<span class="deltaxml-old"> </span></span></p></dd><dt><a id="GLdt-private-item-type"></a><a id="GLdt-private-function"></a>private <span class="deltaxml-old">item type</span><span class="deltaxml-new">function</span></dt><dd><p><span style="display: none;" class="delete_version">A <b>private item type</b> is a named item type with a <code>%private</code> annotation. A private item type is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types">in-scope named item types</a> of another module. </span><span style="display: none;" class="add_version">A <b>private function</b> is a function with a <code>%private</code> annotation. A private function is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a class="termref" title="statically known function definitions" href="#dt-statically-known-function-definitions">statically known function definitions</a> of another module. </span><span class="modify_version">A <b>private <span class="deltaxml-old">item</span><span class="deltaxml-new">function</span></b> <span class="deltaxml-old">type</span><span class="deltaxml-old"> </span>is a <span class="deltaxml-old">named item type</span><span class="deltaxml-new">function</span> with a <code>%private</code> annotation. A private <span class="deltaxml-old">item type</span><span class="deltaxml-new">function</span> is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types"><span class="deltaxml-old">in-scope named item types</span></a><a class="termref" title="statically known function definitions" href="#dt-statically-known-function-definitions"><span class="deltaxml-new">statically known function definitions</span></a> of another module. </span></p></dd><dt><a id="GLdt-private-variable"></a><a id="GLdt-private-item-type"></a>private <span class="deltaxml-old">variable</span><span class="deltaxml-new">item type</span></dt><dd><p><span style="display: none;" class="delete_version">A <b>private variable</b> is a variable with a <code>%private</code> annotation. A private variable is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a class="termref" title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> of another module.</span><span style="display: none;" class="add_version">A <b>private item type</b> is a named item type with a <code>%private</code> annotation. A private item type is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a class="termref" title="item type aliases" href="#dt-item-type-aliases">item type aliases</a> of another module. </span><span class="modify_version">A <b>private <span class="deltaxml-old">variable</span><span class="deltaxml-new">item</span> <span class="deltaxml-new">type</span></b><span class="deltaxml-new"> </span>is a <span class="deltaxml-old">variable</span><span class="deltaxml-new">named item type</span> with a <code>%private</code> annotation. A private <span class="deltaxml-old">variable</span><span class="deltaxml-new">item type</span> is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a class="termref" title="in-scope variables" href="#dt-in-scope-variables"><span class="deltaxml-old">in-scope variables</span></a><a class="termref" title="item type aliases" href="#dt-item-type-aliases"><span class="deltaxml-new">item type aliases</span></a> of another module.<span class="deltaxml-new"> </span></span></p></dd><dt><a id="GLdt-prolog"></a><span class="deltaxml-old">Prolog</span></dt><dd><p><span class="deltaxml-old">A </span><b><span class="deltaxml-old">Prolog</span></b><span class="deltaxml-old"> is a series of declarations and imports that define the processing environment for the </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-old">module</span></a><span class="deltaxml-old"> that contains the Prolog.</span></p></dd><dt><a id="GLdt-public-function"></a>public function</dt><dd><p>A <b>public function</b> is a function without a <code>%private</code> annotation. A public function is accessible to <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can import it into the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a> of another module. </p></dd><dt><a id="GLdt-public-item-type"></a>public item type</dt><dd><p><span style="display: none;" class="delete_version">A <b>public item type</b> is an item type declaration without a <code>%private</code> annotation. A public item type is accessible to <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can import it into the <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types">in-scope named item types</a> of another module. </span><span style="display: none;" class="add_version">A <b>public item type</b> is an item type declaration without a <code>%private</code> annotation. A public item type is accessible to <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can import it into the <a class="termref" title="item type aliases" href="#dt-item-type-aliases">item type aliases</a> of another module. </span><span class="modify_version">A <b>public item type</b> is an item type declaration without a <code>%private</code> annotation. A public item type is accessible to <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can import it into the <a class="termref" title="in-scope named item types" href="#dt-in-scope-named-item-types"><span class="deltaxml-old">in-scope named item types</span></a><a class="termref" title="item type aliases" href="#dt-item-type-aliases"><span class="deltaxml-new">item type aliases</span></a> of another module. </span></p></dd><dt><a id="GLdt-public-variable"></a>public variable</dt><dd><p>A <b>public variable</b> is a variable without a <code>%private</code> annotation. A public variable is accessible to <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can import it into the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> of another module. Using <code>%public</code> and <code>%private</code> annotations in a main module is not an error, but it does not affect module imports, since a main module cannot be imported. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0116" title="err:XQST0116">err:XQST0116</a>] if a variable declaration contains both a <code>%private</code> and a <code>%public</code> annotation, more than one <code>%private</code> annotation, or more than one <code>%public</code> annotation.</p></dd><dt><a id="GLdt-pure-union-type"></a>pure union type</dt><dd><p>A <b>pure union type</b> is a <span><b>simple type</b></span> that satisfies the following constraints: (1) <code>{variety}</code> is <code>union</code>, (2) the <code>{facets}</code> property is empty, (3) no type in the transitive membership of the union type has <code>{variety}</code><code>list</code>, and (4) no type in the transitive membership of the union type is a type with <code>{variety}</code><code>union</code> having a non-empty <code>{facets}</code> property</p></dd><dt><a id="GLdt-query"></a>query</dt><dd><p>A <b>query</b> consists of one or more <a title="module" class="termref" href="#dt-module">modules</a>.</p></dd><dt><a id="GLdt-queryBody"></a>query body</dt><dd><p>The <b>Query Body</b>, if present, consists of an expression that defines the result of the query.</p></dd><dt><a id="GLdt-reserved-namespaces"></a>reserved namespaces</dt><dd><p>A <b>reserved namespace</b> is a namespace that must not be used in the name of a function declaration.</p></dd><dt><a id="GLdt-resolve-relative-uri"></a>resolve</dt><dd><p>To <b>resolve a relative URI</b><code>$rel</code> against a base URI <code>$base</code> is to expand it to an absolute URI, as if by calling the function <code>fn:resolve-uri($rel, $base)</code>.</p></dd><dt><a id="GLdt-reverse-document-order"></a>reverse document order</dt><dd><p>The node ordering that is the reverse of document order is called <b>reverse document order</b>.</p></dd><dt><a id="GLdt-same-key"></a>same key</dt><dd><p><span style="display: none;" class="delete_version">Two atomic values <code>K1</code> and <code>K2</code> have the <b>same key value</b> if <code>fn:atomic-equal(K1, K2)</code> returns <code>true</code>, as specified in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-atomic-equal">Section 14.2.1 fn:atomic-equal</a><sup><small>FO40</small></sup></span><span style="display: none;" class="add_version">Two atomic values <code>K1</code> and <code>K2</code> have the <b>same key value</b> if <code>fn:atomic-equal(K1, K2)</code> returns <code>true</code>, as specified in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-atomic-equal">Section 18.1.1 fn:atomic-equal</a><sup><small>FO40</small></sup></span><span class="modify_version">Two atomic values <code>K1</code> and <code>K2</code> have the <b>same key value</b> if <code>fn:atomic-equal(K1, K2)</code> returns <code>true</code>, as specified in <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-atomic-equal">Section <span class="deltaxml-old">14.2.1</span><span class="deltaxml-new">18.1.1</span> fn:atomic-equal</a><sup><small>FO40</small></sup></span></p></dd><dt><a id="GLdt-schema-aware-feature"></a>schema aware feature</dt><dd><p><span style="display: none;" class="delete_version">The <b>Schema Aware Feature</b> permits the query Prolog to contain a <a title="schema import" class="termref" href="#dt-schema-import">schema import</a>, and permits a query to contain a <code>validate</code> expression (see <a href="#id-validate"><span class="delete_version"><b>4.25 Validate Expressions</b></span><span class="modify_version"><b>4.25 Validate Expressions</b></span></a>). </span><span style="display: none;" class="add_version">The <b>Schema Aware Feature</b> permits the query Prolog to contain a <a title="schema import" class="termref" href="#dt-schema-import">schema import</a>, and permits a query to contain a <code>validate</code> expression (see <a href="#id-validate"><span class="add_version"><b>4.24 Validate Expressions</b></span><span class="modify_version"><b>4.24 Validate Expressions</b></span></a>). </span><span class="modify_version">The <b>Schema Aware Feature</b> permits the query Prolog to contain a <a title="schema import" class="termref" href="#dt-schema-import">schema import</a>, and permits a query to contain a <code>validate</code> expression (see <a href="#id-validate"><span style="display: none;" class="delete_version"><b>4.25 Validate Expressions</b></span><span style="display: none;" class="add_version"><b>4.24 Validate Expressions</b></span><span class="modify_version"><b><span class="deltaxml-old">4.25</span><span class="deltaxml-new">4.24</span> Validate Expressions</b></span></a>). </span></p></dd><dt><a id="GLdt-schema-import"></a>schema import</dt><dd><p>A <b>schema import</b> imports the element declarations, attribute declarations, and type definitions from a schema into the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>. For each named user-defined simple type in the schema, schema import also adds a corresponding <a title="constructor function" class="termref" href="#dt-constructor-function">constructor function</a>. </p></dd><dt><a id="GLdt-schema-type"></a>schema type</dt><dd><p>A <b>schema type</b> is a type that is (or could be) defined using the facilities of <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> (including the built-in types).</p></dd><dt><a id="GLdt-sequence"></a>sequence</dt><dd><p>A <b>sequence</b> is an ordered collection of zero or more <a title="item" class="termref" href="#dt-item">items</a>.</p></dd><dt><a id="GLdt-sequence-arrow-operator"></a><a id="GLdt-sequence-type"></a>sequence <span class="deltaxml-old">arrow operator</span><span class="deltaxml-new">type</span></dt><dd><p><span class="deltaxml-old"> The </span><b><span class="deltaxml-old">sequence arrow operator</span></b><code><span class="deltaxml-old">=&gt;</span></code><span class="deltaxml-old"> applies a function to a supplied sequence.</span></p></dd><dt><a id="GLdt-sequence-type"></a><span class="deltaxml-old">sequence type</span></dt><dd><p>A <b>sequence type</b> is a type that can be expressed using the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax. Sequence types are used whenever it is necessary to refer to a type in an XQuery 4.0 expression. The term <b>sequence type</b> suggests that this syntax is used to describe the type of an XQuery 4.0 value, which is always a sequence.</p></dd><dt><a id="GLdt-sequence-type-designator"></a><span class="deltaxml-old">sequence type designator</span></dt><dd><p><span class="deltaxml-old">A </span><b><span class="deltaxml-old">sequence type designator</span></b><span class="deltaxml-old"> is a syntactic construct conforming to the grammar rule </span><a href="#doc-xquery40-SequenceType"><span class="deltaxml-old">SequenceType</span></a><span class="deltaxml-old">. A sequence type designator is said to </span><b><span class="deltaxml-old">designate</span></b><span class="deltaxml-old"> a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-old">sequence type</span></a><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-sequencetype-matching"></a><span class="deltaxml-old">SequenceType matching</span></dt><dd><p><b><span class="deltaxml-old">SequenceType matching</span></b><span class="deltaxml-old"> compares a value with an expected </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-old">sequence type</span></a><span class="deltaxml-old">. </span></p></dd><dt><a id="GLdt-serialization"></a>serialization</dt><dd><p><span style="display: none;" class="delete_version"><b>Serialization</b> is the process of converting an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> to a sequence of octets (step DM4 in Figure 1.), as described in <a href="#xslt-xquery-serialization-40">[XSLT and XQuery Serialization 4.0]</a>.</span><span style="display: none;" class="add_version"><b>Serialization</b> is the process of converting an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> to a sequence of octets (step DM4 in Figure 1.), as described in <a href="#xslt-xquery-serialization-31">[XSLT and XQuery Serialization 3.1]</a>.</span><span class="modify_version"><b>Serialization</b> is the process of converting an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> to a sequence of octets (step DM4 in Figure 1.), as described in <a href="#xslt-xquery-serialization-31">[XSLT and XQuery Serialization <span class="deltaxml-old">4.0</span><span class="deltaxml-new">3.1</span>]</a>.</span></p></dd><dt><a id="GLdt-serialization-feature"></a>serialization feature</dt><dd><p>The <b>Serialization Feature</b> provides means for serializing the result of a query as specified in <a href="#id-serialization"><b>2.3.4 Serialization</b></a>.</p></dd><dt><a id="GLdt-setter"></a>setter</dt><dd><p><b>Setters</b> are declarations that set the value of some property that affects query processing, such as construction mode, ordering mode, or default collation.</p></dd><dt><a id="GLshould"></a>should</dt><dd><p><b>SHOULD</b> means that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.</p></dd><dt><a id="GLdt-singleton"></a>singleton</dt><dd><p>A sequence containing exactly one item is called a <b>singleton</b>.</p></dd><dt><a id="GLdt-singleton-focus"></a>singleton focus</dt><dd><p><span class="deltaxml-old">A </span><b><span class="deltaxml-old">singleton focus</span></b><span class="deltaxml-old"> is a </span><a title="fixed focus" class="termref" href="#dt-fixed-focus"><span class="deltaxml-old">fixed focus</span></a><span class="deltaxml-old"> in which the </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-old">context value</span></a><span class="deltaxml-old"> is a </span><a title="singleton" class="termref" href="#dt-singleton"><span class="deltaxml-old">singleton</span></a><span class="deltaxml-old"> item.</span></p><p><span class="deltaxml-new">A </span><b><span class="deltaxml-new">singleton focus</span></b><span class="deltaxml-new"> is a focus that refers to a single item; in a singleton focus, context item is set to the item, context position = 1 and context size = 1.</span></p></dd><dt><a id="GLstable"></a>stable</dt><dd><p>Document order is <b>stable</b>, which means that the relative order of two nodes will not change during the processing of a given <span class="xquery">query</span> , even if this order is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p></dd><dt><a id="GLdt-static-collations"></a><span class="deltaxml-old">statically known collations</span></dt><dt><a id="GLdt-static-typing-feature"></a><span class="deltaxml-new">static typing feature</span></dt><dd><p><span class="deltaxml-new">The </span><b><span class="deltaxml-new">Static Typing Feature</span></b><span class="deltaxml-new"> requires implementations to report all </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new">type errors</span></a><span class="deltaxml-new"> during the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new">static analysis phase</span></a><span class="deltaxml-new">.</span></p></dd><dt><a id="GLdt-static-analysis"></a><span class="deltaxml-new">static analysis phase</span></dt><dd><p><span class="deltaxml-new">The </span><b><span class="deltaxml-new">static analysis phase</span></b><span class="deltaxml-new"> depends on the expression itself and on the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new">static context</span></a><span class="deltaxml-new">. The </span><b><span class="deltaxml-new">static analysis phase</span></b><span class="deltaxml-new"> does not depend on input data (other than schemas).</span></p></dd><dt><a id="GLdt-static-context"></a><span class="deltaxml-new">static context</span></dt><dd><p><b><span class="deltaxml-old">Statically known collations.</span></b><span class="deltaxml-old"> This is an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-old">implementation-defined</span></a><span class="deltaxml-old"> mapping from URI to collation. It defines the names of the collations that are available for use in processing </span><span class="xquery"><span class="deltaxml-old">queries and</span></span><span class="deltaxml-old"> expressions.</span></p><p><span class="deltaxml-new">The </span><b><span class="deltaxml-new">static context</span></b><span class="deltaxml-new"> of an expression is the information that is available during static analysis of the expression, prior to its evaluation.</span></p></dd><dt><a id="GLdt-static-error"></a><span class="deltaxml-new">static error</span></dt><dd><p><span class="deltaxml-new"> An error that can be detected during the static analysis phase, and is not a type error, is a </span><b><span class="deltaxml-new">static error</span></b><span class="deltaxml-new">.</span></p></dd><dt><a id="GLdt-static-function-call"></a><span class="deltaxml-new">static function call</span></dt><dd><p><span class="deltaxml-new">A </span><b><span class="deltaxml-new">static function call</span></b><span class="deltaxml-new"> consists of an EQName followed by a parenthesized list of zero or more arguments.</span></p></dd><dt><a id="GLdt-static-type"></a><span class="deltaxml-new">static type</span></dt><dd><p><span class="deltaxml-new">The </span><b><span class="deltaxml-new">static type</span></b><span class="deltaxml-new"> of an expression is the best inference that the processor is able to make statically about the type of the result of the expression.</span></p></dd><dt><a id="GLdt-known-collections"></a>statically known collections</dt><dd><p><b>Statically known collections.</b> This is a mapping from strings to types. The string represents the absolute URI of a resource that is potentially available using the <code>fn:collection</code> function. The type is the type of the sequence of items that would result from calling the <code>fn:collection</code> function with this URI as its argument.</p></dd><dt><a id="GLdt-static-decimal-formats"></a><a id="GLdt-known-docs"></a>statically known <span class="deltaxml-old">decimal formats</span><span class="deltaxml-new">documents</span></dt><dd><p><b><span class="deltaxml-new">Statically known documents.</span></b><span class="deltaxml-new"> This is a mapping from strings to types. The string represents the absolute URI of a resource that is potentially available using the </span><code><span class="deltaxml-new">fn:doc</span></code><span class="deltaxml-new"> function. The type is the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new">static type</span></a><span class="deltaxml-new"> of a call to </span><code><span class="deltaxml-new">fn:doc</span></code><span class="deltaxml-new"> with the given URI as its literal argument. </span></p></dd><dt><a id="GLdt-static-collations"></a><span class="deltaxml-new">statically known collations</span></dt><dd><p><b><span class="deltaxml-new">Statically known collations.</span></b><span class="deltaxml-new"> This is an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new">implementation-defined</span></a><span class="deltaxml-new"> mapping from URI to collation. It defines the names of the collations that are available for use in processing </span><span class="xquery"><span class="deltaxml-new">queries and</span></span><span class="deltaxml-new"> expressions.</span></p></dd><dt><a id="GLdt-static-decimal-formats"></a><span class="deltaxml-new">statically known decimal formats</span></dt><dd><p><b>Statically known decimal formats.</b> This is a mapping from QNames to decimal formats, with one default format that has no visible name, referred to as the unnamed decimal format. Each format is available for use when formatting numbers using the <code>fn:format-number</code> function.</p></dd><dt><a id="GLdt-known-default-collection"></a>statically known default collection type</dt><dd><p><b>Statically known default collection type.</b> This is the type of the sequence of items that would result from calling the <code>fn:collection</code> function with no arguments.</p></dd><dt><a id="GLdt-known-docs"></a><a id="GLdt-statically-known-function-definitions"></a>statically known <span class="deltaxml-old">documents</span><span class="deltaxml-new">function definitions</span></dt><dd><p><b><span class="deltaxml-old">Statically known documents.</span></b><span class="deltaxml-old"> This is a mapping from strings to types. The string represents the absolute URI of a resource that is potentially available using the </span><code><span class="deltaxml-old">fn:doc</span></code><span class="deltaxml-old"> function. The type is the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-old">static type</span></a><span class="deltaxml-old"> of a call to </span><code><span class="deltaxml-old">fn:doc</span></code><span class="deltaxml-old"> with the given URI as its literal argument. </span></p></dd><dt><a id="GLdt-statically-known-function-definitions"></a><span class="deltaxml-old">statically known function definitions</span></dt><dd><p><b>Statically known function definitions.</b> This is a set of <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a>.</p></dd><dt><a id="GLdt-static-namespaces"></a>statically known namespaces</dt><dd><p><b>Statically known namespaces.</b> This is a mapping from prefix to namespace URI that defines all the namespaces that are known during static processing of a given expression.</p></dd><dt><a id="GLdt-static-analysis"></a><span class="deltaxml-old">static analysis phase</span></dt><dd><p><span class="deltaxml-old">The </span><b><span class="deltaxml-old">static analysis phase</span></b><span class="deltaxml-old"> depends on the expression itself and on the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-old">static context</span></a><span class="deltaxml-old">. The </span><b><span class="deltaxml-old">static analysis phase</span></b><span class="deltaxml-old"> does not depend on input data (other than schemas).</span></p></dd><dt><a id="GLdt-static-base-uri"></a><span class="deltaxml-old">Static Base URI</span></dt><dd><p><b><span class="deltaxml-old">Static Base URI.</span></b><span class="deltaxml-old"> This is an absolute URI, used to resolve relative URIs during static analysis. </span></p></dd><dt><a id="GLdt-static-context"></a><span class="deltaxml-old">static context</span></dt><dd><p><span class="deltaxml-old">The </span><b><span class="deltaxml-old">static context</span></b><span class="deltaxml-old"> of an expression is the information that is available during static analysis of the expression, prior to its evaluation.</span></p></dd><dt><a id="GLdt-static-error"></a><span class="deltaxml-old">static error</span></dt><dd><p><span class="deltaxml-old"> An error that can be detected during the static analysis phase, and is not a type error, is a </span><b><span class="deltaxml-old">static error</span></b><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-static-function-call"></a><span class="deltaxml-old">static function call</span></dt><dd><p><span class="deltaxml-old">A </span><b><span class="deltaxml-old">static function call</span></b><span class="deltaxml-old"> consists of an EQName followed by a parenthesized list of zero or more arguments.</span></p></dd><dt><a id="GLdt-static-type"></a><span class="deltaxml-old">static type</span></dt><dd><p><span class="deltaxml-old">The </span><b><span class="deltaxml-old">static type</span></b><span class="deltaxml-old"> of an expression is the best inference that the processor is able to make statically about the type of the result of the expression.</span></p></dd><dt><a id="GLdt-step"></a>step</dt><dd><p>A <b>step</b> is a part of a <a title="path expression" class="termref" href="#dt-path-expression">path expression</a> that generates a sequence of items and then filters the sequence by zero or more <a title="" class="termref" href="#dt-predicate">predicates</a>. The value of the step consists of those items that satisfy the predicates, working from left to right. A step may be either an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a> or a postfix expression.</p></dd><dt><a id="GLdt-string-constructor"></a>string constructor</dt><dd><p>A <b>String Constructor</b> creates a string from literal text and interpolated expressions. </p></dd><dt><a id="GLdt-string-value"></a>string value</dt><dd><p><span style="display: none;" class="delete_version">The <b>string value</b> of a node is a string and can be extracted by applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/#func-string">Section 2.3 fn:string</a><sup><small>FO40</small></sup> function to the node.</span><span style="display: none;" class="add_version">The <b>string value</b> of a node is a string and can be extracted by applying the <a href="https://www.w3.org/TR/xpath-functions-31/#func-string">Section 2.3 fn:string </a><sup><small>FO31</small></sup> function to the node.</span><span class="modify_version">The <b>string value</b> of a node is a string and can be extracted by applying the <a href="https://www.w3.org/TR/xpath-functions-31/#func-string">Section 2.3 fn:string<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">FO40</span><span class="deltaxml-new">FO31</span></small></sup> function to the node.</span></p></dd><dt><a id="GLdt-substitution-group"></a>substitution group</dt><dd><p><b>Substitution groups</b> are defined in <a href="https://www.w3.org/TR/xmlschema-1/#Element_Equivalence_Class">Section 2.2.2.2 Element Substitution Group </a><sup><small>XS1-1</small></sup> and <a href="https://www.w3.org/TR/xmlschema11-1/#Element_Equivalence_Class">Section 2.2.2.2 Element Substitution Group </a><sup><small>XS11-1</small></sup>. Informally, the substitution group headed by a given element (called the <b>head element</b>) consists of the set of elements that can be substituted for the head element without affecting the outcome of schema validation.</p></dd><dt><a id="GLdt-subtype"></a>subtype</dt><dd><p>Given two <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> or <a title="item type" class="termref" href="#dt-item-type">item types</a>, the rules in this section determine if one is a <b>subtype</b> of the other. If a type <var>A</var> is a subtype of type <var>B</var>, it follows that every value matched by <var>A</var> is also matched by <var>B</var>.</p></dd><dt><a id="GLdt-subtype-substitution"></a>subtype substitution</dt><dd><p>The use of a value that has a <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> that is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the expected type is known as <b>subtype substitution</b>.</p></dd><dt><a id="GLsymbol"></a>symbol</dt><dd><p>Each rule in the grammar defines one <b>symbol</b>, using the following format: </p><div class="exampleInner"><pre>symbol ::= expression</pre></div></dd><dt><a id="GLsymbolseparators"></a>symbol separators</dt><dd><p><a title="whitespace" class="termref" href="#Whitespace">Whitespace</a> and <a href="#doc-xquery40-Comment">Comments</a> function as <b>symbol separators</b>. For the most part, they are not mentioned in the grammar, and may occur between any two terminal symbols mentioned in the grammar, except where that is forbidden by the <a href="#ws-explicit">/* ws: explicit */</a> annotation in the EBNF, or by the <a href="#parse-note-xml-version">/* xgc: xml-version */</a> annotation.</p></dd><dt><a id="GLdt-system-function"></a>system function</dt><dd><p><span style="display: none;" class="delete_version"><b>System functions</b> include the functions defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a>, functions defined by the specifications of a host language, <a title="constructor function" class="termref" href="#dt-constructor-function">constructor functions</a> for atomic types, and any additional functions provided by the implementation. System functions are sometimes called built-in functions.</span><span style="display: none;" class="add_version"><b>System functions</b> include the functions defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a> and may also include additional functions provided by the implementation.</span><span class="modify_version"><b>System functions</b> include the functions defined in <a href="#xpath-functions-40">[XQuery and XPath Functions and Operators 4.0]</a><span class="deltaxml-old">, functions defined by the specifications of a host language,</span> <a title="constructor function" class="termref" href="#dt-constructor-function"><span class="deltaxml-old">constructor functions</span></a><span class="deltaxml-old"> for atomic types, and any</span><span class="deltaxml-new">and may also include</span> additional functions provided by the implementation.<span class="deltaxml-old"> System functions are sometimes called built-in functions.</span></span></p></dd><dt><a id="GLdt-target-namespace"></a>target namespace</dt><dd><p> The <b>target namespace</b> of a module is the namespace of the objects (such as elements or functions) that it defines. </p></dd><dt><a id="GLterminal"></a>terminal</dt><dd><p>A <b>terminal</b> is a symbol or string or pattern that can appear in the right-hand side of a rule, but never appears on the left-hand side in the main grammar, although it may appear on the left-hand side of a rule in the grammar for terminals.</p></dd><dt><a id="GLid-tuple-foobar"></a>tuple</dt><dd><p>A <b>tuple</b> is a set of zero or more named variables, each of which is bound to a value that is an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a>.</p></dd><dt><a id="GLid-tuple-stream-foobar"></a>tuple stream</dt><dd><p>A <b>tuple stream</b> is an ordered sequence of zero or more <b>tuples</b>.</p></dd><dt><a id="GLdt-type-annotation"></a><a id="GLdt-type-alias"></a>type <span class="deltaxml-old">annotation</span><span class="deltaxml-new">alias</span></dt><dd><p><span class="deltaxml-new">A </span><b><span class="deltaxml-new">type alias</span></b><span class="deltaxml-new"> is an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new">expanded QName</span></a><span class="deltaxml-new"> that is mapped to an </span><code><span class="deltaxml-new">ItemType</span></code><span class="deltaxml-new"> in the </span><a title="item type aliases" class="termref" href="#dt-item-type-aliases"><span class="deltaxml-new">item type aliases</span></a><span class="deltaxml-new"> of the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new">static context</span></a><span class="deltaxml-new">.</span></p></dd><dt><a id="GLdt-type-annotation"></a><span class="deltaxml-new">type annotation</span></dt><dd><p><span style="display: none;" class="delete_version">Each element node and attribute node in an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> has a <b>type annotation</b> (described in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#types">Section 2.8 Schema Information</a><sup><small>DM40</small></sup>). The type annotation of a node is a reference to an XML Schema type. </span><span style="display: none;" class="add_version">Each element node and attribute node in an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> has a <b>type annotation</b> (described in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types">Section 2.7 Schema Information </a><sup><small>DM31</small></sup>). The type annotation of a node is a reference to an XML Schema type. </span><span class="modify_version">Each element node and attribute node in an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> has a <b>type annotation</b> (described in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types">Section <span class="deltaxml-old">2.8</span><span class="deltaxml-new">2.7</span> Schema Information<span class="deltaxml-new"> </span></a><sup><small><span class="deltaxml-old">DM40</span><span class="deltaxml-new">DM31</span></small></sup>). The type annotation of a node is a reference to an XML Schema type. </span></p></dd><dt><a id="GLdt-typed-data-feature"></a><span class="deltaxml-old">typed data feature</span></dt><dd><p><span class="deltaxml-old">The </span><b><span class="deltaxml-old">Typed Data Feature</span></b><span class="deltaxml-old"> permits an XDM instance to contain element node types other than </span><code><span class="deltaxml-old">xs:untyped</span></code><span class="deltaxml-old"> and attributes node types other than </span><code><span class="deltaxml-old">xs:untypedAtomic</span></code><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-type-declaration"></a>type declaration</dt><dd><p>A variable binding may be accompanied by a <b>type declaration</b>, which consists of the keyword <code>as</code> followed by the static type of the variable, declared using the syntax in <a href="#id-sequencetype-syntax"><b>3.4 Sequence Types</b></a>.</p></dd><dt><a id="GLdt-typed-value"></a><span class="deltaxml-old">typed value</span></dt><dd><p><span class="deltaxml-old">The </span><b><span class="deltaxml-old">typed value</span></b><span class="deltaxml-old"> of a node is a sequence of atomic values and can be extracted by applying the </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-data"><span class="deltaxml-old">Section 2.4 fn:data</span></a><sup><small><span class="deltaxml-old">FO40</span></small></sup><span class="deltaxml-old"> function to the node.</span></p></dd><dt><a id="GLdt-type-error"></a>type error</dt><dd><p>A <b>type error</b> may be raised during the static analysis phase or the dynamic evaluation phase. During the static analysis phase, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs when the <a title="static type" class="termref" href="#dt-static-type">static type</a> of an expression does not match the expected type of the context in which the expression occurs. During the dynamic evaluation phase, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs when the <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> of a value does not match the expected type of the context in which the value occurs.</p></dd><dt><a id="GLdt-type-promotion"></a>type promotion</dt><dd><p><span style="display: none;" class="delete_version">Under certain circumstances, an atomic value can be promoted from one type to another.</span><span style="display: none;" class="add_version">Under certain circumstances, an atomic value can be promoted from one type to another. <b>Type promotion</b> is used in evaluating function calls (see <a href="#id-function-calls"><b>4.4.1.1 Static Function Call Syntax</b></a>)<span class="xquery">, <code>order by</code> clauses (see <a href="#id-order-by-clause"><b>4.14.8 Order By Clause</b></a>),</span> and operators that accept numeric or string operands (see <a href="#mapping"><b>B.2 Operator Mapping</b></a>).</span><span class="modify_version">Under certain circumstances, an atomic value can be promoted from one type to another.<span class="deltaxml-new"> </span><b><span class="deltaxml-new">Type promotion</span></b><span class="deltaxml-new"> is used in evaluating function calls (see </span><a href="#id-function-calls"><b><span class="deltaxml-new">4.4.1.1 Static Function Call Syntax</span></b></a><span class="deltaxml-new">)</span><span class="xquery"><span class="deltaxml-new">, </span><code><span class="deltaxml-new">order by</span></code><span class="deltaxml-new"> clauses (see </span><a href="#id-order-by-clause"><b><span class="deltaxml-new">4.14.8 Order By Clause</span></b></a><span class="deltaxml-new">),</span></span><span class="deltaxml-new"> and operators that accept numeric or string operands (see </span><a href="#mapping"><b><span class="deltaxml-new">B.2 Operator Mapping</span></b></a><span class="deltaxml-new">).</span></span></p></dd><dt><a id="GLdt-URI"></a><span class="deltaxml-old">URI</span></dt><dt><a id="GLdt-typed-data-feature"></a><span class="deltaxml-new">typed data feature</span></dt><dd><p><span class="deltaxml-new">The </span><b><span class="deltaxml-new">Typed Data Feature</span></b><span class="deltaxml-new"> permits an XDM instance to contain element node types other than </span><code><span class="deltaxml-new">xs:untyped</span></code><span class="deltaxml-new"> and attributes node types other than </span><code><span class="deltaxml-new">xs:untypedAtomic</span></code><span class="deltaxml-new">.</span></p></dd><dt><a id="GLdt-typed-value"></a><span class="deltaxml-new">typed value</span></dt><dd><p><span class="deltaxml-old">Within this specification, the term </span><b><span class="deltaxml-old">URI</span></b><span class="deltaxml-old"> refers to a Universal Resource Identifier as defined in </span><a href="#RFC3986"><span class="deltaxml-old">[RFC3986]</span></a><span class="deltaxml-old"> and extended in </span><a href="#RFC3987"><span class="deltaxml-old">[RFC3987]</span></a><span class="deltaxml-old"> with the new name </span><b><span class="deltaxml-old">IRI</span></b><span class="deltaxml-old">.</span></p><p><span class="deltaxml-new">The </span><b><span class="deltaxml-new">typed value</span></b><span class="deltaxml-new"> of a node is a sequence of atomic values and can be extracted by applying the </span><a href="https://www.w3.org/TR/xpath-functions-31/#func-data"><span class="deltaxml-new">Section 2.4 fn:data </span></a><sup><small><span class="deltaxml-new">FO31</span></small></sup><span class="deltaxml-new"> function to the node.</span></p></dd><dt><a id="GLdt-udf"></a>user-defined function</dt><dd><p><b>User defined functions</b> are functions that contain a <b>function body</b>, which provides the implementation of the function as a <a title="content expression" class="termref" href="#dt-content-expression">content expression</a>.</p></dd><dt><a id="GLdt-value"></a>value</dt><dd><p>In the <a title="data model" class="termref" href="#dt-datamodel">data model</a>, a <b>value</b> is always a <a title="sequence" class="termref" href="#dt-sequence">sequence</a>.</p></dd><dt><a id="GLdt-variable-declartion"></a><a id="GLdt-variable-reference"></a>variable <span class="deltaxml-old">declaration</span><span class="deltaxml-new">reference</span></dt><dd><p><span class="deltaxml-old">A </span><b><span class="deltaxml-old">variable declaration</span></b><span class="deltaxml-old"> in the XQuery prolog defines the name and </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-old">static type</span></a><span class="deltaxml-old"> of a variable, and optionally a value for the variable. It adds to the </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-old">in-scope variables</span></a><span class="deltaxml-old"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-old">static context</span></a><span class="deltaxml-old">, and may also add to the </span><a title="variable values" class="termref" href="#dt-variable-values"><span class="deltaxml-old">variable values</span></a><span class="deltaxml-old"> in the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-old">dynamic context</span></a><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-variable-reference"></a><span class="deltaxml-old">variable reference</span></dt><dd><p>A <b>variable reference</b> is an EQName preceded by a $-sign.</p></dd><dt><a id="GLdt-variable-terminal"></a><a id="GLdt-variable-values"></a>variable <span class="deltaxml-old">terminal</span><span class="deltaxml-new">values</span></dt><dd><p><span class="deltaxml-old">A </span><b><span class="deltaxml-old">variable terminal</span></b><span class="deltaxml-old"> is an instance of a production rule that is not itself an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-old">ordinary production rule</span></a><span class="deltaxml-old"> but that is named (directly) on the right-hand side of an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-old">ordinary production rule</span></a><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-variable-values"></a><span class="deltaxml-old">variable values</span></dt><dd><p><b>Variable values</b>. This is a mapping from <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> to value. It contains the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> as the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> for the expression. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is the name of the variable and the value is the dynamic value of the variable, which includes its <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a>.</p></dd><dt><a id="GLdt-version-declaration"></a>version declaration</dt><dd><p> A <b>version declaration</b> can identify the applicable XQuery syntax and semantics for a <a title="module" class="termref" href="#dt-module">module</a>, as well as its encoding.</p></dd><dt><a id="GLdt-warning"></a>warning</dt><dd><p>In addition to <a title="static error" class="termref" href="#dt-static-error">static errors</a>, <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a>, and <a title="type error" class="termref" href="#dt-type-error">type errors</a>, an XQuery 4.0 implementation may raise <b>warnings</b>, either during the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a> or the <a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation">dynamic evaluation phase</a>. The circumstances in which warnings are raised, and the ways in which warnings are handled, are <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p></dd><dt><a id="GLWhitespace"></a>whitespace</dt><dd><p>A <b>whitespace</b> character is any of the characters defined by <a href="http://www.w3.org/TR/REC-xml/#NT-S"> [http://www.w3.org/TR/REC-xml/#NT-S]</a>.</p></dd><dt><a id="GLdt-wildcard-matches"></a>wildcard-matches</dt><dd><p><span style="display: none;" class="delete_version">In these rules, if <var>MU</var> and <var>NU</var> are <a href="#doc-xquery40-NameTestUnion">NameTestUnions</a>, then <var>MU</var><b>wildcard-matches</b><var>NU</var> is true if every name that matches <var>MU</var> also matches <var>NU</var>.</span><span style="display: none;" class="add_version">In these rules, if <var>M</var> and <var>N</var> are <a href="#doc-xquery40-NameTest">NameTests</a>, then <var>M</var><b>wildcard-matches</b><var>N</var> is true if every name that matches <var>M</var> also matches <var>N</var>.</span><span class="modify_version">In these rules, if <var><span class="deltaxml-old">MU</span><span class="deltaxml-new">M</span></var> and <var><span class="deltaxml-old">NU</span><span class="deltaxml-new">N</span></var> are <a href="#doc-xquery40-NameTestUnion"><span class="deltaxml-old">NameTestUnions</span></a><a href="#doc-xquery40-NameTest"><span class="deltaxml-new">NameTests</span></a>, then <var><span class="deltaxml-old">MU</span><span class="deltaxml-new">M</span></var><b>wildcard-matches</b><var><span class="deltaxml-old">NU</span><span class="deltaxml-new">N</span></var> is true if every name that matches <var><span class="deltaxml-old">MU</span><span class="deltaxml-new">M</span></var> also matches <var><span class="deltaxml-old">NU</span><span class="deltaxml-new">N</span></var>.</span></p></dd><dt><a id="GLdt-window"></a>window</dt><dd><p>A <b>window</b> is a sequence of consecutive items drawn from the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>.</p></dd><dt><a id="GLdt-data-model-instance"></a><span class="deltaxml-old">XDM instance</span></dt><dd><p><span class="deltaxml-old">The term </span><b><span class="deltaxml-old">XDM instance</span></b><span class="deltaxml-old"> is used, synonymously with the term </span><a title="value" class="termref" href="#dt-value"><span class="deltaxml-old">value</span></a><span class="deltaxml-old">, to denote an unconstrained </span><a title="sequence" class="termref" href="#dt-sequence"><span class="deltaxml-old">sequence</span></a><span class="deltaxml-old"> of </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-old">items</span></a><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-xpath-compat-mode"></a><span class="deltaxml-old">XPath 1.0 compatibility mode</span></dt><dd><p><b><span class="deltaxml-old">XPath 1.0 compatibility mode.</span></b><span class="xquery"><span class="deltaxml-old">This component must be set by all host languages that include XPath 3.1 as a subset, indicating whether rules for compatibility with XPath 1.0 are in effect. XQuery sets the value of this component to </span><code><span class="deltaxml-old">false</span></code><span class="deltaxml-old">. </span></span></p></dd><dt><a id="GLdt-xquery-10-processor"></a><span class="deltaxml-old">XQuery 1.0 Processor</span></dt><dd><p><span class="deltaxml-old"> An </span><b><span class="deltaxml-old">XQuery 1.0 Processor</span></b><span class="deltaxml-old"> processes a query according to the XQuery 1.0 specification. </span></p></dd><dt><a id="GLdt-xquery-30-processor"></a><span class="deltaxml-old">XQuery 3.0 Processor</span></dt><dd><p><span class="deltaxml-old"> An </span><b><span class="deltaxml-old">XQuery 3.0 Processor</span></b><span class="deltaxml-old"> processes a query according to the XQuery 3.0 specification. </span></p></dd><dt><a id="GLdt-xquery-31-processor"></a><span class="deltaxml-old">XQuery 3.1 Processor</span></dt><dd><p><span class="deltaxml-old"> An </span><b><span class="deltaxml-old">XQuery 3.1 Processor</span></b><span class="deltaxml-old"> processes a query according to the XQuery 3.1 specification. </span></p></dd><dt><a id="GLdt-xquery-40-processor"></a><span class="deltaxml-old">XQuery 4.0 Processor</span></dt><dd><p><span class="deltaxml-old"> An </span><b><span class="deltaxml-old">XQuery 4.0 Processor</span></b><span class="deltaxml-old"> processes a query according to the XQuery 4.0 specification. </span></p></dd><dt><a id="GLdt-version-number"></a><span class="deltaxml-old">XQuery version number</span></dt><dd><p><span class="deltaxml-old">An </span><b><span class="deltaxml-old">XQuery version number</span></b><span class="deltaxml-old"> consists of two integers separated by a dot. The first integer is referred to as the </span><b><span class="deltaxml-old">major version number</span></b><span class="deltaxml-old">; the second as the </span><b><span class="deltaxml-old">minor version number</span></b><span class="deltaxml-old">.</span></p></dd><dt><a id="GLdt-anyAtomicType"></a>xs:anyAtomicType</dt><dd><p><code>xs:anyAtomicType</code> is an atomic type that includes all atomic values (and no values that are not atomic). Its base type is <code>xs:anySimpleType</code> from which all simple types, including atomic, list, and union types, are derived. All primitive atomic types, such as <code>xs:decimal</code> and <code>xs:string</code>, have <code>xs:anyAtomicType</code> as their base type.</p></dd><dt><a id="GLdt-dayTimeDuration"></a>xs:dayTimeDuration</dt><dd><p><code>xs:dayTimeDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:dayTimeDuration</code> is restricted to contain only day, hour, minute, and second components.</p></dd><dt><a id="GLdt-xs-error"></a>xs:error</dt><dd><p><code>xs:error</code> is a simple type with no value space. It is defined in <a href="https://www.w3.org/TR/xmlschema11-1/#xsd-error">Section 3.16.7.3 xs:error </a><sup><small>XS11-1</small></sup> and can be used in the <a href="#id-sequencetype-syntax"><b>3.4 Sequence Types</b></a> to raise errors.</p></dd><dt><a id="GLdt-untyped"></a>xs:untyped</dt><dd><p><code>xs:untyped</code> is used as the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of an element node that has not been validated, or has been validated in <code>skip</code> mode.</p></dd><dt><a id="GLdt-untypedAtomic"></a>xs:untypedAtomic</dt><dd><p><code>xs:untypedAtomic</code> is an atomic type that is used to denote untyped atomic data, such as text that has not been assigned a more specific type.</p></dd><dt><a id="GLdt-yearMonthDuration"></a>xs:yearMonthDuration</dt><dd><p><code>xs:yearMonthDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:yearMonthDuration</code> is restricted to contain only year and month components.</p></dd><dt><a id="GLid-static-decimal-format-zero-digit"></a>zero-digit</dt><dd><p><span style="display: none;" class="delete_version"><b>zero-digit</b> is the character used to represent the digit zero; the default value is the Unicode digit zero (#x30). This character must be a digit (category Nd in the Unicode property database), and it must have the numeric value zero. This property implicitly defines the ten Unicode characters that are used to represent the values 0 to 9: Unicode is organized so that each set of decimal digits forms a contiguous block of characters in numerical sequence. Within the picture string any of these ten character can be used (interchangeably) as a place-holder for a mandatory digit. Within the final result string, these ten characters are used to represent the digits zero to nine.</span><span style="display: none;" class="add_version"><b>zero-digit</b> is the character used to represent the digit zero; the default value is the Western digit zero (#x30). This character must be a digit (category Nd in the Unicode property database), and it must have the numeric value zero. This property implicitly defines the ten Unicode characters that are used to represent the values 0 to 9: Unicode is organized so that each set of decimal digits forms a contiguous block of characters in numerical sequence. Within the picture string any of these ten character can be used (interchangeably) as a place-holder for a mandatory digit. Within the final result string, these ten characters are used to represent the digits zero to nine.</span><span class="modify_version"><b>zero-digit</b> is the character used to represent the digit zero; the default value is the <span class="deltaxml-old">Unicode</span><span class="deltaxml-new">Western</span> digit zero (#x30). This character must be a digit (category Nd in the Unicode property database), and it must have the numeric value zero. This property implicitly defines the ten Unicode characters that are used to represent the values 0 to 9: Unicode is organized so that each set of decimal digits forms a contiguous block of characters in numerical sequence. Within the picture string any of these ten character can be used (interchangeably) as a place-holder for a mandatory digit. Within the final result string, these ten characters are used to represent the digits zero to nine.</span></p></dd></dl></div><div class="div1"><h2><a id="id-atomic-comparisons"></a><span class="deltaxml-old">I Atomic Comparisons: An Overview (Non-Normative)</span></h2><p><span class="deltaxml-old">This appendix provides a non-normative summary of the various functions and operators used for comparison of atomic values, with some background on the history and rationale.</span></p><div class="div2"><h3><a id="id-equality-comparison"></a><span class="deltaxml-old">I.1 Equality Comparisons</span></h3><p><span class="deltaxml-old">In XQuery 4.0 there are essentially four ways of comparing two atomic values for equality:</span></p><ul><li><p><code><span class="deltaxml-old">$A = $B</span></code></p><p><span class="deltaxml-old">This operator was introduced in XPath 1.0. The semantics were changed slightly in XPath 2.0, but the original semantics remain available when XPath 1.0 compatibility mode is enabled.</span></p><p><span class="deltaxml-old">With a general comparison in XPath 2.0 or later (and in XQuery), the following rules are observed:</span></p><ul><li><p><span class="deltaxml-old">Either operand may be a sequence; the result is true if any pair of items from the two sequences compares equal.</span></p><p><span class="deltaxml-old">In consequence, if either operand is an empty sequence, the result is false.</span></p></li><li><p><span class="deltaxml-old">If nodes are supplied, they are atomized.</span></p></li><li><p><span class="deltaxml-old">Untyped atomic values appearing in one operand are converted to the type of the other operand (if both operands are untyped atomic, they are compared as strings).</span></p></li><li><p><span class="deltaxml-old">As a result, the operator is not transitive: the untyped atomic values </span><code><span class="deltaxml-old">"4.0"</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">"4"</span></code><span class="deltaxml-old"> are not equal to each other, but both compare equal to the integer value </span><code><span class="deltaxml-old">4</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">Comparison of certain values is context-sensitive. In particular, comparison of strings uses the default collation from the static context, while comparison of date/time values lacking an explicit timezone takes the timezone from the dynamic context.</span></p></li><li><p><span class="deltaxml-old">NaN is not equal to NaN; negative zero is equal to positive zero.</span></p></li><li><p><code><span class="deltaxml-old">xs:hexBinary</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:base64Binary</span></code><span class="deltaxml-old"> values are mutually comparable: they are equal if they represent the same sequence of octets.</span></p></li><li><p><span class="deltaxml-old">Comparing incompatible values (for example </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:date</span></code><span class="deltaxml-old">) raises an error.</span></p></li></ul></li><li><p><code><span class="deltaxml-old">$A eq $B</span></code></p><p><span class="deltaxml-old">Value comparisons were introduced in XPath 2.0 and XQuery 1.0. One of the aims was to make the comparison transitive (a precondition for a wide variety of optimizations), however in edge cases involving comparisons across different numeric types this was not entirely achieved.</span></p><p><span class="deltaxml-old">With a value comparison, the rules are:</span></p><ul><li><p><span class="deltaxml-old">Each operand must either be a single atomic value, or an empty sequence.</span></p></li><li><p><span class="deltaxml-old">If either operand is an empty sequence, the result is an empty sequence; in most contexts this has the same effect as returning false.</span></p></li><li><p><span class="deltaxml-old">If nodes are supplied, they are atomized.</span></p></li><li><p><span class="deltaxml-old">Untyped atomic values are converted to strings (regardless of the type of the other operand).</span></p></li><li><p><span class="deltaxml-old">Numeric values of types </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">xs:decimal</span></code><span class="deltaxml-old">, or </span><code><span class="deltaxml-old">xs:float</span></code><span class="deltaxml-old"> are converted to </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">This can lead to problems with implementations of </span><code><span class="deltaxml-old">xs:decimal</span></code><span class="deltaxml-old"> that support more precision than can be held in an </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">As with general comparisons, the default collation and implicit timezone are taken from the context.</span></p></li><li><p><span class="deltaxml-old">NaN is not equal to NaN; negative zero is equal to positive zero.</span></p></li><li><p><code><span class="deltaxml-old">xs:hexBinary</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:base64Binary</span></code><span class="deltaxml-old"> values are mutually comparable: they are equal if they represent the same sequence of octets.</span></p></li><li><p><span class="deltaxml-old">Comparing incompatible values (for example </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:date</span></code><span class="deltaxml-old">) raises an error.</span></p></li></ul></li><li><p><code><span class="deltaxml-old">deep-equal($A, $B)</span></code></p><p><span class="deltaxml-old">As the name implies, the </span><code><span class="deltaxml-old">deep-equal</span></code><span class="deltaxml-old"> function was introduced primarily for comparing nodes, or sequences of nodes; however in its simplest form it can also be used to compare two atomic values. The semantics of the comparison used by </span><code><span class="deltaxml-old">deep-equal($A, $B)</span></code><span class="deltaxml-old"> are also invoked by a wide variety of other functions including </span><code><span class="deltaxml-old">distinct-values</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">all-equal</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">all-different</span></code><span class="deltaxml-old">; it is also used to underpin grouping constructs in both XQuery 4.0 and XSLT 4.0.</span></p><p><span class="deltaxml-old">Some of the relevant rules are:</span></p><ul><li><p><span class="deltaxml-old">Because </span><code><span class="deltaxml-old">deep-equal</span></code><span class="deltaxml-old"> is used to compare sequences, if one of the operands is an empty sequence the result is false; but if both operands are empty sequences, the result is true.</span></p></li><li><p><span class="deltaxml-old">If nodes are supplied, they are not atomized; they are compared as nodes.</span></p></li><li><p><span class="deltaxml-old">Strings can be compared using the default collation or using an explicitly specified collation; there are also options to compare after normalizing whitespace or unicode.</span></p></li><li><p><span class="deltaxml-old">Comparisons of dates and times lacking a timezone uses the implicit timezone from the dynamic context.</span></p></li><li><p><span class="deltaxml-old">Numeric values are converted to </span><code><span class="deltaxml-old">xs:decimal</span></code><span class="deltaxml-old"> prior to comparison, not to </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old">. This represents a departure in 4.0 from previous versions of the specification. The conversion must use an implementation of </span><code><span class="deltaxml-old">xs:decimal</span></code><span class="deltaxml-old"> that does not cause loss of precision. As a result, the comparison is now truly transitive, which makes it suitable to underpin grouping operations.</span></p></li><li><p><span class="deltaxml-old">To ensure that every value is equal to itself, comparing NaN to NaN returns true.</span></p></li><li><p><code><span class="deltaxml-old">xs:hexBinary</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:base64Binary</span></code><span class="deltaxml-old"> values are mutually comparable: they are equal if they represent the same sequence of octets.</span></p></li><li><p><span class="deltaxml-old">Comparing incompatible values (for example </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:date</span></code><span class="deltaxml-old">) returns false; it does not raise an error.</span></p></li></ul></li><li><p><code><span class="deltaxml-old">atomic-equal($A, $B)</span></code></p><p><span class="deltaxml-old">This comparison operation was introduced in XPath 3.0 (and XQuery 3.0) for comparing keys in maps; the 4.0 specifications expose it directly as a function that can be called from user applications. The dominant requirements for keys in maps were that the comparison should be transitive, error-free, and context-independent. The relevant rules are:</span></p><ul><li><p><span class="deltaxml-old">The type signature of the function ensures that it can only be used to compare single items; empty sequences do not arise.</span></p></li><li><p><span class="deltaxml-old">If nodes are supplied, they are atomized.</span></p></li><li><p><span class="deltaxml-old">Strings are compared codepoint-by-codepoint, without reference to any collation or normalization.</span></p></li><li><p><span class="deltaxml-old">Dates and times lacking a timezone are never equal to dates and times that have a timezone. However, when comparing two dates or times that both have a timezone, the timezone is normalized.</span></p></li><li><p><span class="deltaxml-old">As with </span><code><span class="deltaxml-old">deep-equal</span></code><span class="deltaxml-old">, numeric values are converted to </span><code><span class="deltaxml-old">xs:decimal</span></code><span class="deltaxml-old"> prior to comparison, not to </span><code><span class="deltaxml-old">xs:double</span></code><span class="deltaxml-old">.</span></p></li><li><p><span class="deltaxml-old">Comparing NaN to NaN returns true.</span></p></li><li><p><code><span class="deltaxml-old">xs:hexBinary</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:base64Binary</span></code><span class="deltaxml-old"> values are distinct: both can co-exist as distinct keys in a map even if the underlying sequence of octets is the same.</span></p></li><li><p><span class="deltaxml-old">Comparing incompatible values (for example </span><code><span class="deltaxml-old">xs:integer</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">xs:date</span></code><span class="deltaxml-old">) returns false; it does not raise an error.</span></p></li></ul></li></ul><p><span class="deltaxml-old">The following table summarizes these differences. For all these examples it is assumed that (a) the default collation is the HTML case-blind collation, (b) the implicit timezone is +01:00, and (c) nodes are untyped.</span></p><table style="border:1px solid" class="small"><thead><tr><th><code><span class="deltaxml-old">$A</span></code></th><th><code><span class="deltaxml-old">$B</span></code></th><th><code><span class="deltaxml-old">$A = $B</span></code></th><th><code><span class="deltaxml-old">$A eq $B</span></code></th><th><code><span class="deltaxml-old">deep-equal(​$A, $B)</span></code></th><th><code><span class="deltaxml-old">atomic-equal(​$A, $B)</span></code></th></tr></thead><tbody><tr><td><p><code><span class="deltaxml-old">()</span></code></p></td><td><p><code><span class="deltaxml-old">()</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td><td><p><code><span class="deltaxml-old">()</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">error</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-old">12</span></code></p></td><td><p><code><span class="deltaxml-old">()</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td><td><p><code><span class="deltaxml-old">()</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td><td><p><code><span class="deltaxml-old">error</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-old">(1,2)</span></code></p></td><td><p><code><span class="deltaxml-old">(2,3)</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">error</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td><td><p><code><span class="deltaxml-old">error</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-old">12</span></code></p></td><td><p><code><span class="deltaxml-old">12e0</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-old">0.2</span></code></p></td><td><p><code><span class="deltaxml-old">0.2e0</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-old">NaN</span></code></p></td><td><p><code><span class="deltaxml-old">NaN</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-old">+0e0</span></code></p></td><td><p><code><span class="deltaxml-old">-0e0</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-old">"A"</span></code></p></td><td><p><code><span class="deltaxml-old">"a"</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-old">"A"</span></code></p></td><td><p><code><span class="deltaxml-old">12</span></code></p></td><td><p><code><span class="deltaxml-old">error</span></code></p></td><td><p><code><span class="deltaxml-old">error</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-old">&lt;a&gt;A&lt;/a&gt;</span></code></p></td><td><p><code><span class="deltaxml-old">"A"</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-old">&lt;a&gt;12&lt;/a&gt;</span></code></p></td><td><p><code><span class="deltaxml-old">12</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">error</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-old">xs:time(​'12:00:00Z')</span></code></p></td><td><p><code><span class="deltaxml-old">xs:time(​'13:00:00+01:00')</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-old">xs:time(​'12:00:00Z')</span></code></p></td><td><p><code><span class="deltaxml-old">xs:time(​'13:00:00')</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-old">xs:hexBinary(​"0000")</span></code></p></td><td><p><code><span class="deltaxml-old">xs:base64Binary(​"AAA=")</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">true</span></code></p></td><td><p><code><span class="deltaxml-old">false</span></code></p></td></tr></tbody></table></div><div class="div2"><h3><a id="id-ordering-comparison"></a><span class="deltaxml-old">I.2 Ordering Comparisons</span></h3><p><span class="deltaxml-old">In XQuery 4.0 there are essentially three ways of comparing two atomic values for their relative ordering:</span></p><ul><li><p><code><span class="deltaxml-old">$A &lt; $B</span></code></p></li><li><p><code><span class="deltaxml-old">$A lt $B</span></code></p></li><li><p><code><span class="deltaxml-old">Sorting</span></code></p></li></ul><p><span class="deltaxml-old">TODO: to be expanded.</span></p></div></div><div class="div1"><h2><a id="id-example-applications"></a><span class="deltaxml-old">J</span><span class="deltaxml-new">I</span> Example Applications (Non-Normative)</h2><p>This section contains examples of several important classes of queries that can be expressed using XQuery. The applications described here include joins across multiple data sources, grouping and aggregation, queries based on sequential relationships, recursive transformations, and selection of distinct combinations of values.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The new features of XQuery 3.0 and XQuery 3.1 can significantly simplify some of these queries.</p></div><div class="div2"><h3><a id="id-joins"></a><span class="deltaxml-old">J</span><span class="deltaxml-new">I</span>.1 Joins</h3><p>Joins, which combine data from multiple sources into a single result, are a very important type of query. In this section we will illustrate how several types of joins can be expressed in XQuery. We will base our examples on the following three documents:</p><ol class="enumar"><li><p>A document named <code>parts.xml</code> that contains many <code>part</code> elements; each <code>part</code> element in turn contains <code>partno</code> and <code>description</code> subelements.</p></li><li><p>A document named <code>suppliers.xml</code> that contains many <code>supplier</code> elements; each <code>supplier</code> element in turn contains <code>suppno</code> and <code>suppname</code> subelements.</p></li><li><p>A document named <code>catalog.xml</code> that contains information about the relationships between suppliers and parts. The catalog document contains many <code>item</code> elements, each of which in turn contains <code>partno</code>, <code>suppno</code>, and <code>price</code> subelements.</p></li></ol><p>A conventional ("inner") join returns information from two or more related sources, as illustrated by the following example, which combines information from three documents. The example generates a <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>descriptive catalog<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> derived from the catalog document, but containing part descriptions instead of part numbers and supplier names instead of supplier numbers. The new catalog is ordered alphabetically by part description and secondarily by supplier name.</p><div class="exampleInner"><pre><span class="deltaxml-old">&lt;descriptive-catalog&gt; { for $i in doc("catalog.xml")/items/item, $p in doc("parts.xml")/parts/part[partno = $i/partno], $s in doc("suppliers.xml")/suppliers /supplier[suppno = $i/suppno] order by $p/description, $s/suppname return &lt;item&gt; { $p/description, $s/suppname, $i/price } &lt;/item&gt; } &lt;/descriptive-catalog&gt;</span></pre><pre><span class="deltaxml-new">&lt;descriptive-catalog&gt; { for $i in fn:doc("catalog.xml")/items/item, $p in fn:doc("parts.xml")/parts/part[partno = $i/partno], $s in fn:doc("suppliers.xml")/suppliers /supplier[suppno = $i/suppno] order by $p/description, $s/suppname return &lt;item&gt; { $p/description, $s/suppname, $i/price } &lt;/item&gt; } &lt;/descriptive-catalog&gt;</span></pre></div><p>The previous query returns information only about parts that have suppliers and suppliers that have parts. An <b>outer join</b> is a join that preserves information from one or more of the participating sources, including elements that have no matching element in the other source. For example, a <b>left outer join</b> between suppliers and parts might return information about suppliers that have no matching parts. </p><p>The following query demonstrates a left outer join. It returns names of all the suppliers in alphabetic order, including those that supply no parts. In the result, each supplier element contains the descriptions of all the parts it supplies, in alphabetic order.</p><div class="exampleInner"><pre><span class="deltaxml-old">for $s in doc("suppliers.xml")/suppliers/supplier order by $s/suppname return &lt;supplier&gt; { $s/suppname, for $i in doc("catalog.xml")/items/item [suppno = $s/suppno], $p in doc("parts.xml")/parts/part [partno = $i/partno] order by $p/description return $p/description } &lt;/supplier&gt;</span></pre><pre><span class="deltaxml-new">for $s in fn:doc("suppliers.xml")/suppliers/supplier order by $s/suppname return &lt;supplier&gt; { $s/suppname, for $i in fn:doc("catalog.xml")/items/item [suppno = $s/suppno], $p in fn:doc("parts.xml")/parts/part [partno = $i/partno] order by $p/description return $p/description } &lt;/supplier&gt;</span></pre></div><p><span style="display: none;" class="delete_version">The previous query preserves information about suppliers that supply no parts. Another type of join, called a <b>full outer join</b>, might be used to preserve information about both suppliers that supply no parts and parts that have no supplier. The result of a full outer join can be structured in any of several ways. The following query generates a list of <code>supplier</code> elements, each containing nested <code>part</code> elements for the parts that it supplies (if any), followed by a list of <code>part</code> elements for the parts that have no supplier. This might be thought of as a “supplier-centered” full outer join. Other forms of outer join queries are also possible.</span><span style="display: none;" class="add_version">The previous query preserves information about suppliers that supply no parts. Another type of join, called a <b>full outer join</b>, might be used to preserve information about both suppliers that supply no parts and parts that have no supplier. The result of a full outer join can be structured in any of several ways. The following query generates a list of <code>supplier</code> elements, each containing nested <code>part</code> elements for the parts that it supplies (if any), followed by a list of <code>part</code> elements for the parts that have no supplier. This might be thought of as a "supplier-centered" full outer join. Other forms of outer join queries are also possible.</span><span class="modify_version">The previous query preserves information about suppliers that supply no parts. Another type of join, called a <b>full outer join</b>, might be used to preserve information about both suppliers that supply no parts and parts that have no supplier. The result of a full outer join can be structured in any of several ways. The following query generates a list of <code>supplier</code> elements, each containing nested <code>part</code> elements for the parts that it supplies (if any), followed by a list of <code>part</code> elements for the parts that have no supplier. This might be thought of as a <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>supplier-centered<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> full outer join. Other forms of outer join queries are also possible.</span></p><div class="exampleInner"><pre><span class="deltaxml-old">&lt;master-list&gt; { for $s in doc("suppliers.xml")/suppliers/supplier order by $s/suppname return &lt;supplier&gt; { $s/suppname, for $i in doc("catalog.xml")/items/item [suppno = $s/suppno], $p in doc("parts.xml")/parts/part [partno = $i/partno] order by $p/description return &lt;part&gt; { $p/description, $i/price } &lt;/part&gt; } &lt;/supplier&gt; , (: parts that have no supplier :) &lt;orphan-parts&gt; { for $p in doc("parts.xml")/parts/part where empty(doc("catalog.xml")/items/item [partno = $p/partno] ) order by $p/description return $p/description } &lt;/orphan-parts&gt; } &lt;/master-list&gt;</span></pre><pre><span class="deltaxml-new">&lt;master-list&gt; { for $s in fn:doc("suppliers.xml")/suppliers/supplier order by $s/suppname return &lt;supplier&gt; { $s/suppname, for $i in fn:doc("catalog.xml")/items/item [suppno = $s/suppno], $p in fn:doc("parts.xml")/parts/part [partno = $i/partno] order by $p/description return &lt;part&gt; { $p/description, $i/price } &lt;/part&gt; } &lt;/supplier&gt; , (: parts that have no supplier :) &lt;orphan-parts&gt; { for $p in fn:doc("parts.xml")/parts/part where fn:empty(fn:doc("catalog.xml")/items/item [partno = $p/partno] ) order by $p/description return $p/description } &lt;/orphan-parts&gt; } &lt;/master-list&gt;</span></pre></div><p>The previous query uses an element constructor to enclose its output inside a <code>master-list</code> element. The concatenation operator (",") is used to combine the two main parts of the query. The result is an ordered sequence of <code>supplier</code> elements followed by an <code>orphan-parts</code> element that contains descriptions of all the parts that have no supplier.</p></div><div class="div2"><h3><a id="id-queries-on-sequence"></a><span class="deltaxml-old">J</span><span class="deltaxml-new">I</span>.2 Queries on Sequence</h3><p>XQuery uses the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators to compare nodes based on document order. Although these operators are quite simple, they can be used to express complex queries for XML documents in which sequence is meaningful. The first two queries in this section involve a surgical report that contains <code>procedure</code>, <code>incision</code>, <code>instrument</code>, <code>action</code>, and <code>anesthesia</code> elements.</p><p>The following query returns all the <code>action</code> elements that occur between the first and second <code>incision</code> elements inside the first procedure. The original document order among these nodes is preserved in the result of the query.</p><div class="exampleInner"><pre>let $proc := /report/procedure[1] for $i in $proc//action where $i &gt;&gt; ($proc//incision)[1] and $i &lt;&lt; ($proc//incision)[2] return $i</pre></div><p>It is worth noting here that document order is defined in such a way that a node is considered to precede its descendants in document order. In the surgical report, an <code>action</code> is never part of an <code>incision</code>, but an <code>instrument</code> is. Since the <code>&gt;&gt;</code> operator is based on document order, the predicate <code>$i &gt;&gt; ($proc//incision)[1]</code> is true for any <code>instrument</code> element that is a descendant of the first <code>incision</code> element in the first procedure.</p><p>For some queries, it may be helpful to declare a function that can test whether a node precedes another node without being its ancestor. The following function returns <code>true</code> if its first operand precedes its second operand but is not an ancestor of its second operand; otherwise it returns <code>false</code>:</p><div class="exampleInner"><pre><span class="deltaxml-old">declare function local:precedes($a as node(), $b as node()) as boolean { $a &lt;&lt; $b and empty($a//node() intersect $b) };</span></pre><pre><span class="deltaxml-new">declare function local:precedes($a as node(), $b as node()) as boolean { $a &lt;&lt; $b and fn:empty($a//node() intersect $b) }; </span></pre></div><p>Similarly, a <code>local:follows</code> function could be written:</p><div class="exampleInner"><pre><span class="deltaxml-old">declare function local:follows($a as node(), $b as node()) as boolean { $a &gt;&gt; $b and empty($b//node() intersect $a) };</span></pre><pre><span class="deltaxml-new">declare function local:follows($a as node(), $b as node()) as boolean { $a &gt;&gt; $b and fn:empty($b//node() intersect $a) }; </span></pre></div><p>Using the <code>local:precedes</code> function, we can write a query that finds <code>instrument</code> elements between the first two incisions, excluding from the query result any <code>instrument</code> that is a descendant of the first <code>incision</code>:</p><div class="exampleInner"><pre>let $proc := /report/procedure[1] for $i in $proc//instrument where local:precedes(($proc//incision)[1], $i) and local:precedes($i, ($proc//incision)[2]) return $i</pre></div><p>The following query reports incisions for which no prior anesthesia was recorded in the surgical report. Since an <code>anesthesia</code> is never part of an <code>incision</code>, we can use <code>&lt;&lt;</code> instead of the less-efficient <code>local:precedes</code> function:</p><div class="exampleInner"><pre><span class="deltaxml-old">for $proc in /report/procedure where some $i in $proc//incision satisfies empty($proc//anesthesia[. &lt;&lt; $i]) return $proc</span></pre><pre><span class="deltaxml-new">for $proc in /report/procedure where some $i in $proc//incision satisfies fn:empty($proc//anesthesia[. &lt;&lt; $i]) return $proc</span></pre></div><p><span style="display: none;" class="delete_version">In some documents, particular sequences of elements may indicate a logical hierarchy. This is most commonly true of HTML. The following query returns the introduction of an XHTML document, wrapping it in a <code>div</code> element. In this example, we assume that an <code>h2</code> element containing the text “Introduction” marks the beginning of the introduction, and the introduction continues until the next <code>h2</code> or <code>h1</code> element, or the end of the document, whichever comes first. </span><span style="display: none;" class="add_version">In some documents, particular sequences of elements may indicate a logical hierarchy. This is most commonly true of HTML. The following query returns the introduction of an XHTML document, wrapping it in a <code>div</code> element. In this example, we assume that an <code>h2</code> element containing the text "Introduction" marks the beginning of the introduction, and the introduction continues until the next <code>h2</code> or <code>h1</code> element, or the end of the document, whichever comes first. </span><span class="modify_version">In some documents, particular sequences of elements may indicate a logical hierarchy. This is most commonly true of HTML. The following query returns the introduction of an XHTML document, wrapping it in a <code>div</code> element. In this example, we assume that an <code>h2</code> element containing the text <span class="deltaxml-old">“Introduction”</span><span class="deltaxml-new">"Introduction"</span> marks the beginning of the introduction, and the introduction continues until the next <code>h2</code> or <code>h1</code> element, or the end of the document, whichever comes first. </span></p><div class="exampleInner"><pre><span class="deltaxml-old">let $intro := //h2[text()="Introduction"], $next-h := //(h1|h2)[. &gt;&gt; $intro][1] return &lt;div&gt; { $intro, if (empty($next-h)) then //node()[. &gt;&gt; $intro] else //node()[. &gt;&gt; $intro and . &lt;&lt; $next-h] } &lt;/div&gt;</span></pre><pre><span class="deltaxml-new">let $intro := //h2[text()="Introduction"], $next-h := //(h1|h2)[. &gt;&gt; $intro][1] return &lt;div&gt; { $intro, if (fn:empty($next-h)) then //node()[. &gt;&gt; $intro] else //node()[. &gt;&gt; $intro and . &lt;&lt; $next-h] } &lt;/div&gt;</span></pre></div><p><span style="display: none;" class="delete_version">Note that the above query makes explicit the hierarchy that was implicit in the original document. In this example, we assume that the <code>h2</code> element containing the text “Introduction” has no subelements.</span><span style="display: none;" class="add_version">Note that the above query makes explicit the hierarchy that was implicit in the original document. In this example, we assume that the <code>h2</code> element containing the text "Introduction" has no subelements.</span><span class="modify_version">Note that the above query makes explicit the hierarchy that was implicit in the original document. In this example, we assume that the <code>h2</code> element containing the text <span class="deltaxml-old">“Introduction”</span><span class="deltaxml-new">"Introduction"</span> has no subelements.</span></p></div><div class="div2"><h3><a id="id-recursive-transformations"></a><span class="deltaxml-old">J</span><span class="deltaxml-new">I</span>.3 Recursive Transformations</h3><p>Occasionally it is necessary to scan over a hierarchy of elements, applying some transformation at each level of the hierarchy. In XQuery this can be accomplished by defining a recursive function. In this section we will present two examples of such recursive functions.</p><p>Suppose that we need to compute a table of contents for a given document by scanning over the document, retaining only elements named <code>section</code> or <code>title</code>, and preserving the hierarchical relationships among these elements. For each <code>section</code>, we retain subelements named <code>section</code> or <code>title</code>; but for each <code>title</code>, we retain the full content of the element. This might be accomplished by the following recursive function:</p><div class="exampleInner"><pre><span class="deltaxml-old">declare function local:sections-and-titles($n as node()) as node()? { if (local-name($n) = "section") then element { local-name($n) } { for $c in $n/* return local:sections-and-titles($c) } else if (local-name($n) = "title") then $n else ( ) };</span></pre><pre><span class="deltaxml-new">declare function local:sections-and-titles($n as node()) as node()? { if (fn:local-name($n) = "section") then element { fn:local-name($n) } { for $c in $n/* return local:sections-and-titles($c) } else if (fn:local-name($n) = "title") then $n else ( ) };</span></pre></div><p><span style="display: none;" class="delete_version">The “skeleton” of a given document, containing only its sections and titles, can then be obtained by invoking the <code>local:sections-and-titles</code> function on the root node of the document, as follows:</span><span style="display: none;" class="add_version">The "skeleton" of a given document, containing only its sections and titles, can then be obtained by invoking the <code>local:sections-and-titles</code> function on the root node of the document, as follows:</span><span class="modify_version">The <span class="deltaxml-old">“skeleton”</span><span class="deltaxml-new">"skeleton"</span> of a given document, containing only its sections and titles, can then be obtained by invoking the <code>local:sections-and-titles</code> function on the root node of the document, as follows:</span></p><div class="exampleInner"><pre><span class="deltaxml-old">local:sections-and-titles(doc("cookbook.xml"))</span></pre><pre><span class="deltaxml-new">local:sections-and-titles(fn:doc("cookbook.xml"))</span></pre></div><p>As another example of a recursive transformation, suppose that we wish to scan over a document, transforming every attribute named <code>color</code> to an element named <code>color</code>, and every element named <code>size</code> to an attribute named <code>size</code>. This can be accomplished by the following recursive function (note that the element constructor in case <code>$e</code> generates attributes before child elements):</p><div class="exampleInner"><pre><span class="deltaxml-old">declare function local:swizzle($n as node()) as node() { typeswitch($n) case $a as attribute(color) return element color { string($a) } case $es as element(size) return attribute size { string($es) } case $e as element() return element { local-name($e) } { for $c in ($e/@* except $e/@color, (: attr -&gt; attr :) $e/size, (: elem -&gt; attr :) $e/@color, (: attr -&gt; elem :) $e/node() except $e/size ) (: elem -&gt; elem :) return local:swizzle($c) } case $d as document-node() return document { for $c in $d/* return local:swizzle($c) } default return $n };</span></pre><pre><span class="deltaxml-new">declare function local:swizzle($n as node()) as node() { typeswitch($n) case $a as attribute(color) return element color { fn:string($a) } case $es as element(size) return attribute size { fn:string($es) } case $e as element() return element { fn:local-name($e) } { for $c in ($e/@* except $e/@color, (: attr -&gt; attr :) $e/size, (: elem -&gt; attr :) $e/@color, (: attr -&gt; elem :) $e/node() except $e/size ) (: elem -&gt; elem :) return local:swizzle($c) } case $d as document-node() return document { for $c in $d/* return local:swizzle($c) } default return $n };</span></pre></div><p>The transformation can be applied to a whole document by invoking the <code>local:swizzle</code> function on the root node of the document, as follows:</p><div class="exampleInner"><pre><span class="deltaxml-old">local:swizzle(doc("plans.xml"))</span></pre><pre><span class="deltaxml-new">local:swizzle(fn:doc("plans.xml"))</span></pre></div></div><div class="div2"><h3><a id="id-select-distinct"></a><span class="deltaxml-old">J</span><span class="deltaxml-new">I</span>.4 Selecting Distinct Combinations</h3><p>It is sometimes necessary to search through a set of data to find all the distinct combinations of a given list of properties. For example, an input data set might consist of a large set of <code>order</code> elements, each of which has the same basic structure, as illustrated by the following example:</p><div class="exampleInner"><pre>&lt;order&gt; &lt;date&gt;2003-10-15&lt;/date&gt; &lt;product&gt;Dress Shirt&lt;/product&gt; &lt;size&gt;M&lt;/size&gt; &lt;color&gt;Blue&lt;/color&gt; &lt;supplier&gt;Fashion Trends&lt;/supplier&gt; &lt;quantity&gt;50&lt;/quantity&gt; &lt;/order&gt;</pre></div><p>From this data set, a user might wish to find all the distinct combinations of <code>product</code>, <code>size</code>, and <code>color</code> that occur together in an <code>order</code>. The following query returns this list, enclosing each distinct combination in a new element named <code>option</code>:</p><div class="exampleInner"><pre><span class="deltaxml-old">for $p in distinct-values(/orders/order/product), $s in distinct-values(/orders/order/size), $c in distinct-values(/orders/order/color) order by $p, $s, $c return if (exists(/orders/order[product eq $p and size eq $s and color eq $c])) { &lt;option&gt; &lt;product&gt;{$p}&lt;/product&gt; &lt;size&gt;{$s}&lt;/size&gt; &lt;color&gt;{$c}&lt;/color&gt; &lt;/option&gt; }</span></pre><pre><span class="deltaxml-new">for $p in fn:distinct-values(/orders/order/product), $s in fn:distinct-values(/orders/order/size), $c in fn:distinct-values(/orders/order/color) order by $p, $s, $c return if (fn:exists(/orders/order[product eq $p and size eq $s and color eq $c])) { &lt;option&gt; &lt;product&gt;{$p}&lt;/product&gt; &lt;size&gt;{$s}&lt;/size&gt; &lt;color&gt;{$c}&lt;/color&gt; &lt;/option&gt; }</span></pre></div></div></div><div class="div1"><h2><a id="id-incompatibilities"></a><span class="deltaxml-old">K</span><span class="deltaxml-new">J</span> Backwards Compatibility (Non-Normative)</h2><div class="div2"><h3><a id="id-incompatibilities-31"></a><span class="deltaxml-old">K</span><span class="deltaxml-new">J</span>.1 Incompatibilities relative to XQuery 3.1</h3><p><span class="deltaxml-old">In </span><code><span class="deltaxml-old">fn:format-integer</span></code><span class="deltaxml-old">, certain formatting pictures using a circumflex as a grouping separator might be interpreted differently in 4.0: for example </span><code><span class="deltaxml-old">format-integer(1234, "9^999")</span></code><span class="deltaxml-old"> would output </span><code><span class="deltaxml-old">"1^234"</span></code><span class="deltaxml-old"> in 3.1, but will output </span><code><span class="deltaxml-old">"1621"</span></code><span class="deltaxml-old"> (1234 in base 9) with 4.0. As a workaround, this can be rewritten as </span><code><span class="deltaxml-old">format-integer(1234, "0^000")</span></code><span class="deltaxml-old">.</span></p><p><span class="deltaxml-old">In XQuery 4.0, certain expressions are classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-old">implausible</span></a><span class="deltaxml-old">: an example is </span><code><span class="deltaxml-old">@code/text()</span></code><span class="deltaxml-old">, which will always return an empty sequence. A processor may report a static error when such expressions are encountered; however, processors are </span><strong><span class="deltaxml-old">required</span></strong><span class="deltaxml-old"> to provide a mode of operation in which such expressions are accepted, thus retaining backwards compatibility.</span></p><p><span class="deltaxml-old">In expressions that deliver a function item, notably partial function applications, named function references, and the </span><code><span class="deltaxml-old">fn:function-lookup</span></code><span class="deltaxml-old"> function, errors may now be detected at the point where the function item is created when they were previously detected at the point where the function item was called. This was underspecified in previous versions. For example, the partial function application </span><code><span class="deltaxml-old">contains(?, 42)</span></code><span class="deltaxml-old"> is now required to raise a type error (because the second argument should be a string, not an integer) at the point where the partial function application occurs, not at the point where the resulting function is called.</span></p><p><span class="deltaxml-old">As explained in </span><a href="#id-function-coercion"><b><span class="deltaxml-old">3.8.2 Function Coercion</span></b></a><span class="deltaxml-old">, the fact that coercion rules are now applied to global variables and local variable bindings introduces an incompatibility in the case of variables whose value is a function item. Previously it was possible to supply a function item that accepted a wider range of argument values than those declared in the variable's type declaration; this is no longer the case.</span></p><p><span class="deltaxml-new">None.</span></p></div><div class="div2"><h3><a id="id-incompatibilities-30"></a><span class="deltaxml-old">K</span><span class="deltaxml-new">J</span>.2 Incompatibilities relative to XQuery 3.0</h3><p>The following names are now reserved, and cannot appear as function names (see <a href="#id-reserved-fn-names"><span style="display: none;" class="delete_version"><b>A.4 Reserved Function Names</b></span><span style="display: none;" class="add_version"><b>A.3 Reserved Function Names</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">4</span><span class="deltaxml-new">3</span> Reserved Function Names</b></span></a>):</p><ul><li><p><code>map</code></p></li><li><p><code>array</code></p></li></ul></div><div class="div2"><h3><span style="display: none;" class="delete_version"><a id="id-incompatibilities-10"></a>K.3 Incompatibilities relative to XQuery <span class="xquery">1.0</span></span><span style="display: none;" class="add_version"><a id="id-incompatibilities-10"></a>J.3 Incompatibilities relative to XQuery <span class="xquery">1.0</span></span><span class="modify_version"><a id="id-incompatibilities-10"></a><span class="deltaxml-old">K</span><span class="deltaxml-new">J</span>.3 Incompatibilities relative to XQuery <span class="xquery">1.0</span></span></h3><p>The following names are now reserved, and cannot appear as function names (see <a href="#id-reserved-fn-names"><span style="display: none;" class="delete_version"><b>A.4 Reserved Function Names</b></span><span style="display: none;" class="add_version"><b>A.3 Reserved Function Names</b></span><span class="modify_version"><b>A.<span class="deltaxml-old">4</span><span class="deltaxml-new">3</span> Reserved Function Names</b></span></a>):</p><ul><li><p><code>function</code></p></li><li><p><code>namespace-node</code></p></li><li><p><code>switch</code></p></li></ul><p>If <code>U</code> is a union type with <code>T</code> as one of its members, and if <code>E</code> is an element with <code>T</code> as its type annotation, the expression <code>E instance of element(*, U)</code> returns <code>true</code> in both XQuery 3.0 and 3.1. In <span class="xquery">XQuery 1.0</span>, it returns <code>false</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">This is not an incompatibility with XQuery 3.0. It should be included in XQuery 3.0 as an incompatibility with <span class="xquery">XQuery 1.0</span>, but it was discovered after publication.</span><span style="display: none;" class="add_version">This is not an incompatibility with XQuery 3.0. It should be included in XQuery 3.0 as an incompatibility with <span class="xquery">XQuery 1.0</span> but it was discovered after publication.</span><span class="modify_version">This is not an incompatibility with XQuery 3.0. It should be included in XQuery 3.0 as an incompatibility with <span class="xquery">XQuery 1.0</span><span class="deltaxml-old">,</span> but it was discovered after publication.</span></p></div></div></div><div class="div1"><h2><a id="id-revision-log"></a><span class="deltaxml-old">L</span><span class="deltaxml-new">K</span> Change Log (Non-Normative)</h2><p class="xquery">This appendix lists the changes that have been made to this specification since the publication of the XQuery 3.1 Recommendation.</p><div class="div2"><h3><a id="id-changes-since-3.1"></a><span class="deltaxml-old">L</span><span class="deltaxml-new">K</span>.1 Changes since version 3.1</h3><div class="div3"><h4><a id="id-substantive-changes-since-3.1"></a><span class="deltaxml-old">L</span><span class="deltaxml-new">K</span>.1.1 Substantive Changes</h4><p>The following changes have been agreed by the working group:</p><ol class="enumar"><li class="delete_version" style="display: none;"><p>The concept of the context item has been generalized, so it is now a context value. That is, it is no longer constrained to be a single item.</p></li><li class="modify_version"><p><span class="deltaxml-old">The concept of the context item has been generalized, so it is now a context value. That is, it is no longer constrained to be a single item.</span></p></li><li><p>Function definitions in the static context may now have optional parameters, provided this does not cause ambiguity across multiple function definitions with the same name. Optional parameters are given a default value, which can be any expression, including one that depends on the context of the caller (so an argument can default to the context <span class="deltaxml-old">value</span><span class="deltaxml-new">item</span>).</p></li><li><p>In a static function call, arguments can be specified either positionally or <span class="deltaxml-old">by keyword</span><span class="deltaxml-new">using keywords</span>, or a combination of both.</p></li><li><p>An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is an empty sequence, in which case it returns the value of <code>B</code>.</p></li><li><p>Alternative syntax for conditional expressions is available: <code>if (condition) {X} else {Y}</code>, with the <code>else</code> part being optional.</p></li><li><p>The syntax <code>for $x in X for $y in Y return Z</code> is now accepted in XPath as well as in XQuery.</p></li><li><p>The <code>NodeTest</code> in an <code>AxisStep</code> now allows alternatives: <code>ancestor::(section|appendix)</code>.</p></li><li class="delete_version" style="display: none;"><p>Element and attribute tests can include alternative names: <code>element(chapter|section)</code>, <code>attribute(role|class)</code>.</p></li><li class="modify_version"><p><span class="deltaxml-old">Element and attribute tests can include alternative names: </span><code><span class="deltaxml-old">element(chapter|section)</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">attribute(role|class)</span></code><span class="deltaxml-old">.</span></p></li><li><p>String templates provide a new way of constructing strings: for example <code>`{$greeting}, {$planet}!`</code> is equivalent to <code>$greeting || ', ' || $planet || '!'</code></p></li><li class="delete_version" style="display: none;"><p>In inline function expressions, the keyword <code>function</code> may be abbreviated as <code>fn</code>.</p></li><li class="modify_version"><p><span class="deltaxml-old">In inline function expressions, the keyword </span><code><span class="deltaxml-old">function</span></code><span class="deltaxml-old"> may be abbreviated as </span><code><span class="deltaxml-old">fn</span></code><span class="deltaxml-old">.</span></p></li><li class="delete_version" style="display: none;"><p>New abbreviated syntax is introduced (<a title="focus function" class="termref" href="#dt-focus-function">focus function</a>) for simple inline functions taking a single argument. An example is <code>fn{../@code}</code></p></li><li class="modify_version"><p><span class="deltaxml-old">New abbreviated syntax is introduced (</span><a title="focus function" class="termref" href="#dt-focus-function"><span class="deltaxml-old">focus function</span></a><span class="deltaxml-old">) for simple inline functions taking a single argument. An example is </span><code><span class="deltaxml-old">fn{../@code}</span></code></p></li><li class="delete_version" style="display: none;"><p>The arrow operator <code>=&gt;</code> is now complemented by a “mapping arrow” operator <code>=!&gt;</code> which applies a the supplied function to each item in the input sequence independently.</p></li><li class="modify_version"><p><span class="deltaxml-old">The arrow operator </span><code><span class="deltaxml-old">=&gt;</span></code><span class="deltaxml-old"> is now complemented by a “mapping arrow” operator </span><code><span class="deltaxml-old">=!&gt;</span></code><span class="deltaxml-old"> which applies a the supplied function to each item in the input sequence independently.</span></p></li><li><p>The <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>function conversion rules<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> are now renamed <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>coercion rules<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span>.</p></li><li><p><span style="display: none;" class="delete_version">The coercion rules allow “relabeling” of a supplied atomic value where the required type is a derived atomic type: for example, it is now permitted to supply the value 3 when calling a function that expects an instance of <code>xs:positiveInteger</code>.</span><span style="display: none;" class="add_version">The coercion rules allow "relabeling" of a supplied atomic value where the required type is a derived atomic type: for example, it is now permitted to supply the value 3 when calling a function that expects an instance of <code>xs:positiveInteger</code>.</span><span class="modify_version">The coercion rules allow <span class="deltaxml-old">“relabeling”</span><span class="deltaxml-new">"relabeling"</span> of a supplied atomic value where the required type is a derived atomic type: for example, it is now permitted to supply the value 3 when calling a function that expects an instance of <code>xs:positiveInteger</code>.</span></p></li><li class="delete_version" style="display: none;"><p>In XQuery, the coercion rules are now used when binding values to variables (both global variable declarations and local variable bindings). This aligns XQuery with XSLT, and means that the rules for binding to variables are the same as the rules for binding to function parameters.</p></li><li class="modify_version"><p><span class="deltaxml-old">In XQuery, the coercion rules are now used when binding values to variables (both global variable declarations and local variable bindings). This aligns XQuery with XSLT, and means that the rules for binding to variables are the same as the rules for binding to function parameters.</span></p></li><li class="delete_version" style="display: none;"><p>Function coercion allows a function with arity <var>N</var> to be supplied where a function of arity greater than <var>N</var> is expected. For example this allows the function <code>true#0</code> to be supplied where a predicate function is required.</p></li><li class="modify_version"><p><span class="deltaxml-old">Function coercion allows a function with arity </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> to be supplied where a function of arity greater than </span><var><span class="deltaxml-old">N</span></var><span class="deltaxml-old"> is expected. For example this allows the function </span><code><span class="deltaxml-old">true#0</span></code><span class="deltaxml-old"> to be supplied where a predicate function is required.</span></p></li><li><p><span style="display: none;" class="delete_version">The rules for “errors and optimization” have been tightened up to disallow many cases of optimizations that alter error behavior. In particular there are restrictions on reordering the operands of <code>and</code> and <code>or</code>, and of predicates in filter expressions, in a way that might allow the processor to raise dynamic errors that the author intended to prevent. </span><span style="display: none;" class="add_version">The rules for "errors and optimization" have been tightened up to disallow many cases of optimizations that alter error behavior. In particular there are restrictions on reordering the operands of <code>and</code> and <code>or</code>, and of predicates in filter expressions, in a way that might allow the processor to raise dynamic errors that the author intended to prevent. </span><span class="modify_version">The rules for <span class="deltaxml-old">“</span><span class="deltaxml-new">"</span>errors and optimization<span class="deltaxml-old">”</span><span class="deltaxml-new">"</span> have been tightened up to disallow many cases of optimizations that alter error behavior. In particular there are restrictions on reordering the operands of <code>and</code> and <code>or</code>, and of predicates in filter expressions, in a way that might allow the processor to raise dynamic errors that the author intended to prevent. </span></p></li><li><p>Support for higher-order functions is now a mandatory feature (in 3.1 it was optional).</p></li><li class="xquery"><p>Switch expressions now allow a <code>case</code> clause to match multiple atomic values.</p></li><li><p>Numeric literals can now be written in hexadecimal or binary notation; and underscores can be included for readability.</p></li><li class="delete_version" style="display: none;"><p>Switch and typeswitch expressions can now be written with curly braces, to improve readability.</p></li><li class="xquery"><p><span class="deltaxml-old">Switch and typeswitch expressions can now be written with curly braces, to improve readability.</span></p></li><li class="delete_version" style="display: none;"><p>The comparand expression in a switch expression can be omitted, allowing the switch cases to be provided as arbitrary boolean expressions.</p></li><li class="xquery"><p><span class="deltaxml-old">The comparand expression in a switch expression can be omitted, allowing the switch cases to be provided as arbitrary boolean expressions.</span></p></li><li class="delete_version" style="display: none;"><p>The symbols <code>×</code> and <code>÷</code> can be used for multiplication and division, and operators such as <code>&lt;</code> and <code>&gt;</code> can use the full-width forms <code>＜</code> and <code>＞</code> to avoid the need for XML escaping.</p></li><li class="modify_version"><p><span class="deltaxml-old">The symbols </span><code><span class="deltaxml-old">×</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">÷</span></code><span class="deltaxml-old"> can be used for multiplication and division, and operators such as </span><code><span class="deltaxml-old">&lt;</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">&gt;</span></code><span class="deltaxml-old"> can use the full-width forms </span><code><span class="deltaxml-old">＜</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">＞</span></code><span class="deltaxml-old"> to avoid the need for XML escaping.</span></p></li><li class="delete_version" style="display: none;"><p>The <code>start</code> clause in window expressions has become optional, as well as the <code>when</code> keyword and its associated expression.</p></li><li class="xquery"><p><span class="deltaxml-old">The </span><code><span class="deltaxml-old">start</span></code><span class="deltaxml-old"> clause in window expressions has become optional, as well as the </span><code><span class="deltaxml-old">when</span></code><span class="deltaxml-old"> keyword and its associated expression.</span></p></li><li class="delete_version" style="display: none;"><p>The values <code>true()</code> and <code>false()</code> are allowed in function annotations, and negated numeric literals are also allowed.</p></li><li class="xquery"><p><span class="deltaxml-old">The values </span><code><span class="deltaxml-old">true()</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">false()</span></code><span class="deltaxml-old"> are allowed in function annotations, and negated numeric literals are also allowed.</span></p></li><li class="delete_version" style="display: none;"><p>All implementations must now predeclare the namespace prefixes <code>math</code>, <code>map</code>, <code>array</code>, and <code>err</code>. In XQuery 3.1 it was permitted but not required to predeclare these namespaces.</p></li><li class="xquery"><p><span class="deltaxml-old">All implementations must now predeclare the namespace prefixes </span><code><span class="deltaxml-old">math</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">map</span></code><span class="deltaxml-old">, </span><code><span class="deltaxml-old">array</span></code><span class="deltaxml-old">, and </span><code><span class="deltaxml-old">err</span></code><span class="deltaxml-old">. In XQuery 3.1 it was permitted but not required to predeclare these namespaces.</span></p></li><li class="delete_version" style="display: none;"><p>In previous versions the interpretation of location hints in <code>import schema</code> declarations was entirely at the discretion of the processor. To improve interoperability, XQuery 4.0 recommends (but does not mandate) a specific strategy for interpreting these hints.</p></li><li class="xquery"><p><span class="deltaxml-old">In previous versions the interpretation of location hints in </span><code><span class="deltaxml-old">import schema</span></code><span class="deltaxml-old"> declarations was entirely at the discretion of the processor. To improve interoperability, XQuery 4.0 recommends (but does not mandate) a specific strategy for interpreting these hints.</span></p></li><li class="delete_version" style="display: none;"><p>The rules for the consistency of schemas imported by different query modules, and for consistency between imported schemas and those used for validating input documents, have been defined with greater precision. It is now recognized that these schemas will not always be identical, and that validation with respect to different schemas may produce different outcomes, even if the components of one are a subset of the components of the other.</p></li><li class="xquery"><p><span class="deltaxml-old">The rules for the consistency of schemas imported by different query modules, and for consistency between imported schemas and those used for validating input documents, have been defined with greater precision. It is now recognized that these schemas will not always be identical, and that validation with respect to different schemas may produce different outcomes, even if the components of one are a subset of the components of the other.</span></p></li><li class="delete_version" style="display: none;"><p>Element and attribute tests of the form <code>element(N)</code> and <code>attribute(N)</code> now allow <code>N</code> to be any <code>NameTest</code>, including a wildcard.</p></li><li class="modify_version"><p><span class="deltaxml-old">Element and attribute tests of the form </span><code><span class="deltaxml-old">element(N)</span></code><span class="deltaxml-old"> and </span><code><span class="deltaxml-old">attribute(N)</span></code><span class="deltaxml-old"> now allow </span><code><span class="deltaxml-old">N</span></code><span class="deltaxml-old"> to be any </span><code><span class="deltaxml-old">NameTest</span></code><span class="deltaxml-old">, including a wildcard.</span></p></li><li class="delete_version" style="display: none;"><p>The <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> can now be declared to be fixed for a query module, meaning it is unaffected by a namespace declaration appearing on a direct element constructor.</p></li><li class="xquery"><p><span class="deltaxml-old">The </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-old">default namespace for elements and types</span></a><span class="deltaxml-old"> can now be declared to be fixed for a query module, meaning it is unaffected by a namespace declaration appearing on a direct element constructor.</span></p></li></ol><p>The following changes are present in this draft, but are awaiting review and agreement:</p><ol class="enumar"><li class="add_version" style="display: none;"><p>The static context now allows the default namespace for elements and the default namespace for types to be different. XSLT 4.0 takes advantage of this, XQuery 4.0 currently does not.</p></li><li class="modify_version"><p><span class="deltaxml-new">The static context now allows the default namespace for elements and the default namespace for types to be different. XSLT 4.0 takes advantage of this, XQuery 4.0 currently does not.</span></p></li><li><p>A new <code>with</code> expression allows namespace bindings to be defined within an expression (and to be redefined in nested expressions).</p></li><li class="add_version" style="display: none;"><p>The static context now allows the unprefixed function names to be resolved using an arbitrary algorithm, rather than requiring the resolution to use a default namespace.</p></li><li class="modify_version"><p><span class="deltaxml-new">The static context now allows the unprefixed function names to be resolved using an arbitrary algorithm, rather than requiring the resolution to use a default namespace.</span></p></li><li><p>The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return an empty sequence rather than an error.</p></li><li><p>Record types are added as a new kind of <code>ItemType</code>, constraining the value space of maps.</p></li><li><p>Local union types are added as a new kind of <code>ItemType</code>, constraining the value space of atomic values.</p></li><li><p>Enumeration types are added as a new kind of <code>ItemType</code>, constraining the value space of strings.</p></li><li class="add_version" style="display: none;"><p>Element and attribute tests of the form <code>element(N)</code> and <code>attribute(N)</code> now allow <code>N</code> to be any <code>NameTest</code>, including a wildcard.</p></li><li class="modify_version"><p><span class="deltaxml-new">Element and attribute tests of the form </span><code><span class="deltaxml-new">element(N)</span></code><span class="deltaxml-new"> and </span><code><span class="deltaxml-new">attribute(N)</span></code><span class="deltaxml-new"> now allow </span><code><span class="deltaxml-new">N</span></code><span class="deltaxml-new"> to be any </span><code><span class="deltaxml-new">NameTest</span></code><span class="deltaxml-new">, including a wildcard.</span></p></li><li class="add_version" style="display: none;"><p>New abbreviated syntax is introduced for simple inline functions.</p></li><li class="modify_version"><p><span class="deltaxml-new">New abbreviated syntax is introduced for simple inline functions.</span></p></li><li><p><span style="display: none;" class="delete_version">The lookup operator <code>?</code> can now be followed by a string literal, for cases where map keys are strings other than NCNames.</span><span style="display: none;" class="add_version">The lookup operator "?" can now be followed by a string literal, for cases where map keys are strings other than NCNames.</span><span class="modify_version">The lookup operator <span class="deltaxml-new">"</span>?<span class="deltaxml-new">"</span> can now be followed by a string literal, for cases where map keys are strings other than NCNames.</span></p></li><li class="add_version" style="display: none;"><p>The arrow operator <code>=&gt;</code> is now complemented by a "thin arrow" operator <code>-&gt;</code> which applies a function to each item in the input sequence independently.</p></li><li class="modify_version"><p><span class="deltaxml-new">The arrow operator </span><code><span class="deltaxml-new">=&gt;</span></code><span class="deltaxml-new"> is now complemented by a "thin arrow" operator </span><code><span class="deltaxml-new">-&gt;</span></code><span class="deltaxml-new"> which applies a function to each item in the input sequence independently.</span></p></li><li><p>The rules for value comparisons when comparing values of different types (for example, decimal and double) have changed to be transitive. A decimal value is no longer converted to double, instead the double is converted to a decimal without loss of precision. This may affect compatibility in edge cases involving comparison of values that are numerically very close.</p></li><li><p>A <code>for member</code> clause is added to FLWOR expressions to allow iteration over an array.</p></li><li class="add_version" style="display: none;"><p>Mathematical operator symbols are available as alternatives to alphabetic operator names, for example <code>div</code> can be written as <code>÷</code>, while <code>intersect</code> can be written as <code></code>.</p></li><li class="modify_version"><p><span class="deltaxml-new">Mathematical operator symbols are available as alternatives to alphabetic operator names, for example </span><code><span class="deltaxml-new">div</span></code><span class="deltaxml-new"> can be written as </span><code><span class="deltaxml-new">÷</span></code><span class="deltaxml-new">, while </span><code><span class="deltaxml-new">intersect</span></code><span class="deltaxml-new"> can be written as </span><code></code><span class="deltaxml-new">.</span></p></li></ol></div><div class="div3"><h4><a id="id-editorial-changes-since-3.1"></a><span class="deltaxml-old">L</span><span class="deltaxml-new">K</span>.1.2 Editorial Changes</h4><ol class="enumar"><li><p>The presentation of the rules for the subtype relationship between sequence types and item types has been substantially rewritten to improve clarity; no change to the semantics is intended.</p></li><li><p>The operator mapping table has been simplified by removing entries for the operators <code>ne</code>, <code>le</code>, <code>gt</code>, and <code>ge</code>; these are now defined by reference to the rules for the operators <code>eq</code> and <code>lt</code>.</p></li><li class="delete_version" style="display: none;"><p>Recommended rules for processing an <code>import schema</code> declaration with multiple location hints are now provided, though they are not binding on implementors.</p></li><li class="modify_version"><p><span class="deltaxml-old">Recommended rules for processing an </span><code><span class="deltaxml-old">import schema</span></code><span class="deltaxml-old"> declaration with multiple location hints are now provided, though they are not binding on implementors.</span></p></li></ol></div></div></div></div><script>https://www.w3.org/scripts/TR/2016/fixup.js//www.w3.org/scripts/TR/2016/fixup.js</script><script src="/js/scroll.js"></script></body></html>