<item>
   <title>Issue #602 created</title>
   <pubDate>2023-07-13T06:55:05Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/602</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-602</guid>
   <description>&lt;div&gt;&lt;p&gt;Semi-strict static typing: reporting implausible expressions&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;Strict &lt;em&gt;static typing&lt;/em&gt;, as originally defined for XQuery 1.0, was not a success, because it prohibits too many constructs that are perfectly reasonable to write. However, the alternative, pure &lt;em&gt;dynamic typing&lt;/em&gt;, prevents a processor reporting many obvious errors at compile time. A compromise is &lt;em&gt;optimistic static typing&lt;/em&gt;, where the processor is allowed to report a type error statically in the cases where it can be shown that evaluation of an expression is bound to fail at run-time.&lt;/p&gt;
&lt;p&gt;Optimistic static typing has proved a reasonably successful compromise, but there are a number of cases where things that are obviously user mistakes cannot be reported as static errors.  I propose that a processor should be allowed (not required) to treat some of these conditions as static errors.&lt;/p&gt;
&lt;p&gt;The first of these conditions is exemplified by passing an argument whose static type is &lt;code&gt;xs:integer*&lt;/code&gt; to a function where the declared parameter type is &lt;code&gt;xs:string*&lt;/code&gt;. Under optimistic static typing this cannot be reported as a static error, because it is not bound to fail; if the actual value at run-time turns out to be an empty sequence, the call will succeed. So the proposal is that where the inferred supplied type and the required sequence types are both emptiable (that is, occurrence indicator is "?" or "*"), but their respective item types are disjoint, the processor should be allowed to report a static error.&lt;/p&gt;
&lt;p&gt;The second condition is what I call a &lt;em&gt;void path expression&lt;/em&gt;. Specifically, if we know statically that the result of &lt;code&gt;$A/B&lt;/code&gt;, or &lt;code&gt;$A!B&lt;/code&gt;, or &lt;code&gt;$A?B&lt;/code&gt; will be an empty sequence for any possible value of $A (given its inferred type), this almost certainly means the user has made a mistake, and we should be allowed to report a static error. This extends to the unary or implicit forms of these operators, based on the inferred type of the context item. This is most likely to occur with schema-aware code, where it should be possible to report a path such as A/B/C/D as incorrect if the schema does not allow such a path. But it also arises for example for &lt;code&gt;$A?B&lt;/code&gt; if the inferred type of $A is a non-extensible record type and B is not one of its known fields; and it arises for inappropriate combinations of axes such as &lt;code&gt;@code/text()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that I'm not proposing (as XQuery 1.0 static typing did) that &lt;em&gt;any&lt;/em&gt; expression whose result is bound to be empty is a static error; the rule is confined to a few specific operators.&lt;/p&gt;
&lt;p&gt;Perhaps, for backwards compatibility and interoperability, we should require processors to provide an option to switch this kind of static error detection off. (For example, XSLT 1.0 code sometimes deliberately uses &lt;code&gt;/..&lt;/code&gt; to represent an empty sequence, and this construct would be flagged under these rules.)&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
