<item>
   <title>Issue #910 created</title>
   <pubDate>2023-12-18T02:45:17Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/910</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-910</guid>
   <description>&lt;div&gt;&lt;p&gt;Introduce a Kollection object with functions that operate on all types of items that can be containers of unlimited number of "members"&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;The base for this issue is the email sent by @ndw  to  public-xslt-40@w3.org on Dec. 13th 2023, fully quoted below:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hello all,&lt;/p&gt;
&lt;p&gt;After a couple of weeks of discussion[1][2] about naming things, there
seem to be a some quite different perspectives on the problem.&lt;/p&gt;
&lt;p&gt;As background, let’s remember that we have a language (or a set of
languages) that evolved over time. We couldn’t anticipate in version
1.0 what we would have in 4.0. We added new features in 2.0 and 3.0
that weren’t anticipated in previous versions either.&lt;/p&gt;
&lt;p&gt;We live with decisions (some the result of long and hard battles
within the working group(s)) like the fact that sequences don’t nest
so all individual items are also sequences of length one.&lt;/p&gt;
&lt;p&gt;The context for each addition to the language has been roughly: how
can we add new, useful features with a minimum of backwards
incompatibility.&lt;/p&gt;
&lt;p&gt;It’s a natural consequence of this sort of evolution that there are
rough edges. Why does fn:count returns the number of items in a
sequence but always returns 1 if the argument is an array? Because an
array is an item and an item is a sequence of length one.&lt;/p&gt;
&lt;p&gt;(It doesn’t help that the vision of what the X* languages should be
has changed over time. What started out envisioned as a tool for
transforming documents from one format to another for presentation on
the web or in print has grown into something that at least some
members of the group view as first class, functional programming
languages. That’s not bad, but it puts entirely different stresses on
the design, I think.)&lt;/p&gt;
&lt;p&gt;As we add new functions (specifically, in the case of recent
discussions, but I expect the same perspectives apply more generally),
I think one perspective is roughly this:&lt;/p&gt;
&lt;p&gt;How can we name and organize the functions so that users are least
likely to be surprised and most likely to be able to figure out how
to solve a particular problem?&lt;/p&gt;
&lt;p&gt;Taken to an extreme, this perspective isn’t about changing the
semantics of the functions at all, it’s “just” about naming them. Is
fn:get() better (easier to understand, less confusing) than
fn:items-at?&lt;/p&gt;
&lt;p&gt;I think another perspective is roughly this:&lt;/p&gt;
&lt;p&gt;We have a messy design. It would be better if we could refactor the
design so that it was more harmonious and logical. We don’t need
four different, closely related functions to get items out of
different sorts of data structures, we need a set of abstractions
that make it obvious that only one function is necessary.&lt;/p&gt;
&lt;p&gt;Taken to an extreme, this perspective is about reshaping the whole
language so that a single, obvious set of function names emerges
naturally from the carefully constructed abstractions.&lt;/p&gt;
&lt;p&gt;I don’t think anyone holds exactly one perspective (discussions about
renaming often involve some level of discussion about semantics, for
example) and I’m attempting to polarize the perspectives a little bit
in an effort to shine light on a larger problem, not to be divisive.&lt;/p&gt;
&lt;p&gt;With my chair’s hat on, the main problem I see with the first
perspective is that naming is hard, often personal and emotional, and
will never be wholly logical (so there will always be more to discuss,
so the “problem” is never resolved). It’s not quite fair to say it’s a
distraction from the “bigger” issues we need to resolve, but it does
take a lot of time.&lt;/p&gt;
&lt;p&gt;I see the appeal of the second perspective. If we had a green field,
we’d do things differently. I think we might all agree that, ideally,
fn:count should return the number of items in a sequence, the number
of items in an array, and the number of key-value pairs in a map. But
it doesn’t and it can’t without fundamentally breaking things. I don’t
think we’d get agreement to break fn:count, so what can we do?&lt;/p&gt;
&lt;p&gt;A proposal to fundamentally redesign the data model would be a tough
sell, I think.&lt;/p&gt;
&lt;p&gt;One thing we could do is define a new namespace “gn” with functions
that work more logically, that treat sequences, arrays, and maps, as
collections and operate on them uniformly.&lt;/p&gt;
&lt;p&gt;I suppose we could reconstruct the whole set of functions in this new
namespace and focus our efforts there, perhaps going so far as to
deprecate the current fn: namespace in favor of this new one.
But could we get consensus to do that? Would users thank us?&lt;/p&gt;
&lt;p&gt;I dunno. Innovations welcome.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                                    Be seeing you,
                                      norm
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;This issue addresses the 2nd alternative formulated briefly by Norm as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One thing we could do is define a new namespace “gn” with functions
that work more logically, that treat sequences, arrays, and maps, as
collections and operate on them uniformly.&lt;/p&gt;
&lt;p&gt;I suppose we could reconstruct the whole set of functions in this new
namespace and focus our efforts there, perhaps going so far as to
deprecate the current fn: namespace in favor of this new one.
But could we get consensus to do that? Would users thank us?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Here are some of the obvious advantages of having a uniform Kollection concept that covers: arrays, sequences, maps, ... and possibly future new, specific, collection-like datatypes as sets:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Uniform definition and understanding of a single data type - the Kollection.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O(N) functions only, compared to O(M * N) at present. Here N is the number of functions needed for each of the current collection-like data types (Arrays, Sequences and Maps) and M is the number of collection-like data types (currently 3).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The users will need to know about and understand just the single Kollection data type and its functions, not 3 or more similar collection-like data  types and 3 or more number of similar (but different) functions. Minimizing by a factor of 3 the amount of factual knowledge that a user needs is something HUGE  and extremely positive.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Allowing users to say "Good Bye" to the unclear and treacherous flat-sequence concepts we have as legacy from XPath 1.0.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Staying aligned to the examples of other modern programming languages such as C# with its IEnumerable interface. It is good to know that this has already been done in other shining programming languages, thus a nay-sayer will not be able to argue that this is not doable or, if done, would be negative to the language and its users.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Freeing enormous resources and time for the members of the Community Group so that they can spend this on more valuable avenues, than trying to find similar and best names to M similar functions each defined to one of the M current collection-like data types.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now, to dispel some plausible myths before they start circulating here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Myth 1: This will break backwards-compatibility? No, as proposed by Norm, all the functions operating on the generalized collection data type can be in a separate, new namespace and thus no existing user-code is affected.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Myth 2: If a sequence containing a single Kollection still has &lt;code&gt;count()&lt;/code&gt; of 1, then what is the use of the Kollection data type? Actually, as proposed by Norm, the Kollection data type and its functions reside in their own namespace. Doing things using only functions from this new namespace eliminates the possibility of using &lt;code&gt;fn:count&lt;/code&gt; as it resides in the different, currently existing standard function namespace.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Myth 3: This will be too-complex for the users and the users will not embrace it, so let us not waste time designing it. Wow, there were such prophets saying exactly the same about LINQ in 2005. As it often happens, the future proved them wrong. Users clearly and overwhelmingly "voted with their code" incorporating LINQ in almost all everyday applications and code repositories.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Myth 4: Banning the current functions operating on sequences, arrays and maps would be a huge burden to the users, and would intervene negatively with their programming. In fact, nobody would be banning any of the existing functions. Users can continue to use them forever. The acceptance of the uniform and generalized Kollection data - type can happen gradually with time, as was the case with the addition of LINQ to C#.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
