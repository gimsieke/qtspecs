<item>
   <title>Issue #617 created</title>
   <pubDate>2023-07-18T07:42:09Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/617</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-617</guid>
   <description>&lt;div&gt;&lt;p&gt;Implicit constructor functions for record types and union types&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;See also Issue #397 and Issue #322, which this proposal may partially supersede.&lt;/p&gt;
&lt;p&gt;I propose that when declaring a named record type in the static context, this should automatically create a constructor function definition for records of that type.&lt;/p&gt;
&lt;p&gt;So in XQuery if you write&lt;/p&gt;
&lt;p&gt;&lt;code&gt;declare item type my:location as record(longitude: xs:double, latitude: xs:double);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;then the static context acquires both a type (&lt;code&gt;let $loc as my:location := ....&lt;/code&gt;) and a function which you can call with either positional or keyword arguments (&lt;code&gt;let $loc := my:position(-2.03, 50.95)&lt;/code&gt; or &lt;code&gt;:= my:position(longitude := -2.03, latitude := 50.95)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The semantics of the function are roughly &lt;code&gt;map{longitude: -2.03, latitude: 50.95} treat as my:position&lt;/code&gt;, except that the function arguments are first coerced to the required types (in this case the decimals are coerced to double).&lt;/p&gt;
&lt;p&gt;If the record type is extensible, the constructor function does not provide any capability to set values for extension fields. I'm not sure yet whether it will be possible to distinguish fields set to an empty sequence from fields that are absent.&lt;/p&gt;
&lt;p&gt;This is consistent with user-defined atomic types where you automatically get a constructor function.&lt;/p&gt;
&lt;p&gt;Similarly for named union types. If you declare&lt;/p&gt;
&lt;p&gt;&lt;code&gt;declare item type my:binary as union(xs:hexBinary, xs:base64Binary)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;then you should automatically get an arity-1 constructor function &lt;code&gt;my:binary($value)&lt;/code&gt; with the same semantics as if &lt;code&gt;my:binary&lt;/code&gt; were an XSD-defined union type (that is, the same semantics as &lt;code&gt;cast $value as union(xs:hexBinary, xs:base64Binary)&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
