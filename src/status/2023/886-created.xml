<item>
   <title>Issue #886 created</title>
   <pubDate>2023-12-07T23:56:54Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/886</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-886</guid>
   <description>&lt;div&gt;&lt;p&gt;Binary map keys&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;We have made &lt;code&gt;xs:hexBinary&lt;/code&gt; and &lt;code&gt;xs:base64Binary&lt;/code&gt; comparable and we now allow implicit coercion between the two types.&lt;/p&gt;
&lt;p&gt;I've been assuming, though I'm not sure we ever discussed it, that this automatically means that the two types can be "atomic equal" from the point of view of entries in maps: that is, a hexBinary representation of a particular binary value can no longer coexist in a map with a base64Binary representation of the same binary value.&lt;/p&gt;
&lt;p&gt;If we were starting from scratch this would clearly make sense, but it has some messy implications:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It's a backwards incompatibility; in 3.1 you could construct maps that you can no longer construct in 4.0&lt;/li&gt;
&lt;li&gt;It potentially affects interoperability of 3.1 and 4.0 applications. For example, an XQuery 4.0 application invoking an XSLT 3.0 transformation via &lt;code&gt;fn:transform&lt;/code&gt; might get back a map that's not a valid map in 4.0.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In effect, this is not just a change to the behaviour of one function/operator, it is a data model change, because it changes the value space of the &lt;code&gt;map(*)&lt;/code&gt; data type.&lt;/p&gt;
&lt;p&gt;And more parochially, I freely admit, there's a lot of internal complexity trying to maintain a code base that supports both the 3.1 and 4.0 rules simultaneously.&lt;/p&gt;
&lt;p&gt;Is this a feature that benefits users sufficiently to justify the transition complexities? Note that we can still support "eq" between the two data types without supporting &lt;code&gt;fn:atomic-equal&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
