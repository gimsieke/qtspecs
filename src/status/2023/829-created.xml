<item>
   <title>Issue #829 created</title>
   <pubDate>2023-11-12T09:42:50Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/829</link>
   <guid>https://qt4cg.org/@qt4cg/2023/#created-829</guid>
   <description>&lt;div&gt;&lt;p&gt;fn:boolean: EBV support for more item types&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;In #817, it was discussed that the current EBV semantics have been inspired a lot by XPath 1.0. Today, we have numerous other data types apart from strings, doubles, booleans, and nodes, and I believe itâ€™s time to do justice to this by getting rid of the error for unsupported data types for &lt;code&gt;fn:boolean&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We currently have:&lt;/p&gt;
&lt;p&gt;Type | Rule to compute boolean value
--- | ---
&lt;code&gt;node()&lt;/code&gt; | &lt;code&gt;true()&lt;/code&gt;
&lt;code&gt;xs:boolean&lt;/code&gt; | &lt;code&gt;$item != 0 and not(is-NaN($item))&lt;/code&gt;
&lt;code&gt;xs:untypedAtomic&lt;/code&gt;, &lt;code&gt;xs:string&lt;/code&gt;, &lt;code&gt;xs:anyURI&lt;/code&gt; | &lt;code&gt;$item != ''&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;I have two options in mind:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The easiest solution, which would come closest to JavaScript, would be to return &lt;code&gt;true()&lt;/code&gt; for all other items. This would allow us to do simple checks like:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;declare function local:byte-length($data as xs:basexBinary?) xs:integer {
  (: instead of exists($data); utilizes the EXPath Binary Module :)
  if($data) then bin:length($data) else 0
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="2"&gt;
&lt;li&gt;If we want to be more fine granular, we could do justice to the specifics of 4 more types:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Type | Rule to compute boolean value
--- | ---
&lt;code&gt;array(*)&lt;/code&gt; | &lt;code&gt;array:size($item) != 0&lt;/code&gt;
&lt;code&gt;map(*)&lt;/code&gt; | &lt;code&gt;map:size($item) != 0&lt;/code&gt;
&lt;code&gt;xs:base64Binary&lt;/code&gt;&lt;br/&gt;&lt;code&gt;xs:hex64Binary&lt;/code&gt; | &lt;code&gt;bin:length($item) != 0&lt;/code&gt; or &lt;br/&gt;&lt;code&gt;not($item = (xs:hexBinary(''), xs:base64Binary(''))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;It would then be possible to write:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if($map)&lt;/code&gt; instead of &lt;code&gt;map:size($map) != 0&lt;/code&gt; or &lt;code&gt;map:exists($map)&lt;/code&gt; (see &lt;a href="https://github.com/qt4cg/qtspecs/issues/827"&gt;#827&lt;/a&gt; for the naming controversy).&lt;br/&gt;Note that &lt;code&gt;if($map)&lt;/code&gt; will also return &lt;code&gt;false()&lt;/code&gt; is &lt;code&gt;$map&lt;/code&gt; is an empty sequence.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if($func) { $func(1, 2) }&lt;/code&gt; instead of &lt;code&gt;exists($func)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the last comments of #817, it was addressed that the behavior of existing code may change if errors are replaced by results. I hope we can live with that, as I cannot think of cases in which the EBV computation make sense for items that always raise an error.&lt;/p&gt;
&lt;p&gt;Which option do some of you prefer?&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
