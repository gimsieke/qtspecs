<item>
   <title>Issue #1021 created</title>
   <pubDate>2024-02-12T12:46:10Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1021</link>
   <guid>https://qt4cg.org/@qt4cg/2024/#created-1021</guid>
   <description>&lt;div&gt;&lt;p&gt;Extend `fn:doc`, `fn:collection` and `fn:uri-collection` with options maps&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;&lt;code&gt;fn:doc&lt;/code&gt;, &lt;code&gt;fn:collection&lt;/code&gt; and &lt;code&gt;fn:uri-collection&lt;/code&gt; currently expect only a single argument, a URI.&lt;/p&gt;
&lt;p&gt;There is no way of adding additional parameters to those functions.&lt;/p&gt;
&lt;p&gt;Several implementations of XPath have worked around that limitation by&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;passing of parameters via query string as part of the URI:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;see https://www.saxonica.com/documentation10/index.html#!sourcedocs/collections&lt;/li&gt;
&lt;li&gt;exist-db's implementation of &lt;code&gt;uri-collection&lt;/code&gt; works similarly&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="2"&gt;
&lt;li&gt;create custom functions in other namespaces to add an options map as a second parameter&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;saxon:doc&lt;/code&gt; in Saxon https://www.saxonica.com/documentation10/index.html#!changes/extensions/9.7-9.8&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fetch:doc&lt;/code&gt; in baseX https://docs.basex.org/wiki/Fetch_Module#fetch:doc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While both approaches do work well, they do fall flat in terms of interoperability and discoverability.
A script written for Saxon leveraging &lt;code&gt;saxon:doc&lt;/code&gt; will not work on baseX in vice versa even though they offer options with some overlap.
And a developer looking at the language specification will not discover that these options even exist.&lt;/p&gt;
&lt;p&gt;I would like to add a second signature to the above functions with an options map as a second argument.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;fn:doc($href as xs:string?) as document-node()?
fn:doc($href as xs:string?, $options as map(xs:string, *)? := ()) as document-node()?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NOTE: Looking at the other two functions below I believe the first parameter should be defined as &lt;code&gt;$href as xs:string? := ()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;fn:collection( $uri as xs:string? := ()) as item()*
fn:collection( $uri as xs:string? := (), $options as map(xs:string, *)? := ()) as item()*
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;fn:uri-collection( $uri as xs:string? := ()) as xs:anyURI*
fn:uri-collection( $uri as xs:string? := (), $options as map(xs:string, *)? := ()) as xs:anyURI*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since a lot of those options depend on the current runtime most of them will be "free" options.
This will also help us get to a specification quickly and circumvent long infighting about some very specific details.&lt;/p&gt;
&lt;p&gt;I do see, however, a good chance of specifying a small set of options that would work across implementations.&lt;/p&gt;
&lt;h2&gt;Possible standard options&lt;/h2&gt;
&lt;h3&gt;For &lt;code&gt;fn:doc&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;validation&lt;/code&gt;: wether and how to validate the input files against a schema&lt;/li&gt;
&lt;li&gt;&lt;code&gt;whitespace&lt;/code&gt;: (&lt;code&gt;strip-space&lt;/code&gt;, &lt;code&gt;stripws&lt;/code&gt;) what to do with whitespace in the input document&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parser&lt;/code&gt;: could be used to define a different parser (for html documents)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;For &lt;code&gt;collection&lt;/code&gt; and &lt;code&gt;uri-collection&lt;/code&gt; I see the following:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;recurse&lt;/code&gt;: traverse collection trees down into its subcollections&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stable&lt;/code&gt;: this is already vaguely mentioned in the spec and would benefit from a clearer specification&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;: (aka &lt;code&gt;media-type&lt;/code&gt; or &lt;code&gt;content-type&lt;/code&gt;) while the allowed values will be implementation defined the key should be standardised&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This would bring the above functions to follow a pattern developers are already familiar with (see &lt;code&gt;fn:serialize&lt;/code&gt; and others)&lt;/p&gt;
&lt;p&gt;Thanks for initial input by @ChristianGruen, Liam Quin and @michaelhkay&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
