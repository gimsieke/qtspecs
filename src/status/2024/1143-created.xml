<item>
   <title>Issue #1143 created</title>
   <pubDate>2024-04-11T21:52:09Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1143</link>
   <guid>https://qt4cg.org/@qt4cg/2024/#created-1143</guid>
   <description>&lt;div&gt;&lt;p&gt;Coercion Rules for Choice Item Types&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;The proposal that we accepted for choice item types (PR #1132) invokes atomization only if the choice type is a generalised atomic type, that is, if all alternatives in the choice are atomic.&lt;/p&gt;
&lt;p&gt;This makes it tricky to take advantage of choice types for extending existing functions in a backwards-compatible way. For example, we might want to change the second argument of fn:unparsed-text from &lt;code&gt;$encoding as xs:string&lt;/code&gt; to &lt;code&gt;$options as (xs:string | map(*))&lt;/code&gt;. But under the current rules, this means the supplied value of the $encoding argument will no longer be atomized.&lt;/p&gt;
&lt;p&gt;I propose to change this by effectively promoting rule 3 to appear before rule 2. Rule 2 is the atomization rule, and rule 3 is the new rule:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If R is a [choice item type] &lt;em&gt;that is not a [generalized atomic type]&lt;/em&gt;, then the following rules are applied with R set to each of the alternatives in the choice item type, in order, until an alternative is found that does not result in a type error; a type error is raised only if all alternatives fail.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The phrase in italics is deleted.&lt;/p&gt;
&lt;p&gt;The effect is that if the required type is &lt;code&gt;(xs:string | map(*))&lt;/code&gt; then we first try converting the supplied argument as if the required type were &lt;code&gt;xs:string&lt;/code&gt; (including atomization), and if that fails we try converting it as if the required type were map(*).&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
