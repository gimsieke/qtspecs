<item>
   <title>Issue #1144 created</title>
   <pubDate>2024-04-12T07:47:44Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1144</link>
   <guid>https://qt4cg.org/@qt4cg/2024/#created-1144</guid>
   <description>&lt;div&gt;&lt;p&gt;Sequence Decomposition&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;This proposal allows sequences to be decomposed and assigned to separate variables in a single declaration within a for or let expression binding.&lt;/p&gt;
&lt;p&gt;Given a sequence such as &lt;code&gt;(1, 2, 3)&lt;/code&gt;, the values within that sequence cannot easily be extracted. With the current version of XPath and XQuery, they need to be assigned to a temporary variable first. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let $result := get-camera-point()
let $x := $result[1]
let $y := $result[2]
let $z := $result[3]
return "(" || $x || "," || $y || "," || $z || ")"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This proposal would allow this to be written more concisely as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let ($x, $y, $z) := get-camera-point()
return "(" || $x || "," || $y || "," || $z || ")"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These are equivalent in this proposal, except that &lt;code&gt;$result&lt;/code&gt; is not a statically known variable binding in the sequence decomposition let clause.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: The older syntax in &lt;a href="https://github.com/expath/xpath-ng/pull/8"&gt;XPath-NG&lt;/a&gt; was:&lt;/p&gt;
&lt;p&gt;let $(x, y, z) := get-camera-point()
return "(" || $x || "," || $y || "," || $z || ")"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For each variable declaration in the sequence decomposition at index &lt;code&gt;N&lt;/code&gt;, and &lt;code&gt;$expr&lt;/code&gt; being the result of the for/let expression, then &lt;code&gt;$expr[N]&lt;/code&gt; is the value bound to the variable declaration as a new variable binding. If the value does not exist, an empty sequence is bound to the variable.&lt;/p&gt;
&lt;p&gt;A sequence decomposition can be used in any for or let clause binding to decompose the items in a sequence. If the type of the for or let clause binding expression is not a sequence, an &lt;code&gt;err:XPTY0004&lt;/code&gt; error is raised.&lt;/p&gt;
&lt;h3&gt;Assigning the rest of a sequence&lt;/h3&gt;
&lt;p&gt;It can be useful to only extract part of a sequence or array (e.g. the heading of a table), and store the rest of the items in another variable. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let $(heading, rows ...) := fn:parse-csv("test.csv")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If there are no items remaining in the sequence the result is an empty sequence.&lt;/p&gt;
&lt;h3&gt;Influences&lt;/h3&gt;
&lt;p&gt;Tuple decomposition is found in various languages such as Python, Scala, and C#. These languages also have support for tuple types.&lt;/p&gt;
&lt;p&gt;Python has support for specifying that a variable is assigned the remaining values in the tuple.&lt;/p&gt;
&lt;h2&gt;Use Cases&lt;/h2&gt;
&lt;p&gt;There are many cases where fixed size sequences may be used such as points, complex and rational numbers, sin/cos, and mul/div. This makes extracting data from these simpler, and may also be used to aid readability by assigning descriptive names to each of the items in the sequence.&lt;/p&gt;
&lt;h2&gt;Examples&lt;/h2&gt;
&lt;p&gt;Extracting values from a sequence:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;declare function sincos($angle as xs:double?) {
    math:sin($angle), math:cos($angle)
};

let $angle := math:pi()
let ($sin, $cos) := sincos($angle)
return $sin || "," || $cos
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
