<item>
   <title>Issue #1052 created</title>
   <pubDate>2024-02-29T08:41:10Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1052</link>
   <guid>https://qt4cg.org/@qt4cg/2024/#created-1052</guid>
   <description>&lt;div&gt;&lt;p&gt;parse-csv() - simplify output&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;Currently parse-csv produces a structure like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map {
  "columns": map {
      "names": map{"one":1, "two":2},
      "fields": ("one", "two")
   }
  "rows":  (
     map{
        "fields": ("aaa", "bbb"),
        "field" fn($col){$this?fields[$col]}
    },
   map{
        "fields": ("ccc", "ddd"),
        "field" fn($col){$this?fields[$col]}
    }
 )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a number of ways this could be improved.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The structure is needlessly different from the return value of maps-to-arrays(). Users will get confused between the two representations, and will find it hard to switch from one to the other. For example, one delivers rows as sequences, the other delivers rows as arrays.&lt;/li&gt;
&lt;li&gt;There are too many levels in the structure; the expressions to select within it are unnecessarily complicated, and users will get poor diagnostics when they get it wrong.&lt;/li&gt;
&lt;li&gt;In this example (with two columns) for each row there is one map, one sequence, one function, and two strings - five values in all. The output of &lt;code&gt;csv-to-arrays&lt;/code&gt; has only three objects (one array and two strings). However hard an optimized implementation tries to reduce the overhead, the space occupied by a million-row parsed CSV is likely to be larger than needed.&lt;/li&gt;
&lt;li&gt;The use of sequences rather than arrays means that no JSON-serialization of the structure is possible&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I propose using a flatter structure, like this pseudo-code sketch:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map {
      "column-index": map{"one":1, "two":2},
      "columns": ["one", "two"]
      "rows": (
         ["aaa", "bbb"],
         ["ccc", "ddd"]
     )
     "get": fn($row, $col){$this?rows[$row]($col)}
     "size": fn(){count($this?rows)}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This doesn't meet all the objections outlined above; for example it represents rows as a sequence of arrays, which is consistent with &lt;code&gt;csv-to-arrays&lt;/code&gt;, but not JSON-serializable. But I think it's a considerable improvement.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
