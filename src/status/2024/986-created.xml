<item>
   <title>Issue #986 created</title>
   <pubDate>2024-01-31T17:07:07Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/986</link>
   <guid>https://qt4cg.org/@qt4cg/2024/#created-986</guid>
   <description>&lt;div&gt;&lt;p&gt;Numeric Comparisons&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;We've been trying to change the semantics of numeric comparison without breaking existing applications. As a result, the current status quo is very messy. Let's review where we are.&lt;/p&gt;
&lt;p&gt;The eq/lt operators, given mixed operand types, convert decimal operands to double and compare as double. No change from 3.1. This comparison is not transitive in edge cases. The &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; operators are defined in terms of &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;lt&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Map key comparisons compare as "infinite precision decimal". No change from 3.1. This comparison is now exposed as fn:atomic-equal().&lt;/p&gt;
&lt;p&gt;deep-equal() refers to atomic-equal(), which is a change in behaviour from 3.1.&lt;/p&gt;
&lt;p&gt;distinct-values() refers to deep-equal(), which is a change in behaviour - deliberate, because it needs to be transitive.&lt;/p&gt;
&lt;p&gt;index-of() refers to eq. No change from 3.1.&lt;/p&gt;
&lt;p&gt;compare() has been newly introduced; like atomic-equal() it uses infinite precision decimal for comparison.&lt;/p&gt;
&lt;p&gt;sort() uses compare(). This is a change from 3.1; again needed because transitivity is important.&lt;/p&gt;
&lt;p&gt;min() and max() use compare(). This is a change from 3.1.&lt;/p&gt;
&lt;p&gt;The new highest() and lowest() functions use sort().&lt;/p&gt;
&lt;p&gt;XSLT for-each-group refers to distinct-values().&lt;/p&gt;
&lt;p&gt;XSLT xsl:sort currently refers to numeric-compare() and will presumably change to use compare().&lt;/p&gt;
&lt;p&gt;XSLT xsl:merge refers to xsl:sort&lt;/p&gt;
&lt;p&gt;XQuery "group by" refers to deep-equal()&lt;/p&gt;
&lt;p&gt;XQuery "order by" refers to compare()&lt;/p&gt;
&lt;p&gt;So:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nearly everything now uses decimal comparison where the operands are of mixed type&lt;/li&gt;
&lt;li&gt;There are many different ways that we say this - it's often indirect. There are only two comparison methods, but you have to follow a chain of references to work out which one applies.&lt;/li&gt;
&lt;li&gt;The two exceptions that still do comparison the 3.1 way (converting both operands to xs:double) are (a) the eq/lt/=/&amp;lt; operators, and (b) the index-of and array:index-of functions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are definitely things that now break. For example I was working on tests yesterday with assertions in the form deep-equal(nodes/number(.), (8.2, 5.4, 6.5)) - that is, comparing doubles to decimals. The nodes actually contain the strings "8.2", "5.4", "6.5". The test was failing because converting the string "8.2" to a double and then converting the double to a decimal does not produce the decimal value 8.2.&lt;/p&gt;
&lt;p&gt;This mixed bag really doesn't seem acceptable. What options do we have?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Be bold: make everything uniformly use transitive comparisons, and accept that some user code will break.&lt;/li&gt;
&lt;li&gt;Be timid: use transitive comparisons only where it really matters (distinct-values, grouping, sorting) and use promotion to double everywhere else.&lt;/li&gt;
&lt;li&gt;Compromise: introduce a compatibility mode, or a context option that allows users to control the behaviour, or another set of comparison operators.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Any other ideas?&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
