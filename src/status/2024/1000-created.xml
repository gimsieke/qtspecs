<item>
   <title>Issue #1000 created</title>
   <pubDate>2024-02-04T08:34:08Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1000</link>
   <guid>https://qt4cg.org/@qt4cg/2024/#created-1000</guid>
   <description>&lt;div&gt;&lt;p&gt;XQFO Code in the Rules sections&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;In #978, it’s being discussed what is the best language for presenting code in the Rules sections of the XQFO specification. Currently, XPath is used for compact equivalencies, for example…&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;(: array:size :)
count(array:members($array))

(: fn:remove :)
$input[not(position() = $positions)].
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...while XQuery is used for more complex expressions, including function declarations, or when the XPath representation would be syntactically more complex. Examples:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;(: fn:deep-equal :)
declare function equal-strings(
  $string1   as xs:string,
  $string2   as xs:string, 
  $collation as xs:string,
  $options   as map(*)
) as xs:boolean {
  let $n1 := if ($options?whitespace = "normalize"))
             then normalize-unicode(?, $options?normalization-form) 
             else identity#1
  let $n2 := if ($options?normalize-space)
             then normalize-space#1 
             else identity#1               
  return compare($n1($n2($string1)), $n1($n2($string2)), $collation) eq 0    
}

(: fn:index-where :)
for $item at $pos in $input
where $predicate($item, $pos)
return $pos

(: …flatten, fold-left, while-do, others :)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we have many cases in which XPath/XQuery code is omitted, either because the presented feature is basic enough, because the equivalent code would get too complicated, or (e.g., for &lt;code&gt;fn:doc&lt;/code&gt;) because it does not provide means to express the feature.&lt;/p&gt;
&lt;p&gt;We should strive for consistency and decide which language(s) the majority of us believes is the best choice…&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;XPath &amp;amp; XQuery (what we currently have)&lt;/li&gt;
&lt;li&gt;XPath only&lt;/li&gt;
&lt;li&gt;XPath, XQuery and XSLT (whatever seems most appropriate)&lt;/li&gt;
&lt;li&gt;Other pseudocode&lt;/li&gt;
&lt;li&gt;Don’t use pseudocode at all  if it is too complex to be represented with moderately simple XPath code&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
