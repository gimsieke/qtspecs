<item>
   <title>Issue #944 created</title>
   <pubDate>2024-01-12T11:18:52Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/944</link>
   <guid>https://qt4cg.org/@qt4cg/2024/#created-944</guid>
   <description>&lt;div&gt;&lt;p&gt;Coercion rules: implicit types&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;Since 2.0, the coercion rules (formerly function conversion rules) have allowed implicit conversion from decimal to double, decimal to float, and float to double on function calls; other conversions such as double to decimal or float to decimal are not allowed. This has never made very much sense because in some implementations, decimal to float is a lossy conversion whereas float to decimal is not.&lt;/p&gt;
&lt;p&gt;One option would be to allow conversion from any numeric type to any other.&lt;/p&gt;
&lt;p&gt;The main caveat here is that I don't think it makes sense to allow a double such as 1.5e0 to be supplied where the required type is xs:integer. We have introduced new conversions that make it possible to supply a decimal where an integer is expected, but only if the decimal is in the value space of integer.&lt;/p&gt;
&lt;p&gt;A possible formulation would be:&lt;/p&gt;
&lt;p&gt;If the required type is a numeric type (that is, xs:decimal, xs:double, xs:float, or any type derived from these), and if the supplied value is a numeric value, then the supplied value is cast to the required primitive type, and if the result is in the value space of the actual required type it is then relabelled as an instance of the actual required type (if not, the conversion fails).&lt;/p&gt;
&lt;p&gt;This means that supplying 1.0e0 for an argument expecting xs:integer (or xs:positiveInteger, etc) would work (it would cast to xs:decimal and then relabel as xs:integer), but supplying 1.1e0 would fail.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
