<item>
   <title>Issue #1104 created</title>
   <pubDate>2024-03-21T10:06:18Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1104</link>
   <guid>https://qt4cg.org/@qt4cg/2024/#created-1104</guid>
   <description>&lt;div&gt;&lt;p&gt;TypeTest expressions&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;Our current status quo text allows the result of a lookup expression to be filtered by type:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[[1,2], [3,4], 5, 6]?*::array(*)?1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;and issue #859 points out that this doesn't work because of a syntax ambiguity involving occurrence indicators ('?' is both an occurrence indicator and a lookup operator).&lt;/p&gt;
&lt;p&gt;This issue addresses that problem by re-examining the requirements, and pulling in a number of other issues at the same time.&lt;/p&gt;
&lt;p&gt;In path expressions we have a shorthand syntax for selecting nodes, called the node test, and the proposed syntax &lt;code&gt;::array(*)&lt;/code&gt; was modelled on this. Node tests have a considerable overlap with types, but there are limitations. For example the &lt;code&gt;self&lt;/code&gt; axis is often used to turn a node test into a general predicate, but &lt;code&gt;[self::XX]&lt;/code&gt; can only be used to test elements, not attributes. However, the popularity of node tests and the self axis illustrates the need for a concise filtering operation.&lt;/p&gt;
&lt;p&gt;Of course it's always possible to write &lt;code&gt;[. instance of array(*)]&lt;/code&gt; but this gets extremely verbose.&lt;/p&gt;
&lt;p&gt;In XSLT 3.0, template rules matching maps and arrays could only be written as &lt;code&gt;match=".[. instance of array(*)]"&lt;/code&gt;, which gets really ugly, so we have proposed an alternative in 4.0. Specifically, you can match any type using &lt;code&gt;match="type(ItemType)"&lt;/code&gt;, and for many types such as arrays and maps you can abbreviate this to, for example &lt;code&gt;match="array(*)"&lt;/code&gt;. But this feels clumsy because the type() wrapper is sometimes needed and sometimes not.&lt;/p&gt;
&lt;p&gt;I would like to propose an expression that has concise syntax, whose effect is equivalent to &lt;code&gt;. instance of T&lt;/code&gt;. I propose to use the &lt;code&gt;~&lt;/code&gt; symbol. This is available as both a binary and unary operator, so we can define a binary form &lt;code&gt;$z ~ T&lt;/code&gt; which is syntactic shorthand for &lt;code&gt;$z instance of T&lt;/code&gt;, and a unary form &lt;code&gt;~T&lt;/code&gt; which is shorthand for &lt;code&gt;. ~ T&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;First, in the case of lookup expressions, we can now write:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[[1,2], [3,4], 5, 6]?*[~array(*)]?1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;TypeTests will often be used within predicates in this way, and of course the usage is completely general.&lt;/p&gt;
&lt;p&gt;Here's an example used for array:filter: &lt;code&gt;array:filter($array, fn{~xs:integer+})&lt;/code&gt; which selects all members of the array comprising one or more integers.&lt;/p&gt;
&lt;p&gt;In XSLT 4.0 the syntax &lt;code&gt;~T&lt;/code&gt; replaces the current TypePattern, giving a much more uniform way of matching items by type.&lt;/p&gt;
&lt;p&gt;In XPath and XSLT conditionals the construct can be used as an equivalent to XQuery's TypeswitchExpr:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;xsl:choose&amp;gt;
  &amp;lt;xsl:when test="~xs:integer"&amp;gt;...&amp;lt;/xsl:when&amp;gt;
  &amp;lt;xsl:when test="~xs:string"&amp;gt;...&amp;lt;/xsl:when&amp;gt;
  ...
&amp;lt;/xsl:choose&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The choice of tilde for this operator is motivated by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There are not many symbols available&lt;/li&gt;
&lt;li&gt;Tilde has many different uses in mathematics and computing, some of which represent a boolean test applied to a value (for example testing whether it is similar to another value or whether it matches some pattern), which is not dissimilar to this proposed usage&lt;/li&gt;
&lt;li&gt;The alliteration between "tilde" and "type" has some mnemonic value (cf. the use of &lt;code&gt;@&lt;/code&gt; for the attribute axis).&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
